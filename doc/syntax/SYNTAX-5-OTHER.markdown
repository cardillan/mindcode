# Compiler directives

Mindcode allows you to alter some compiler options in the source code using special `#set` commands.
The basic syntax is: 

```
#set option = value
```

Some of these options can be alternatively specified as parameters of the command line compiler.

Supported compiler options are described below.

## Option `target`

Use the `target` option to specify the Mindcode version:

```
#set target = ML6
```

Possible values for this option are:
* `ML6`: compile for Mindcode Logic version 6
* `ML7S`: compile for Mindcode Logic version 7 standard processors
* `ML7W`: compile for Mindcode Logic version 7 world processor
* `ML7AS`: compile for Mindcode Logic version 7 (revision A) standard processors
* `ML7AW`: compile for Mindcode Logic version 7 (revision A) world processor

## Option `goal`

Use the `goal` option to specify whether Mindcode should prefer to generate smaller code, or faster code. 
Possible values are:

* `size`: Mindcode tries to generate smaller code.
* `speed`: Mindcode can generate additional instructions, if it makes the resulting code faster while adhering to 
  the 1000 instructions limit. When several possible optimizations of this kind are available, the ones having the 
  best effect (highest speedup per additional instruction generated) are selected until the instruction limit is 
  reached. 
* `auto`: the default value. At this moment the setting is identical to `speed`.

## Option `memory-model`

This option has been added to support future enhancements of Mindcode. Setting the option doesn't have any effect at 
this moment. 

## Option `instruction-limit`

This option allows to change the instruction limit used by [speed
optimization](SYNTAX-6-OPTIMIZATIONS.markdown#optimization-for-speed). The speed optimization strives not to exceed 
this instruction limit. In some cases, the optimization cost estimates are too conservative - some optimizations 
applied together may lead to code reductions that are not known to individual optimizers considering each 
optimization in isolation. In these cases, increasing the instruction limit might allow more optimizations to be 
performed. When the resulting code exceeds 1000 instructions, it is not usable in Mindustry processors and the 
option should be decreased or set back to 1000. (A new feature, which would perform this trial-and-error 
optimization automatically, is planned.)

The limit only affects the optimization for speed. The option has no effect on code generated by the compiler or 
optimizers which do not work in the speed optimization mode, and doesn't help reduce the code size generated outside 
the optimization for speed mechanism. 

It is also possible to decrease the instruction limit, if you wish so. The valid range for this compiler option is 1 
to 100,000 for the command-line tool, and 1 to 1,500 for the web application.

> [!IMPORTANT]
> Setting the limit to a very high value can have severe impact on the performance of the compiler. High 
> values of the instruction limit might cause the code compilation to take minutes or even hours to complete.

## Option `optimization`

Use the `optimization` option to set the optimization level of the compiler:

```
#set optimization = basic
```

Possible values for this option are:

* `off`
* `basic`
* `aggressive`

The `off` setting deactivates all optimizations. The `basic` setting performs most of the available optimizations.
The `aggressive` optimizations performs all the available optimizations, even those that might take more time, or 
which make changes that are potentially risky or make understanding of the resulting mlog code more difficult.

The default optimization level for the web application compiler is `basic`, for the command line compiler it is 
`aggressive`.

## Option `passes`

Use the `passes` option to set the maximum number of optimization passes to be done:

```
#set passes = 10
```

The default value is 3 for the web application and 25 for the command line tool. The number of optimization passes
can be limited to a value between 1 and 1000 (inclusive).

A more complex code can usually benefit from more optimization passes. On the other hand, each optimization pass can
take some time to complete. Limiting the total number can prevent optimization from taking too much time or
consuming too many resources (this is a consideration for the web application).

## Individual optimization options

It is possible to set the level of individual optimization tasks. Every optimization is assigned a name,
and this name can be used in the compiler directive like this:

```
#set dead-code-elimination = aggressive
```

Not all optimizations support the `aggressive` level. For those the level `aggressive` is the same as `basic`.
The complete list of available optimizations, including the option name for setting the level of given optimization
and availability of the aggressive optimization level is:

| Optimization                                                                                       | Option name                  | Aggressive |
|----------------------------------------------------------------------------------------------------|------------------------------|:----------:|
| [Temporary Variables Elimination](SYNTAX-6-OPTIMIZATIONS.markdown#temporary-variables-elimination) | temp-variables-elimination   |     N      |
| [Case Expression Optimization](SYNTAX-6-OPTIMIZATIONS.markdown#case-expression-optimization)       | case-expression-optimization |     N      |
| [Dead Code Elimination](SYNTAX-6-OPTIMIZATIONS.markdown#dead-code-elimination)                     | dead-code-elimination        |     Y      |
| [Jump Normalization](SYNTAX-6-OPTIMIZATIONS.markdown#jump-normalization)                           | jump-normalization           |     N      |
| [Jump Optimization](SYNTAX-6-OPTIMIZATIONS.markdown#jump-optimization)                             | jump-optimization            |     N      |
| [Single Step Elimination](SYNTAX-6-OPTIMIZATIONS.markdown#single-step-elimination)                 | single-step-elimination      |     N      |
| [Expression Optimization](SYNTAX-6-OPTIMIZATIONS.markdown#expression-optimization)                 | expression-optimization      |     Y      |
| [If Expression Optimization](SYNTAX-6-OPTIMIZATIONS.markdown#if-expression-optimization)           | if-expression-optimization   |     N      |
| [Data Flow Optimization](SYNTAX-6-OPTIMIZATIONS.markdown#data-flow-optimization)                   | data-flow-optimization       |     Y      |
| [Loop Hoisting](SYNTAX-6-OPTIMIZATIONS.markdown#loop-hoisting)                                     | loop-hoisting                |     N      |
| [Loop Optimization](SYNTAX-6-OPTIMIZATIONS.markdown#loop-optimization)                             | loop-optimization            |     N      |
| [Loop Unrolling](SYNTAX-6-OPTIMIZATIONS.markdown#loop-unrolling)                                   | loop-unrolling               |     Y      |
| [Function Inlining](SYNTAX-6-OPTIMIZATIONS.markdown#function-inlining)                             | function-inlining            |     Y      |
| [Case Switching](SYNTAX-6-OPTIMIZATIONS.markdown#case-switching)                                   | case-switching               |     N      |
| [Return Optimization](SYNTAX-6-OPTIMIZATIONS.markdown#return-optimization)                         | case-switching               |     N      |
| [Jump Straightening](SYNTAX-6-OPTIMIZATIONS.markdown#jump-straightening)                           | return-optimization          |     N      |
| [Jump Threading](SYNTAX-6-OPTIMIZATIONS.markdown#jump-threading)                                   | jump-threading               |     Y      |
| [Unreachable Code Elimination](SYNTAX-6-OPTIMIZATIONS.markdown#unreachable-code-elimination)       | unreachable-code-elimination |     Y      |
| [Stack Optimization](SYNTAX-6-OPTIMIZATIONS.markdown#stack-optimization)                           | stack-optimization           |     N      |
| [Print Merging](SYNTAX-6-OPTIMIZATIONS.markdown#print-merging)                                     | print-merging                |     Y      |

You normally shouldn't need to deactivate any optimization, but if there was a bug in some of the optimizers,
deactivating it might allow you to use Mindcode until a fix is available.

In particular, some optimizers expect to work on code that was already processed by different optimizations,
so turning off some optimizations might render other optimizations ineffective. **This is not a bug.**  

---

[« Previous: Functions](SYNTAX-4-FUNCTIONS.markdown) &nbsp; | &nbsp; [Next: Code optimization »](SYNTAX-6-OPTIMIZATIONS.markdown)
