This file Lists the issues and ideas being actively worked or pondered upon. Updated occasionally. 

# Change in default language target

The default language target will be bumped to `8` as soon as regular Mindustry 8 release is made.

# Roadmap

A broad plan for the next few releases. Everything may change, though.

See [changelog in the development branch](https://github.com/cardillan/mindcode/blob/devel/CHANGELOG.markdown) for a list of features ready for the upcoming release.

## Upcoming release

Changes intended for the next regular release.

**Done**

* UI redesign by JeanJPNM
* `break` in code blocks
  * the code blocks must be labeled and the `break` must refer to the label
  * it is possible to use `begin`, `atomic` or `debug` as implicit labels (depending on the block type and only if the block is unlabeled)
* Full support for parallel execution in the emulator
  * In the web app, all four modules will support running the code

**Doing**

* **Planned**

* Expression optimization: replace `floor(x + 0.5)` with `round(x)`.
* Detect unused variables/constants/functions from AST analysis and report them as warnings.
* If expression telescoping optimization

## Next releases

These are topics that I'm spending time thinking about. Some of these should appear in the next release after the upcoming one.

* Modules/namespaces (see #149)
  * Implement public/private modifiers for variables, functions, and constants.
  * [Refactoring of Mindustry Logic functions](#refactoring-of-mindustry-logic-functions)
* [Variable types](https://github.com/cardillan/mindcode/issues/232)
  * "Natural" types
  * Structures/records, including arrays of structures
  * Enums
  * Local arrays/structures
  * Function pointers/array pointers

## Active

These are topics that I'm currently planning to implement.

* [Redesign of optimization options](#redesign-of-optimization-options)
* AST interpretation for much more powerful compile-time evaluation.
* Optimization engine rewrite
  * An overhaul of all existing optimizations (similar in principle to the recently completed compiler rewrite) would be very useful. Possibly written from scratch, with no links to the code structure generated by Mindcode (it could optimize any mlog code). Potentially a base for a decompiler as well. No commitment yet, as it would be a lot of work.
* Partial loop unrolling optimization
* Instruction reordering optimization
* Terminology: intrinsic functions
* Further optimizations (maybe in the new optimization engine)
  * Array access fusing
  * Array operation injection
  * Linear transformation of loop control variables and conditions (induction variables)

## Small tasks backlog 

These are relatively small tasks that might be slipped in when I feel like it.

* Detection of unexpected processor restarts
* Verify (using unit tests or extended tests) that the dynamic optimizations estimate optimization costs well (i.e., the resulting code must not be larger than the initial estimate).
* Storing precompiled AST trees of system functions
* Allow specifying URL, not just port, for watcher (offline)
* Output variable mapping (source code names to mlog names) to a log file
* Extended testing:
    * Avoid repeated compilation
    * Add support for running tests for a predetermined time instead of a specific number of test cases.
* Customizable variable naming schemes

## Shelf

These are topics that I've spent some time thinking about and still want them, but they're in a distant future at best.

* Implement some way to parametrize schematic creation:
  * Alternative 1: add parametrization or processing to Schemacode. E.g., a loop that will create a column or row of blocks. Needs way to express loops and basic expressions evaluation.
  * Alternative 2: provide some means to generate schematics from Mindcode. E.g., a Mindcode program, run by the emulator, creates a schematic, populates it with blocks, sets block configurations, and writes the result into a file.
* [Autolinked variables](#autolinked-variables)
* `fallthrough` and `yield` in case expressions
* Memory model
* Remote parameters. Or maybe not, needs figuring out how to enforce restarting dependent processors when updated??

# Issue details

## Autolinked variables

Support for declaring a variable as a block of a certain type, e.g.

```
linked @message msg, @switch button, @memory-bank storage;
```

Mindcode would generate code to iterate through linked blocks and automatically assign them to variables:

- `msg` would be assigned the first block of type `@message`
- `button` would

## Refactoring of Mindustry Logic functions

Implementing namespaces would allow better organization of Mindcode functions into related groups (e.g., separate namespace for world-processor functions).

The current system would be accessible in one namespace for backwards compatibility, implicitly imported in relaxed syntax mode. The new systems would come with its own namespaces.

## Redesign of optimization options

Instead of configuring optimization by individual optimizer, allow each optimization to be configured independently. The options would be structured hierarchically, e.g.:

- `opt.if-expression.value-propagation`
- `opt.if-expression.instruction-propagation`
- `opt.if-expression.forward-assignment`
- `opt.data-flow.preserve-globals`
- `opt.data-flow.preserve-main`
- `opt.data-flow.constant-folding`
- `opt.data-flow.constant-folding`
- `opt.print-merging.use-format`
- etc.

Possible values in the set directive would be `on`, `off` and `force`.
`force` would force the optimization even when it would be deemed dangerous by the optimizer (e.g., print merging using the
`format` instruction in presence of `{0}` string literals).

`#set` directives will set all values in given subtree, e.g.

```
#set opt = off;                             // Turn off all
#set opt.data-flow = off;                   // Turn off just the data flow
#set opt.data-flow.constant-folding = off;  // Turn off just the constant folding
```

Furthermore, the general optimization levels won't be used to choose the optimization 'intrusiveness' or 'riskiness,' but to choose how much effort is put into optimizations. On lower levels, more expensive optimizations (in terms of compiler/optimizer effort) will be skipped.

## `fallthrough` and `yield` in case expressions

The `fallthrough` keyword can be used in a `when` branch in
`case` expression to transfer the control to the next branch:

```
case number
    when 1 then 
        print "one";
        fallthrough;
    when 2 then
        print "two";
end;
```

When `number` is 1, the code will print "onetwo". When `number` is 2, the output will be just "two".
`fallthrough` can be used anywhere in the `when` branch, for example, inside an `if` statement.

The
`yield` keyword can be used in a when branch in case expression to terminate the evaluation of the case expression and provide the resulting value (the code will output "even"):

```
number = 4;
output = case number
    when 1 .. 10 then
        if number % 2 == 0 then
            yield "even";
        end;
        print("not even\n");
        "odd"; 
    else
        "too big";
end;
print(output);
```

The value after `yield` will be optional; when not given, the resulting value of the case expression will be `null`.

## Memory model

Optimizations of external variables are planned for the future. These should prevent unnecessary reads and writes from/to memory blocks. To help the compiler with these optimizations, it will be possible to assign a memory block or a variable one of three possible memory models:

* `volatile`: this means that the external memory may be modified by another processor, and therefore reads and writes from/to this memory must not be eliminated from the code.
* `aliased`: this means that another processor will not modify the external memory, but the memory block might be accessed using two different variables.
* `restricted`: this means the memory block will never be accessed using two different variables.

A memory model can be assigned to a memory block, or to a concrete slot inside a memory block. Model assigned to a slot has precedence over a model assigned to the whole block. Conflicting assignments on a block or slot level cause compilation error. Declaring a variable as restricted when it can be inferred from a code it is actually aliased causes a compilation error.

Example (the syntax is outdated and wonky):

```
param MEMORY1 = bank1;
param MEMORY2 = bank2;

external MEMORY1[0] $state;

declare MEMORY1 restricted;
declare MEMORY2[0 ... 256] volatile;
declare MEMORY2[256 ... 512] aliased;

declare $state volatile;

external MEMORY1[0] $state2;
declare $state2 restricted;             // Error: we know $state2 is an alias to $state
```

## Enums

It will be possible to declare enums using the `enum` keyword:

```
enum enum_name is element1, element2, element3 end;
```

Mindcode will assign values to the enums as it sees fit. There are no guarantees on the numbers whatsoever, except preserving the declaration order. They could be instruction addresses inside a case expression, for example, if there's just one case expression.

Mindcode will provide functions to access enum properties (e.g. `element.name`, `element.next`,
`element.previous`). They might be a bit costly to use.

Support for enums in list iteration Loops: `for i in enum_name`.

## Function pointers

> [!NOTE]
> This text is outdated and doesn't incorporate the upcoming adoption of types in Mindcode and the possibility of implementing lambdas/function pointers through interfaces.

Function pointers would allow storing a function address in a variable and calling the function through that variable. The internal mechanism is briefly described in the [road map](https://github.com/cardillan/mindcode/blob/main/ROADMAP.markdown#function-pointers).

Assigning a function address to a variable could happen in several ways:

```
def foo()
    print("foo");
end;

fptr1 = foo;                // Note: no parentheses

fptr2 = def bar() 
    print("bar");
end;

// Lambda syntax
fptr3 = () -> print("baz");
fptr4 = n -> print("n");    // No parentheses required for lambdas with single parameter 
fptr5 = (x, y) -> x + y;

// Code block needs to be used if the lambda is more than one expression
fptr6 = n -> begin
    sum = 0;
    while n > 0 do
        sum += n--;
    end;
    return n;               // Lambda is just another way of writing functions, return is allowed
end;

// Code block is not needed if the lambda is just one expression, even a complex one
fptr7 = n-> while n > 0
    println(n--);
end;

// Lambdas with output parameters
fptr8 = (x, out y) -> begin y = x * x; return y + x + 1; end;

// Calls via the function pointers
fptr3();
fptr4("Hello");
print(fptr5(5, 7));

// Will print numbers 10 to 1 in descending order and then null, as loops always returns null.  
print(fptr7(10));

// Mindcode lambdas will probably have read-only access to the outside variables:
status1 = () -> printf("Running: $count reactors active\n");
status2 = () -> printf("Shutdown: cryofluid level $level too low\n");

print_status(running ? status1 : status2);

def print_status(fptr_status)
    ...
    println("Power plant status:");
    printf("Energy consumption: $consumption\n");
    fptr_status();
    printf("Battery level: $battery\n");
end;
```
