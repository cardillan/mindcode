package info.teksol.mc.emulator.processor;

import info.teksol.mc.mindcode.logic.opcodes.Opcode;
import org.jspecify.annotations.NullMarked;
import org.jspecify.annotations.Nullable;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@NullMarked
public class TextBuffer {
    private final int outputLimit;
    private final int bufferLimit;
    private final boolean overflowError;
    private final List<String> output = new ArrayList<>();
    private final Map<String, String> cache = new HashMap<>();

    private final StringBuilder buffer = new StringBuilder();
    private int flushIndex = 0;
    private int assertBufferStart = -1;
    private int assertListStart = -1;

    TextBuffer() {
        this(0, 0, true);
    }

    public TextBuffer(int outputLimit, int bufferLimit, boolean overflowError) {
        this.outputLimit = outputLimit;
        this.bufferLimit = bufferLimit;
        this.overflowError = overflowError;
    }

    public boolean isEmpty() {
        return buffer.isEmpty();
    }

    // String deduplication
    private String cache(String text) {
        String result = cache.putIfAbsent(text, text);
        return result == null ? text : result;
    }

    private void checkBuffer() {
        if (overflowError && buffer.length() - flushIndex >= bufferLimit) {
            throw new ExecutionException(ExecutionFlag.ERR_TEXT_BUFFER_OVERFLOW,
                    "The capacity of the text buffer (%d) exceeded.", bufferLimit);
        }
    }

    public void print(String text) {
        checkBuffer();

        if (buffer.length() <= outputLimit) {
            output.add(cache(text));
            buffer.append(text);
            if (buffer.length() > outputLimit) {
                buffer.append("\nText buffer size limit exceeded.");
            }
        }
    }

    /// Appends the text directly to the output buffer, without modifying the print output list.
    /// Used to add text to program output not generated by the program itself.
    public TextBuffer append(String text) {
        buffer.append(text);
        return this;
    }

    /// Replaces a formatter placeholder in the output buffer with the value.
    ///
    /// @param text value to use for formatting
    /// @return false if the formatting placeholder was not found
    public boolean format(String text) {
        checkBuffer();
        if (buffer.length() > outputLimit) {
            // We didn't even try to replace anything -- do not report error
            return true;
        }

        int index = findLeastPlaceholderIndex();

        if (index >= 0) {
            buffer.replace(index, index + 3, text);
            if (buffer.length() > outputLimit) {
                buffer.append("\nText buffer size limit exceeded.");
            }
        }

        return index >= 0;
    }

    /// Finds the first occurrence of a placeholder with the least value in the text buffer and
    /// returns it's position (index in the text buffer).
    ///
    /// @return position of the placeholder to be replaced
    private int findLeastPlaceholderIndex() {
        int index = -1;
        char minValue = '9' + 1;                // Least found value so far, won't be matched again
        int limit = buffer.length() - 2;

        for (int i = flushIndex; i < limit; i++) {
            if (buffer.charAt(i) == '{') {
                char placeholder = buffer.charAt(i + 1);
                if (placeholder >= '0' && placeholder < minValue && buffer.charAt(i + 2) == '}') {
                    minValue = placeholder;
                    index = i;
                }
            }
        }

        return index;
    }

    public static final String REPETITIONS_INT = "\n[--- Previous segment repeated %,d times ---]\n";
    public static final String REPETITIONS_DEC = "\n[--- Previous segment repeated %,.2f times ---]\n";
    private int repetitions = 0;
    private @Nullable String last = null;

    public void printflush(@Nullable StringBuilder contents) {
        String current = buffer.substring(flushIndex);

        if (contents != null) {
            contents.setLength(0);
            contents.append(current);
            if (contents.length() > bufferLimit) {
                contents.setLength(bufferLimit);
            }
        }

        if (flushIndex != buffer.length()) {
            if (last != null && last.equals(current)) {
                repetitions++;
                buffer.setLength(flushIndex);
            } else {
                last = current;
                if (repetitions > 0) {
                    buffer.insert(flushIndex, String.format(REPETITIONS_INT, repetitions));
                }
                flushIndex = buffer.length();
                repetitions = 0;
            }
        }
    }

    public void prepareAssert() {
        if (assertBufferStart != -1) {
            throw new ExecutionException(ExecutionFlag.ERR_INVALID_ASSERT_PRINTS,
                    "Multiple or nested '%s' instruction calls.", Opcode.ASSERT_FLUSH);
        }
        assertBufferStart = buffer.length();
        assertListStart = output.size();
    }

    public String getAssertedOutput() {
        if (assertBufferStart == -1) {
            throw new ExecutionException(ExecutionFlag.ERR_INVALID_ASSERT_PRINTS,
                    "'%s' without '%s'.", Opcode.ASSERT_PRINTS, Opcode.ASSERT_FLUSH);
        }
        String text = buffer.substring(assertBufferStart);
        buffer.setLength(assertBufferStart);
        output.subList(assertListStart, output.size()).clear();
        assertBufferStart = -1;
        assertListStart = -1;
        return text;
    }

    /// Provides the individual values of print instructions. Format instruction doesn't
    /// affect this output.
    ///
    /// @return the list of individual print statement values
    public List<String> getPrintOutput() {
        return output;
    }

    /// @return the joined and possible formatted output of print and format instructions.
    public String getFormattedOutput() {
        if (repetitions > 0) {
            assert last != null;
            if (last.startsWith(buffer.substring(flushIndex))) {
                double ratio = (double) (buffer.length() - flushIndex) / last.length();
                buffer.setLength(flushIndex);
                buffer.append(String.format(REPETITIONS_DEC, repetitions + ratio));
            } else {
                buffer.insert(flushIndex, String.format(REPETITIONS_INT, repetitions));
            }
            flushIndex = buffer.length();
        }
        repetitions = 0;
        last = null;
        return buffer.toString();
    }

    static final TextBuffer EMPTY = new TextBuffer(0, 0, false);
}
