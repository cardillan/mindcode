package info.teksol.mc.mindcode.compiler.optimization;

import info.teksol.mc.mindcode.compiler.optimization.OptimizationContext.LogicIterator;
import info.teksol.mc.mindcode.logic.arguments.ArgumentType;
import info.teksol.mc.mindcode.logic.arguments.LogicVariable;
import info.teksol.mc.mindcode.logic.instructions.JumpInstruction;
import info.teksol.mc.mindcode.logic.instructions.LogicInstruction;
import info.teksol.mc.mindcode.logic.instructions.PushOrPopInstruction;
import info.teksol.mc.mindcode.logic.instructions.SetInstruction;
import org.jspecify.annotations.NullMarked;

import java.util.List;

/// Removes unnecessary case expression variable (`__ast`) and replaces it with the original variable containing
/// the value of the case expression. The set instruction is removed, while the other instructions (one or more jump
/// instruction per `when` branch) are updated to replace the `__ast` variable with the one used
/// in the set statement.
///
/// The optimization is performed only when the following conditions are met:
/// <ol>
///   - The set instruction assigns to an `__ast` variable.
///   - The set instruction is the first of all those using the `__ast` variable (the check is based on absolute
///     instruction sequence in the program, not on the actual program flow).
///   - Each subsequent instruction using the `__ast` variable conforms to the code generated by the compiler
///     (i.e. has the form of `jump target <condition> __astX testValue`)
/// </ol>
/// Push and pop instructions are ignored by the above algorithm. Push/pop instructions of any eliminated variables
/// are removed by the stack usage optimization down the line.
@NullMarked
class CaseExpressionOptimizer extends BaseOptimizer {
    public CaseExpressionOptimizer(OptimizationContext optimizationContext) {
        super(Optimization.CASE_EXPRESSION_OPTIMIZATION, optimizationContext);
    }

    @Override
    protected boolean optimizeProgram(OptimizationPhase phase) {
        try (LogicIterator it = createIterator()) {
            while (it.hasNext()) {
                if (it.next() instanceof SetInstruction ix && ix.getResult().getType() == ArgumentType.AST_VARIABLE) {
                    LogicVariable result = ix.getResult();
                    List<LogicInstruction> list = instructions(
                            in -> in.getArgs().contains(result) && !(in instanceof PushOrPopInstruction));

                    // The set instruction is not the first one
                    if (list.getFirst() != ix) continue;

                    // Some of the other instructions aren't part of the case expression
                    if (!list.stream().skip(1).allMatch(in -> isStandardCaseWhenInstruction(in, result))) continue;

                    // Replace __ast with actual value in all case branches
                    list.stream().skip(1).forEach(in -> replaceInstruction(in, replaceAllArgs(in, result, ix.getValue())));

                    // This doesn't break AST context structure. The set instruction is in a standalone context.
                    it.remove();
                }
            }
        }

        return false;
    }

    private boolean isStandardCaseWhenInstruction(LogicInstruction instruction, LogicVariable ast) {
        return instruction instanceof JumpInstruction ix && ix.getX().equals(ast);
    }
}
