package info.teksol.mindcode.compiler.optimization;

import info.teksol.mindcode.compiler.instructions.LogicInstruction;
import info.teksol.mindcode.compiler.LogicInstructionPipeline;
import info.teksol.mindcode.compiler.instructions.InstructionProcessor;

/**
 * Replaces conditional jumps whose condition is always true with unconditional jumps
 * and completely removes jumps that are always false.
 * Such conditions will only be generated by explicit code, e.g. {@code if false} or {@code while true}.
 * If a variable is involved (e.g. {@code ACTIVE = false; while ACTIVE ...}) the jump won't be removed/replaced.
 */
class ConditionalJumpsNormalizer extends PipelinedOptimizer {
    public ConditionalJumpsNormalizer(InstructionProcessor instructionProcessor, LogicInstructionPipeline next) {
        super(instructionProcessor, next);
    }

    @Override
    protected State initialState() {
        return new BaseState();
    }

    private final class BaseState implements State {
        @Override
        public State emit(LogicInstruction instruction) {
            if (instruction.isJump()) {
                if (effectivelyUnconditional(instruction)) {
                    emitToNext(createInstruction(instruction.getOpcode(), instruction.getArgs().get(0), "always"));
                } else if (!alwaysFalse(instruction)) {
                    emitToNext(instruction);
                }
            } else {
                emitToNext(instruction);
            }
            return this;
        }

        @Override
        public State flush() {
            return this;
        }
    }

    private boolean effectivelyUnconditional(LogicInstruction jump) {
        switch (jump.getArgs().get(1)) {
            case "equal":       return hasArgs(jump, "true", "true") || hasArgs(jump, "false", "false");
            case "notEqual":    return hasArgs(jump, "true", "false") || hasArgs(jump, "false", "true");
            default:            return false;
        }
    }

    private boolean alwaysFalse(LogicInstruction jump) {
        switch (jump.getArgs().get(1)) {
            case "equal":       return hasArgs(jump, "true", "false") || hasArgs(jump, "false", "true");
            case "notEqual":    return hasArgs(jump, "true", "true") || hasArgs(jump, "false", "false");
            default:            return false;
        }
    }

    private boolean hasArgs(LogicInstruction jump, String arg2, String arg3) {
        return jump.getArgs().get(2).equals(arg2) && jump.getArgs().get(3).equals(arg3);
    }
}
