package info.teksol.mindcode.mindustry;

import java.util.ArrayList;
import java.util.List;

// 1. Remove jumps (both conditional and unconditional) that target the next instruction.
//    Technically, if we have a sequence
//      0: jump 2 ...
//      1: jump 2 ...
//      2: ...
//    we could eliminate both jumps. This class will only remove the second jump, because before that removal the first
//    one doesn't target the next instruction. However, such sequences aren't typically generated by the compiler.
//
// 2. Removes jumps with "notEqual true true" condition (always false jumps generated by the compiler)
class SingleStepJumpEliminator implements LogicInstructionPipeline {
    private final LogicInstructionPipeline next;
    private State state;
    
    SingleStepJumpEliminator(LogicInstructionPipeline next) {
        this.next = next;
        this.state = new EmptyState();
    }

    @Override
    public void emit(LogicInstruction instruction) {
        state = state.emit(instruction);
    }

    @Override
    public void flush() {
        state = state.flush();
        next.flush();
    }

    private interface State {
        State emit(LogicInstruction instruction);

        State flush();
    }

    private final class EmptyState implements State {
        @Override
        public State emit(LogicInstruction instruction) {
            if (instruction.isJump()) {
                return new ExpectLabel(instruction);
            } else {
                next.emit(instruction);
                return this;
            }
        }

        @Override
        public State flush() {
            return this;
        }
    }

    private final class ExpectLabel implements State {
        private final LogicInstruction jump;
        private final String targetLabel;
        private final List<LogicInstruction> labels = new ArrayList<>();
        private boolean isJumpToNext = false;

        ExpectLabel(LogicInstruction jump) {
            this.jump = jump;
            this.targetLabel = jump.getArgs().get(0);
        }

        @Override
        public State emit(LogicInstruction instruction) {
            if (instruction.isLabel()) {
                if (instruction.getArgs().get(0).equals(targetLabel)) {
                    isJumpToNext = true;
                }
                labels.add(instruction);
                return this;
            }
            
            boolean remove = isJumpToNext || isAlwaysFalseJump(jump);
            
            if (!remove) {
                next.emit(jump);
            }
            labels.forEach(next::emit);
            
            if (instruction.isJump()) {
                return new ExpectLabel(instruction);
            } else {
                next.emit(instruction);
                return new EmptyState();
            }
        }

        @Override
        public State flush() {
            next.emit(jump);
            labels.forEach(next::emit);
            return new EmptyState();
        }

        private boolean isAlwaysFalseJump(LogicInstruction instruction) {
            List<String> args = instruction.getArgs();
            return args.get(1).equals("notEqual") && args.get(2).equals("true") && args.get(3).equals("true");
        }
    }
}
