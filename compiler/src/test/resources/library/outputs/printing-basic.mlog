assertflush *tmp0
print "1\n2\n3\n"
assertprints *tmp0 "1\n2\n3\n" "printLines(1, 2, 3)"
assertflush *tmp2
print "{2}"
op floor :formatNumber:n 0 0
format :formatNumber:n
assertprints *tmp2 "0" "printNumber(null)"
assertflush *tmp3
print "{2}"
op floor :formatNumber:n 1 0
format :formatNumber:n
assertprints *tmp3 "1" "printNumber(1)"
assertflush *tmp4
print "{2}"
op floor :formatNumber:n 1.5 0
format :formatNumber:n
assertprints *tmp4 "1" "printNumber(1.5)"
assertflush *tmp5
print "{2}"
op floor :formatNumber:n 1.5 0
format "-{2}"
format :formatNumber:n
assertprints *tmp5 "-1" "printNumber(-1.5)"
assertflush *tmp6
print "{2}"
op floor :formatNumber:n 1234567 0
op mod :formatNumber:mod :formatNumber:n 1000
select *tmp59 greaterThanEq :formatNumber:mod 10 "{2},0{1}" "{2},00{1}"
select *tmp57 greaterThanEq :formatNumber:mod 100 "{2},{1}" *tmp59
format *tmp57
format :formatNumber:mod
op idiv :formatNumber:n :formatNumber:n 1000
jump 27 greaterThan :formatNumber:n 999
format :formatNumber:n
assertprints *tmp6 "1,234,567" "printNumber(1234567)"
assertflush *tmp7
print "{2}"
op floor :formatNumber:n 1234567 0
format "-{2}"
op mod :formatNumber:mod :formatNumber:n 1000
select *tmp59 greaterThanEq :formatNumber:mod 10 "{2},0{1}" "{2},00{1}"
select *tmp57 greaterThanEq :formatNumber:mod 100 "{2},{1}" *tmp59
format *tmp57
format :formatNumber:mod
op idiv :formatNumber:n :formatNumber:n 1000
jump 40 greaterThan :formatNumber:n 999
format :formatNumber:n
assertprints *tmp7 "-1,234,567" "printNumber(-1234567)"
assertflush *tmp8
print "{2}"
op floor :formatNumber:n 9009099999 0
op mod :formatNumber:mod :formatNumber:n 1000
select *tmp59 greaterThanEq :formatNumber:mod 10 "{2},0{1}" "{2},00{1}"
select *tmp57 greaterThanEq :formatNumber:mod 100 "{2},{1}" *tmp59
format *tmp57
format :formatNumber:mod
op idiv :formatNumber:n :formatNumber:n 1000
jump 52 greaterThan :formatNumber:n 999
format :formatNumber:n
assertprints *tmp8 "9,009,099,999" "printNumber(9009099999)"
assertflush *tmp9
print "{2}"
set :formatBinaryNumber:digits 0
op floor :formatBinaryNumber:n 0b1001 0
op and *tmp64 :formatBinaryNumber:n 1
format "{2}{1}"
format *tmp64
op shr :formatBinaryNumber:n :formatBinaryNumber:n 1
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 65 greaterThan :formatBinaryNumber:n 0
jump 75 lessThanEq :formatBinaryNumber:digits 0
format "{2}0"
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 72 greaterThan :formatBinaryNumber:digits 0
format "0b"
assertprints *tmp9 "0b1001" "printBinaryNumber(0b1001, 0)"
assertflush *tmp10
print "{2}"
set :formatBinaryNumber:digits 6
op floor :formatBinaryNumber:n 0b1010 0
op and *tmp64 :formatBinaryNumber:n 1
format "{2}{1}"
format *tmp64
op shr :formatBinaryNumber:n :formatBinaryNumber:n 1
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 81 greaterThan :formatBinaryNumber:n 0
jump 91 lessThanEq :formatBinaryNumber:digits 0
format "{2}0"
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 88 greaterThan :formatBinaryNumber:digits 0
format "0b"
assertprints *tmp10 "0b001010" "printBinaryNumber(0b1010, 6)"
assertflush *tmp11
print "{2}"
set :formatBinaryNumber:digits 6
format "-{2}"
op floor :formatBinaryNumber:n 10 0
op and *tmp64 :formatBinaryNumber:n 1
format "{2}{1}"
format *tmp64
op shr :formatBinaryNumber:n :formatBinaryNumber:n 1
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 98 greaterThan :formatBinaryNumber:n 0
jump 108 lessThanEq :formatBinaryNumber:digits 0
format "{2}0"
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 105 greaterThan :formatBinaryNumber:digits 0
format "0b"
assertprints *tmp11 "-0b001010" "printBinaryNumber(-0b1010, 6)"
assertflush *tmp12
print "{2}"
set :formatHexNumber:digits 0
op floor :formatHexNumber:n 0xABCDEF 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "uwy{}" :formatHexNumber:digit
jump 131 always 0 0
format "{2}A"                           # Origin: 115, keys: 10
jump 131 always 0 0
format "{2}B"                           # Origin: 115, keys: 11
jump 131 always 0 0
format "{2}C"                           # Origin: 115, keys: 12
jump 131 always 0 0
format "{2}D"                           # Origin: 115, keys: 13
jump 131 always 0 0
format "{2}E"                           # Origin: 115, keys: 14
jump 131 always 0 0
format "{2}F"                           # Origin: 115, keys: 15
jump 131 always 0 0
format "{2}{1}"                         # Origin: 115, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 114 greaterThan :formatHexNumber:n 0
jump 138 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 135 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints *tmp12 "0xABCDEF" "printHexNumber(0xABCDEF, 0)"
assertflush *tmp13
print "{2}"
set :formatHexNumber:digits 0
op floor :formatHexNumber:n 0x1234567890 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "" :formatHexNumber:digit
jump 161 always 0 0
format "{2}A"                           # Origin: 145, keys: 10
jump 161 always 0 0
format "{2}B"                           # Origin: 145, keys: 11
jump 161 always 0 0
format "{2}C"                           # Origin: 145, keys: 12
jump 161 always 0 0
format "{2}D"                           # Origin: 145, keys: 13
jump 161 always 0 0
format "{2}E"                           # Origin: 145, keys: 14
jump 161 always 0 0
format "{2}F"                           # Origin: 145, keys: 15
jump 161 always 0 0
format "{2}{1}"                         # Origin: 145, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 144 greaterThan :formatHexNumber:n 0
jump 168 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 165 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints *tmp13 "0x1234567890" "printHexNumber(0x1234567890, 0)"
assertflush *tmp14
print "{2}"
set :formatHexNumber:digits 8
op floor :formatHexNumber:n 0xAABBCC 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "½½½½½½½½½½±³µ·¹»" :formatHexNumber:digit
jump 191 always 0 0
format "{2}A"                           # Origin: 175, keys: 10
jump 191 always 0 0
format "{2}B"                           # Origin: 175, keys: 11
jump 191 always 0 0
format "{2}C"                           # Origin: 175, keys: 12
jump 191 always 0 0
format "{2}D"                           # Origin: 175, keys: 13
jump 191 always 0 0
format "{2}E"                           # Origin: 175, keys: 14
jump 191 always 0 0
format "{2}F"                           # Origin: 175, keys: 15
jump 191 always 0 0
format "{2}{1}"                         # Origin: 175, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 174 greaterThan :formatHexNumber:n 0
jump 198 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 195 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints *tmp14 "0x00AABBCC" "printHexNumber(0xAABBCC, 8)"
assertflush *tmp15
print "{2}"
set :formatHexNumber:digits 8
format "-{2}"
op floor :formatHexNumber:n 11189196 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "ÜÜÜÜÜÜÜÜÜÜÐÒÔÖØÚ" :formatHexNumber:digit
jump 222 always 0 0
format "{2}A"                           # Origin: 206, keys: 10
jump 222 always 0 0
format "{2}B"                           # Origin: 206, keys: 11
jump 222 always 0 0
format "{2}C"                           # Origin: 206, keys: 12
jump 222 always 0 0
format "{2}D"                           # Origin: 206, keys: 13
jump 222 always 0 0
format "{2}E"                           # Origin: 206, keys: 14
jump 222 always 0 0
format "{2}F"                           # Origin: 206, keys: 15
jump 222 always 0 0
format "{2}{1}"                         # Origin: 206, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 205 greaterThan :formatHexNumber:n 0
jump 229 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 226 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints *tmp15 "-0x00AABBCC" "printHexNumber(-0xAABBCC, 8)"
assertflush *tmp16
print null
assertprints *tmp16 "null" "printExactFast(null)"
assertflush *tmp17
print 0
assertprints *tmp17 "0" "printExactFast(0)"
assertflush *tmp18
print 1
assertprints *tmp18 "1" "printExactFast(1)"
assertflush *tmp19
print "1.000000100000000"
assertprints *tmp19 "1.000000100000000" "printExactFast(1.0000001)"
assertflush *tmp20
print "3.000000070000000"
assertprints *tmp20 "3.000000070000000" "printExactFast(3.00000007)"
assertflush *tmp21
print "3E50"
assertprints *tmp21 "3E50" "printExactFast(3e50)"
assertflush *tmp22
print 1.0123456789
assertprints *tmp22 "1.0123456789" "printExactFast(1.0123456789)"
assertflush *tmp23
print "1.000000099999999E20"
assertprints *tmp23 "1.000000099999999E20" "printExactFast(1.0000001e20)"
assertflush *tmp24
print "1.2345000000000002E-50"
assertprints *tmp24 "1.2345000000000002E-50" "printExactFast(1.2345e-50)"
assertflush *tmp25
print "-1.2345000000000002E-50"
assertprints *tmp25 "-1.2345000000000002E-50" "printExactFast(-1.2345e-50)"
assertflush *tmp26
print null
assertprints *tmp26 "null" "printExactSlow(null)"
assertflush *tmp27
print 0
assertprints *tmp27 "0" "printExactSlow(0)"
assertflush *tmp28
print "1.000000000000000"
assertprints *tmp28 "1.000000000000000" "printExactSlow(1)"
assertflush *tmp29
print "1.000000100000000"
assertprints *tmp29 "1.000000100000000" "printExactSlow(1.0000001)"
assertflush *tmp30
print "3.000000070000000"
assertprints *tmp30 "3.000000070000000" "printExactSlow(3.00000007)"
assertflush *tmp31
print "3.000000000000000E50"
assertprints *tmp31 "3.000000000000000E50" "printExactSlow(3e50)"
assertflush *tmp32
print "1.012345678900000"
assertprints *tmp32 "1.012345678900000" "printExactSlow(1.0123456789)"
assertflush *tmp33
print "1.000000099999999E20"
assertprints *tmp33 "1.000000099999999E20" "printExactSlow(1.0000001e20)"
assertflush *tmp34
print "1.234500000000000E-50"
assertprints *tmp34 "1.234500000000000E-50" "printExactSlow(1.2345e-50)"
assertflush *tmp35
print "-1.234500000000000E-50"
assertprints *tmp35 "-1.234500000000000E-50" "printExactSlow(-1.2345e-50)"
assertflush *tmp36
print "1111111111111111111111110000111100000000000000000000000000000000"
assertprints *tmp36 "1111111111111111111111110000111100000000000000000000000000000000" "printExactBinary(0xFFFFFF0F << 32)"
assertflush *tmp42
print "FFFFFF0F00000000"
assertprints *tmp42 "FFFFFF0F00000000" "printExactHex(0xFFFFFF0F << 32)"
stop
print "Compiled by Mindcode - github.com/cardillan/mindcode"
