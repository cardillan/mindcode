assertflush
print "1\n2\n3\n"
assertprints "1\n2\n3\n" "printLines(1, 2, 3)"
assertflush
print "{2}"
op floor :formatNumber:n 0 0
format :formatNumber:n
assertprints "0" "printNumber(null)"
assertflush
print "{2}"
op floor :formatNumber:n 1 0
format :formatNumber:n
assertprints "1" "printNumber(1)"
assertflush
print "{2}"
op floor :formatNumber:n 1.5 0
format :formatNumber:n
assertprints "1" "printNumber(1.5)"
assertflush
print "{2}"
op floor :formatNumber:n 1.5 0
format "-{2}"
format :formatNumber:n
assertprints "-1" "printNumber(-1.5)"
assertflush
print "{2}"
op floor :formatNumber:n 1234567 0
op mod :formatNumber:mod :formatNumber:n 1000
select *tmp22 greaterThanEq :formatNumber:mod 10 "{2},0{1}" "{2},00{1}"
select *tmp20 greaterThanEq :formatNumber:mod 100 "{2},{1}" *tmp22
format *tmp20
format :formatNumber:mod
op idiv :formatNumber:n :formatNumber:n 1000
jump 27 greaterThan :formatNumber:n 999
format :formatNumber:n
assertprints "1,234,567" "printNumber(1234567)"
assertflush
print "{2}"
op floor :formatNumber:n 1234567 0
format "-{2}"
op mod :formatNumber:mod :formatNumber:n 1000
select *tmp22 greaterThanEq :formatNumber:mod 10 "{2},0{1}" "{2},00{1}"
select *tmp20 greaterThanEq :formatNumber:mod 100 "{2},{1}" *tmp22
format *tmp20
format :formatNumber:mod
op idiv :formatNumber:n :formatNumber:n 1000
jump 40 greaterThan :formatNumber:n 999
format :formatNumber:n
assertprints "-1,234,567" "printNumber(-1234567)"
assertflush
print "{2}"
op floor :formatNumber:n 9009099999 0
op mod :formatNumber:mod :formatNumber:n 1000
select *tmp22 greaterThanEq :formatNumber:mod 10 "{2},0{1}" "{2},00{1}"
select *tmp20 greaterThanEq :formatNumber:mod 100 "{2},{1}" *tmp22
format *tmp20
format :formatNumber:mod
op idiv :formatNumber:n :formatNumber:n 1000
jump 52 greaterThan :formatNumber:n 999
format :formatNumber:n
assertprints "9,009,099,999" "printNumber(9009099999)"
assertflush
print "{2}"
set :formatBinaryNumber:digits 0
op floor :formatBinaryNumber:n 0b1001 0
op and *tmp27 :formatBinaryNumber:n 1
format "{2}{1}"
format *tmp27
op shr :formatBinaryNumber:n :formatBinaryNumber:n 1
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 65 greaterThan :formatBinaryNumber:n 0
jump 75 lessThanEq :formatBinaryNumber:digits 0
format "{2}0"
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 72 greaterThan :formatBinaryNumber:digits 0
format "0b"
assertprints "0b1001" "printBinaryNumber(0b1001, 0)"
assertflush
print "{2}"
set :formatBinaryNumber:digits 6
op floor :formatBinaryNumber:n 0b1010 0
op and *tmp27 :formatBinaryNumber:n 1
format "{2}{1}"
format *tmp27
op shr :formatBinaryNumber:n :formatBinaryNumber:n 1
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 81 greaterThan :formatBinaryNumber:n 0
jump 91 lessThanEq :formatBinaryNumber:digits 0
format "{2}0"
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 88 greaterThan :formatBinaryNumber:digits 0
format "0b"
assertprints "0b001010" "printBinaryNumber(0b1010, 6)"
assertflush
print "{2}"
set :formatBinaryNumber:digits 6
format "-{2}"
op floor :formatBinaryNumber:n 10 0
op and *tmp27 :formatBinaryNumber:n 1
format "{2}{1}"
format *tmp27
op shr :formatBinaryNumber:n :formatBinaryNumber:n 1
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 98 greaterThan :formatBinaryNumber:n 0
jump 108 lessThanEq :formatBinaryNumber:digits 0
format "{2}0"
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 105 greaterThan :formatBinaryNumber:digits 0
format "0b"
assertprints "-0b001010" "printBinaryNumber(-0b1010, 6)"
assertflush
print "{2}"
set :formatHexNumber:digits 0
op floor :formatHexNumber:n 0xABCDEF 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "uwy{}" :formatHexNumber:digit
jump 131 always 0 0
format "{2}A"                           # Origin: 115, keys: 10
jump 131 always 0 0
format "{2}B"                           # Origin: 115, keys: 11
jump 131 always 0 0
format "{2}C"                           # Origin: 115, keys: 12
jump 131 always 0 0
format "{2}D"                           # Origin: 115, keys: 13
jump 131 always 0 0
format "{2}E"                           # Origin: 115, keys: 14
jump 131 always 0 0
format "{2}F"                           # Origin: 115, keys: 15
jump 131 always 0 0
format "{2}{1}"                         # Origin: 115, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 114 greaterThan :formatHexNumber:n 0
jump 138 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 135 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints "0xABCDEF" "printHexNumber(0xABCDEF, 0)"
assertflush
print "{2}"
set :formatHexNumber:digits 0
op floor :formatHexNumber:n 0x1234567890 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "" :formatHexNumber:digit
jump 161 always 0 0
format "{2}A"                           # Origin: 145, keys: 10
jump 161 always 0 0
format "{2}B"                           # Origin: 145, keys: 11
jump 161 always 0 0
format "{2}C"                           # Origin: 145, keys: 12
jump 161 always 0 0
format "{2}D"                           # Origin: 145, keys: 13
jump 161 always 0 0
format "{2}E"                           # Origin: 145, keys: 14
jump 161 always 0 0
format "{2}F"                           # Origin: 145, keys: 15
jump 161 always 0 0
format "{2}{1}"                         # Origin: 145, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 144 greaterThan :formatHexNumber:n 0
jump 168 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 165 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints "0x1234567890" "printHexNumber(0x1234567890, 0)"
assertflush
print "{2}"
set :formatHexNumber:digits 8
op floor :formatHexNumber:n 0xAABBCC 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "½½½½½½½½½½±³µ·¹»" :formatHexNumber:digit
jump 191 always 0 0
format "{2}A"                           # Origin: 175, keys: 10
jump 191 always 0 0
format "{2}B"                           # Origin: 175, keys: 11
jump 191 always 0 0
format "{2}C"                           # Origin: 175, keys: 12
jump 191 always 0 0
format "{2}D"                           # Origin: 175, keys: 13
jump 191 always 0 0
format "{2}E"                           # Origin: 175, keys: 14
jump 191 always 0 0
format "{2}F"                           # Origin: 175, keys: 15
jump 191 always 0 0
format "{2}{1}"                         # Origin: 175, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 174 greaterThan :formatHexNumber:n 0
jump 198 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 195 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints "0x00AABBCC" "printHexNumber(0xAABBCC, 8)"
assertflush
print "{2}"
set :formatHexNumber:digits 8
format "-{2}"
op floor :formatHexNumber:n 11189196 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "ÜÜÜÜÜÜÜÜÜÜÐÒÔÖØÚ" :formatHexNumber:digit
jump 222 always 0 0
format "{2}A"                           # Origin: 206, keys: 10
jump 222 always 0 0
format "{2}B"                           # Origin: 206, keys: 11
jump 222 always 0 0
format "{2}C"                           # Origin: 206, keys: 12
jump 222 always 0 0
format "{2}D"                           # Origin: 206, keys: 13
jump 222 always 0 0
format "{2}E"                           # Origin: 206, keys: 14
jump 222 always 0 0
format "{2}F"                           # Origin: 206, keys: 15
jump 222 always 0 0
format "{2}{1}"                         # Origin: 206, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 205 greaterThan :formatHexNumber:n 0
jump 229 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 226 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints "-0x00AABBCC" "printHexNumber(-0xAABBCC, 8)"
assertflush
print null
assertprints "null" "printExactFast(null)"
assertflush
print 0
assertprints "0" "printExactFast(0)"
assertflush
print 1
assertprints "1" "printExactFast(1)"
assertflush
print "1.000000100000000"
assertprints "1.000000100000000" "printExactFast(1.0000001)"
assertflush
print "3.000000070000000"
assertprints "3.000000070000000" "printExactFast(3.00000007)"
assertflush
print "3E50"
assertprints "3E50" "printExactFast(3e50)"
assertflush
print 1.0123456789
assertprints "1.0123456789" "printExactFast(1.0123456789)"
assertflush
print "1.000000099999999E20"
assertprints "1.000000099999999E20" "printExactFast(1.0000001e20)"
assertflush
print "1.2345000000000002E-50"
assertprints "1.2345000000000002E-50" "printExactFast(1.2345e-50)"
assertflush
print "-1.2345000000000002E-50"
assertprints "-1.2345000000000002E-50" "printExactFast(-1.2345e-50)"
assertflush
op abs *tmp77 null 0
print null
assertprints "null" "printExactSlow(null)"
assertflush
set :printExactSlow:n 0
set :printExactSlow*retaddr 269
jump 419 always 0 0
assertprints "0" "printExactSlow(0)"
assertflush
set :printExactSlow:n 1
set :printExactSlow*retaddr 274
jump 419 always 0 0
assertprints "1.000000000000000" "printExactSlow(1)"
assertflush
set :printExactSlow:n 1.0000001
set :printExactSlow*retaddr 279
jump 419 always 0 0
assertprints "1.000000100000000" "printExactSlow(1.0000001)"
assertflush
set :printExactSlow:n 3.00000007
set :printExactSlow*retaddr 284
jump 419 always 0 0
assertprints "3.000000070000000" "printExactSlow(3.00000007)"
assertflush
set :printExactSlow:n 3E50
set :printExactSlow*retaddr 289
jump 419 always 0 0
assertprints "3.000000000000000E50" "printExactSlow(3e50)"
assertflush
set :printExactSlow:n 1.0123456789
set :printExactSlow*retaddr 294
jump 419 always 0 0
assertprints "1.012345678900000" "printExactSlow(1.0123456789)"
assertflush
set :printExactSlow:n 10000001E13
set :printExactSlow*retaddr 299
jump 419 always 0 0
assertprints "1.000000099999999E20" "printExactSlow(1.0000001e20)"
assertflush
set :printExactSlow:n 12345E-54
set :printExactSlow*retaddr 304
jump 419 always 0 0
assertprints "1.234500000000000E-50" "printExactSlow(1.2345e-50)"
assertflush
set :printExactSlow:n -12345E-54
set :printExactSlow*retaddr 309
jump 419 always 0 0
assertprints "-1.234500000000000E-50" "printExactSlow(-1.2345e-50)"
assertflush
op shr :printExactBinary:t -1035087118336 32
set *tmp1 314
jump 316 always 0 0
op and :printExactBinary:t -1035087118336 0xFFFFFFFF
set *tmp1 413
op shr *tmp4 :printExactBinary:t 31
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 30
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 29
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 28
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 27
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 26
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 25
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 24
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 23
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 22
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 21
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 20
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 19
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 18
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 17
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 16
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 15
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 14
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 13
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 12
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 11
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 10
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 9
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 8
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 7
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 6
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 5
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 4
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 3
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 2
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 1
op and *tmp5 *tmp4 1
print *tmp5
op shr *tmp4 :printExactBinary:t 0
op and *tmp5 *tmp4 1
print *tmp5
set @counter *tmp1
assertprints "1111111111111111111111110000111100000000000000000000000000000000" "printExactBinary(0xFFFFFF0F << 32)"
assertflush
print "FFFFFF0F00000000"
assertprints "FFFFFF0F00000000" "printExactHex(0xFFFFFF0F << 32)"
stop
end
op abs *tmp77 :printExactSlow:n 0
jump 423 greaterThan *tmp77 0
print :printExactSlow:n
set @counter :printExactSlow*retaddr
jump 426 greaterThanEq :printExactSlow:n 0
print "-"
op abs :printExactSlow:n :printExactSlow:n 0
op log10 *tmp83 :printExactSlow:n 0
op floor :printExactSlow:exp *tmp83 0
op sub *tmp85 0 :printExactSlow:exp
op pow *tmp86 10 *tmp85
op mul :printExactSlow:base :printExactSlow:n *tmp86
op floor *tmp88 :printExactSlow:base 0
print *tmp88
print "."
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
op mod *tmp89 :printExactSlow:base 1
op mul :printExactSlow:base *tmp89 10
op floor *tmp92 :printExactSlow:base 0
print *tmp92
jump 497 equal :printExactSlow:exp 0
print "E"
print :printExactSlow:exp
set @counter :printExactSlow*retaddr
print "Compiled by Mindcode - github.com/cardillan/mindcode"
