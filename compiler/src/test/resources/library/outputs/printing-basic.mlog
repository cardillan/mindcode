assertflush
print "1\n2\n3\n"
assertprints "1\n2\n3\n" "printLines(1, 2, 3)"
assertflush
print "{2}"
op floor :formatNumber:n 0 0
format :formatNumber:n
assertprints "0" "printNumber(null)"
assertflush
print "{2}"
op floor :formatNumber:n 1 0
format :formatNumber:n
assertprints "1" "printNumber(1)"
assertflush
print "{2}"
op floor :formatNumber:n 1.5 0
format :formatNumber:n
assertprints "1" "printNumber(1.5)"
assertflush
print "{2}"
op floor :formatNumber:n 1.5 0
format "-{2}"
format :formatNumber:n
assertprints "-1" "printNumber(-1.5)"
assertflush
print "{2}"
op floor :formatNumber:n 1234567 0
op mod :formatNumber:mod :formatNumber:n 1000
select *tmp22 greaterThanEq :formatNumber:mod 10 "{2},0{1}" "{2},00{1}"
select *tmp20 greaterThanEq :formatNumber:mod 100 "{2},{1}" *tmp22
format *tmp20
format :formatNumber:mod
op idiv :formatNumber:n :formatNumber:n 1000
jump 27 greaterThan :formatNumber:n 999
format :formatNumber:n
assertprints "1,234,567" "printNumber(1234567)"
assertflush
print "{2}"
op floor :formatNumber:n 1234567 0
format "-{2}"
op mod :formatNumber:mod :formatNumber:n 1000
select *tmp22 greaterThanEq :formatNumber:mod 10 "{2},0{1}" "{2},00{1}"
select *tmp20 greaterThanEq :formatNumber:mod 100 "{2},{1}" *tmp22
format *tmp20
format :formatNumber:mod
op idiv :formatNumber:n :formatNumber:n 1000
jump 40 greaterThan :formatNumber:n 999
format :formatNumber:n
assertprints "-1,234,567" "printNumber(-1234567)"
assertflush
print "{2}"
op floor :formatNumber:n 9009099999 0
op mod :formatNumber:mod :formatNumber:n 1000
select *tmp22 greaterThanEq :formatNumber:mod 10 "{2},0{1}" "{2},00{1}"
select *tmp20 greaterThanEq :formatNumber:mod 100 "{2},{1}" *tmp22
format *tmp20
format :formatNumber:mod
op idiv :formatNumber:n :formatNumber:n 1000
jump 52 greaterThan :formatNumber:n 999
format :formatNumber:n
assertprints "9,009,099,999" "printNumber(9009099999)"
assertflush
print "{2}"
set :formatBinaryNumber:digits 0
op floor :formatBinaryNumber:n 0b1001 0
op and *tmp27 :formatBinaryNumber:n 1
format "{2}{1}"
format *tmp27
op shr :formatBinaryNumber:n :formatBinaryNumber:n 1
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 65 greaterThan :formatBinaryNumber:n 0
jump 75 lessThanEq :formatBinaryNumber:digits 0
format "{2}0"
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 72 greaterThan :formatBinaryNumber:digits 0
format "0b"
assertprints "0b1001" "printBinaryNumber(0b1001, 0)"
assertflush
print "{2}"
set :formatBinaryNumber:digits 6
op floor :formatBinaryNumber:n 0b1010 0
op and *tmp27 :formatBinaryNumber:n 1
format "{2}{1}"
format *tmp27
op shr :formatBinaryNumber:n :formatBinaryNumber:n 1
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 81 greaterThan :formatBinaryNumber:n 0
jump 91 lessThanEq :formatBinaryNumber:digits 0
format "{2}0"
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 88 greaterThan :formatBinaryNumber:digits 0
format "0b"
assertprints "0b001010" "printBinaryNumber(0b1010, 6)"
assertflush
print "{2}"
set :formatBinaryNumber:digits 6
format "-{2}"
op floor :formatBinaryNumber:n 10 0
op and *tmp27 :formatBinaryNumber:n 1
format "{2}{1}"
format *tmp27
op shr :formatBinaryNumber:n :formatBinaryNumber:n 1
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 98 greaterThan :formatBinaryNumber:n 0
jump 108 lessThanEq :formatBinaryNumber:digits 0
format "{2}0"
op sub :formatBinaryNumber:digits :formatBinaryNumber:digits 1
jump 105 greaterThan :formatBinaryNumber:digits 0
format "0b"
assertprints "-0b001010" "printBinaryNumber(-0b1010, 6)"
assertflush
print "{2}"
set :formatHexNumber:digits 0
op floor :formatHexNumber:n 0xABCDEF 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "uwy{}" :formatHexNumber:digit
jump 131 always 0 0
format "{2}A"                           # Origin: 115, keys: 10
jump 131 always 0 0
format "{2}B"                           # Origin: 115, keys: 11
jump 131 always 0 0
format "{2}C"                           # Origin: 115, keys: 12
jump 131 always 0 0
format "{2}D"                           # Origin: 115, keys: 13
jump 131 always 0 0
format "{2}E"                           # Origin: 115, keys: 14
jump 131 always 0 0
format "{2}F"                           # Origin: 115, keys: 15
jump 131 always 0 0
format "{2}{1}"                         # Origin: 115, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 114 greaterThan :formatHexNumber:n 0
jump 138 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 135 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints "0xABCDEF" "printHexNumber(0xABCDEF, 0)"
assertflush
print "{2}"
set :formatHexNumber:digits 0
op floor :formatHexNumber:n 0x1234567890 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "" :formatHexNumber:digit
jump 161 always 0 0
format "{2}A"                           # Origin: 145, keys: 10
jump 161 always 0 0
format "{2}B"                           # Origin: 145, keys: 11
jump 161 always 0 0
format "{2}C"                           # Origin: 145, keys: 12
jump 161 always 0 0
format "{2}D"                           # Origin: 145, keys: 13
jump 161 always 0 0
format "{2}E"                           # Origin: 145, keys: 14
jump 161 always 0 0
format "{2}F"                           # Origin: 145, keys: 15
jump 161 always 0 0
format "{2}{1}"                         # Origin: 145, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 144 greaterThan :formatHexNumber:n 0
jump 168 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 165 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints "0x1234567890" "printHexNumber(0x1234567890, 0)"
assertflush
print "{2}"
set :formatHexNumber:digits 8
op floor :formatHexNumber:n 0xAABBCC 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "½½½½½½½½½½±³µ·¹»" :formatHexNumber:digit
jump 191 always 0 0
format "{2}A"                           # Origin: 175, keys: 10
jump 191 always 0 0
format "{2}B"                           # Origin: 175, keys: 11
jump 191 always 0 0
format "{2}C"                           # Origin: 175, keys: 12
jump 191 always 0 0
format "{2}D"                           # Origin: 175, keys: 13
jump 191 always 0 0
format "{2}E"                           # Origin: 175, keys: 14
jump 191 always 0 0
format "{2}F"                           # Origin: 175, keys: 15
jump 191 always 0 0
format "{2}{1}"                         # Origin: 175, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 174 greaterThan :formatHexNumber:n 0
jump 198 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 195 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints "0x00AABBCC" "printHexNumber(0xAABBCC, 8)"
assertflush
print "{2}"
set :formatHexNumber:digits 8
format "-{2}"
op floor :formatHexNumber:n 11189196 0
op mod :formatHexNumber:digit :formatHexNumber:n 16
read @counter "ÜÜÜÜÜÜÜÜÜÜÐÒÔÖØÚ" :formatHexNumber:digit
jump 222 always 0 0
format "{2}A"                           # Origin: 206, keys: 10
jump 222 always 0 0
format "{2}B"                           # Origin: 206, keys: 11
jump 222 always 0 0
format "{2}C"                           # Origin: 206, keys: 12
jump 222 always 0 0
format "{2}D"                           # Origin: 206, keys: 13
jump 222 always 0 0
format "{2}E"                           # Origin: 206, keys: 14
jump 222 always 0 0
format "{2}F"                           # Origin: 206, keys: 15
jump 222 always 0 0
format "{2}{1}"                         # Origin: 206, keys: 0 .. 9
format :formatHexNumber:digit
op shr :formatHexNumber:n :formatHexNumber:n 4
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 205 greaterThan :formatHexNumber:n 0
jump 229 lessThanEq :formatHexNumber:digits 0
format "{2}0"
op sub :formatHexNumber:digits :formatHexNumber:digits 1
jump 226 greaterThan :formatHexNumber:digits 0
format "0x"
assertprints "-0x00AABBCC" "printHexNumber(-0xAABBCC, 8)"
assertflush
print null
assertprints "null" "printExactFast(null)"
assertflush
print 0
assertprints "0" "printExactFast(0)"
assertflush
print 1
assertprints "1" "printExactFast(1)"
assertflush
print "1.000000100000000"
assertprints "1.000000100000000" "printExactFast(1.0000001)"
assertflush
print "3.000000070000000"
assertprints "3.000000070000000" "printExactFast(3.00000007)"
assertflush
print "3E50"
assertprints "3E50" "printExactFast(3e50)"
assertflush
print 1.0123456789
assertprints "1.0123456789" "printExactFast(1.0123456789)"
assertflush
print "1.000000099999999E20"
assertprints "1.000000099999999E20" "printExactFast(1.0000001e20)"
assertflush
print "1.2345000000000002E-50"
assertprints "1.2345000000000002E-50" "printExactFast(1.2345e-50)"
assertflush
print "-1.2345000000000002E-50"
assertprints "-1.2345000000000002E-50" "printExactFast(-1.2345e-50)"
assertflush
print null
assertprints "null" "printExactSlow(null)"
assertflush
print 0
assertprints "0" "printExactSlow(0)"
assertflush
print "1.000000000000000"
assertprints "1.000000000000000" "printExactSlow(1)"
assertflush
print "1.000000100000000"
assertprints "1.000000100000000" "printExactSlow(1.0000001)"
assertflush
print "3.000000070000000"
assertprints "3.000000070000000" "printExactSlow(3.00000007)"
assertflush
print "3.000000000000000E50"
assertprints "3.000000000000000E50" "printExactSlow(3e50)"
assertflush
print "1.012345678900000"
assertprints "1.012345678900000" "printExactSlow(1.0123456789)"
assertflush
print "1.000000099999999E20"
assertprints "1.000000099999999E20" "printExactSlow(1.0000001e20)"
assertflush
print "1.234500000000000E-50"
assertprints "1.234500000000000E-50" "printExactSlow(1.2345e-50)"
assertflush
print "-1.234500000000000E-50"
assertprints "-1.234500000000000E-50" "printExactSlow(-1.2345e-50)"
assertflush
print "1111111111111111111111110000111100000000000000000000000000000000"
assertprints "1111111111111111111111110000111100000000000000000000000000000000" "printExactBinary(0xFFFFFF0F << 32)"
assertflush
print "FFFFFF0F00000000"
assertprints "FFFFFF0F00000000" "printExactHex(0xFFFFFF0F << 32)"
stop
print "Compiled by Mindcode - github.com/cardillan/mindcode"
