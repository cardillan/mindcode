   179 instructions before optimizations.
     7 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
    26 instructions eliminated by Dead Code Elimination (6 iterations).
    15 instructions eliminated by Condition Optimization (7 iterations).
    14 instructions eliminated by Single Step Elimination (4 passes, 10 iterations).
     2 instructions eliminated by Boolean Optimization (7 iterations).
       2 fully-evaluated expressions optimized using selects.
    23 instructions eliminated by Data Flow Optimization (6 iterations).
     6 instructions updated by Jump Threading.
     7 instructions eliminated by Unreachable Code Elimination (2 passes, 3 iterations).
     8 instructions eliminated by Print Merging.
    77 instructions after optimizations.

Final code before resolving virtual instructions:

    0:  sensor *tmp1 @unit @x
    1:  op sub *tmp2 null *tmp1
    2:  sensor *tmp3 @unit @y
    3:  op sub *tmp4 null *tmp3
    4:  op len *tmp5 *tmp2 *tmp4
    5:  op lessThan *tmp0 *tmp5 null
    6:  print *tmp0
    7:  print "\n"
    8:  ubind null
    9:  jump *label3 notEqual @unit null
   10:  set *tmp7 null
   11:  jump *label2 always 0 0
        label *label3
   12:  set :findFreeUnit:first_unit @unit
        label *label5
   13:  sensor *tmp10 @unit @controlled
   14:  jump *label8 notEqual *tmp10 0
   15:  ucontrol flag null 0 0 0 0
   16:  set *tmp7 @unit
   17:  jump *label2 always 0 0
        label *label8
   18:  sensor *tmp13 :findFreeUnit:first_unit @dead
   19:  select :findFreeUnit:first_unit equal *tmp13 1 @unit :findFreeUnit:first_unit
   20:  ubind null
   21:  jump *label5 notEqual :findFreeUnit:first_unit @unit
   22:  set *tmp7 null
        label *label2
   23:  print *tmp7
   24:  print "\n"
        label *label13
   25:  ubind null
   26:  jump *label16 notEqual @unit null
   27:  set *tmp18 null
   28:  jump *label12 always 0 0
        label *label16
   29:  set :findClosestUnit:first_unit @unit
   30:  set :findClosestUnit:best_unit null
   31:  set :findClosestUnit:best_distance 10000000000
        label *label18
   32:  sensor *tmp21 @unit @controlled
   33:  jump *label21 notEqual *tmp21 0
   34:  sensor *tmp24 @unit @x
   35:  op sub *tmp25 *tmp24 null
   36:  sensor *tmp26 @unit @y
   37:  op sub *tmp27 *tmp26 null
   38:  op len :findClosestUnit:distance *tmp25 *tmp27
   39:  jump *label22 greaterThanEq :findClosestUnit:distance :findClosestUnit:best_distance
   40:  set :findClosestUnit:best_distance :findClosestUnit:distance
   41:  set :findClosestUnit:best_unit @unit
   42:  jump *label22 always 0 0
        label *label21
   43:  sensor *tmp32 :findClosestUnit:first_unit @dead
   44:  select :findClosestUnit:first_unit equal *tmp32 1 @unit :findClosestUnit:first_unit
        label *label22
   45:  ubind null
   46:  jump *label18 notEqual :findClosestUnit:first_unit @unit
   47:  jump *label27 notEqual :findClosestUnit:best_unit null
   48:  set *tmp18 null
   49:  jump *label12 always 0 0
        label *label27
   50:  sensor *tmp39 :findClosestUnit:best_unit @controlled
   51:  jump *label13 notEqual *tmp39 0
   52:  ubind :findClosestUnit:best_unit
   53:  ucontrol flag null 0 0 0 0
   54:  set *tmp18 :findClosestUnit:best_unit
        label *label12
   55:  print *tmp18
   56:  print "\n"
        label *label32
   57:  ubind null
   58:  jump *label32 equal @unit null
   59:  sensor *tmp45 @unit @controlled
   60:  jump *label32 notEqual *tmp45 0
   61:  ucontrol flag null 0 0 0 0
   62:  print @unit
   63:  print "\n"
        label *label40
   64:  ubind null
   65:  jump *label43 notEqual @unit null
   66:  print "nullNo unit of type null found."
   67:  printflush null
   68:  jump *label40 always 0 0
        label *label43
   69:  sensor *tmp51 @unit @controlled
   70:  jump *label45 equal *tmp51 0
   71:  print "nullLooking for a free null..."
   72:  printflush null
   73:  jump *label40 always 0 0
        label *label45
   74:  ucontrol flag null 0 0 0 0
   75:  print @unit
   76:  print "\n"
