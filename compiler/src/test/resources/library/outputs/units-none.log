
Final code before resolving virtual instructions:

    0:  set :initial_flag null
    1:  set :message null
    2:  set :preface null
    3:  set :radius null
    4:  set :unit_type null
    5:  set :x null
    6:  set :y null
    7:  set :noControlWithin:x :x
    8:  set :noControlWithin:y :y
    9:  set :noControlWithin:radius :radius
   10:  sensor *tmp1 @unit @x
   11:  op sub *tmp2 :noControlWithin:x *tmp1
   12:  sensor *tmp3 @unit @y
   13:  op sub *tmp4 :noControlWithin:y *tmp3
   14:  op len *tmp5 *tmp2 *tmp4
   15:  op lessThan *tmp6 *tmp5 :noControlWithin:radius
   16:  set *tmp0 *tmp6
        label *label1
   17:  print *tmp0
   18:  print "\n"
   19:  set :findFreeUnit:unit_type :unit_type
   20:  set :findFreeUnit:initial_flag :initial_flag
   21:  ubind :findFreeUnit:unit_type
   22:  op equal *tmp8 @unit null
   23:  jump *label3 equal *tmp8 false
   24:  set *tmp7 null
   25:  jump *label2 always 0 0
   26:  set *tmp9 null
   27:  jump *label4 always 0 0
        label *label3
   28:  set *tmp9 null
        label *label4
   29:  set :findFreeUnit:first_unit @unit
        label *label5
   30:  sensor *tmp10 @unit @controlled
   31:  op equal *tmp11 *tmp10 0
   32:  jump *label8 equal *tmp11 false
   33:  ucontrol flag :findFreeUnit:initial_flag 0 0 0 0
   34:  set *tmp7 @unit
   35:  jump *label2 always 0 0
   36:  set *tmp12 null
   37:  jump *label9 always 0 0
        label *label8
   38:  sensor *tmp13 :findFreeUnit:first_unit @dead
   39:  op equal *tmp14 *tmp13 1
   40:  jump *label10 equal *tmp14 false
   41:  set *tmp16 @unit
   42:  set :findFreeUnit:first_unit *tmp16
   43:  set *tmp15 :findFreeUnit:first_unit
   44:  jump *label11 always 0 0
        label *label10
   45:  set *tmp15 null
        label *label11
   46:  set *tmp12 *tmp15
        label *label9
   47:  ubind :findFreeUnit:unit_type
        label *label6
   48:  op notEqual *tmp17 :findFreeUnit:first_unit @unit
   49:  jump *label5 notEqual *tmp17 false
        label *label7
   50:  set *tmp7 null
   51:  jump *label2 always 0 0
   52:  set *tmp7 null
        label *label2
   53:  print *tmp7
   54:  print "\n"
   55:  set :findClosestUnit:x :x
   56:  set :findClosestUnit:y :y
   57:  set :findClosestUnit:unit_type :unit_type
   58:  set :findClosestUnit:initial_flag :initial_flag
        label *label13
   59:  ubind :findClosestUnit:unit_type
   60:  op equal *tmp19 @unit null
   61:  jump *label16 equal *tmp19 false
   62:  set *tmp18 null
   63:  jump *label12 always 0 0
   64:  set *tmp20 null
   65:  jump *label17 always 0 0
        label *label16
   66:  set *tmp20 null
        label *label17
   67:  set :findClosestUnit:first_unit @unit
   68:  set :findClosestUnit:best_unit null
   69:  set :findClosestUnit:best_distance 10000000000
        label *label18
   70:  sensor *tmp21 @unit @controlled
   71:  op equal *tmp22 *tmp21 0
   72:  jump *label21 equal *tmp22 false
   73:  sensor *tmp24 @unit @x
   74:  op sub *tmp25 *tmp24 :findClosestUnit:x
   75:  sensor *tmp26 @unit @y
   76:  op sub *tmp27 *tmp26 :findClosestUnit:y
   77:  op len *tmp28 *tmp25 *tmp27
   78:  set :findClosestUnit:distance *tmp28
   79:  op lessThan *tmp29 :findClosestUnit:distance :findClosestUnit:best_distance
   80:  jump *label23 equal *tmp29 false
   81:  set :findClosestUnit:best_distance :findClosestUnit:distance
   82:  set *tmp31 @unit
   83:  set :findClosestUnit:best_unit *tmp31
   84:  set *tmp30 :findClosestUnit:best_unit
   85:  jump *label24 always 0 0
        label *label23
   86:  set *tmp30 null
        label *label24
   87:  set *tmp23 *tmp30
   88:  jump *label22 always 0 0
        label *label21
   89:  sensor *tmp32 :findClosestUnit:first_unit @dead
   90:  op equal *tmp33 *tmp32 1
   91:  jump *label25 equal *tmp33 false
   92:  set *tmp35 @unit
   93:  set :findClosestUnit:first_unit *tmp35
   94:  set *tmp34 :findClosestUnit:first_unit
   95:  jump *label26 always 0 0
        label *label25
   96:  set *tmp34 null
        label *label26
   97:  set *tmp23 *tmp34
        label *label22
   98:  ubind :findClosestUnit:unit_type
        label *label19
   99:  op notEqual *tmp36 :findClosestUnit:first_unit @unit
  100:  jump *label18 notEqual *tmp36 false
        label *label20
  101:  op equal *tmp37 :findClosestUnit:best_unit null
  102:  jump *label27 equal *tmp37 false
  103:  set *tmp18 null
  104:  jump *label12 always 0 0
  105:  set *tmp38 null
  106:  jump *label28 always 0 0
        label *label27
  107:  set *tmp38 null
        label *label28
  108:  sensor *tmp39 :findClosestUnit:best_unit @controlled
  109:  op equal *tmp40 *tmp39 0
  110:  jump *label29 equal *tmp40 false
  111:  ubind :findClosestUnit:best_unit
  112:  ucontrol flag :findClosestUnit:initial_flag 0 0 0 0
  113:  set *tmp18 :findClosestUnit:best_unit
  114:  jump *label12 always 0 0
  115:  set *tmp41 null
  116:  jump *label30 always 0 0
        label *label29
  117:  set *tmp41 null
        label *label30
        label *label14
  118:  jump *label13 always 0 0
        label *label15
  119:  set *tmp18 null
        label *label12
  120:  print *tmp18
  121:  print "\n"
  122:  set :waitForFreeUnit:unit_type :unit_type
  123:  set :waitForFreeUnit:initial_flag :initial_flag
        label *label32
  124:  ubind :waitForFreeUnit:unit_type
  125:  op notEqual *tmp43 @unit null
  126:  jump *label35 equal *tmp43 false
  127:  sensor *tmp45 @unit @controlled
  128:  op equal *tmp46 *tmp45 0
  129:  jump *label37 equal *tmp46 false
  130:  ucontrol flag :waitForFreeUnit:initial_flag 0 0 0 0
  131:  set *tmp42 @unit
  132:  jump *label31 always 0 0
  133:  set *tmp47 null
  134:  jump *label38 always 0 0
        label *label37
  135:  set *tmp47 null
        label *label38
  136:  set *tmp44 *tmp47
  137:  jump *label36 always 0 0
        label *label35
  138:  set *tmp44 null
        label *label36
        label *label33
  139:  jump *label32 always 0 0
        label *label34
  140:  set *tmp42 null
        label *label31
  141:  print *tmp42
  142:  print "\n"
  143:  set :waitForFreeUnit.1:message :message
  144:  set :waitForFreeUnit.1:preface :preface
  145:  set :waitForFreeUnit.1:unit_type :unit_type
  146:  set :waitForFreeUnit.1:initial_flag :initial_flag
        label *label40
  147:  ubind :waitForFreeUnit.1:unit_type
  148:  op equal *tmp49 @unit null
  149:  jump *label43 equal *tmp49 false
  150:  print :waitForFreeUnit.1:preface
  151:  print "No unit of type "
  152:  print :waitForFreeUnit.1:unit_type
  153:  print " "
  154:  print "found."
  155:  printflush :waitForFreeUnit.1:message
  156:  set *tmp50 null
  157:  jump *label44 always 0 0
        label *label43
  158:  sensor *tmp51 @unit @controlled
  159:  op notEqual *tmp52 *tmp51 0
  160:  jump *label45 equal *tmp52 false
  161:  print :waitForFreeUnit.1:preface
  162:  print "Looking for a free "
  163:  print :waitForFreeUnit.1:unit_type
  164:  print "."
  165:  print ".."
  166:  printflush :waitForFreeUnit.1:message
  167:  set *tmp53 null
  168:  jump *label46 always 0 0
        label *label45
  169:  ucontrol flag :waitForFreeUnit.1:initial_flag 0 0 0 0
  170:  set *tmp48 @unit
  171:  jump *label39 always 0 0
  172:  set *tmp53 null
        label *label46
  173:  set *tmp50 *tmp53
        label *label44
        label *label41
  174:  jump *label40 always 0 0
        label *label42
  175:  set *tmp48 null
        label *label39
  176:  print *tmp48
  177:  print "\n"
        label *label0
  178:  end
