set p 0
set :fill:value "x"
set :fill:i 0
jump 11 greaterThanEq :fill:i 5
set *tmp0 :fill:i
set .a*ret 8
op mul *tmp85 *tmp0 2
op add @counter 302 *tmp85
write :fill:value @this .a*elem
op add :fill:i :fill:i 1
jump 3 always 0 0
assertflush
print .a*0
print .a*1
print .a*2
print .a*3
print .a*4
assertprints "xxxxx" "Array fill"
set :i 0
jump 34 greaterThanEq :i 10
set *tmp2 :i
op add *tmp4 p :i
set .b*ret 25
op mul *tmp86 *tmp2 2
op add @counter 313 *tmp86
write *tmp4 @this .b*elem
set *tmp5 :i
op add *tmp7 p :i
set .c*ret 31
op mul *tmp87 *tmp5 2
op add @counter 334 *tmp87
write *tmp7 @this .c*elem
op add :i :i 1
jump 19 always 0 0
set :reverse:i 0
jump 61 greaterThanEq :reverse:i 5
op sub *tmp8 9 :reverse:i
set :reverse:j *tmp8
set *tmp9 :reverse:i
set .b*ret 42
op mul *tmp88 *tmp9 2
op add @counter 313 *tmp88
read *tmp10 @this .b*elem
set :reverse:t *tmp10
set *tmp11 :reverse:i
set *tmp13 :reverse:j
set .b*ret 49
op mul *tmp89 *tmp13 2
op add @counter 313 *tmp89
read *tmp14 @this .b*elem
set .b*ret 53
op mul *tmp90 *tmp11 2
op add @counter 313 *tmp90
write *tmp14 @this .b*elem
set *tmp15 :reverse:j
set .b*ret 58
op mul *tmp91 *tmp15 2
op add @counter 313 *tmp91
write :reverse:t @this .b*elem
op add :reverse:i :reverse:i 1
jump 35 always 0 0
assertflush
print .b*0
print .b*1
print .b*2
print .b*3
print .b*4
print .b*5
print .b*6
print .b*7
print .b*8
print .b*9
assertprints "9876543210" "Array reverse"
set :bubblesort:maxToMin false
set :bubblesort:flag false
set :bubblesort:a .b*0
set :bubblesort:i 1
jump 110 greaterThanEq :bubblesort:i 10
set *tmp17 :bubblesort:i
set .b*ret 82
op mul *tmp92 *tmp17 2
op add @counter 313 *tmp92
read *tmp18 @this .b*elem
set :bubblesort:b *tmp18
jump 88 equal :bubblesort:maxToMin false
op lessThan *tmp20 :bubblesort:a :bubblesort:b
set *tmp19 *tmp20
jump 90 always 0 0
op greaterThan *tmp21 :bubblesort:a :bubblesort:b
set *tmp19 *tmp21
set :bubblesort:condition *tmp19
jump 106 equal :bubblesort:condition false
op sub *tmp23 :bubblesort:i 1
set *tmp24 *tmp23
set .b*ret 97
op mul *tmp93 *tmp24 2
op add @counter 313 *tmp93
write :bubblesort:b @this .b*elem
set *tmp26 :bubblesort:i
set .b*ret 102
op mul *tmp94 *tmp26 2
op add @counter 313 *tmp94
write :bubblesort:a @this .b*elem
set :bubblesort:flag true
set *tmp22 :bubblesort:flag
jump 108 always 0 0
set :bubblesort:a :bubblesort:b
set *tmp22 :bubblesort:a
op add :bubblesort:i :bubblesort:i 1
jump 77 always 0 0
op equal *tmp28 :bubblesort:flag false
jump 115 equal *tmp28 false
jump 152 always 0 0
set *tmp29 null
jump 116 always 0 0
set *tmp29 null
set :bubblesort:a .b*9
op sub :bubblesort:i.1 9 1
jump 151 lessThan :bubblesort:i.1 0
set *tmp30 :bubblesort:i.1
set .b*ret 123
op mul *tmp95 *tmp30 2
op add @counter 313 *tmp95
read *tmp31 @this .b*elem
set :bubblesort:b.1 *tmp31
jump 129 equal :bubblesort:maxToMin false
op greaterThan *tmp33 :bubblesort:a :bubblesort:b.1
set *tmp32 *tmp33
jump 131 always 0 0
op lessThan *tmp34 :bubblesort:a :bubblesort:b.1
set *tmp32 *tmp34
set :bubblesort:condition.1 *tmp32
jump 147 equal :bubblesort:condition.1 false
op add *tmp36 :bubblesort:i.1 1
set *tmp37 *tmp36
set .b*ret 138
op mul *tmp96 *tmp37 2
op add @counter 313 *tmp96
write :bubblesort:b.1 @this .b*elem
set *tmp39 :bubblesort:i.1
set .b*ret 143
op mul *tmp97 *tmp39 2
op add @counter 313 *tmp97
write :bubblesort:a @this .b*elem
set :bubblesort:flag true
set *tmp35 :bubblesort:flag
jump 149 always 0 0
set :bubblesort:a :bubblesort:b.1
set *tmp35 :bubblesort:a
op sub :bubblesort:i.1 :bubblesort:i.1 1
jump 118 always 0 0
jump 74 notEqual :bubblesort:flag false
assertflush
print .b*0
print .b*1
print .b*2
print .b*3
print .b*4
print .b*5
print .b*6
print .b*7
print .b*8
print .b*9
assertprints "0123456789" "Array sort 1"
set :bubblesort.1:maxToMin true
set :bubblesort.1:flag false
set :bubblesort.1:a .b*0
set :bubblesort.1:i 1
jump 224 greaterThanEq :bubblesort.1:i 10
set *tmp41 :bubblesort.1:i
set .b*ret 173
op mul *tmp98 *tmp41 2
op add @counter 313 *tmp98
read *tmp42 @this .b*elem
set :bubblesort.1:b *tmp42
jump 179 equal :bubblesort.1:maxToMin false
op lessThan *tmp44 :bubblesort.1:a :bubblesort.1:b
set *tmp43 *tmp44
jump 181 always 0 0
op greaterThan *tmp45 :bubblesort.1:a :bubblesort.1:b
set *tmp43 *tmp45
set :bubblesort.1:condition *tmp43
jump 220 equal :bubblesort.1:condition false
op sub *tmp47 :bubblesort.1:i 1
set *tmp48 *tmp47
set .b*ret 188
op mul *tmp99 *tmp48 2
op add @counter 313 *tmp99
write :bubblesort.1:b @this .b*elem
set *tmp50 :bubblesort.1:i
set .b*ret 193
op mul *tmp100 *tmp50 2
op add @counter 313 *tmp100
write :bubblesort.1:a @this .b*elem
op sub *tmp52 :bubblesort.1:i 1
set *tmp53 *tmp52
set .c*ret 199
op mul *tmp101 *tmp53 2
op add @counter 334 *tmp101
read *tmp54 @this .c*elem
set :bubblesort.1:v *tmp54
op sub *tmp55 :bubblesort.1:i 1
set *tmp56 *tmp55
set *tmp58 :bubblesort.1:i
set .c*ret 207
op mul *tmp102 *tmp58 2
op add @counter 334 *tmp102
read *tmp59 @this .c*elem
set .c*ret 211
op mul *tmp103 *tmp56 2
op add @counter 334 *tmp103
write *tmp59 @this .c*elem
set *tmp60 :bubblesort.1:i
set .c*ret 216
op mul *tmp104 *tmp60 2
op add @counter 334 *tmp104
write :bubblesort.1:v @this .c*elem
set :bubblesort.1:flag true
set *tmp46 :bubblesort.1:flag
jump 222 always 0 0
set :bubblesort.1:a :bubblesort.1:b
set *tmp46 :bubblesort.1:a
op add :bubblesort.1:i :bubblesort.1:i 1
jump 168 always 0 0
op equal *tmp62 :bubblesort.1:flag false
jump 229 equal *tmp62 false
jump 289 always 0 0
set *tmp63 null
jump 230 always 0 0
set *tmp63 null
set :bubblesort.1:a .b*9
op sub :bubblesort.1:i.1 9 1
jump 288 lessThan :bubblesort.1:i.1 0
set *tmp64 :bubblesort.1:i.1
set .b*ret 237
op mul *tmp105 *tmp64 2
op add @counter 313 *tmp105
read *tmp65 @this .b*elem
set :bubblesort.1:b.1 *tmp65
jump 243 equal :bubblesort.1:maxToMin false
op greaterThan *tmp67 :bubblesort.1:a :bubblesort.1:b.1
set *tmp66 *tmp67
jump 245 always 0 0
op lessThan *tmp68 :bubblesort.1:a :bubblesort.1:b.1
set *tmp66 *tmp68
set :bubblesort.1:condition.1 *tmp66
jump 284 equal :bubblesort.1:condition.1 false
op add *tmp70 :bubblesort.1:i.1 1
set *tmp71 *tmp70
set .b*ret 252
op mul *tmp106 *tmp71 2
op add @counter 313 *tmp106
write :bubblesort.1:b.1 @this .b*elem
set *tmp73 :bubblesort.1:i.1
set .b*ret 257
op mul *tmp107 *tmp73 2
op add @counter 313 *tmp107
write :bubblesort.1:a @this .b*elem
op add *tmp75 :bubblesort.1:i.1 1
set *tmp76 *tmp75
set .c*ret 263
op mul *tmp108 *tmp76 2
op add @counter 334 *tmp108
read *tmp77 @this .c*elem
set :bubblesort.1:v.1 *tmp77
op add *tmp78 :bubblesort.1:i.1 1
set *tmp79 *tmp78
set *tmp81 :bubblesort.1:i.1
set .c*ret 271
op mul *tmp109 *tmp81 2
op add @counter 334 *tmp109
read *tmp82 @this .c*elem
set .c*ret 275
op mul *tmp110 *tmp79 2
op add @counter 334 *tmp110
write *tmp82 @this .c*elem
set *tmp83 :bubblesort.1:i.1
set .c*ret 280
op mul *tmp111 *tmp83 2
op add @counter 334 *tmp111
write :bubblesort.1:v.1 @this .c*elem
set :bubblesort.1:flag true
set *tmp69 :bubblesort.1:flag
jump 286 always 0 0
set :bubblesort.1:a :bubblesort.1:b.1
set *tmp69 :bubblesort.1:a
op sub :bubblesort.1:i.1 :bubblesort.1:i.1 1
jump 232 always 0 0
jump 165 notEqual :bubblesort.1:flag false
assertflush
print .c*0
print .c*1
print .c*2
print .c*3
print .c*4
print .c*5
print .c*6
print .c*7
print .c*8
print .c*9
assertprints "9876543210" "Array sort 2"
end
set .a*elem ".a*0"
set @counter .a*ret
set .a*elem ".a*1"
set @counter .a*ret
set .a*elem ".a*2"
set @counter .a*ret
set .a*elem ".a*3"
set @counter .a*ret
set .a*elem ".a*4"
set @counter .a*ret
end
set .b*elem ".b*0"
set @counter .b*ret
set .b*elem ".b*1"
set @counter .b*ret
set .b*elem ".b*2"
set @counter .b*ret
set .b*elem ".b*3"
set @counter .b*ret
set .b*elem ".b*4"
set @counter .b*ret
set .b*elem ".b*5"
set @counter .b*ret
set .b*elem ".b*6"
set @counter .b*ret
set .b*elem ".b*7"
set @counter .b*ret
set .b*elem ".b*8"
set @counter .b*ret
set .b*elem ".b*9"
set @counter .b*ret
end
set .c*elem ".c*0"
set @counter .c*ret
set .c*elem ".c*1"
set @counter .c*ret
set .c*elem ".c*2"
set @counter .c*ret
set .c*elem ".c*3"
set @counter .c*ret
set .c*elem ".c*4"
set @counter .c*ret
set .c*elem ".c*5"
set @counter .c*ret
set .c*elem ".c*6"
set @counter .c*ret
set .c*elem ".c*7"
set @counter .c*ret
set .c*elem ".c*8"
set @counter .c*ret
set .c*elem ".c*9"
set @counter .c*ret
print "Compiled by Mindcode - github.com/cardillan/mindcode"
