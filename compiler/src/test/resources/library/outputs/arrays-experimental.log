   329 instructions before optimizations.
    40 instructions eliminated by Temp Variables Elimination (8 iterations).
    12 instructions eliminated by Dead Code Elimination (4 iterations).
     9 instructions eliminated by Jump Normalization (2 passes, 7 iterations).
     6 instructions eliminated by Condition Optimization (2 passes, 9 iterations).
    13 instructions eliminated by Single Step Elimination (4 passes, 11 iterations).
   450 instructions eliminated by Expression Optimization (5 iterations).
   205 instructions eliminated by Data Flow Optimization (10 passes, 43 iterations).
       7 loop conditions were partially rotated.
   809 instructions added by Loop Unrolling (12 iterations).
     7 loops unrolled by Loop Unrolling.
    27 instructions eliminated by Array Optimization (12 iterations).
     2 instructions eliminated by Jump Straightening (8 iterations).
     4 instructions eliminated by Print Merging.
   343 instructions after optimizations.

Pass 3: speed optimization selection (cost limit 818):
  * Unroll loop at *arrays:23:5                                  size    -1, benefit      250.0, efficiency   Infinity (+9 instructions)
    Unroll loop at line 12:5                                     size   +20, benefit      500.0, efficiency     25.000
    Unroll loop at *arrays:39:5                                  size   +29, benefit      250.0, efficiency      8.621
    Unroll loop at *arrays:63:9                                  size   +73, benefit    11250.0, efficiency    154.110
    Unroll loop at *arrays:78:9                                  size   +73, benefit    11250.0, efficiency    154.110
    Unroll loop at *arrays:109:9                                 size  +133, benefit    11250.0, efficiency     84.586
    Unroll loop at *arrays:127:9                                 size  +133, benefit    11250.0, efficiency     84.586

Pass 3: speed optimization selection (cost limit 809):
    Unroll loop at line 12:5                                     size   +20, benefit      500.0, efficiency     25.000
    Unroll loop at *arrays:39:5                                  size   +29, benefit      250.0, efficiency      8.621
  * Unroll loop at *arrays:63:9                                  size   +73, benefit    11250.0, efficiency    154.110 (+99 instructions)
    Unroll loop at *arrays:78:9                                  size   +73, benefit    11250.0, efficiency    154.110
    Unroll loop at *arrays:109:9                                 size  +133, benefit    11250.0, efficiency     84.586
    Unroll loop at *arrays:127:9                                 size  +133, benefit    11250.0, efficiency     84.586

Pass 3: speed optimization selection (cost limit 710):
    Unroll loop at line 12:5                                     size   +20, benefit      500.0, efficiency     25.000
    Unroll loop at *arrays:39:5                                  size   +29, benefit      250.0, efficiency      8.621
  * Unroll loop at *arrays:78:9                                  size   +73, benefit    11250.0, efficiency    154.110 (+99 instructions)
    Unroll loop at *arrays:109:9                                 size  +133, benefit    11250.0, efficiency     84.586
    Unroll loop at *arrays:127:9                                 size  +133, benefit    11250.0, efficiency     84.586

Pass 3: speed optimization selection (cost limit 611):
    Unroll loop at line 12:5                                     size   +20, benefit      500.0, efficiency     25.000
    Unroll loop at *arrays:39:5                                  size   +29, benefit      250.0, efficiency      8.621
  * Unroll loop at *arrays:109:9                                 size  +133, benefit    11250.0, efficiency     84.586 (+195 instructions)
    Unroll loop at *arrays:127:9                                 size  +133, benefit    11250.0, efficiency     84.586

Pass 3: speed optimization selection (cost limit 416):
    Unroll loop at line 12:5                                     size   +20, benefit      500.0, efficiency     25.000
    Unroll loop at *arrays:39:5                                  size   +29, benefit      250.0, efficiency      8.621
  * Unroll loop at *arrays:127:9                                 size  +133, benefit    11250.0, efficiency     84.586 (+195 instructions)

Pass 3: speed optimization selection (cost limit 221):
  * Unroll loop at line 12:5                                     size   +20, benefit      500.0, efficiency     25.000 (+60 instructions)
    Unroll loop at *arrays:39:5                                  size   +29, benefit      250.0, efficiency      8.621

Pass 3: speed optimization selection (cost limit 161):
  * Unroll loop at *arrays:39:5                                  size   +29, benefit      250.0, efficiency      8.621 (+44 instructions)

Final code before resolving virtual instructions:

    0:  set p 0
    1:  assertflush *tmp2
    2:  print "xxxxx"
    3:  assertprints *tmp2 "xxxxx" "Array fill"
    4:  set .b*9 p
    5:  set .c*0 p
    6:  op add *tmp5 p 1
    7:  set .b*8 *tmp5
    8:  set .c*1 *tmp5
    9:  op add *tmp5 p 2
   10:  set .b*7 *tmp5
   11:  set .c*2 *tmp5
   12:  op add *tmp5 p 3
   13:  set .b*6 *tmp5
   14:  set .c*3 *tmp5
   15:  op add *tmp5 p 4
   16:  set :reverse:t *tmp5
   17:  set .c*4 *tmp5
   18:  op add *tmp5 p 5
   19:  set *tmp15 *tmp5
   20:  set .c*5 *tmp5
   21:  op add *tmp5 p 6
   22:  set .b*3 *tmp5
   23:  set .c*6 *tmp5
   24:  op add *tmp5 p 7
   25:  set .b*2 *tmp5
   26:  set .c*7 *tmp5
   27:  op add *tmp5 p 8
   28:  set .b*1 *tmp5
   29:  set .c*8 *tmp5
   30:  op add *tmp5 p 9
   31:  set .b*0 *tmp5
   32:  set .c*9 *tmp5
   33:  set .b*4 *tmp15
   34:  set .b*5 :reverse:t
   35:  assertflush *tmp18
   36:  print *tmp5
   37:  print .b*1
   38:  print .b*2
   39:  print .b*3
   40:  print *tmp15
   41:  print :reverse:t
   42:  print .b*6
   43:  print .b*7
   44:  print .b*8
   45:  print p
   46:  assertprints *tmp18 "9876543210" "Array reverse"
        label *label13
   47:  set :bubblesort:flag false
   48:  set :bubblesort:a .b*0
   49:  jump *label68 lessThanEq .b*0 .b*1
   50:  set .b*0 .b*1
   51:  set .b*1 :bubblesort:a
   52:  set :bubblesort:flag true
   53:  jump *label69 always 0 0
        label *label68
   54:  set :bubblesort:a .b*1
        label *label69
   55:  jump *label73 lessThanEq :bubblesort:a .b*2
   56:  set .b*1 .b*2
   57:  set .b*2 :bubblesort:a
   58:  set :bubblesort:flag true
   59:  jump *label74 always 0 0
        label *label73
   60:  set :bubblesort:a .b*2
        label *label74
   61:  jump *label78 lessThanEq :bubblesort:a .b*3
   62:  set .b*2 .b*3
   63:  set .b*3 :bubblesort:a
   64:  set :bubblesort:flag true
   65:  jump *label79 always 0 0
        label *label78
   66:  set :bubblesort:a .b*3
        label *label79
   67:  jump *label83 lessThanEq :bubblesort:a .b*4
   68:  set .b*3 .b*4
   69:  set .b*4 :bubblesort:a
   70:  set :bubblesort:flag true
   71:  jump *label84 always 0 0
        label *label83
   72:  set :bubblesort:a .b*4
        label *label84
   73:  jump *label88 lessThanEq :bubblesort:a .b*5
   74:  set .b*4 .b*5
   75:  set .b*5 :bubblesort:a
   76:  set :bubblesort:flag true
   77:  jump *label89 always 0 0
        label *label88
   78:  set :bubblesort:a .b*5
        label *label89
   79:  jump *label93 lessThanEq :bubblesort:a .b*6
   80:  set .b*5 .b*6
   81:  set .b*6 :bubblesort:a
   82:  set :bubblesort:flag true
   83:  jump *label94 always 0 0
        label *label93
   84:  set :bubblesort:a .b*6
        label *label94
   85:  jump *label98 lessThanEq :bubblesort:a .b*7
   86:  set .b*6 .b*7
   87:  set .b*7 :bubblesort:a
   88:  set :bubblesort:flag true
   89:  jump *label99 always 0 0
        label *label98
   90:  set :bubblesort:a .b*7
        label *label99
   91:  jump *label103 lessThanEq :bubblesort:a .b*8
   92:  set .b*7 .b*8
   93:  set .b*8 :bubblesort:a
   94:  set :bubblesort:flag true
   95:  jump *label104 always 0 0
        label *label103
   96:  set :bubblesort:a .b*8
        label *label104
   97:  jump *label108 lessThanEq :bubblesort:a .b*9
   98:  set .b*8 .b*9
   99:  set .b*9 :bubblesort:a
  100:  set :bubblesort:flag true
        label *label108
  101:  jump *label12 equal :bubblesort:flag false
  102:  set :bubblesort:a .b*9
  103:  jump *label114 greaterThanEq .b*9 .b*8
  104:  set .b*9 .b*8
  105:  set .b*8 :bubblesort:a
  106:  set :bubblesort:flag true
  107:  jump *label115 always 0 0
        label *label114
  108:  set :bubblesort:a .b*8
        label *label115
  109:  jump *label119 greaterThanEq :bubblesort:a .b*7
  110:  set .b*8 .b*7
  111:  set .b*7 :bubblesort:a
  112:  set :bubblesort:flag true
  113:  jump *label120 always 0 0
        label *label119
  114:  set :bubblesort:a .b*7
        label *label120
  115:  jump *label124 greaterThanEq :bubblesort:a .b*6
  116:  set .b*7 .b*6
  117:  set .b*6 :bubblesort:a
  118:  set :bubblesort:flag true
  119:  jump *label125 always 0 0
        label *label124
  120:  set :bubblesort:a .b*6
        label *label125
  121:  jump *label129 greaterThanEq :bubblesort:a .b*5
  122:  set .b*6 .b*5
  123:  set .b*5 :bubblesort:a
  124:  set :bubblesort:flag true
  125:  jump *label130 always 0 0
        label *label129
  126:  set :bubblesort:a .b*5
        label *label130
  127:  jump *label134 greaterThanEq :bubblesort:a .b*4
  128:  set .b*5 .b*4
  129:  set .b*4 :bubblesort:a
  130:  set :bubblesort:flag true
  131:  jump *label135 always 0 0
        label *label134
  132:  set :bubblesort:a .b*4
        label *label135
  133:  jump *label139 greaterThanEq :bubblesort:a .b*3
  134:  set .b*4 .b*3
  135:  set .b*3 :bubblesort:a
  136:  set :bubblesort:flag true
  137:  jump *label140 always 0 0
        label *label139
  138:  set :bubblesort:a .b*3
        label *label140
  139:  jump *label144 greaterThanEq :bubblesort:a .b*2
  140:  set .b*3 .b*2
  141:  set .b*2 :bubblesort:a
  142:  set :bubblesort:flag true
  143:  jump *label145 always 0 0
        label *label144
  144:  set :bubblesort:a .b*2
        label *label145
  145:  jump *label149 greaterThanEq :bubblesort:a .b*1
  146:  set .b*2 .b*1
  147:  set .b*1 :bubblesort:a
  148:  set :bubblesort:flag true
  149:  jump *label150 always 0 0
        label *label149
  150:  set :bubblesort:a .b*1
        label *label150
  151:  jump *label154 greaterThanEq :bubblesort:a .b*0
  152:  set .b*1 .b*0
  153:  set .b*0 :bubblesort:a
  154:  set :bubblesort:flag true
        label *label154
  155:  jump *label13 notEqual :bubblesort:flag false
        label *label12
  156:  assertflush *tmp43
  157:  print .b*0
  158:  print .b*1
  159:  print .b*2
  160:  print .b*3
  161:  print .b*4
  162:  print .b*5
  163:  print .b*6
  164:  print .b*7
  165:  print .b*8
  166:  print .b*9
  167:  assertprints *tmp43 "0123456789" "Array sort 1"
        label *label33
  168:  set :bubblesort.1:flag false
  169:  set :bubblesort.1:a .b*0
  170:  jump *label160 greaterThanEq .b*0 .b*1
  171:  set .b*0 .b*1
  172:  set .b*1 :bubblesort.1:a
  173:  set :bubblesort.1:v .c*0
  174:  set .c*0 .c*1
  175:  set .c*1 :bubblesort.1:v
  176:  set :bubblesort.1:flag true
  177:  jump *label161 always 0 0
        label *label160
  178:  set :bubblesort.1:a .b*1
        label *label161
  179:  jump *label165 greaterThanEq :bubblesort.1:a .b*2
  180:  set .b*1 .b*2
  181:  set .b*2 :bubblesort.1:a
  182:  set :bubblesort.1:v .c*1
  183:  set .c*1 .c*2
  184:  set .c*2 :bubblesort.1:v
  185:  set :bubblesort.1:flag true
  186:  jump *label166 always 0 0
        label *label165
  187:  set :bubblesort.1:a .b*2
        label *label166
  188:  jump *label170 greaterThanEq :bubblesort.1:a .b*3
  189:  set .b*2 .b*3
  190:  set .b*3 :bubblesort.1:a
  191:  set :bubblesort.1:v .c*2
  192:  set .c*2 .c*3
  193:  set .c*3 :bubblesort.1:v
  194:  set :bubblesort.1:flag true
  195:  jump *label171 always 0 0
        label *label170
  196:  set :bubblesort.1:a .b*3
        label *label171
  197:  jump *label175 greaterThanEq :bubblesort.1:a .b*4
  198:  set .b*3 .b*4
  199:  set .b*4 :bubblesort.1:a
  200:  set :bubblesort.1:v .c*3
  201:  set .c*3 .c*4
  202:  set .c*4 :bubblesort.1:v
  203:  set :bubblesort.1:flag true
  204:  jump *label176 always 0 0
        label *label175
  205:  set :bubblesort.1:a .b*4
        label *label176
  206:  jump *label180 greaterThanEq :bubblesort.1:a .b*5
  207:  set .b*4 .b*5
  208:  set .b*5 :bubblesort.1:a
  209:  set :bubblesort.1:v .c*4
  210:  set .c*4 .c*5
  211:  set .c*5 :bubblesort.1:v
  212:  set :bubblesort.1:flag true
  213:  jump *label181 always 0 0
        label *label180
  214:  set :bubblesort.1:a .b*5
        label *label181
  215:  jump *label185 greaterThanEq :bubblesort.1:a .b*6
  216:  set .b*5 .b*6
  217:  set .b*6 :bubblesort.1:a
  218:  set :bubblesort.1:v .c*5
  219:  set .c*5 .c*6
  220:  set .c*6 :bubblesort.1:v
  221:  set :bubblesort.1:flag true
  222:  jump *label186 always 0 0
        label *label185
  223:  set :bubblesort.1:a .b*6
        label *label186
  224:  jump *label190 greaterThanEq :bubblesort.1:a .b*7
  225:  set .b*6 .b*7
  226:  set .b*7 :bubblesort.1:a
  227:  set :bubblesort.1:v .c*6
  228:  set .c*6 .c*7
  229:  set .c*7 :bubblesort.1:v
  230:  set :bubblesort.1:flag true
  231:  jump *label191 always 0 0
        label *label190
  232:  set :bubblesort.1:a .b*7
        label *label191
  233:  jump *label195 greaterThanEq :bubblesort.1:a .b*8
  234:  set .b*7 .b*8
  235:  set .b*8 :bubblesort.1:a
  236:  set :bubblesort.1:v .c*7
  237:  set .c*7 .c*8
  238:  set .c*8 :bubblesort.1:v
  239:  set :bubblesort.1:flag true
  240:  jump *label196 always 0 0
        label *label195
  241:  set :bubblesort.1:a .b*8
        label *label196
  242:  jump *label200 greaterThanEq :bubblesort.1:a .b*9
  243:  set .b*8 .b*9
  244:  set .b*9 :bubblesort.1:a
  245:  set :bubblesort.1:v .c*8
  246:  set .c*8 .c*9
  247:  set .c*9 :bubblesort.1:v
  248:  set :bubblesort.1:flag true
        label *label200
  249:  jump *label32 equal :bubblesort.1:flag false
  250:  set :bubblesort.1:a .b*9
  251:  jump *label206 lessThanEq .b*9 .b*8
  252:  set .b*9 .b*8
  253:  set .b*8 :bubblesort.1:a
  254:  set :bubblesort.1:v.1 .c*9
  255:  set .c*9 .c*8
  256:  set .c*8 :bubblesort.1:v.1
  257:  set :bubblesort.1:flag true
  258:  jump *label207 always 0 0
        label *label206
  259:  set :bubblesort.1:a .b*8
        label *label207
  260:  jump *label211 lessThanEq :bubblesort.1:a .b*7
  261:  set .b*8 .b*7
  262:  set .b*7 :bubblesort.1:a
  263:  set :bubblesort.1:v.1 .c*8
  264:  set .c*8 .c*7
  265:  set .c*7 :bubblesort.1:v.1
  266:  set :bubblesort.1:flag true
  267:  jump *label212 always 0 0
        label *label211
  268:  set :bubblesort.1:a .b*7
        label *label212
  269:  jump *label216 lessThanEq :bubblesort.1:a .b*6
  270:  set .b*7 .b*6
  271:  set .b*6 :bubblesort.1:a
  272:  set :bubblesort.1:v.1 .c*7
  273:  set .c*7 .c*6
  274:  set .c*6 :bubblesort.1:v.1
  275:  set :bubblesort.1:flag true
  276:  jump *label217 always 0 0
        label *label216
  277:  set :bubblesort.1:a .b*6
        label *label217
  278:  jump *label221 lessThanEq :bubblesort.1:a .b*5
  279:  set .b*6 .b*5
  280:  set .b*5 :bubblesort.1:a
  281:  set :bubblesort.1:v.1 .c*6
  282:  set .c*6 .c*5
  283:  set .c*5 :bubblesort.1:v.1
  284:  set :bubblesort.1:flag true
  285:  jump *label222 always 0 0
        label *label221
  286:  set :bubblesort.1:a .b*5
        label *label222
  287:  jump *label226 lessThanEq :bubblesort.1:a .b*4
  288:  set .b*5 .b*4
  289:  set .b*4 :bubblesort.1:a
  290:  set :bubblesort.1:v.1 .c*5
  291:  set .c*5 .c*4
  292:  set .c*4 :bubblesort.1:v.1
  293:  set :bubblesort.1:flag true
  294:  jump *label227 always 0 0
        label *label226
  295:  set :bubblesort.1:a .b*4
        label *label227
  296:  jump *label231 lessThanEq :bubblesort.1:a .b*3
  297:  set .b*4 .b*3
  298:  set .b*3 :bubblesort.1:a
  299:  set :bubblesort.1:v.1 .c*4
  300:  set .c*4 .c*3
  301:  set .c*3 :bubblesort.1:v.1
  302:  set :bubblesort.1:flag true
  303:  jump *label232 always 0 0
        label *label231
  304:  set :bubblesort.1:a .b*3
        label *label232
  305:  jump *label236 lessThanEq :bubblesort.1:a .b*2
  306:  set .b*3 .b*2
  307:  set .b*2 :bubblesort.1:a
  308:  set :bubblesort.1:v.1 .c*3
  309:  set .c*3 .c*2
  310:  set .c*2 :bubblesort.1:v.1
  311:  set :bubblesort.1:flag true
  312:  jump *label237 always 0 0
        label *label236
  313:  set :bubblesort.1:a .b*2
        label *label237
  314:  jump *label241 lessThanEq :bubblesort.1:a .b*1
  315:  set .b*2 .b*1
  316:  set .b*1 :bubblesort.1:a
  317:  set :bubblesort.1:v.1 .c*2
  318:  set .c*2 .c*1
  319:  set .c*1 :bubblesort.1:v.1
  320:  set :bubblesort.1:flag true
  321:  jump *label242 always 0 0
        label *label241
  322:  set :bubblesort.1:a .b*1
        label *label242
  323:  jump *label246 lessThanEq :bubblesort.1:a .b*0
  324:  set .b*1 .b*0
  325:  set .b*0 :bubblesort.1:a
  326:  set :bubblesort.1:v.1 .c*1
  327:  set .c*1 .c*0
  328:  set .c*0 :bubblesort.1:v.1
  329:  set :bubblesort.1:flag true
        label *label246
  330:  jump *label33 notEqual :bubblesort.1:flag false
        label *label32
  331:  assertflush *tmp88
  332:  print .c*0
  333:  print .c*1
  334:  print .c*2
  335:  print .c*3
  336:  print .c*4
  337:  print .c*5
  338:  print .c*6
  339:  print .c*7
  340:  print .c*8
  341:  print .c*9
  342:  assertprints *tmp88 "9876543210" "Array sort 2"
