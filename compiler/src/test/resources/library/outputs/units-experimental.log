   182 instructions before optimizations.
     5 instructions eliminated by Temp Variables Elimination (2 iterations).
    26 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Jump Normalization (5 iterations).
    15 instructions eliminated by Jump Optimization (5 iterations).
    14 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     2 instructions eliminated by If Expression Optimization (4 iterations).
    23 instructions eliminated by Data Flow Optimization (6 iterations).
     6 instructions updated by Jump Threading.
     7 instructions eliminated by Unreachable Code Elimination (2 iterations).
     8 instructions eliminated by Print Merging.
    79 instructions after optimizations.

Final code before resolving virtual instructions:

    0:  sensor *tmp1 @unit @x
    1:  op sub *tmp2 null *tmp1
    2:  sensor *tmp3 @unit @y
    3:  op sub *tmp4 null *tmp3
    4:  op len *tmp5 *tmp2 *tmp4
    5:  op lessThan *tmp0 *tmp5 null
    6:  print *tmp0
    7:  print "\n"
    8:  ubind null
    9:  jump *label2 notEqual @unit null
   10:  set *tmp7 null
   11:  jump *label1 always 0 0
        label *label2
   12:  set :findFreeUnit:first_unit @unit
        label *label4
   13:  sensor *tmp10 @unit @controlled
   14:  jump *label7 notEqual *tmp10 0
   15:  ucontrol flag null 0 0 0 0
   16:  set *tmp7 @unit
   17:  jump *label1 always 0 0
        label *label7
   18:  sensor *tmp13 :findFreeUnit:first_unit @dead
   19:  select :findFreeUnit:first_unit equal *tmp13 1 @unit :findFreeUnit:first_unit
   20:  ubind null
   21:  jump *label4 notEqual :findFreeUnit:first_unit @unit
   22:  set *tmp7 null
        label *label1
   23:  print *tmp7
   24:  print "\n"
        label *label12
   25:  ubind null
   26:  jump *label15 notEqual @unit null
   27:  set *tmp18 null
   28:  jump *label11 always 0 0
        label *label15
   29:  set :findClosestUnit:first_unit @unit
   30:  set :findClosestUnit:best_unit null
   31:  set :findClosestUnit:best_distance 10000000000
        label *label17
   32:  sensor *tmp21 @unit @controlled
   33:  jump *label20 notEqual *tmp21 0
   34:  sensor *tmp24 @unit @x
   35:  op sub *tmp25 *tmp24 null
   36:  sensor *tmp26 @unit @y
   37:  op sub *tmp27 *tmp26 null
   38:  op len :findClosestUnit:distance *tmp25 *tmp27
   39:  jump *label21 greaterThanEq :findClosestUnit:distance :findClosestUnit:best_distance
   40:  set :findClosestUnit:best_distance :findClosestUnit:distance
   41:  set :findClosestUnit:best_unit @unit
   42:  jump *label21 always 0 0
        label *label20
   43:  sensor *tmp32 :findClosestUnit:first_unit @dead
   44:  select :findClosestUnit:first_unit equal *tmp32 1 @unit :findClosestUnit:first_unit
        label *label21
   45:  ubind null
   46:  jump *label17 notEqual :findClosestUnit:first_unit @unit
   47:  jump *label26 notEqual :findClosestUnit:best_unit null
   48:  set *tmp18 null
   49:  jump *label11 always 0 0
        label *label26
   50:  sensor *tmp39 :findClosestUnit:best_unit @controlled
   51:  jump *label12 notEqual *tmp39 0
   52:  ubind :findClosestUnit:best_unit
   53:  ucontrol flag null 0 0 0 0
   54:  set *tmp18 :findClosestUnit:best_unit
        label *label11
   55:  print *tmp18
   56:  print "\n"
        label *label31
   57:  ubind null
   58:  jump *label31 equal @unit null
   59:  sensor *tmp45 @unit @controlled
   60:  jump *label31 notEqual *tmp45 0
   61:  ucontrol flag null 0 0 0 0
   62:  set *tmp42 @unit
   63:  print *tmp42
   64:  print "\n"
        label *label39
   65:  ubind null
   66:  jump *label42 notEqual @unit null
   67:  print "nullNo unit of type null found."
   68:  printflush null
   69:  jump *label39 always 0 0
        label *label42
   70:  sensor *tmp51 @unit @controlled
   71:  jump *label44 equal *tmp51 0
   72:  print "nullLooking for a free null..."
   73:  printflush null
   74:  jump *label39 always 0 0
        label *label44
   75:  ucontrol flag null 0 0 0 0
   76:  set *tmp48 @unit
   77:  print *tmp48
   78:  print "\n"
