   121 instructions before optimizations.
     1 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Dead Code Elimination (3 iterations).
     1 instructions eliminated by Jump Optimization (6 iterations).
     3 instructions eliminated by Single Step Elimination (2 passes, 8 iterations).
   180 instructions eliminated by Expression Optimization (5 iterations).
    41 instructions eliminated by Data Flow Optimization (4 passes, 16 iterations).
     1 instructions eliminated by Loop Optimization (5 iterations).
     2 loops improved by Loop Optimization.
   179 instructions added by Loop Unrolling (9 iterations).
     2 loops unrolled by Loop Unrolling.
     3 jump tables inlined by Array Optimization.
     8 instructions eliminated by Print Merging.
    75 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 895):
  * Unroll iteration loop at line 7:5                            cost     0, benefit       49.0, efficiency   Infinity (-22 instructions)
    Unroll loop at line 25:5                                     cost    18, benefit      450.0, efficiency       25.0
    Inline read jump table of array 'array'                      cost    13, benefit     1300.0, efficiency      100.0
    Inline write jump table of array 'array'                     cost     0, benefit     1250.0, efficiency   Infinity
    Inline 'array' read access at line 17:5                      cost    17, benefit     1250.0, efficiency       73.5
    Inline 'array' read access at line 26:9                      cost    17, benefit       50.0, efficiency        2.9
    Inline 'array' write access at line 17:5                     cost    17, benefit     1250.0, efficiency       73.5

Pass 1: speed optimization selection (cost limit 917):
    Unroll loop at line 25:5                                     cost    18, benefit      450.0, efficiency       25.0
    Inline read jump table of array 'array'                      cost    13, benefit     1300.0, efficiency      100.0
  * Inline write jump table of array 'array'                     cost     0, benefit     1250.0, efficiency   Infinity (-4 instructions)
    Inline 'array' read access at line 17:5                      cost    17, benefit     1250.0, efficiency       73.5
    Inline 'array' read access at line 26:9                      cost    17, benefit       50.0, efficiency        2.9
    Inline 'array' write access at line 17:5                     cost    17, benefit     1250.0, efficiency       73.5

Pass 1: speed optimization selection (cost limit 921):
    Unroll loop at line 25:5                                     cost    18, benefit      450.0, efficiency       25.0
  * Inline read jump table of array 'array'                      cost    13, benefit     1300.0, efficiency      100.0 (+13 instructions)
    Inline 'array' read access at line 17:5                      cost    17, benefit     1250.0, efficiency       73.5
    Inline 'array' read access at line 26:9                      cost    17, benefit       50.0, efficiency        2.9

Pass 1: speed optimization selection (cost limit 908):
  * Unroll loop at line 25:5                                     cost     1, benefit      450.0, efficiency      450.0 (+181 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-1 instructions):
 
    65 op mod *tmp1 :countDigits.0:number 10
    66 set *tmp2 *tmp1
    67 readarr<regular> *tmp3 .array[] *tmp2
-    * set *tmp4 *tmp3
    68 op add *tmp3 *tmp3 1
    69 writearr<regular> *tmp3 .array[] *tmp2
    70 op idiv :countDigits.0:number :countDigits.0:number 10

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-1 instructions):
 
    62 # "Function: void countDigits(in number)"
    63 set :countDigits.0:number :i
    64 label *label19
-    * op mod *tmp1 :countDigits.0:number 10
-    * set *tmp2 *tmp1
+   65 op mod *tmp2 :countDigits.0:number 10
    66 readarr<regular> *tmp3 .array[] *tmp2
    67 op add *tmp3 *tmp3 1
    68 writearr<regular> *tmp3 .array[] *tmp2

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-1 instructions):
 
    68 writearr<regular> *tmp3 .array[] *tmp2
    69 op idiv :countDigits.0:number :countDigits.0:number 10
    70 label *label20
-    * op greaterThan *tmp5 :countDigits.0:number 0
-    * jump *label19 notEqual *tmp5 false
+   71 jump *label19 greaterThan :countDigits.0:number 0
    72 label *label21
    73 label *label18
    74 label *label16

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-10 instructions):
     0 set LIMIT 100
-    * set :a .array*0
     1 op add *tmp0 @counter 1
     2 jump *label0 always
     3 multilabel *label3 (m:marker0)
-    * set .array*0 :a
-    * set :a .array*1
+    4 set .array*0 0
     5 op add *tmp0 @counter 1
     6 jump *label0 always
     7 multilabel *label4 (m:marker0)
-    * set .array*1 :a
-    * set :a .array*2
+    8 set .array*1 0
     9 op add *tmp0 @counter 1
    10 jump *label0 always
    11 multilabel *label5 (m:marker0)
-    * set .array*2 :a
-    * set :a .array*3
+   12 set .array*2 0
    13 op add *tmp0 @counter 1
    14 jump *label0 always
    15 multilabel *label6 (m:marker0)
-    * set .array*3 :a
-    * set :a .array*4
+   16 set .array*3 0
    17 op add *tmp0 @counter 1
    18 jump *label0 always
    19 multilabel *label7 (m:marker0)
-    * set .array*4 :a
-    * set :a .array*5
+   20 set .array*4 0
    21 op add *tmp0 @counter 1
    22 jump *label0 always
    23 multilabel *label8 (m:marker0)
-    * set .array*5 :a
-    * set :a .array*6
+   24 set .array*5 0
    25 op add *tmp0 @counter 1
    26 jump *label0 always
    27 multilabel *label9 (m:marker0)
-    * set .array*6 :a
-    * set :a .array*7
+   28 set .array*6 0
    29 op add *tmp0 @counter 1
    30 jump *label0 always
    31 multilabel *label10 (m:marker0)
-    * set .array*7 :a
-    * set :a .array*8
+   32 set .array*7 0
    33 op add *tmp0 @counter 1
    34 jump *label0 always
    35 multilabel *label11 (m:marker0)
-    * set .array*8 :a
-    * set :a .array*9
+   36 set .array*8 0
    37 op add *tmp0 @counter 1
    38 jump *label0 always
    39 multilabel *label13 (m:marker0)
 
    44 multijump *tmp0 0 0 (m:marker0)
    45 multilabel *label12 (m:marker0)
    46 label *label14
-    * set .array*9 :a
+   47 set .array*9 0
    48 label *label2
    49 set :i 0
    50 label *label15
 
    73 jump *label25 greaterThanEq :printArray.0:i 10
    74 set *tmp6 :printArray.0:i
    75 print "-"
-    * readarr<regular> *tmp7 .array[] *tmp6
+   76 readarr<regular> *tmp7 .array[] :printArray.0:i
    77 print *tmp7
    78 label *label24
    79 op add :printArray.0:i :printArray.0:i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-2 instructions):
 
    39 multilabel *label13 (m:marker0)
    40 jump *label14 always
    41 label *label0
-    * set :a 0
    42 label *label1
    43 multijump *tmp0 0 0 (m:marker0)
    44 multilabel *label12 (m:marker0)
 
    70 set :printArray.0:i 1
    71 label *label23
    72 jump *label25 greaterThanEq :printArray.0:i 10
-    * set *tmp6 :printArray.0:i
    73 print "-"
    74 readarr<regular> *tmp7 .array[] :printArray.0:i
    75 print *tmp7

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
 
    48 set :i 0
    49 label *label15
    50 jump *label17 greaterThanEq :i LIMIT
+   51 label *label26
    52 # "Function: void countDigits(in number)"
    53 set :countDigits.0:number :i
    54 label *label19
 
    63 label *label18
    64 label *label16
    65 op add :i :i 1
-    * jump *label15 always
+   66 jump *label26 lessThan :i LIMIT
    67 label *label17
    68 assertflush
    69 # "Function: void printArray()"
    70 print .array*0
    71 set :printArray.0:i 1
    72 label *label23
-    * jump *label25 greaterThanEq :printArray.0:i 10
+   73 label *label27
    74 print "-"
    75 readarr<regular> *tmp7 .array[] :printArray.0:i
    76 print *tmp7
    77 label *label24
    78 op add :printArray.0:i :printArray.0:i 1
-    * jump *label23 always
+   79 jump *label27 lessThan :printArray.0:i 10
    80 label *label25
    81 label *label22
    82 assertprints "10-20-20-20-20-20-20-20-20-20" "digit counts"

Modifications by Unroll iteration loop at line 7:5 (-12 instructions):
     0 set LIMIT 100
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label3 (m:marker0)
-    * set .array*0 0
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label4 (m:marker0)
-    * set .array*1 0
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label5 (m:marker0)
-    * set .array*2 0
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label6 (m:marker0)
-    * set .array*3 0
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label7 (m:marker0)
-    * set .array*4 0
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label8 (m:marker0)
-    * set .array*5 0
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label9 (m:marker0)
-    * set .array*6 0
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label10 (m:marker0)
-    * set .array*7 0
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label11 (m:marker0)
-    * set .array*8 0
-    * op add *tmp0 @counter 1
-    * jump *label0 always
-    * multilabel *label13 (m:marker0)
-    * jump *label14 always
-    * label *label0
-    * label *label1
-    * multijump *tmp0 0 0 (m:marker0)
-    * multilabel *label12 (m:marker0)
-    * label *label14
-    * set .array*9 0
-    * label *label2
+    1 op add *tmp0 @counter 1
+    2 label *label28
+    3 label *label29
+    4 set .array*0 0
+    5 op add *tmp0 @counter 1
+    6 label *label32
+    7 label *label33
+    8 set .array*1 0
+    9 op add *tmp0 @counter 1
+   10 label *label36
+   11 label *label37
+   12 set .array*2 0
+   13 op add *tmp0 @counter 1
+   14 label *label40
+   15 label *label41
+   16 set .array*3 0
+   17 op add *tmp0 @counter 1
+   18 label *label44
+   19 label *label45
+   20 set .array*4 0
+   21 op add *tmp0 @counter 1
+   22 label *label48
+   23 label *label49
+   24 set .array*5 0
+   25 op add *tmp0 @counter 1
+   26 label *label52
+   27 label *label53
+   28 set .array*6 0
+   29 op add *tmp0 @counter 1
+   30 label *label56
+   31 label *label57
+   32 set .array*7 0
+   33 op add *tmp0 @counter 1
+   34 label *label60
+   35 label *label61
+   36 set .array*8 0
+   37 op add *tmp0 @counter 1
+   38 label *label64
+   39 label *label65
+   40 set .array*9 0
+   41 label *label14
+   42 label *label2
    43 set :i 0
    44 label *label15
    45 jump *label17 greaterThanEq :i LIMIT

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-10 instructions):
     0 set LIMIT 100
-    * op add *tmp0 @counter 1
     1 label *label28
     2 label *label29
     3 set .array*0 0
-    * op add *tmp0 @counter 1
     4 label *label32
     5 label *label33
     6 set .array*1 0
-    * op add *tmp0 @counter 1
     7 label *label36
     8 label *label37
     9 set .array*2 0
-    * op add *tmp0 @counter 1
    10 label *label40
    11 label *label41
    12 set .array*3 0
-    * op add *tmp0 @counter 1
    13 label *label44
    14 label *label45
    15 set .array*4 0
-    * op add *tmp0 @counter 1
    16 label *label48
    17 label *label49
    18 set .array*5 0
-    * op add *tmp0 @counter 1
    19 label *label52
    20 label *label53
    21 set .array*6 0
-    * op add *tmp0 @counter 1
    22 label *label56
    23 label *label57
    24 set .array*7 0
-    * op add *tmp0 @counter 1
    25 label *label60
    26 label *label61
    27 set .array*8 0
-    * op add *tmp0 @counter 1
    28 label *label64
    29 label *label65
    30 set .array*9 0
 
    32 label *label2
    33 set :i 0
    34 label *label15
-    * jump *label17 greaterThanEq :i LIMIT
+   35 jump *label17 greaterThanEq 0 LIMIT
    36 label *label26
    37 # "Function: void countDigits(in number)"
    38 set :countDigits.0:number :i

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
 
    40 op mod *tmp2 :countDigits.0:number 10
    41 readarr<regular> *tmp3 .array[] *tmp2
    42 op add *tmp3 *tmp3 1
-    * writearr<regular> *tmp3 .array[] *tmp2
+   43 writearr<inlined> *tmp3 .array[] *tmp2
    44 op idiv :countDigits.0:number :countDigits.0:number 10
    45 label *label20
    46 jump *label19 greaterThan :countDigits.0:number 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (+13 instructions):
 
    38 set :countDigits.0:number :i
    39 label *label19
    40 op mod *tmp2 :countDigits.0:number 10
-    * readarr<regular> *tmp3 .array[] *tmp2
+   41 readarr<inlined> *tmp3 .array[] *tmp2
    42 op add *tmp3 *tmp3 1
    43 writearr<inlined> *tmp3 .array[] *tmp2
    44 op idiv :countDigits.0:number :countDigits.0:number 10
 
    57 label *label23
    58 label *label27
    59 print "-"
-    * readarr<regular> *tmp7 .array[] :printArray.0:i
+   60 readarr<inlined> *tmp7 .array[] :printArray.0:i
    61 print *tmp7
    62 label *label24
    63 op add :printArray.0:i :printArray.0:i 1

Modifications by Unroll loop at line 25:5 (+191 instructions):
 
    53 assertflush
    54 # "Function: void printArray()"
    55 print .array*0
-    * set :printArray.0:i 1
-    * label *label23
-    * label *label27
-    * print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
-    * print *tmp7
-    * label *label24
-    * op add :printArray.0:i :printArray.0:i 1
-    * jump *label27 lessThan :printArray.0:i 10
-    * label *label25
+   56 set :printArray.0:i 1
+   57 label *label70
+   58 label *label71
+   59 print "-"
+   60 readarr<inlined> *tmp7 .array[] :printArray.0:i
+   61 print *tmp7
+   62 label *label72
+   63 op add :printArray.0:i :printArray.0:i 1
+   64 label *label73
+   65 print "-"
+   66 readarr<inlined> *tmp7 .array[] :printArray.0:i
+   67 print *tmp7
+   68 label *label74
+   69 op add :printArray.0:i :printArray.0:i 1
+   70 label *label75
+   71 print "-"
+   72 readarr<inlined> *tmp7 .array[] :printArray.0:i
+   73 print *tmp7
+   74 label *label76
+   75 op add :printArray.0:i :printArray.0:i 1
+   76 label *label77
+   77 print "-"
+   78 readarr<inlined> *tmp7 .array[] :printArray.0:i
+   79 print *tmp7
+   80 label *label78
+   81 op add :printArray.0:i :printArray.0:i 1
+   82 label *label79
+   83 print "-"
+   84 readarr<inlined> *tmp7 .array[] :printArray.0:i
+   85 print *tmp7
+   86 label *label80
+   87 op add :printArray.0:i :printArray.0:i 1
+   88 label *label81
+   89 print "-"
+   90 readarr<inlined> *tmp7 .array[] :printArray.0:i
+   91 print *tmp7
+   92 label *label82
+   93 op add :printArray.0:i :printArray.0:i 1
+   94 label *label83
+   95 print "-"
+   96 readarr<inlined> *tmp7 .array[] :printArray.0:i
+   97 print *tmp7
+   98 label *label84
+   99 op add :printArray.0:i :printArray.0:i 1
+  100 label *label85
+  101 print "-"
+  102 readarr<inlined> *tmp7 .array[] :printArray.0:i
+  103 print *tmp7
+  104 label *label86
+  105 op add :printArray.0:i :printArray.0:i 1
+  106 label *label87
+  107 print "-"
+  108 readarr<inlined> *tmp7 .array[] :printArray.0:i
+  109 print *tmp7
+  110 label *label88
+  111 op add :printArray.0:i :printArray.0:i 1
+  112 label *label25
   113 label *label22
   114 assertprints "10-20-20-20-20-20-20-20-20-20" "digit counts"
   115 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    57 label *label70
    58 label *label71
    59 print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
+   60 readarr<inlined> *tmp7 .array[] 1
    61 print *tmp7
    62 label *label72
-    * op add :printArray.0:i :printArray.0:i 1
+   63 op add :printArray.0:i 1 1
    64 label *label73
    65 print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
+   66 readarr<inlined> *tmp7 .array[] 2
    67 print *tmp7
    68 label *label74
-    * op add :printArray.0:i :printArray.0:i 1
+   69 op add :printArray.0:i 2 1
    70 label *label75
    71 print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
+   72 readarr<inlined> *tmp7 .array[] 3
    73 print *tmp7
    74 label *label76
-    * op add :printArray.0:i :printArray.0:i 1
+   75 op add :printArray.0:i 3 1
    76 label *label77
    77 print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
+   78 readarr<inlined> *tmp7 .array[] 4
    79 print *tmp7
    80 label *label78
-    * op add :printArray.0:i :printArray.0:i 1
+   81 op add :printArray.0:i 4 1
    82 label *label79
    83 print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
+   84 readarr<inlined> *tmp7 .array[] 5
    85 print *tmp7
    86 label *label80
-    * op add :printArray.0:i :printArray.0:i 1
+   87 op add :printArray.0:i 5 1
    88 label *label81
    89 print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
+   90 readarr<inlined> *tmp7 .array[] 6
    91 print *tmp7
    92 label *label82
-    * op add :printArray.0:i :printArray.0:i 1
+   93 op add :printArray.0:i 6 1
    94 label *label83
    95 print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
+   96 readarr<inlined> *tmp7 .array[] 7
    97 print *tmp7
    98 label *label84
-    * op add :printArray.0:i :printArray.0:i 1
+   99 op add :printArray.0:i 7 1
   100 label *label85
   101 print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
+  102 readarr<inlined> *tmp7 .array[] 8
   103 print *tmp7
   104 label *label86
-    * op add :printArray.0:i :printArray.0:i 1
+  105 op add :printArray.0:i 8 1
   106 label *label87
   107 print "-"
-    * readarr<inlined> *tmp7 .array[] :printArray.0:i
+  108 readarr<inlined> *tmp7 .array[] 9
   109 print *tmp7
   110 label *label88
-    * op add :printArray.0:i :printArray.0:i 1
+  111 op add :printArray.0:i 9 1
   112 label *label25
   113 label *label22
   114 assertprints "10-20-20-20-20-20-20-20-20-20" "digit counts"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-10 instructions):
 
    53 assertflush
    54 # "Function: void printArray()"
    55 print .array*0
-    * set :printArray.0:i 1
    56 label *label70
    57 label *label71
    58 print "-"
    59 readarr<inlined> *tmp7 .array[] 1
    60 print *tmp7
    61 label *label72
-    * op add :printArray.0:i 1 1
    62 label *label73
    63 print "-"
    64 readarr<inlined> *tmp7 .array[] 2
    65 print *tmp7
    66 label *label74
-    * op add :printArray.0:i 2 1
    67 label *label75
    68 print "-"
    69 readarr<inlined> *tmp7 .array[] 3
    70 print *tmp7
    71 label *label76
-    * op add :printArray.0:i 3 1
    72 label *label77
    73 print "-"
    74 readarr<inlined> *tmp7 .array[] 4
    75 print *tmp7
    76 label *label78
-    * op add :printArray.0:i 4 1
    77 label *label79
    78 print "-"
    79 readarr<inlined> *tmp7 .array[] 5
    80 print *tmp7
    81 label *label80
-    * op add :printArray.0:i 5 1
    82 label *label81
    83 print "-"
    84 readarr<inlined> *tmp7 .array[] 6
    85 print *tmp7
    86 label *label82
-    * op add :printArray.0:i 6 1
    87 label *label83
    88 print "-"
    89 readarr<inlined> *tmp7 .array[] 7
    90 print *tmp7
    91 label *label84
-    * op add :printArray.0:i 7 1
    92 label *label85
    93 print "-"
    94 readarr<inlined> *tmp7 .array[] 8
    95 print *tmp7
    96 label *label86
-    * op add :printArray.0:i 8 1
    97 label *label87
    98 print "-"
    99 readarr<inlined> *tmp7 .array[] 9
   100 print *tmp7
   101 label *label88
-    * op add :printArray.0:i 9 1
   102 label *label25
   103 label *label22
   104 assertprints "10-20-20-20-20-20-20-20-20-20" "digit counts"

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-180 instructions):
 
    56 label *label70
    57 label *label71
    58 print "-"
-    * readarr<inlined> *tmp7 .array[] 1
+   59 set *tmp7 .array*1
    60 print *tmp7
    61 label *label72
    62 label *label73
    63 print "-"
-    * readarr<inlined> *tmp7 .array[] 2
+   64 set *tmp7 .array*2
    65 print *tmp7
    66 label *label74
    67 label *label75
    68 print "-"
-    * readarr<inlined> *tmp7 .array[] 3
+   69 set *tmp7 .array*3
    70 print *tmp7
    71 label *label76
    72 label *label77
    73 print "-"
-    * readarr<inlined> *tmp7 .array[] 4
+   74 set *tmp7 .array*4
    75 print *tmp7
    76 label *label78
    77 label *label79
    78 print "-"
-    * readarr<inlined> *tmp7 .array[] 5
+   79 set *tmp7 .array*5
    80 print *tmp7
    81 label *label80
    82 label *label81
    83 print "-"
-    * readarr<inlined> *tmp7 .array[] 6
+   84 set *tmp7 .array*6
    85 print *tmp7
    86 label *label82
    87 label *label83
    88 print "-"
-    * readarr<inlined> *tmp7 .array[] 7
+   89 set *tmp7 .array*7
    90 print *tmp7
    91 label *label84
    92 label *label85
    93 print "-"
-    * readarr<inlined> *tmp7 .array[] 8
+   94 set *tmp7 .array*8
    95 print *tmp7
    96 label *label86
    97 label *label87
    98 print "-"
-    * readarr<inlined> *tmp7 .array[] 9
+   99 set *tmp7 .array*9
   100 print *tmp7
   101 label *label88
   102 label *label25

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    57 label *label71
    58 print "-"
    59 set *tmp7 .array*1
-    * print *tmp7
+   60 print .array*1
    61 label *label72
    62 label *label73
    63 print "-"
    64 set *tmp7 .array*2
-    * print *tmp7
+   65 print .array*2
    66 label *label74
    67 label *label75
    68 print "-"
    69 set *tmp7 .array*3
-    * print *tmp7
+   70 print .array*3
    71 label *label76
    72 label *label77
    73 print "-"
    74 set *tmp7 .array*4
-    * print *tmp7
+   75 print .array*4
    76 label *label78
    77 label *label79
    78 print "-"
    79 set *tmp7 .array*5
-    * print *tmp7
+   80 print .array*5
    81 label *label80
    82 label *label81
    83 print "-"
    84 set *tmp7 .array*6
-    * print *tmp7
+   85 print .array*6
    86 label *label82
    87 label *label83
    88 print "-"
    89 set *tmp7 .array*7
-    * print *tmp7
+   90 print .array*7
    91 label *label84
    92 label *label85
    93 print "-"
    94 set *tmp7 .array*8
-    * print *tmp7
+   95 print .array*8
    96 label *label86
    97 label *label87
    98 print "-"
    99 set *tmp7 .array*9
-    * print *tmp7
+  100 print .array*9
   101 label *label88
   102 label *label25
   103 label *label22

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-9 instructions):
 
    56 label *label70
    57 label *label71
    58 print "-"
-    * set *tmp7 .array*1
    59 print .array*1
    60 label *label72
    61 label *label73
    62 print "-"
-    * set *tmp7 .array*2
    63 print .array*2
    64 label *label74
    65 label *label75
    66 print "-"
-    * set *tmp7 .array*3
    67 print .array*3
    68 label *label76
    69 label *label77
    70 print "-"
-    * set *tmp7 .array*4
    71 print .array*4
    72 label *label78
    73 label *label79
    74 print "-"
-    * set *tmp7 .array*5
    75 print .array*5
    76 label *label80
    77 label *label81
    78 print "-"
-    * set *tmp7 .array*6
    79 print .array*6
    80 label *label82
    81 label *label83
    82 print "-"
-    * set *tmp7 .array*7
    83 print .array*7
    84 label *label84
    85 label *label85
    86 print "-"
-    * set *tmp7 .array*8
    87 print .array*8
    88 label *label86
    89 label *label87
    90 print "-"
-    * set *tmp7 .array*9
    91 print .array*9
    92 label *label88
    93 label *label25

Modifications by Virtual Instruction Expansion (+2 instructions):
 
    38 set :countDigits.0:number :i
    39 label *label19
    40 op mod *tmp2 :countDigits.0:number 10
-    * readarr<inlined> *tmp3 .array[] *tmp2
+   41 op mul *tmp8 *tmp2 2
+   42 multijump *label90 *tmp8 0 (m:marker1)
+   43 multilabel *label90 (m:marker1)
+   44 set *tmp3 .array*0
+   45 jump *label89 always
+   46 multilabel *label91 (m:marker1)
+   47 set *tmp3 .array*1
+   48 jump *label89 always
+   49 multilabel *label92 (m:marker1)
+   50 set *tmp3 .array*2
+   51 jump *label89 always
+   52 multilabel *label93 (m:marker1)
+   53 set *tmp3 .array*3
+   54 jump *label89 always
+   55 multilabel *label94 (m:marker1)
+   56 set *tmp3 .array*4
+   57 jump *label89 always
+   58 multilabel *label95 (m:marker1)
+   59 set *tmp3 .array*5
+   60 jump *label89 always
+   61 multilabel *label96 (m:marker1)
+   62 set *tmp3 .array*6
+   63 jump *label89 always
+   64 multilabel *label97 (m:marker1)
+   65 set *tmp3 .array*7
+   66 jump *label89 always
+   67 multilabel *label98 (m:marker1)
+   68 set *tmp3 .array*8
+   69 jump *label89 always
+   70 multilabel *label99 (m:marker1)
+   71 set *tmp3 .array*9
+   72 jump *label89 always
+   73 label *label89
    74 op add *tmp3 *tmp3 1
-    * writearr<inlined> *tmp3 .array[] *tmp2
+   75 op mul *tmp9 *tmp2 2
+   76 multijump *label102 *tmp9 0 (m:marker2)
+   77 multilabel *label102 (m:marker2)
+   78 set .array*0 *tmp3
+   79 jump *label101 always
+   80 multilabel *label103 (m:marker2)
+   81 set .array*1 *tmp3
+   82 jump *label101 always
+   83 multilabel *label104 (m:marker2)
+   84 set .array*2 *tmp3
+   85 jump *label101 always
+   86 multilabel *label105 (m:marker2)
+   87 set .array*3 *tmp3
+   88 jump *label101 always
+   89 multilabel *label106 (m:marker2)
+   90 set .array*4 *tmp3
+   91 jump *label101 always
+   92 multilabel *label107 (m:marker2)
+   93 set .array*5 *tmp3
+   94 jump *label101 always
+   95 multilabel *label108 (m:marker2)
+   96 set .array*6 *tmp3
+   97 jump *label101 always
+   98 multilabel *label109 (m:marker2)
+   99 set .array*7 *tmp3
+  100 jump *label101 always
+  101 multilabel *label110 (m:marker2)
+  102 set .array*8 *tmp3
+  103 jump *label101 always
+  104 multilabel *label111 (m:marker2)
+  105 set .array*9 *tmp3
+  106 jump *label101 always
+  107 label *label101
   108 op idiv :countDigits.0:number :countDigits.0:number 10
   109 label *label20
   110 jump *label19 greaterThan :countDigits.0:number 0

Modifications by Iterated phase, Single Step Elimination, pass 4, iteration 1 (-2 instructions):
 
    69 jump *label89 always
    70 multilabel *label99 (m:marker1)
    71 set *tmp3 .array*9
-    * jump *label89 always
    72 label *label89
    73 op add *tmp3 *tmp3 1
    74 op mul *tmp9 *tmp2 2
 
   102 jump *label101 always
   103 multilabel *label111 (m:marker2)
   104 set .array*9 *tmp3
-    * jump *label101 always
   105 label *label101
   106 op idiv :countDigits.0:number :countDigits.0:number 10
   107 label *label20

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
   155 label *label25
   156 label *label22
   157 assertprints "10-20-20-20-20-20-20-20-20-20" "digit counts"
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-8 instructions):
 
   117 print .array*0
   118 label *label70
   119 label *label71
-    * print "-"
-    * print .array*1
+  120 print "-{0}-{0}-{0}-{0}-{0}-{0}-{0}-{0}-"
+  121 format .array*1
   122 label *label72
   123 label *label73
-    * print "-"
-    * print .array*2
+  124 format .array*2
   125 label *label74
   126 label *label75
-    * print "-"
-    * print .array*3
+  127 format .array*3
   128 label *label76
   129 label *label77
-    * print "-"
-    * print .array*4
+  130 format .array*4
   131 label *label78
   132 label *label79
-    * print "-"
-    * print .array*5
+  133 format .array*5
   134 label *label80
   135 label *label81
-    * print "-"
-    * print .array*6
+  136 format .array*6
   137 label *label82
   138 label *label83
-    * print "-"
-    * print .array*7
+  139 format .array*7
   140 label *label84
   141 label *label85
-    * print "-"
-    * print .array*8
+  142 format .array*8
   143 label *label86
   144 label *label87
-    * print "-"
   145 print .array*9
   146 label *label88
   147 label *label25

Final code before resolving virtual instructions:

set LIMIT 100
set .array*0 0
set .array*1 0
set .array*2 0
set .array*3 0
set .array*4 0
set .array*5 0
set .array*6 0
set .array*7 0
set .array*8 0
set .array*9 0
set :i 0
jump *label17 greaterThanEq 0 LIMIT
label *label26
# "Function: void countDigits(in number)"
set :countDigits.0:number :i
label *label19
op mod *tmp2 :countDigits.0:number 10
op mul *tmp8 *tmp2 2
multijump *label90 *tmp8 0
multilabel *label90
set *tmp3 .array*0
jump *label89 always
multilabel *label91
set *tmp3 .array*1
jump *label89 always
multilabel *label92
set *tmp3 .array*2
jump *label89 always
multilabel *label93
set *tmp3 .array*3
jump *label89 always
multilabel *label94
set *tmp3 .array*4
jump *label89 always
multilabel *label95
set *tmp3 .array*5
jump *label89 always
multilabel *label96
set *tmp3 .array*6
jump *label89 always
multilabel *label97
set *tmp3 .array*7
jump *label89 always
multilabel *label98
set *tmp3 .array*8
jump *label89 always
multilabel *label99
set *tmp3 .array*9
label *label89
op add *tmp3 *tmp3 1
op mul *tmp9 *tmp2 2
multijump *label102 *tmp9 0
multilabel *label102
set .array*0 *tmp3
jump *label101 always
multilabel *label103
set .array*1 *tmp3
jump *label101 always
multilabel *label104
set .array*2 *tmp3
jump *label101 always
multilabel *label105
set .array*3 *tmp3
jump *label101 always
multilabel *label106
set .array*4 *tmp3
jump *label101 always
multilabel *label107
set .array*5 *tmp3
jump *label101 always
multilabel *label108
set .array*6 *tmp3
jump *label101 always
multilabel *label109
set .array*7 *tmp3
jump *label101 always
multilabel *label110
set .array*8 *tmp3
jump *label101 always
multilabel *label111
set .array*9 *tmp3
label *label101
op idiv :countDigits.0:number :countDigits.0:number 10
jump *label19 greaterThan :countDigits.0:number 0
op add :i :i 1
jump *label26 lessThan :i LIMIT
label *label17
assertflush
# "Function: void printArray()"
print .array*0
print "-{0}-{0}-{0}-{0}-{0}-{0}-{0}-{0}-"
format .array*1
format .array*2
format .array*3
format .array*4
format .array*5
format .array*6
format .array*7
format .array*8
print .array*9
assertprints "10-20-20-20-20-20-20-20-20-20" "digit counts"
