    47 instructions before optimizations.
     3 instructions eliminated by Temp Variables Elimination (5 iterations).
     5 instructions eliminated by Dead Code Elimination (4 iterations).
     3 instructions eliminated by Condition Optimization (5 iterations).
     2 instructions eliminated by Single Step Elimination (5 iterations).
     2 instructions modified by Data Flow Optimization (4 iterations).
     7 instructions added by Loop Rotation (2 iterations).
       1 loop conditions were partially rotated.
     2 instructions eliminated by Jump Straightening (5 iterations).
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
     1 instructions eliminated by Print Merging.
    37 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 966):
  * Full loop rotation at line 4:5                               size    +7, benefit       26.0, efficiency      3.714 (+7 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-5 instructions):
 
    21 op equal *tmp6 *tmp5 4
    22 jump *label7 equal *tmp6 false
    23 jump *label3 always
-    * set *tmp7 null
    24 jump *label8 always
    25 label *label7
-    * set *tmp7 null
    26 label *label8
    27 print :test:i
    28 print "|"
 
    36 op equal *tmp9 *tmp8 10
    37 jump *label10 equal *tmp9 false
    38 jump *label4 always
-    * set *tmp10 null
    39 jump *label11 always
    40 label *label10
-    * set *tmp10 null
    41 label *label11
    42 label *label3
    43 op add :test:i :test:i 2
    44 op add :test:j :test:j 1
    45 jump *label2 always
    46 label *label4
-    * set *tmp1 null
    47 label *label1
    48 assertprints *tmp0 "0|10|2|11|6|13|8|14|10|15|" "iterated-for-loop-break-continue"
    49 stop

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-3 instructions):
 
    10 setaddr :d*retaddr *label6 (h:*label6)
    11 call *label0 *invalid :d*retval (m:*label6) (h:*label6)
    12 label *label6
-    * set *tmp3 :d*retval
-    * op lessThanEq *tmp4 *tmp2 *tmp3
+   13 op lessThanEq *tmp4 *tmp2 :d*retval
    14 jump *label4 equal *tmp4 false
    15 set :d:n :test:i
    16 setaddr :d*retaddr *label9 (h:*label9)
    17 call *label0 *invalid :d*retval (m:*label9) (h:*label9)
    18 label *label9
-    * set *tmp5 :d*retval
-    * op equal *tmp6 *tmp5 4
+   19 op equal *tmp6 :d*retval 4
    20 jump *label7 equal *tmp6 false
    21 jump *label3 always
    22 jump *label8 always
 
    30 setaddr :d*retaddr *label12 (h:*label12)
    31 call *label0 *invalid :d*retval (m:*label12) (h:*label12)
    32 label *label12
-    * set *tmp8 :d*retval
-    * op equal *tmp9 *tmp8 10
+   33 op equal *tmp9 :d*retval 10
    34 jump *label10 equal *tmp9 false
    35 jump *label4 always
    36 jump *label11 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-3 instructions):
 
    10 setaddr :d*retaddr *label6 (h:*label6)
    11 call *label0 *invalid :d*retval (m:*label6) (h:*label6)
    12 label *label6
-    * op lessThanEq *tmp4 *tmp2 :d*retval
-    * jump *label4 equal *tmp4 false
+   13 jump *label4 greaterThan *tmp2 :d*retval
    14 set :d:n :test:i
    15 setaddr :d*retaddr *label9 (h:*label9)
    16 call *label0 *invalid :d*retval (m:*label9) (h:*label9)
    17 label *label9
-    * op equal *tmp6 :d*retval 4
-    * jump *label7 equal *tmp6 false
+   18 jump *label7 notEqual :d*retval 4
    19 jump *label3 always
    20 jump *label8 always
    21 label *label7
 
    28 setaddr :d*retaddr *label12 (h:*label12)
    29 call *label0 *invalid :d*retval (m:*label12) (h:*label12)
    30 label *label12
-    * op equal *tmp9 :d*retval 10
-    * jump *label10 equal *tmp9 false
+   31 jump *label10 notEqual :d*retval 10
    32 jump *label4 always
    33 jump *label11 always
    34 label *label10

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    17 label *label9
    18 jump *label7 notEqual :d*retval 4
    19 jump *label3 always
-    * jump *label8 always
    20 label *label7
    21 label *label8
    22 print :test:i
 
    29 label *label12
    30 jump *label10 notEqual :d*retval 10
    31 jump *label4 always
-    * jump *label11 always
    32 label *label10
    33 label *label11
    34 label *label3

Modifications by Full loop rotation at line 4:5 (+7 instructions):
 
    11 call *label0 *invalid :d*retval (m:*label6) (h:*label6)
    12 label *label6
    13 jump *label4 greaterThan *tmp2 :d*retval
+   14 label *label16
    15 set :d:n :test:i
    16 setaddr :d*retaddr *label9 (h:*label9)
    17 call *label0 *invalid :d*retval (m:*label9) (h:*label9)
 
    35 label *label3
    36 op add :test:i :test:i 2
    37 op add :test:j :test:j 1
-    * jump *label2 always
+   38 set :d:n :test:i
+   39 setaddr :d*retaddr *label14 (h:*label14)
+   40 call *label0 *invalid :d*retval (m:*label14) (h:*label14)
+   41 label *label14
+   42 set *tmp2 :d*retval
+   43 set :d:n :test:j
+   44 setaddr :d*retaddr *label15 (h:*label15)
+   45 call *label0 *invalid :d*retval (m:*label15) (h:*label15)
+   46 label *label15
+   47 jump *label16 lessThanEq *tmp2 :d*retval
    48 label *label4
    49 label *label1
    50 assertprints *tmp0 "0|10|2|11|6|13|8|14|10|15|" "iterated-for-loop-break-continue"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     1 set :test:i 0
     2 set :test:j 10
     3 label *label2
-    * set :d:n :test:i
+    4 set :d:n 0
     5 setaddr :d*retaddr *label5 (h:*label5)
     6 call *label0 *invalid :d*retval (m:*label5) (h:*label5)
     7 label *label5
     8 set *tmp2 :d*retval
-    * set :d:n :test:j
+    9 set :d:n 10
    10 setaddr :d*retaddr *label6 (h:*label6)
    11 call *label0 *invalid :d*retval (m:*label6) (h:*label6)
    12 label *label6

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-1 instructions):
     0 assertflush *tmp0
     1 set :test:i 0
     2 set :test:j 10
-    * label *label2
     3 set :d:n 0
     4 setaddr :d*retaddr *label5 (h:*label5)
     5 call *label0 *invalid :d*retval (m:*label5) (h:*label5)
 
    18 jump *label7 notEqual :d*retval 4
    19 jump *label3 always
    20 label *label7
-    * label *label8
    21 print :test:i
    22 print "|"
    23 print :test:j
 
    29 jump *label10 notEqual :d*retval 10
    30 jump *label4 always
    31 label *label10
-    * label *label11
    32 label *label3
    33 op add :test:i :test:i 2
    34 op add :test:j :test:j 1
 
    43 label *label15
    44 jump *label16 lessThanEq *tmp2 :d*retval
    45 label *label4
-    * label *label1
    46 assertprints *tmp0 "0|10|2|11|6|13|8|14|10|15|" "iterated-for-loop-break-continue"
    47 stop
    48 end
    49 label *label0
    50 set :d*retval :d:n
-    * label *label13
    51 return :d*retaddr
-    * end

Modifications by Jumps phase, Jump Straightening, pass 3, iteration 1 (-2 instructions):
 
    15 setaddr :d*retaddr *label9 (h:*label9)
    16 call *label0 *invalid :d*retval (m:*label9) (h:*label9)
    17 label *label9
-    * jump *label7 notEqual :d*retval 4
-    * jump *label3 always
+   18 jump *label3 equal :d*retval 4
    19 label *label7
    20 print :test:i
    21 print "|"
 
    25 setaddr :d*retaddr *label12 (h:*label12)
    26 call *label0 *invalid :d*retval (m:*label12) (h:*label12)
    27 label *label12
-    * jump *label10 notEqual :d*retval 10
-    * jump *label4 always
+   28 jump *label4 equal :d*retval 10
    29 label *label10
    30 label *label3
    31 op add :test:i :test:i 2

Modifications by Final phase, Print Merging, iteration 1 (-1 instructions):
 
    17 label *label9
    18 jump *label3 equal :d*retval 4
    19 print :test:i
-    * print "|"
-    * print :test:j
-    * print "|"
+   20 print "|{0}|"
+   21 format :test:j
    22 set :d:n :test:i
    23 setaddr :d*retaddr *label12 (h:*label12)
    24 call *label0 *invalid :d*retval (m:*label12) (h:*label12)

Final code before resolving virtual instructions:

assertflush *tmp0
set :test:i 0
set :test:j 10
set :d:n 0
setaddr :d*retaddr *label5
call *label0 *invalid :d*retval
label *label5
set *tmp2 :d*retval
set :d:n 10
setaddr :d*retaddr *label6
call *label0 *invalid :d*retval
label *label6
jump *label4 greaterThan *tmp2 :d*retval
label *label16
set :d:n :test:i
setaddr :d*retaddr *label9
call *label0 *invalid :d*retval
label *label9
jump *label3 equal :d*retval 4
print :test:i
print "|{0}|"
format :test:j
set :d:n :test:i
setaddr :d*retaddr *label12
call *label0 *invalid :d*retval
label *label12
jump *label4 equal :d*retval 10
label *label3
op add :test:i :test:i 2
op add :test:j :test:j 1
set :d:n :test:i
setaddr :d*retaddr *label14
call *label0 *invalid :d*retval
label *label14
set *tmp2 :d*retval
set :d:n :test:j
setaddr :d*retaddr *label15
call *label0 *invalid :d*retval
label *label15
jump *label16 lessThanEq *tmp2 :d*retval
label *label4
assertprints *tmp0 "0|10|2|11|6|13|8|14|10|15|" "iterated-for-loop-break-continue"
stop
end
label *label0
set :d*retval :d:n
return :d*retaddr
