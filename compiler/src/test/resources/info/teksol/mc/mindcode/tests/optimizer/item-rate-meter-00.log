   189 instructions before optimizations.
    20 instructions eliminated by Temp Variables Elimination (6 iterations).
     2 instructions eliminated by Case Expression Optimization.
    20 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    12 instructions eliminated by Condition Optimization (6 iterations).
     8 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Expression Optimization (3 iterations).
     1 instructions eliminated by Boolean Optimization (6 iterations).
       1 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by If Expression Optimization (3 iterations).
     4 instructions modified by Data Flow Optimization (2 passes, 7 iterations).
     1 instructions added by Loop Rotation (3 iterations).
       4 loop conditions were partially rotated.
     1 instructions eliminated by Case Switching (5 iterations).
     1 case expressions converted to fast dispatch by Case Switching.
     5 instructions eliminated by Jump Straightening (6 iterations).
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
    23 instructions eliminated by Print Merging.
    94 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 880):
  * Full loop rotation at line 57:1                              size    +1, benefit       26.0, efficiency     26.000 (+1 instructions)
  o Fast-dispatch case at line 13:9                              size    -2, benefit      312.5, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 879):
  * Fast-dispatch case at line 13:9                              size    -2, benefit      312.5, efficiency   Infinity (-1 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-2 instructions):
 
    18 print "\nFound: "
    19 print :block
    20 sensor *tmp6 :block @type
-    * set *tmp7 *tmp6
-    * jump *label8 equal *tmp7 @message
+   21 jump *label8 equal *tmp6 @message
    22 jump *label7 always
    23 label *label8
    24 set .MESSAGE :block
    25 set *tmp5 .MESSAGE
    26 jump *label6 always
    27 label *label7
-    * jump *label10 equal *tmp7 @switch
+   28 jump *label10 equal *tmp6 @switch
    29 jump *label9 always
    30 label *label10
    31 set .SWITCH :block
    32 set *tmp5 .SWITCH
    33 jump *label6 always
    34 label *label9
-    * jump *label12 equal *tmp7 @memory-bank
-    * jump *label12 equal *tmp7 @memory-cell
+   35 jump *label12 equal *tmp6 @memory-bank
+   36 jump *label12 equal *tmp6 @memory-cell
    37 jump *label11 always
    38 label *label12
    39 set .TARGET_MEMORY .SOURCE_MEMORY
 
    76 label *label16
    77 set :startIndex 0
    78 sensor *tmp13 .TARGET_MEMORY @type
-    * set *tmp14 *tmp13
-    * jump *label19 equal *tmp14 @memory-cell
+   79 jump *label19 equal *tmp13 @memory-cell
    80 jump *label18 always
    81 label *label19
    82 set *tmp12 64
    83 jump *label17 always
    84 label *label18
-    * jump *label21 equal *tmp14 @memory-bank
+   85 jump *label21 equal *tmp13 @memory-bank
    86 jump *label20 always
    87 label *label21
    88 set *tmp12 512

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-18 instructions):
 
    22 jump *label7 always
    23 label *label8
    24 set .MESSAGE :block
-    * set *tmp5 .MESSAGE
    25 jump *label6 always
    26 label *label7
    27 jump *label10 equal *tmp6 @switch
    28 jump *label9 always
    29 label *label10
    30 set .SWITCH :block
-    * set *tmp5 .SWITCH
    31 jump *label6 always
    32 label *label9
    33 jump *label12 equal *tmp6 @memory-bank
 
    36 label *label12
    37 set .TARGET_MEMORY .SOURCE_MEMORY
    38 set .SOURCE_MEMORY :block
-    * set *tmp5 .SOURCE_MEMORY
    39 jump *label6 always
    40 label *label11
-    * set *tmp5 null
    41 label *label6
    42 label *label4
    43 jump *label3 always
 
    53 op equal *tmp8 .SOURCE_MEMORY null
    54 jump *label13 equal *tmp8 false
    55 print "\nNo memory."
-    * set *tmp9 "\nNo memory."
    56 jump *label14 always
    57 label *label13
-    * set *tmp9 null
    58 label *label14
    59 printflush .MESSAGE
    60 label *label1
 
    63 op equal *tmp10 .TARGET_MEMORY null
    64 jump *label15 equal *tmp10 false
    65 set .TARGET_MEMORY .SOURCE_MEMORY
-    * set *tmp11 .TARGET_MEMORY
    66 jump *label16 always
    67 label *label15
-    * set *tmp11 null
    68 label *label16
    69 set :startIndex 0
    70 sensor *tmp13 .TARGET_MEMORY @type
 
    88 op idiv *tmp17 :memSize 2
    89 set :startIndex *tmp17
    90 op sub :memSize :memSize 1
-    * set *tmp16 :memSize
    91 jump *label23 always
    92 label *label22
-    * set *tmp16 null
    93 label *label23
    94 set *tmp18 @tick
    95 set :prevTick *tmp18
 
   116 op add *tmp32 :prevTick TICKS
   117 set :nextTick *tmp32
   118 set :currTick :prevTick
-    * set *tmp30 :currTick
   119 jump *label28 always
   120 label *label27
-    * set *tmp30 null
   121 label *label28
   122 label *label29
   123 op lessThan *tmp33 @tick :nextTick
 
   125 op lessThan *tmp34 @tick :prevTick
   126 jump *label32 equal *tmp34 false
   127 end
-    * set *tmp35 null
   128 jump *label33 always
   129 label *label32
   130 read *tmp37 .SOURCE_MEMORY 0
 
   139 label *label34
   140 set *tmp39 null
   141 label *label35
-    * set *tmp35 *tmp39
   142 label *label33
   143 label *label30
   144 jump *label29 always
 
   150 op equal *tmp43 :amount 0
   151 jump *label36 equal *tmp43 false
   152 set :rate 0
-    * set *tmp44 :rate
   153 jump *label37 always
   154 label *label36
   155 op div *tmp45 :amount :time
   156 op max *tmp46 *tmp45 0
   157 set :rate *tmp46
-    * set *tmp44 :rate
   158 label *label37
   159 op add :index :index 1
   160 op greaterThanEq *tmp47 :index :memSize
   161 jump *label38 equal *tmp47 false
   162 op add *tmp49 :startIndex 1
   163 set :index *tmp49
-    * set *tmp48 :index
   164 jump *label39 always
   165 label *label38
-    * set *tmp48 null
   166 label *label39
   167 set *tmp50 :startIndex
   168 write :index .TARGET_MEMORY *tmp50

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
   134 set *tmp40 @tick
   135 set :currTick *tmp40
   136 set :curr :value
-    * set *tmp39 :curr
   137 jump *label35 always
   138 label *label34
-    * set *tmp39 null
   139 label *label35
   140 label *label33
   141 label *label30

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-20 instructions):
 
     6 op equal *tmp0 .SOURCE_MEMORY null
     7 jump *label2 equal *tmp0 false
     8 print "Item Rate Meter"
-    * set *tmp1 @links
-    * set :n *tmp1
+    9 set :n @links
    10 label *label3
    11 op greaterThan *tmp2 :n 0
    12 jump *label5 equal *tmp2 false
-    * op sub *tmp3 :n 1
-    * set :n *tmp3
-    * getlink *tmp4 :n
-    * set :block *tmp4
+   13 op sub :n :n 1
+   14 getlink :block :n
    15 print "\nFound: "
    16 print :block
    17 sensor *tmp6 :block @type
 
    82 set :memSize *tmp12
    83 op equal *tmp15 .SOURCE_MEMORY .TARGET_MEMORY
    84 jump *label22 equal *tmp15 false
-    * op idiv *tmp17 :memSize 2
-    * set :startIndex *tmp17
+   85 op idiv :startIndex :memSize 2
    86 op sub :memSize :memSize 1
    87 jump *label23 always
    88 label *label22
    89 label *label23
-    * set *tmp18 @tick
-    * set :prevTick *tmp18
-    * read *tmp20 .SOURCE_MEMORY 0
-    * set :prev *tmp20
+   90 set :prevTick @tick
+   91 read :prev .SOURCE_MEMORY 0
    92 set :currTick :prevTick
    93 set :curr :prev
-    * set *tmp21 :startIndex
-    * read *tmp24 .TARGET_MEMORY *tmp21
-    * op max *tmp23 :startIndex *tmp24
-    * set :index *tmp23
+   94 read *tmp24 .TARGET_MEMORY :startIndex
+   95 op max :index :startIndex *tmp24
    96 set :nextTick :prevTick
    97 label *label24
    98 sensor *tmp25 switch1 @enabled
    99 op equal *tmp26 *tmp25 0
   100 jump *label26 equal *tmp26 false
-    * op add *tmp27 :nextTick TICKS
-    * set :nextTick *tmp27
+  101 op add :nextTick :nextTick TICKS
   102 op add *tmp28 :nextTick TICKS
   103 op greaterThan *tmp29 @tick *tmp28
   104 jump *label27 equal *tmp29 false
-    * set *tmp31 @tick
-    * set :prevTick *tmp31
-    * op add *tmp32 :prevTick TICKS
-    * set :nextTick *tmp32
+  105 set :prevTick @tick
+  106 op add :nextTick :prevTick TICKS
   107 set :currTick :prevTick
   108 jump *label28 always
   109 label *label27
 
   116 end
   117 jump *label33 always
   118 label *label32
-    * read *tmp37 .SOURCE_MEMORY 0
-    * set :value *tmp37
+  119 read :value .SOURCE_MEMORY 0
   120 op notEqual *tmp38 :value :curr
   121 jump *label34 equal *tmp38 false
-    * set *tmp40 @tick
-    * set :currTick *tmp40
+  122 set :currTick @tick
   123 set :curr :value
   124 jump *label35 always
   125 label *label34
 
   128 label *label30
   129 jump *label29 always
   130 label *label31
-    * op sub *tmp41 :curr :prev
-    * set :amount *tmp41
-    * op sub *tmp42 :currTick :prevTick
-    * set :time *tmp42
+  131 op sub :amount :curr :prev
+  132 op sub :time :currTick :prevTick
   133 op equal *tmp43 :amount 0
   134 jump *label36 equal *tmp43 false
   135 set :rate 0
   136 jump *label37 always
   137 label *label36
   138 op div *tmp45 :amount :time
-    * op max *tmp46 *tmp45 0
-    * set :rate *tmp46
+  139 op max :rate *tmp45 0
   140 label *label37
   141 op add :index :index 1
   142 op greaterThanEq *tmp47 :index :memSize
   143 jump *label38 equal *tmp47 false
-    * op add *tmp49 :startIndex 1
-    * set :index *tmp49
+  144 op add :index :startIndex 1
   145 jump *label39 always
   146 label *label38
   147 label *label39
-    * set *tmp50 :startIndex
-    * write :index .TARGET_MEMORY *tmp50
-    * set *tmp52 :index
-    * write :rate .TARGET_MEMORY *tmp52
+  148 write :index .TARGET_MEMORY :startIndex
+  149 write :rate .TARGET_MEMORY :index
   150 print "Item Rate Meter"
   151 print "\n"
   152 print "Total items: [gold]"
 
   182 label *label25
   183 jump *label24 always
   184 label *label26
-    * set *tmp57 switch1
-    * control enabled *tmp57 0
+  185 control enabled switch1 0
   186 end

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-5 instructions):
 
    15 print "\nFound: "
    16 print :block
    17 sensor *tmp6 :block @type
-    * jump *label8 equal *tmp6 @message
-    * jump *label7 always
+   18 jump *label7 notEqual *tmp6 @message
    19 label *label8
    20 set .MESSAGE :block
    21 jump *label6 always
    22 label *label7
-    * jump *label10 equal *tmp6 @switch
-    * jump *label9 always
+   23 jump *label9 notEqual *tmp6 @switch
    24 label *label10
    25 set .SWITCH :block
    26 jump *label6 always
    27 label *label9
    28 jump *label12 equal *tmp6 @memory-bank
-    * jump *label12 equal *tmp6 @memory-cell
-    * jump *label11 always
+   29 jump *label11 notEqual *tmp6 @memory-cell
    30 label *label12
    31 set .TARGET_MEMORY .SOURCE_MEMORY
    32 set .SOURCE_MEMORY :block
 
    62 label *label16
    63 set :startIndex 0
    64 sensor *tmp13 .TARGET_MEMORY @type
-    * jump *label19 equal *tmp13 @memory-cell
-    * jump *label18 always
+   65 jump *label18 notEqual *tmp13 @memory-cell
    66 label *label19
    67 set *tmp12 64
    68 jump *label17 always
    69 label *label18
-    * jump *label21 equal *tmp13 @memory-bank
-    * jump *label20 always
+   70 jump *label20 notEqual *tmp13 @memory-bank
    71 label *label21
    72 set *tmp12 512
    73 jump *label17 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-12 instructions):
 
     3 set .SWITCH null
     4 set .MESSAGE .SWITCH
     5 label *label0
-    * op equal *tmp0 .SOURCE_MEMORY null
-    * jump *label2 equal *tmp0 false
+    6 jump *label2 notEqual .SOURCE_MEMORY null
     7 print "Item Rate Meter"
     8 set :n @links
     9 label *label3
-    * op greaterThan *tmp2 :n 0
-    * jump *label5 equal *tmp2 false
+   10 jump *label5 lessThanEq :n 0
    11 op sub :n :n 1
    12 getlink :block :n
    13 print "\nFound: "
 
    42 print .SOURCE_MEMORY
    43 print "\nTarget memory: "
    44 print .TARGET_MEMORY
-    * op equal *tmp8 .SOURCE_MEMORY null
-    * jump *label13 equal *tmp8 false
+   45 jump *label13 notEqual .SOURCE_MEMORY null
    46 print "\nNo memory."
    47 jump *label14 always
    48 label *label13
 
    51 label *label1
    52 jump *label0 always
    53 label *label2
-    * op equal *tmp10 .TARGET_MEMORY null
-    * jump *label15 equal *tmp10 false
+   54 jump *label15 notEqual .TARGET_MEMORY null
    55 set .TARGET_MEMORY .SOURCE_MEMORY
    56 jump *label16 always
    57 label *label15
 
    71 set *tmp12 0
    72 label *label17
    73 set :memSize *tmp12
-    * op equal *tmp15 .SOURCE_MEMORY .TARGET_MEMORY
-    * jump *label22 equal *tmp15 false
+   74 jump *label22 notEqual .SOURCE_MEMORY .TARGET_MEMORY
    75 op idiv :startIndex :memSize 2
    76 op sub :memSize :memSize 1
    77 jump *label23 always
 
    86 set :nextTick :prevTick
    87 label *label24
    88 sensor *tmp25 switch1 @enabled
-    * op equal *tmp26 *tmp25 0
-    * jump *label26 equal *tmp26 false
+   89 jump *label26 notEqual *tmp25 0
    90 op add :nextTick :nextTick TICKS
    91 op add *tmp28 :nextTick TICKS
-    * op greaterThan *tmp29 @tick *tmp28
-    * jump *label27 equal *tmp29 false
+   92 jump *label27 lessThanEq @tick *tmp28
    93 set :prevTick @tick
    94 op add :nextTick :prevTick TICKS
    95 set :currTick :prevTick
 
    97 label *label27
    98 label *label28
    99 label *label29
-    * op lessThan *tmp33 @tick :nextTick
-    * jump *label31 equal *tmp33 false
-    * op lessThan *tmp34 @tick :prevTick
-    * jump *label32 equal *tmp34 false
+  100 jump *label31 greaterThanEq @tick :nextTick
+  101 jump *label32 greaterThanEq @tick :prevTick
   102 end
   103 jump *label33 always
   104 label *label32
   105 read :value .SOURCE_MEMORY 0
-    * op notEqual *tmp38 :value :curr
-    * jump *label34 equal *tmp38 false
+  106 jump *label34 equal :value :curr
   107 set :currTick @tick
   108 set :curr :value
   109 jump *label35 always
 
   115 label *label31
   116 op sub :amount :curr :prev
   117 op sub :time :currTick :prevTick
-    * op equal *tmp43 :amount 0
-    * jump *label36 equal *tmp43 false
+  118 jump *label36 notEqual :amount 0
   119 set :rate 0
   120 jump *label37 always
   121 label *label36
 
   123 op max :rate *tmp45 0
   124 label *label37
   125 op add :index :index 1
-    * op greaterThanEq *tmp47 :index :memSize
-    * jump *label38 equal *tmp47 false
+  126 jump *label38 lessThan :index :memSize
   127 op add :index :startIndex 1
   128 jump *label39 always
   129 label *label38

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    28 label *label12
    29 set .TARGET_MEMORY .SOURCE_MEMORY
    30 set .SOURCE_MEMORY :block
-    * jump *label6 always
    31 label *label11
    32 label *label6
    33 label *label4
 
    43 print .TARGET_MEMORY
    44 jump *label13 notEqual .SOURCE_MEMORY null
    45 print "\nNo memory."
-    * jump *label14 always
    46 label *label13
    47 label *label14
    48 printflush .MESSAGE
 
    51 label *label2
    52 jump *label15 notEqual .TARGET_MEMORY null
    53 set .TARGET_MEMORY .SOURCE_MEMORY
-    * jump *label16 always
    54 label *label15
    55 label *label16
    56 set :startIndex 0
 
    71 jump *label22 notEqual .SOURCE_MEMORY .TARGET_MEMORY
    72 op idiv :startIndex :memSize 2
    73 op sub :memSize :memSize 1
-    * jump *label23 always
    74 label *label22
    75 label *label23
    76 set :prevTick @tick
 
    89 set :prevTick @tick
    90 op add :nextTick :prevTick TICKS
    91 set :currTick :prevTick
-    * jump *label28 always
    92 label *label27
    93 label *label28
    94 label *label29
 
   101 jump *label34 equal :value :curr
   102 set :currTick @tick
   103 set :curr :value
-    * jump *label35 always
   104 label *label34
   105 label *label35
   106 label *label33
 
   119 op add :index :index 1
   120 jump *label38 lessThan :index :memSize
   121 op add :index :startIndex 1
-    * jump *label39 always
   122 label *label38
   123 label *label39
   124 write :index .TARGET_MEMORY :startIndex

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   130 print "["
   131 print "]"
   132 print "\n"
-    * op mul *tmp54 :rate 3600
-    * op floor *tmp55 *tmp54
+  133 op idiv *tmp55 :rate 0.0002777777777777778
   134 print "Current rate [green]"
   135 print *tmp55
   136 print "["

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     1 set .SOURCE_MEMORY null
     2 set .TARGET_MEMORY null
     3 set .SWITCH null
-    * set .MESSAGE .SWITCH
+    4 set .MESSAGE null
     5 label *label0
     6 jump *label2 notEqual .SOURCE_MEMORY null
     7 print "Item Rate Meter"
 
    69 label *label17
    70 set :memSize *tmp12
    71 jump *label22 notEqual .SOURCE_MEMORY .TARGET_MEMORY
-    * op idiv :startIndex :memSize 2
-    * op sub :memSize :memSize 1
+   72 op idiv :startIndex *tmp12 2
+   73 op sub :memSize *tmp12 1
    74 label *label22
    75 label *label23
    76 set :prevTick @tick

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     4 set .MESSAGE null
     5 label *label0
     6 jump *label2 notEqual .SOURCE_MEMORY null
+    7 label *label40
     8 print "Item Rate Meter"
     9 set :n @links
    10 label *label3
    11 jump *label5 lessThanEq :n 0
+   12 label *label41
    13 op sub :n :n 1
    14 getlink :block :n
    15 print "\nFound: "
 
    33 label *label11
    34 label *label6
    35 label *label4
-    * jump *label3 always
+   36 jump *label41 greaterThan :n 0
    37 label *label5
    38 print "\nMessage: "
    39 print .MESSAGE
 
    49 label *label14
    50 printflush .MESSAGE
    51 label *label1
-    * jump *label0 always
+   52 jump *label40 equal .SOURCE_MEMORY null
    53 label *label2
    54 jump *label15 notEqual .TARGET_MEMORY null
    55 set .TARGET_MEMORY .SOURCE_MEMORY
 
    95 label *label28
    96 label *label29
    97 jump *label31 greaterThanEq @tick :nextTick
+   98 label *label42
    99 jump *label32 greaterThanEq @tick :prevTick
   100 end
   101 jump *label33 always
 
   108 label *label35
   109 label *label33
   110 label *label30
-    * jump *label29 always
+  111 jump *label42 lessThan @tick :nextTick
   112 label *label31
   113 op sub :amount :curr :prev
   114 op sub :time :currTick :prevTick

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
    51 label *label1
    52 jump *label40 equal .SOURCE_MEMORY null
    53 label *label2
-    * jump *label15 notEqual .TARGET_MEMORY null
-    * set .TARGET_MEMORY .SOURCE_MEMORY
-    * label *label15
-    * label *label16
+   54 select .TARGET_MEMORY equal .TARGET_MEMORY null .SOURCE_MEMORY .TARGET_MEMORY
    55 set :startIndex 0
    56 sensor *tmp13 .TARGET_MEMORY @type
    57 jump *label18 notEqual *tmp13 @memory-cell

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
   109 label *label31
   110 op sub :amount :curr :prev
   111 op sub :time :currTick :prevTick
-    * jump *label36 notEqual :amount 0
   112 set :rate 0
-    * jump *label37 always
+  113 jump *label37 equal :amount 0
   114 label *label36
   115 op div *tmp45 :amount :time
   116 op max :rate *tmp45 0

Modifications by Full loop rotation at line 57:1 (+1 instructions):
 
    82 label *label24
    83 sensor *tmp25 switch1 @enabled
    84 jump *label26 notEqual *tmp25 0
+   85 label *label43
    86 op add :nextTick :nextTick TICKS
    87 op add *tmp28 :nextTick TICKS
    88 jump *label27 lessThanEq @tick *tmp28
 
   155 set :prevTick :currTick
   156 set :prev :curr
   157 label *label25
-    * jump *label24 always
+  158 sensor *tmp25 switch1 @enabled
+  159 jump *label43 equal *tmp25 0
   160 label *label26
   161 control enabled switch1 0
   162 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 set .SWITCH null
     4 set .MESSAGE null
     5 label *label0
-    * jump *label2 notEqual .SOURCE_MEMORY null
+    6 jump *label2 notEqual null null
     7 label *label40
     8 print "Item Rate Meter"
     9 set :n @links

Modifications by Fast-dispatch case at line 13:9 (-1 instructions):
 
    15 print "\nFound: "
    16 print :block
    17 sensor *tmp6 :block @type
-    * jump *label7 notEqual *tmp6 @message
+   18 sensor *tmp59 *tmp6 @id
+   19 multijump *tmp59 0 0 (m:*label45)
+   20 multilabel *label50 (m:*label45)
+   21 multilabel *label46 (m:*label45)
+   22 label *label44
+   23 jump *label6 always
+   24 multilabel *label47 (m:*label45)
    25 label *label8
    26 set .MESSAGE :block
    27 jump *label6 always
    28 label *label7
-    * jump *label9 notEqual *tmp6 @switch
+   29 multilabel *label48 (m:*label45)
    30 label *label10
    31 set .SWITCH :block
    32 jump *label6 always
    33 label *label9
-    * jump *label12 equal *tmp6 @memory-bank
-    * jump *label11 notEqual *tmp6 @memory-cell
+   34 multilabel *label49 (m:*label45)
    35 label *label12
    36 set .TARGET_MEMORY .SOURCE_MEMORY
    37 set .SOURCE_MEMORY :block
-    * label *label11
    38 label *label6
    39 label *label4
    40 jump *label41 greaterThan :n 0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
     3 set .SWITCH null
     4 set .MESSAGE null
     5 label *label0
-    * jump *label2 notEqual null null
     6 label *label40
     7 print "Item Rate Meter"
     8 set :n @links

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-1 instructions):
 
     2 set .TARGET_MEMORY null
     3 set .SWITCH null
     4 set .MESSAGE null
-    * label *label0
     5 label *label40
     6 print "Item Rate Meter"
     7 set :n @links
-    * label *label3
     8 jump *label5 lessThanEq :n 0
     9 label *label41
    10 op sub :n :n 1
 
    16 multijump *tmp59 0 0 (m:*label45)
    17 multilabel *label50 (m:*label45)
    18 multilabel *label46 (m:*label45)
-    * label *label44
    19 jump *label6 always
    20 multilabel *label47 (m:*label45)
-    * label *label8
    21 set .MESSAGE :block
    22 jump *label6 always
-    * label *label7
    23 multilabel *label48 (m:*label45)
-    * label *label10
    24 set .SWITCH :block
    25 jump *label6 always
-    * label *label9
    26 multilabel *label49 (m:*label45)
-    * label *label12
    27 set .TARGET_MEMORY .SOURCE_MEMORY
    28 set .SOURCE_MEMORY :block
    29 label *label6
-    * label *label4
    30 jump *label41 greaterThan :n 0
    31 label *label5
    32 print "\nMessage: "
 
    40 jump *label13 notEqual .SOURCE_MEMORY null
    41 print "\nNo memory."
    42 label *label13
-    * label *label14
    43 printflush .MESSAGE
-    * label *label1
    44 jump *label40 equal .SOURCE_MEMORY null
-    * label *label2
    45 select .TARGET_MEMORY equal .TARGET_MEMORY null .SOURCE_MEMORY .TARGET_MEMORY
    46 set :startIndex 0
    47 sensor *tmp13 .TARGET_MEMORY @type
    48 jump *label18 notEqual *tmp13 @memory-cell
-    * label *label19
    49 set *tmp12 64
    50 jump *label17 always
    51 label *label18
    52 jump *label20 notEqual *tmp13 @memory-bank
-    * label *label21
    53 set *tmp12 512
    54 jump *label17 always
    55 label *label20
 
    60 op idiv :startIndex *tmp12 2
    61 op sub :memSize *tmp12 1
    62 label *label22
-    * label *label23
    63 set :prevTick @tick
    64 read :prev .SOURCE_MEMORY 0
    65 set :currTick :prevTick
 
    67 read *tmp24 .TARGET_MEMORY :startIndex
    68 op max :index :startIndex *tmp24
    69 set :nextTick :prevTick
-    * label *label24
    70 sensor *tmp25 switch1 @enabled
    71 jump *label26 notEqual *tmp25 0
    72 label *label43
 
    77 op add :nextTick :prevTick TICKS
    78 set :currTick :prevTick
    79 label *label27
-    * label *label28
-    * label *label29
    80 jump *label31 greaterThanEq @tick :nextTick
    81 label *label42
    82 jump *label32 greaterThanEq @tick :prevTick
    83 end
-    * jump *label33 always
    84 label *label32
    85 read :value .SOURCE_MEMORY 0
    86 jump *label34 equal :value :curr
    87 set :currTick @tick
    88 set :curr :value
    89 label *label34
-    * label *label35
    90 label *label33
-    * label *label30
    91 jump *label42 lessThan @tick :nextTick
    92 label *label31
    93 op sub :amount :curr :prev
    94 op sub :time :currTick :prevTick
    95 set :rate 0
    96 jump *label37 equal :amount 0
-    * label *label36
    97 op div *tmp45 :amount :time
    98 op max :rate *tmp45 0
    99 label *label37
 
   101 jump *label38 lessThan :index :memSize
   102 op add :index :startIndex 1
   103 label *label38
-    * label *label39
   104 write :index .TARGET_MEMORY :startIndex
   105 write :rate .TARGET_MEMORY :index
   106 print "Item Rate Meter"
 
   134 printflush message1
   135 set :prevTick :currTick
   136 set :prev :curr
-    * label *label25
   137 sensor *tmp25 switch1 @enabled
   138 jump *label43 equal *tmp25 0
   139 label *label26

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   137 jump *label43 equal *tmp25 0
   138 label *label26
   139 control enabled switch1 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-23 instructions):
 
    29 label *label6
    30 jump *label41 greaterThan :n 0
    31 label *label5
-    * print "\nMessage: "
-    * print .MESSAGE
-    * print "\nSwitch: "
-    * print .SWITCH
-    * print "\nSource memory: "
-    * print .SOURCE_MEMORY
-    * print "\nTarget memory: "
+   32 print "\nMessage: {0}\nSwitch: {0}\nSource memory: {0}\nTarget memory: "
+   33 format .MESSAGE
+   34 format .SWITCH
+   35 format .SOURCE_MEMORY
    36 print .TARGET_MEMORY
    37 jump *label13 notEqual .SOURCE_MEMORY null
    38 print "\nNo memory."
 
    99 label *label38
   100 write :index .TARGET_MEMORY :startIndex
   101 write :rate .TARGET_MEMORY :index
-    * print "Item Rate Meter"
-    * print "\n"
-    * print "Total items: [gold]"
-    * print :curr
-    * print "["
-    * print "]"
-    * print "\n"
+  102 print "Item Rate Meter\nTotal items: [gold]{0}[]\nCurrent rate [green]{0}[]/min\n  memory start: [gold]{0}[]\n  memory index: [gold]{0}[]\n[lightgray]Loop time: {0} ms"
+  103 format :curr
   104 op idiv *tmp55 :rate 0.0002777777777777778
-    * print "Current rate [green]"
-    * print *tmp55
-    * print "["
-    * print "]/min"
-    * print "\n"
-    * print "  memory start: [gold]"
-    * print :startIndex
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "  memory index: [gold]"
-    * print :index
-    * print "["
-    * print "]"
-    * print "\n"
+  105 format *tmp55
+  106 format :startIndex
+  107 format :index
   108 op floor *tmp56 :time
-    * print "[lightgray]Loop time: "
-    * print *tmp56
-    * print " "
-    * print "ms"
+  109 format *tmp56
   110 printflush message1
   111 set :prevTick :currTick
   112 set :prev :curr

Final code before resolving virtual instructions:

set TICKS 60
set .SOURCE_MEMORY null
set .TARGET_MEMORY null
set .SWITCH null
set .MESSAGE null
label *label40
print "Item Rate Meter"
set :n @links
jump *label5 lessThanEq :n 0
label *label41
op sub :n :n 1
getlink :block :n
print "\nFound: "
print :block
sensor *tmp6 :block @type
sensor *tmp59 *tmp6 @id
multijump *tmp59 0 0
multilabel *label50
multilabel *label46
jump *label6 always
multilabel *label47
set .MESSAGE :block                     # Origin: 14, keys: 137
jump *label6 always
multilabel *label48
set .SWITCH :block                      # Origin: 14, keys: 138
jump *label6 always
multilabel *label49
set .TARGET_MEMORY .SOURCE_MEMORY       # Origin: 14, keys: 142, 143
set .SOURCE_MEMORY :block
label *label6
jump *label41 greaterThan :n 0
label *label5
print "\nMessage: {0}\nSwitch: {0}\nSource memory: {0}\nTarget memory: "
format .MESSAGE
format .SWITCH
format .SOURCE_MEMORY
print .TARGET_MEMORY
jump *label13 notEqual .SOURCE_MEMORY null
print "\nNo memory."
label *label13
printflush .MESSAGE
jump *label40 equal .SOURCE_MEMORY null
select .TARGET_MEMORY equal .TARGET_MEMORY null .SOURCE_MEMORY .TARGET_MEMORY
set :startIndex 0
sensor *tmp13 .TARGET_MEMORY @type
jump *label18 notEqual *tmp13 @memory-cell
set *tmp12 64
jump *label17 always
label *label18
jump *label20 notEqual *tmp13 @memory-bank
set *tmp12 512
jump *label17 always
label *label20
set *tmp12 0
label *label17
set :memSize *tmp12
jump *label22 notEqual .SOURCE_MEMORY .TARGET_MEMORY
op idiv :startIndex *tmp12 2
op sub :memSize *tmp12 1
label *label22
set :prevTick @tick
read :prev .SOURCE_MEMORY 0
set :currTick :prevTick
set :curr :prev
read *tmp24 .TARGET_MEMORY :startIndex
op max :index :startIndex *tmp24
set :nextTick :prevTick
sensor *tmp25 switch1 @enabled
jump *label26 notEqual *tmp25 0
label *label43
op add :nextTick :nextTick TICKS
op add *tmp28 :nextTick TICKS
jump *label27 lessThanEq @tick *tmp28
set :prevTick @tick
op add :nextTick :prevTick TICKS
set :currTick :prevTick
label *label27
jump *label31 greaterThanEq @tick :nextTick
label *label42
jump *label32 greaterThanEq @tick :prevTick
end
label *label32
read :value .SOURCE_MEMORY 0
jump *label34 equal :value :curr
set :currTick @tick
set :curr :value
label *label34
jump *label42 lessThan @tick :nextTick
label *label31
op sub :amount :curr :prev
op sub :time :currTick :prevTick
set :rate 0
jump *label37 equal :amount 0
op div *tmp45 :amount :time
op max :rate *tmp45 0
label *label37
op add :index :index 1
jump *label38 lessThan :index :memSize
op add :index :startIndex 1
label *label38
write :index .TARGET_MEMORY :startIndex
write :rate .TARGET_MEMORY :index
print "Item Rate Meter\nTotal items: [gold]{0}[]\nCurrent rate [green]{0}[]/min\n  memory start: [gold]{0}[]\n  memory index: [gold]{0}[]\n[lightgray]Loop time: {0} ms"
format :curr
op idiv *tmp55 :rate 0.0002777777777777778
format *tmp55
format :startIndex
format :index
op floor *tmp56 :time
format *tmp56
printflush message1
set :prevTick :currTick
set :prev :curr
sensor *tmp25 switch1 @enabled
jump *label43 equal *tmp25 0
label *label26
control enabled switch1 0
