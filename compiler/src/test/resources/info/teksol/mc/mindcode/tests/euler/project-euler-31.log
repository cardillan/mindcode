    96 instructions before optimizations.
     5 instructions eliminated by Temp Variables Elimination.
     4 instructions eliminated by Dead Code Elimination (4 iterations).
     2 instructions eliminated by Jump Optimization (4 iterations).
     2 instructions eliminated by Single Step Elimination (5 iterations).
    18 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
     1 instructions modified by Loop Optimization (2 iterations).
     1 loops improved by Loop Optimization.
     2 instructions eliminated by Loop Unrolling (4 iterations).
     1 loops unrolled by Loop Unrolling.
     2 instructions added by Return Optimization (4 iterations).
     1 return statements optimized by Return Optimization.
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
     4 instructions eliminated by Stack Optimization.
    60 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 918):
  * Unroll iteration loop at line 4:1                            cost     0, benefit       31.0, efficiency   Infinity (-19 instructions)
    Optimize return at line 14:9                                 cost     2, benefit       13.0, efficiency        6.5

Pass 1: speed optimization selection (cost limit 937):
  * Optimize return at line 14:9                                 cost     2, benefit       13.0, efficiency        6.5 (+2 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-4 instructions):
 
    52 jump *label15 equal *tmp4 false
    53 set :ways.0*retval 1
    54 jump *label14 always
-    * set *tmp5 null
    55 jump *label16 always
    56 label *label15
-    * set *tmp5 null
    57 label *label16
    58 set :ways.0:result 0
    59 set :ways.0:i :ways.0:index
 
    83 pop bank1 :ways.0:amount
    84 set *tmp11 :ways.0*retval
    85 op add :ways.0:result :ways.0:result *tmp11
-    * set *tmp9 :ways.0:result
    86 jump *label21 always
    87 label *label20
-    * set *tmp9 null
    88 label *label21
    89 label *label18
    90 op add :ways.0:i :ways.0:i 1

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-5 instructions):
 
    32 set :value 1
    33 setaddr *tmp0 *label12
    34 label *label2
-    * set *tmp1 :index
-    * write :value bank1 *tmp1
+   35 write :value bank1 :index
    36 op add :index :index 1
    37 label *label3
    38 multijump *tmp0 0 0 (m:marker0)
 
    42 set :ways.0:index 1
    43 callrec bank1 *label0 *label13 :ways.0*retval
    44 label *label13
-    * set *tmp3 :ways.0*retval
-    * assertequals 41 *tmp3 "Project Euler 31"
+   45 assertequals 41 :ways.0*retval "Project Euler 31"
    46 stop
    47 end
    48 label *label0
 
    57 set :ways.0:i :ways.0:index
    58 label *label17
    59 jump *label19 greaterThanEq :ways.0:i 8
-    * set *tmp6 :ways.0:i
-    * read *tmp7 bank1 *tmp6
-    * set :ways.0:p *tmp7
+   60 read :ways.0:p bank1 :ways.0:i
    61 op lessThanEq *tmp8 :ways.0:p :ways.0:amount
    62 jump *label20 equal *tmp8 false
    63 op sub *tmp10 :ways.0:amount :ways.0:p
 
    77 pop bank1 :ways.0:result
    78 pop bank1 :ways.0:index
    79 pop bank1 :ways.0:amount
-    * set *tmp11 :ways.0*retval
-    * op add :ways.0:result :ways.0:result *tmp11
+   80 op add :ways.0:result :ways.0:result :ways.0*retval
    81 jump *label21 always
    82 label *label20
    83 label *label21

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-2 instructions):
 
    46 stop
    47 end
    48 label *label0
-    * op equal *tmp4 :ways.0:amount 0
-    * jump *label15 equal *tmp4 false
+   49 jump *label15 notEqual :ways.0:amount 0
    50 set :ways.0*retval 1
    51 jump *label14 always
    52 jump *label16 always
 
    57 label *label17
    58 jump *label19 greaterThanEq :ways.0:i 8
    59 read :ways.0:p bank1 :ways.0:i
-    * op lessThanEq *tmp8 :ways.0:p :ways.0:amount
-    * jump *label20 equal *tmp8 false
+   60 jump *label20 greaterThan :ways.0:p :ways.0:amount
    61 op sub *tmp10 :ways.0:amount :ways.0:p
    62 push bank1 :ways.0:amount
    63 push bank1 :ways.0:index

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    49 jump *label15 notEqual :ways.0:amount 0
    50 set :ways.0*retval 1
    51 jump *label14 always
-    * jump *label16 always
    52 label *label15
    53 label *label16
    54 set :ways.0:result 0
 
    75 pop bank1 :ways.0:index
    76 pop bank1 :ways.0:amount
    77 op add :ways.0:result :ways.0:result :ways.0*retval
-    * jump *label21 always
    78 label *label20
    79 label *label21
    80 label *label18

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    64 push bank1 :ways.0:i
    65 push bank1 :ways.0:p
    66 push bank1 *tmp5
-    * set :ways.0:amount *tmp10
+   67 op sub :ways.0:amount :ways.0:amount :ways.0:p
    68 set :ways.0:index :ways.0:i
    69 callrec bank1 *label0 *label22 :ways.0*retval
    70 label *label22

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    57 jump *label19 greaterThanEq :ways.0:i 8
    58 read :ways.0:p bank1 :ways.0:i
    59 jump *label20 greaterThan :ways.0:p :ways.0:amount
-    * op sub *tmp10 :ways.0:amount :ways.0:p
    60 push bank1 :ways.0:amount
    61 push bank1 :ways.0:index
    62 push bank1 :ways.0:result

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    55 set :ways.0:i :ways.0:index
    56 label *label17
    57 jump *label19 greaterThanEq :ways.0:i 8
+   58 label *label23
    59 read :ways.0:p bank1 :ways.0:i
    60 jump *label20 greaterThan :ways.0:p :ways.0:amount
    61 push bank1 :ways.0:amount
 
    79 label *label21
    80 label *label18
    81 op add :ways.0:i :ways.0:i 1
-    * jump *label17 always
+   82 jump *label23 lessThan :ways.0:i 8
    83 label *label19
    84 set :ways.0*retval :ways.0:result
    85 label *label14

Modifications by Unroll iteration loop at line 4:1 (-2 instructions):
 
     1 jump *label1 equal bank1 null
     2 set *sp 16
     3 set :index 0
-    * set :value 200
-    * setaddr *tmp0 *label5
-    * jump *label2 always
-    * multilabel *label5 (m:marker0)
-    * set :value 100
-    * setaddr *tmp0 *label6
-    * jump *label2 always
-    * multilabel *label6 (m:marker0)
-    * set :value 50
-    * setaddr *tmp0 *label7
-    * jump *label2 always
-    * multilabel *label7 (m:marker0)
-    * set :value 20
-    * setaddr *tmp0 *label8
-    * jump *label2 always
-    * multilabel *label8 (m:marker0)
-    * set :value 10
-    * setaddr *tmp0 *label9
-    * jump *label2 always
-    * multilabel *label9 (m:marker0)
-    * set :value 5
-    * setaddr *tmp0 *label10
-    * jump *label2 always
-    * multilabel *label10 (m:marker0)
-    * set :value 2
-    * setaddr *tmp0 *label11
-    * jump *label2 always
-    * multilabel *label11 (m:marker0)
-    * set :value 1
-    * setaddr *tmp0 *label12
-    * label *label2
-    * write :value bank1 :index
-    * op add :index :index 1
-    * label *label3
-    * multijump *tmp0 0 0 (m:marker0)
-    * multilabel *label12 (m:marker0)
-    * label *label4
+    4 set :value 200
+    5 label *label24
+    6 write :value bank1 :index
+    7 op add :index :index 1
+    8 label *label25
+    9 set :value 100
+   10 label *label28
+   11 write :value bank1 :index
+   12 op add :index :index 1
+   13 label *label29
+   14 set :value 50
+   15 label *label32
+   16 write :value bank1 :index
+   17 op add :index :index 1
+   18 label *label33
+   19 set :value 20
+   20 label *label36
+   21 write :value bank1 :index
+   22 op add :index :index 1
+   23 label *label37
+   24 set :value 10
+   25 label *label40
+   26 write :value bank1 :index
+   27 op add :index :index 1
+   28 label *label41
+   29 set :value 5
+   30 label *label44
+   31 write :value bank1 :index
+   32 op add :index :index 1
+   33 label *label45
+   34 set :value 2
+   35 label *label48
+   36 write :value bank1 :index
+   37 op add :index :index 1
+   38 label *label49
+   39 set :value 1
+   40 label *label52
+   41 write :value bank1 :index
+   42 op add :index :index 1
+   43 label *label53
+   44 label *label4
    45 set :ways.0:amount 20
    46 set :ways.0:index 1
    47 callrec bank1 *label0 *label13 :ways.0*retval

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 set :index 0
     4 set :value 200
     5 label *label24
-    * write :value bank1 :index
-    * op add :index :index 1
+    6 write 200 bank1 0
+    7 op add :index 0 1
     8 label *label25
     9 set :value 100
    10 label *label28
-    * write :value bank1 :index
-    * op add :index :index 1
+   11 write 100 bank1 1
+   12 op add :index 1 1
    13 label *label29
    14 set :value 50
    15 label *label32
-    * write :value bank1 :index
-    * op add :index :index 1
+   16 write 50 bank1 2
+   17 op add :index 2 1
    18 label *label33
    19 set :value 20
    20 label *label36
-    * write :value bank1 :index
-    * op add :index :index 1
+   21 write 20 bank1 3
+   22 op add :index 3 1
    23 label *label37
    24 set :value 10
    25 label *label40
-    * write :value bank1 :index
-    * op add :index :index 1
+   26 write 10 bank1 4
+   27 op add :index 4 1
    28 label *label41
    29 set :value 5
    30 label *label44
-    * write :value bank1 :index
-    * op add :index :index 1
+   31 write 5 bank1 5
+   32 op add :index 5 1
    33 label *label45
    34 set :value 2
    35 label *label48
-    * write :value bank1 :index
-    * op add :index :index 1
+   36 write 2 bank1 6
+   37 op add :index 6 1
    38 label *label49
    39 set :value 1
    40 label *label52
-    * write :value bank1 :index
-    * op add :index :index 1
+   41 write 1 bank1 7
+   42 op add :index 7 1
    43 label *label53
    44 label *label4
    45 set :ways.0:amount 20
 
    58 set :ways.0:result 0
    59 set :ways.0:i :ways.0:index
    60 label *label17
-    * jump *label19 greaterThanEq :ways.0:i 8
+   61 jump *label19 greaterThanEq :ways.0:index 8
    62 label *label23
    63 read :ways.0:p bank1 :ways.0:i
    64 jump *label20 greaterThan :ways.0:p :ways.0:amount

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-17 instructions):
     0 label *label1
     1 jump *label1 equal bank1 null
     2 set *sp 16
-    * set :index 0
-    * set :value 200
     3 label *label24
     4 write 200 bank1 0
-    * op add :index 0 1
     5 label *label25
-    * set :value 100
     6 label *label28
     7 write 100 bank1 1
-    * op add :index 1 1
     8 label *label29
-    * set :value 50
     9 label *label32
    10 write 50 bank1 2
-    * op add :index 2 1
    11 label *label33
-    * set :value 20
    12 label *label36
    13 write 20 bank1 3
-    * op add :index 3 1
    14 label *label37
-    * set :value 10
    15 label *label40
    16 write 10 bank1 4
-    * op add :index 4 1
    17 label *label41
-    * set :value 5
    18 label *label44
    19 write 5 bank1 5
-    * op add :index 5 1
    20 label *label45
-    * set :value 2
    21 label *label48
    22 write 2 bank1 6
-    * op add :index 6 1
    23 label *label49
-    * set :value 1
    24 label *label52
    25 write 1 bank1 7
-    * op add :index 7 1
    26 label *label53
    27 label *label4
    28 set :ways.0:amount 20

Modifications by Optimize return at line 14:9 (+2 instructions):
 
    35 label *label0
    36 jump *label15 notEqual :ways.0:amount 0
    37 set :ways.0*retval 1
-    * jump *label14 always
+   38 returnrec bank1
    39 label *label15
    40 label *label16
    41 set :ways.0:result 0

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
     0 label *label1
     1 jump *label1 equal bank1 null
     2 set *sp 16
-    * label *label24
     3 write 200 bank1 0
-    * label *label25
-    * label *label28
     4 write 100 bank1 1
-    * label *label29
-    * label *label32
     5 write 50 bank1 2
-    * label *label33
-    * label *label36
     6 write 20 bank1 3
-    * label *label37
-    * label *label40
     7 write 10 bank1 4
-    * label *label41
-    * label *label44
     8 write 5 bank1 5
-    * label *label45
-    * label *label48
     9 write 2 bank1 6
-    * label *label49
-    * label *label52
    10 write 1 bank1 7
-    * label *label53
-    * label *label4
    11 set :ways.0:amount 20
    12 set :ways.0:index 1
    13 callrec bank1 *label0 *label13 :ways.0*retval
 
    20 set :ways.0*retval 1
    21 returnrec bank1
    22 label *label15
-    * label *label16
    23 set :ways.0:result 0
    24 set :ways.0:i :ways.0:index
-    * label *label17
    25 jump *label19 greaterThanEq :ways.0:index 8
    26 label *label23
    27 read :ways.0:p bank1 :ways.0:i
 
    44 pop bank1 :ways.0:amount
    45 op add :ways.0:result :ways.0:result :ways.0*retval
    46 label *label20
-    * label *label21
-    * label *label18
    47 op add :ways.0:i :ways.0:i 1
    48 jump *label23 lessThan :ways.0:i 8
    49 label *label19
    50 set :ways.0*retval :ways.0:result
-    * label *label14
    51 returnrec bank1
    52 end

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-1 instructions):
 
    49 label *label19
    50 set :ways.0*retval :ways.0:result
    51 returnrec bank1
-    * end

Modifications by Final phase, Stack Optimization, iteration 1 (-4 instructions):
 
    31 push bank1 :ways.0:result
    32 push bank1 :ways.0:i
    33 push bank1 :ways.0:p
-    * push bank1 *tmp5
    34 op sub :ways.0:amount :ways.0:amount :ways.0:p
    35 set :ways.0:index :ways.0:i
    36 callrec bank1 *label0 *label22 :ways.0*retval
    37 label *label22
-    * pop bank1 *tmp5
    38 pop bank1 :ways.0:p
    39 pop bank1 :ways.0:i
    40 pop bank1 :ways.0:result

Final code before resolving virtual instructions:

label *label1
jump *label1 equal bank1 null
set *sp 16
write 200 bank1 0
write 100 bank1 1
write 50 bank1 2
write 20 bank1 3
write 10 bank1 4
write 5 bank1 5
write 2 bank1 6
write 1 bank1 7
set :ways.0:amount 20
set :ways.0:index 1
callrec bank1 *label0 *label13 :ways.0*retval
label *label13
assertequals 41 :ways.0*retval "Project Euler 31"
stop
end
label *label0
jump *label15 notEqual :ways.0:amount 0
set :ways.0*retval 1
returnrec bank1
label *label15
set :ways.0:result 0
set :ways.0:i :ways.0:index
jump *label19 greaterThanEq :ways.0:index 8
label *label23
read :ways.0:p bank1 :ways.0:i
jump *label20 greaterThan :ways.0:p :ways.0:amount
push bank1 :ways.0:amount
push bank1 :ways.0:index
push bank1 :ways.0:result
push bank1 :ways.0:i
push bank1 :ways.0:p
op sub :ways.0:amount :ways.0:amount :ways.0:p
set :ways.0:index :ways.0:i
callrec bank1 *label0 *label22 :ways.0*retval
label *label22
pop bank1 :ways.0:p
pop bank1 :ways.0:i
pop bank1 :ways.0:result
pop bank1 :ways.0:index
pop bank1 :ways.0:amount
op add :ways.0:result :ways.0:result :ways.0*retval
label *label20
op add :ways.0:i :ways.0:i 1
jump *label23 lessThan :ways.0:i 8
label *label19
set :ways.0*retval :ways.0:result
returnrec bank1
