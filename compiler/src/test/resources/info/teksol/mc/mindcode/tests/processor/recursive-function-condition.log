    30 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Jump Optimization (4 iterations).
     1 instructions eliminated by Single Step Elimination (5 iterations).
     1 instructions eliminated by Expression Optimization (3 iterations).
     1 instructions eliminated by If Expression Optimization (3 iterations).
     1 instructions eliminated by Data Flow Optimization (5 iterations).
     1 instructions eliminated by Unreachable Code Elimination.
     4 instructions eliminated by Stack Optimization.
    18 instructions after optimizations.

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
     3 set :foo.0:n 1
     4 callrec bank1 *label0 *label2 :foo.0*retval
     5 label *label2
-    * set *tmp0 :foo.0*retval
-    * assertequals null *tmp0 "recursive-function-condition"
+    6 assertequals null :foo.0*retval "recursive-function-condition"
     7 stop
     8 end
     9 label *label0
 
    15 callrec bank1 *label0 *label6 :foo.0*retval
    16 label *label6
    17 pop bank1 :foo.0:n
-    * set *tmp4 :foo.0*retval
-    * set *tmp2 *tmp4
+   18 set *tmp2 :foo.0*retval
    19 jump *label5 always
    20 label *label4
    21 set *tmp2 null

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-1 instructions):
 
     7 stop
     8 end
     9 label *label0
-    * op greaterThan *tmp1 :foo.0:n 0
-    * jump *label4 equal *tmp1 false
+   10 jump *label4 lessThanEq :foo.0:n 0
    11 op sub *tmp3 :foo.0:n 1
    12 push bank1 :foo.0:n
    13 set :foo.0:n *tmp3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    10 jump *label4 lessThanEq :foo.0:n 0
    11 op sub *tmp3 :foo.0:n 1
    12 push bank1 :foo.0:n
-    * set :foo.0:n *tmp3
+   13 op sub :foo.0:n :foo.0:n 1
    14 callrec bank1 *label0 *label6 :foo.0*retval
    15 label *label6
    16 pop bank1 :foo.0:n

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
     8 end
     9 label *label0
    10 jump *label4 lessThanEq :foo.0:n 0
-    * op sub *tmp3 :foo.0:n 1
    11 push bank1 :foo.0:n
    12 op sub :foo.0:n :foo.0:n 1
    13 callrec bank1 *label0 *label6 :foo.0*retval

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
     7 stop
     8 end
     9 label *label0
-    * jump *label4 lessThanEq :foo.0:n 0
+   10 set :foo.0*retval null
+   11 jump *label5 lessThanEq :foo.0:n 0
    12 push bank1 :foo.0:n
    13 op sub :foo.0:n :foo.0:n 1
    14 callrec bank1 *label0 *label6 :foo.0*retval
    15 label *label6
    16 pop bank1 :foo.0:n
-    * set *tmp2 :foo.0*retval
+   17 set :foo.0*retval :foo.0*retval
    18 jump *label5 always
-    * label *label4
-    * set *tmp2 null
    19 label *label5
-    * set :foo.0*retval *tmp2
    20 label *label3
    21 returnrec bank1
    22 end

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    15 label *label6
    16 pop bank1 :foo.0:n
    17 set :foo.0*retval :foo.0*retval
-    * jump *label5 always
    18 label *label5
    19 label *label3
    20 returnrec bank1

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-1 instructions):
 
    14 callrec bank1 *label0 *label6 :foo.0*retval
    15 label *label6
    16 pop bank1 :foo.0:n
-    * set :foo.0*retval :foo.0*retval
    17 label *label5
    18 label *label3
    19 returnrec bank1

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
    17 label *label5
    18 label *label3
    19 returnrec bank1
-    * end

Modifications by Final phase, Stack Optimization, iteration 1 (-4 instructions):
 
     9 label *label0
    10 set :foo.0*retval null
    11 jump *label5 lessThanEq :foo.0:n 0
-    * push bank1 :foo.0:n
    12 op sub :foo.0:n :foo.0:n 1
    13 callrec bank1 *label0 *label6 :foo.0*retval
    14 label *label6
-    * pop bank1 :foo.0:n
    15 label *label5
    16 label *label3
    17 returnrec bank1

Final code before resolving virtual instructions:

label *label1
jump *label1 equal bank1 null
set *sp 0
set :foo.0:n 1
callrec bank1 *label0 *label2 :foo.0*retval
label *label2
assertequals null :foo.0*retval "recursive-function-condition"
stop
end
label *label0
set :foo.0*retval null
jump *label5 lessThanEq :foo.0:n 0
op sub :foo.0:n :foo.0:n 1
callrec bank1 *label0 *label6 :foo.0*retval
label *label6
label *label5
returnrec bank1
