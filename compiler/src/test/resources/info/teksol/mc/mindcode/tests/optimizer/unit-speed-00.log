    98 instructions before optimizations.
     7 instructions eliminated by Temp Variables Elimination (5 iterations).
     6 instructions eliminated by Condition Optimization (5 iterations).
     1 instructions eliminated by Single Step Elimination (5 iterations).
     1 instructions eliminated by Expression Optimization (2 iterations).
     7 instructions eliminated by Data Flow Optimization (9 iterations).
     5 instructions added by Loop Rotation (2 iterations).
       6 loop conditions were partially rotated.
     1 instructions updated by Jump Threading.
    10 instructions eliminated by Print Merging.
    71 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 923):
  * Full loop rotation at line 17:1                              size    +1, benefit       26.0, efficiency     26.000 (+1 instructions)
    Full loop rotation at line 24:1                              size    +1, benefit       26.0, efficiency     26.000
    Full loop rotation at line 32:1                              size    +1, benefit       26.0, efficiency     26.000
    Full loop rotation at line 45:1                              size    +1, benefit       26.0, efficiency     26.000
    Full loop rotation at line 58:1                              size    +1, benefit       26.0, efficiency     26.000

Pass 1: speed optimization selection (cost limit 922):
  * Full loop rotation at line 24:1                              size    +1, benefit       26.0, efficiency     26.000 (+1 instructions)
    Full loop rotation at line 32:1                              size    +1, benefit       26.0, efficiency     26.000
    Full loop rotation at line 45:1                              size    +1, benefit       26.0, efficiency     26.000
    Full loop rotation at line 58:1                              size    +1, benefit       26.0, efficiency     26.000

Pass 1: speed optimization selection (cost limit 921):
  * Full loop rotation at line 32:1                              size    +1, benefit       26.0, efficiency     26.000 (+1 instructions)
    Full loop rotation at line 45:1                              size    +1, benefit       26.0, efficiency     26.000
    Full loop rotation at line 58:1                              size    +1, benefit       26.0, efficiency     26.000

Pass 1: speed optimization selection (cost limit 920):
  * Full loop rotation at line 45:1                              size    +1, benefit       26.0, efficiency     26.000 (+1 instructions)
    Full loop rotation at line 58:1                              size    +1, benefit       26.0, efficiency     26.000

Pass 1: speed optimization selection (cost limit 919):
  * Full loop rotation at line 58:1                              size    +1, benefit       26.0, efficiency     26.000 (+1 instructions)

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-7 instructions):
 
     1 set .SX 10
     2 set .SY 10
     3 set .DX 10
-    * op sub *tmp0 @maph 10
-    * set .DY *tmp0
+    4 op sub .DY @maph 10
     5 op sub *tmp1 .DX .SX
     6 op sub *tmp2 .DY .SY
     7 op len *tmp3 *tmp1 *tmp2
 
     9 op add *tmp5 *tmp4 0.5
    10 op floor *tmp6 *tmp5
    11 op div *tmp7 *tmp6 100
-    * op sub *tmp8 *tmp7 2
-    * set :distance *tmp8
+   12 op sub :distance *tmp7 2
    13 ubind UNIT
    14 label *label0
    15 op equal *tmp9 @unit null
 
    32 label *label4
    33 jump *label3 always
    34 label *label5
-    * set *tmp12 switch1
-    * control enabled *tmp12 false
+   35 control enabled switch1 false
    36 label *label6
    37 sensor *tmp14 @unit @controlled
    38 op notEqual *tmp15 *tmp14 0
 
    57 label *label11
    58 print "Moving to destination"
    59 printflush message1
-    * set *tmp18 @time
-    * set :start *tmp18
+   60 set :start @time
    61 ucontrol move .DX .DY
    62 label *label12
    63 ucontrol within .DX .DY 1 *tmp19
 
    67 label *label13
    68 jump *label12 always
    69 label *label14
-    * set *tmp21 @time
-    * set :finish *tmp21
+   70 set :finish @time
    71 op sub *tmp22 .SX .DX
    72 op abs *tmp23 *tmp22
    73 op div *tmp24 *tmp23 2
 
    76 op div *tmp27 *tmp26 2
    77 ucontrol move *tmp24 *tmp27
    78 ucontrol flag 0
-    * op sub *tmp28 :finish :start
-    * set :elapsed *tmp28
+   79 op sub :elapsed :finish :start
    80 op div *tmp29 :distance :elapsed
    81 op mul *tmp30 *tmp29 100000
    82 op floor *tmp31 *tmp30
-    * op div *tmp32 *tmp31 100
-    * set :speed *tmp32
+   83 op div :speed *tmp31 100
    84 label *label15
    85 sensor *tmp33 switch1 @enabled
    86 op equal *tmp34 *tmp33 false

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-6 instructions):
 
    12 op sub :distance *tmp7 2
    13 ubind UNIT
    14 label *label0
-    * op equal *tmp9 @unit null
-    * jump *label2 equal *tmp9 false
+   15 jump *label2 notEqual @unit null
    16 print UNIT
    17 print ": no active unit found."
    18 printflush message1
 
    22 label *label2
    23 label *label3
    24 sensor *tmp10 switch1 @enabled
-    * op equal *tmp11 *tmp10 false
-    * jump *label5 equal *tmp11 false
+   25 jump *label5 notEqual *tmp10 false
    26 print "Press button to start measuring "
    27 print UNIT
    28 print " speed."
 
    33 control enabled switch1 false
    34 label *label6
    35 sensor *tmp14 @unit @controlled
-    * op notEqual *tmp15 *tmp14 0
-    * jump *label8 equal *tmp15 false
+   36 jump *label8 equal *tmp14 0
    37 print "Searching free "
    38 print UNIT
    39 printflush message1
 
    44 ucontrol flag 1
    45 label *label9
    46 ucontrol within .SX .SY 1 *tmp16
-    * op equal *tmp17 *tmp16 false
-    * jump *label11 equal *tmp17 false
+   47 jump *label11 notEqual *tmp16 false
    48 print "Moving to start"
    49 printflush message1
    50 ucontrol move .SX .SY
 
    57 ucontrol move .DX .DY
    58 label *label12
    59 ucontrol within .DX .DY 1 *tmp19
-    * op equal *tmp20 *tmp19 false
-    * jump *label14 equal *tmp20 false
+   60 jump *label14 notEqual *tmp19 false
    61 ucontrol move .DX .DY
    62 label *label13
    63 jump *label12 always
 
    78 op div :speed *tmp31 100
    79 label *label15
    80 sensor *tmp33 switch1 @enabled
-    * op equal *tmp34 *tmp33 false
-    * jump *label17 equal *tmp34 false
+   81 jump *label17 notEqual *tmp33 false
    82 print "Measurement results ("
    83 print UNIT
    84 print "):"

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    73 ucontrol flag 0
    74 op sub :elapsed :finish :start
    75 op div *tmp29 :distance :elapsed
-    * op mul *tmp30 *tmp29 100000
-    * op floor *tmp31 *tmp30
+   76 op idiv *tmp31 *tmp29 0.00001
    77 op div :speed *tmp31 100
    78 label *label15
    79 sensor *tmp33 switch1 @enabled

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set .SY 10
     3 set .DX 10
     4 op sub .DY @maph 10
-    * op sub *tmp1 .DX .SX
-    * op sub *tmp2 .DY .SY
-    * op len *tmp3 *tmp1 *tmp2
+    5 op sub *tmp1 10 10
+    6 op sub *tmp2 .DY 10
+    7 op len *tmp3 0 *tmp2
     8 op mul *tmp4 100 *tmp3
     9 op add *tmp5 *tmp4 0.5
    10 op floor *tmp6 *tmp5
 
    43 label *label8
    44 ucontrol flag 1
    45 label *label9
-    * ucontrol within .SX .SY 1 *tmp16
+   46 ucontrol within 10 10 1 *tmp16
    47 jump *label11 notEqual *tmp16 false
    48 print "Moving to start"
    49 printflush message1
-    * ucontrol move .SX .SY
+   50 ucontrol move 10 10
    51 label *label10
    52 jump *label9 always
    53 label *label11
    54 print "Moving to destination"
    55 printflush message1
    56 set :start @time
-    * ucontrol move .DX .DY
+   57 ucontrol move 10 .DY
    58 label *label12
-    * ucontrol within .DX .DY 1 *tmp19
+   59 ucontrol within 10 .DY 1 *tmp19
    60 jump *label14 notEqual *tmp19 false
-    * ucontrol move .DX .DY
+   61 ucontrol move 10 .DY
    62 label *label13
    63 jump *label12 always
    64 label *label14
    65 set :finish @time
-    * op sub *tmp22 .SX .DX
-    * op abs *tmp23 *tmp22
-    * op div *tmp24 *tmp23 2
-    * op sub *tmp25 .SY .DY
+   66 op sub *tmp22 10 10
+   67 op abs *tmp23 0
+   68 op div *tmp24 0 2
+   69 op sub *tmp25 10 .DY
    70 op abs *tmp26 *tmp25
    71 op div *tmp27 *tmp26 2
-    * ucontrol move *tmp24 *tmp27
+   72 ucontrol move 0 *tmp27
    73 ucontrol flag 0
    74 op sub :elapsed :finish :start
    75 op div *tmp29 :distance :elapsed

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
     0 set UNIT @flare
-    * set .SX 10
-    * set .SY 10
-    * set .DX 10
     1 op sub .DY @maph 10
-    * op sub *tmp1 10 10
     2 op sub *tmp2 .DY 10
     3 op len *tmp3 0 *tmp2
     4 op mul *tmp4 100 *tmp3
 
    59 jump *label12 always
    60 label *label14
    61 set :finish @time
-    * op sub *tmp22 10 10
-    * op abs *tmp23 0
-    * op div *tmp24 0 2
    62 op sub *tmp25 10 .DY
    63 op abs *tmp26 *tmp25
    64 op div *tmp27 *tmp26 2

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     9 ubind UNIT
    10 label *label0
    11 jump *label2 notEqual @unit null
+   12 label *label18
    13 print UNIT
    14 print ": no active unit found."
    15 printflush message1
    16 ubind UNIT
    17 label *label1
-    * jump *label0 always
+   18 jump *label18 equal @unit null
    19 label *label2
    20 label *label3
    21 sensor *tmp10 switch1 @enabled

Modifications by Full loop rotation at line 17:1 (+1 instructions):
 
    20 label *label3
    21 sensor *tmp10 switch1 @enabled
    22 jump *label5 notEqual *tmp10 false
+   23 label *label19
    24 print "Press button to start measuring "
    25 print UNIT
    26 print " speed."
    27 printflush message1
    28 label *label4
-    * jump *label3 always
+   29 sensor *tmp10 switch1 @enabled
+   30 jump *label19 equal *tmp10 false
    31 label *label5
    32 control enabled switch1 false
    33 label *label6

Modifications by Full loop rotation at line 24:1 (+1 instructions):
 
    33 label *label6
    34 sensor *tmp14 @unit @controlled
    35 jump *label8 equal *tmp14 0
+   36 label *label20
    37 print "Searching free "
    38 print UNIT
    39 printflush message1
    40 ubind UNIT
    41 label *label7
-    * jump *label6 always
+   42 sensor *tmp14 @unit @controlled
+   43 jump *label20 notEqual *tmp14 0
    44 label *label8
    45 ucontrol flag 1
    46 label *label9

Modifications by Full loop rotation at line 32:1 (+1 instructions):
 
    46 label *label9
    47 ucontrol within 10 10 1 *tmp16
    48 jump *label11 notEqual *tmp16 false
+   49 label *label21
    50 print "Moving to start"
    51 printflush message1
    52 ucontrol move 10 10
    53 label *label10
-    * jump *label9 always
+   54 ucontrol within 10 10 1 *tmp16
+   55 jump *label21 equal *tmp16 false
    56 label *label11
    57 print "Moving to destination"
    58 printflush message1

Modifications by Full loop rotation at line 45:1 (+1 instructions):
 
    61 label *label12
    62 ucontrol within 10 .DY 1 *tmp19
    63 jump *label14 notEqual *tmp19 false
+   64 label *label22
    65 ucontrol move 10 .DY
    66 label *label13
-    * jump *label12 always
+   67 ucontrol within 10 .DY 1 *tmp19
+   68 jump *label22 equal *tmp19 false
    69 label *label14
    70 set :finish @time
    71 op sub *tmp25 10 .DY

Modifications by Full loop rotation at line 58:1 (+1 instructions):
 
    80 label *label15
    81 sensor *tmp33 switch1 @enabled
    82 jump *label17 notEqual *tmp33 false
+   83 label *label23
    84 print "Measurement results ("
    85 print UNIT
    86 print "):"
 
    99 print "\nPress button to repeat"
   100 printflush message1
   101 label *label16
-    * jump *label15 always
+  102 sensor *tmp33 switch1 @enabled
+  103 jump *label23 equal *tmp33 false
   104 label *label17
   105 end

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
+    0 label __start__
     1 set UNIT @flare
     2 op sub .DY @maph 10
     3 op sub *tmp2 .DY 10
 
    69 op idiv *tmp31 *tmp29 0.00001
    70 op div :speed *tmp31 100
    71 sensor *tmp33 switch1 @enabled
-    * jump *label17 notEqual *tmp33 false
+   72 jump __start__ notEqual *tmp33 false
    73 label *label23
    74 print "Measurement results ("
    75 print UNIT

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
    90 printflush message1
    91 sensor *tmp33 switch1 @enabled
    92 jump *label23 equal *tmp33 false
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-10 instructions):
 
    19 sensor *tmp10 switch1 @enabled
    20 jump *label5 notEqual *tmp10 false
    21 label *label19
-    * print "Press button to start measuring "
-    * print UNIT
-    * print " speed."
+   22 print "Press button to start measuring {0} speed."
+   23 format UNIT
    24 printflush message1
    25 sensor *tmp10 switch1 @enabled
    26 jump *label19 equal *tmp10 false
 
    70 sensor *tmp33 switch1 @enabled
    71 jump __start__ notEqual *tmp33 false
    72 label *label23
-    * print "Measurement results ("
-    * print UNIT
-    * print "):"
-    * print "\nMap dimensions: "
-    * print @mapw
-    * print "x"
-    * print @maph
-    * print "\nElapsed time: "
-    * print :elapsed
-    * print "ms"
-    * print "\nDistance travelled: "
-    * print :distance
-    * print "\nSpeed: "
-    * print :speed
-    * print "tiles/s"
-    * print "\nPress button to repeat"
+   73 print "Measurement results ({0}):\nMap dimensions: {0}x{0}\nElapsed time: {0}ms\nDistance travelled: {0}\nSpeed: {0}tiles/s\nPress button to repeat"
+   74 format UNIT
+   75 format @mapw
+   76 format @maph
+   77 format :elapsed
+   78 format :distance
+   79 format :speed
    80 printflush message1
    81 sensor *tmp33 switch1 @enabled
    82 jump *label23 equal *tmp33 false

Final code before resolving virtual instructions:

label __start__
set UNIT @flare
op sub .DY @maph 10
op sub *tmp2 .DY 10
op len *tmp3 0 *tmp2
op mul *tmp4 100 *tmp3
op add *tmp5 *tmp4 0.5
op floor *tmp6 *tmp5
op div *tmp7 *tmp6 100
op sub :distance *tmp7 2
ubind UNIT
jump *label2 notEqual @unit null
label *label18
print UNIT
print ": no active unit found."
printflush message1
ubind UNIT
jump *label18 equal @unit null
label *label2
sensor *tmp10 switch1 @enabled
jump *label5 notEqual *tmp10 false
label *label19
print "Press button to start measuring {0} speed."
format UNIT
printflush message1
sensor *tmp10 switch1 @enabled
jump *label19 equal *tmp10 false
label *label5
control enabled switch1 false
sensor *tmp14 @unit @controlled
jump *label8 equal *tmp14 0
label *label20
print "Searching free "
print UNIT
printflush message1
ubind UNIT
sensor *tmp14 @unit @controlled
jump *label20 notEqual *tmp14 0
label *label8
ucontrol flag 1
ucontrol within 10 10 1 *tmp16
jump *label11 notEqual *tmp16 false
label *label21
print "Moving to start"
printflush message1
ucontrol move 10 10
ucontrol within 10 10 1 *tmp16
jump *label21 equal *tmp16 false
label *label11
print "Moving to destination"
printflush message1
set :start @time
ucontrol move 10 .DY
ucontrol within 10 .DY 1 *tmp19
jump *label14 notEqual *tmp19 false
label *label22
ucontrol move 10 .DY
ucontrol within 10 .DY 1 *tmp19
jump *label22 equal *tmp19 false
label *label14
set :finish @time
op sub *tmp25 10 .DY
op abs *tmp26 *tmp25
op div *tmp27 *tmp26 2
ucontrol move 0 *tmp27
ucontrol flag 0
op sub :elapsed :finish :start
op div *tmp29 :distance :elapsed
op idiv *tmp31 *tmp29 0.00001
op div :speed *tmp31 100
sensor *tmp33 switch1 @enabled
jump __start__ notEqual *tmp33 false
label *label23
print "Measurement results ({0}):\nMap dimensions: {0}x{0}\nElapsed time: {0}ms\nDistance travelled: {0}\nSpeed: {0}tiles/s\nPress button to repeat"
format UNIT
format @mapw
format @maph
format :elapsed
format :distance
format :speed
printflush message1
sensor *tmp33 switch1 @enabled
jump *label23 equal *tmp33 false
