   100 instructions before optimizations.
     5 instructions eliminated by Temp Variables Elimination.
     4 instructions eliminated by Dead Code Elimination (3 iterations).
     2 instructions eliminated by Jump Optimization (3 iterations).
     2 instructions eliminated by Single Step Elimination (4 iterations).
    26 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
     1 instructions modified by Loop Optimization (2 iterations).
     1 loops improved by Loop Optimization.
     4 instructions added by Loop Unrolling (4 iterations).
     1 loops unrolled by Loop Unrolling.
     2 instructions added by Return Optimization (4 iterations).
     1 return statements optimized by Return Optimization.
     1 instructions eliminated by Unreachable Code Elimination.
     4 instructions eliminated by Stack Optimization.
    62 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 914):
  * Unroll iteration loop at line 4:1                            cost     0, benefit       31.0, efficiency   Infinity (-21 instructions)
    Optimize return at line 14:9                                 cost     2, benefit       13.0, efficiency        6.5

Pass 1: speed optimization selection (cost limit 935):
  * Optimize return at line 14:9                                 cost     2, benefit       13.0, efficiency        6.5 (+2 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-4 instructions):
 
    57 jump *label17 equal *tmp4 false
    58 set :ways.0*retval 1
    59 jump *label16 always
-    * set *tmp5 null
    60 jump *label18 always
    61 label *label17
-    * set *tmp5 null
    62 label *label18
    63 set :ways.0:result 0
    64 set :ways.0:i :ways.0:index
 
    88 pop bank1 :ways.0:amount
    89 set *tmp11 :ways.0*retval
    90 op add :ways.0:result :ways.0:result *tmp11
-    * set *tmp9 :ways.0:result
    91 jump *label23 always
    92 label *label22
-    * set *tmp9 null
    93 label *label23
    94 label *label20
    95 op add :ways.0:i :ways.0:i 1

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-5 instructions):
 
    35 multilabel *label13
    36 jump *label14 always
    37 label *label2
-    * set *tmp1 :index
-    * write :value bank1 *tmp1
+   38 write :value bank1 :index
    39 op add :index :index 1
    40 label *label3
    41 multijump *tmp0 0 0
 
    46 set :ways.0:index 1
    47 callrec bank1 *label0 *label15 :ways.0*retval
    48 label *label15
-    * set *tmp3 :ways.0*retval
-    * assertequals 41 *tmp3 "Project Euler 31"
+   49 assertequals 41 :ways.0*retval "Project Euler 31"
    50 stop
    51 end
    52 label *label0
 
    62 set :ways.0:i :ways.0:index
    63 label *label19
    64 jump *label21 greaterThanEq :ways.0:i 8
-    * set *tmp6 :ways.0:i
-    * read *tmp7 bank1 *tmp6
-    * set :ways.0:p *tmp7
+   65 read :ways.0:p bank1 :ways.0:i
    66 op lessThanEq *tmp8 :ways.0:p :ways.0:amount
    67 jump *label22 equal *tmp8 false
    68 op sub *tmp10 :ways.0:amount :ways.0:p
 
    82 pop bank1 :ways.0:result
    83 pop bank1 :ways.0:index
    84 pop bank1 :ways.0:amount
-    * set *tmp11 :ways.0*retval
-    * op add :ways.0:result :ways.0:result *tmp11
+   85 op add :ways.0:result :ways.0:result :ways.0*retval
    86 jump *label23 always
    87 label *label22
    88 label *label23

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-2 instructions):
 
    51 end
    52 label *label0
    53 # "Function: def ways(in amount, in index)"
-    * op equal *tmp4 :ways.0:amount 0
-    * jump *label17 equal *tmp4 false
+   54 jump *label17 notEqual :ways.0:amount 0
    55 set :ways.0*retval 1
    56 jump *label16 always
    57 jump *label18 always
 
    62 label *label19
    63 jump *label21 greaterThanEq :ways.0:i 8
    64 read :ways.0:p bank1 :ways.0:i
-    * op lessThanEq *tmp8 :ways.0:p :ways.0:amount
-    * jump *label22 equal *tmp8 false
+   65 jump *label22 greaterThan :ways.0:p :ways.0:amount
    66 op sub *tmp10 :ways.0:amount :ways.0:p
    67 push bank1 :ways.0:amount
    68 push bank1 :ways.0:index

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    54 jump *label17 notEqual :ways.0:amount 0
    55 set :ways.0*retval 1
    56 jump *label16 always
-    * jump *label18 always
    57 label *label17
    58 label *label18
    59 set :ways.0:result 0
 
    80 pop bank1 :ways.0:index
    81 pop bank1 :ways.0:amount
    82 op add :ways.0:result :ways.0:result :ways.0*retval
-    * jump *label23 always
    83 label *label22
    84 label *label23
    85 label *label20

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    69 push bank1 :ways.0:i
    70 push bank1 :ways.0:p
    71 push bank1 *tmp5
-    * set :ways.0:amount *tmp10
+   72 op sub :ways.0:amount :ways.0:amount :ways.0:p
    73 set :ways.0:index :ways.0:i
    74 callrec bank1 *label0 *label24 :ways.0*retval
    75 label *label24

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    62 jump *label21 greaterThanEq :ways.0:i 8
    63 read :ways.0:p bank1 :ways.0:i
    64 jump *label22 greaterThan :ways.0:p :ways.0:amount
-    * op sub *tmp10 :ways.0:amount :ways.0:p
    65 push bank1 :ways.0:amount
    66 push bank1 :ways.0:index
    67 push bank1 :ways.0:result

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    60 set :ways.0:i :ways.0:index
    61 label *label19
    62 jump *label21 greaterThanEq :ways.0:i 8
+   63 label *label25
    64 read :ways.0:p bank1 :ways.0:i
    65 jump *label22 greaterThan :ways.0:p :ways.0:amount
    66 push bank1 :ways.0:amount
 
    84 label *label23
    85 label *label20
    86 op add :ways.0:i :ways.0:i 1
-    * jump *label19 always
+   87 jump *label25 lessThan :ways.0:i 8
    88 label *label21
    89 set :ways.0*retval :ways.0:result
    90 label *label16

Modifications by Unroll iteration loop at line 4:1 (+4 instructions):
 
     1 jump *label1 equal bank1 null
     2 set *sp 16
     3 set :index 0
-    * set :value 200
-    * op add *tmp0 @counter 1
-    * jump *label2 always
-    * multilabel *label5
-    * set :value 100
-    * op add *tmp0 @counter 1
-    * jump *label2 always
-    * multilabel *label6
-    * set :value 50
-    * op add *tmp0 @counter 1
-    * jump *label2 always
-    * multilabel *label7
-    * set :value 20
-    * op add *tmp0 @counter 1
-    * jump *label2 always
-    * multilabel *label8
-    * set :value 10
-    * op add *tmp0 @counter 1
-    * jump *label2 always
-    * multilabel *label9
-    * set :value 5
-    * op add *tmp0 @counter 1
-    * jump *label2 always
-    * multilabel *label10
-    * set :value 2
-    * op add *tmp0 @counter 1
-    * jump *label2 always
-    * multilabel *label11
-    * set :value 1
-    * op add *tmp0 @counter 1
-    * jump *label2 always
-    * multilabel *label13
-    * jump *label14 always
-    * label *label2
-    * write :value bank1 :index
-    * op add :index :index 1
-    * label *label3
-    * multijump *tmp0 0 0
-    * multilabel *label12
-    * label *label14
-    * label *label4
+    4 set :value 200
+    5 op add *tmp0 @counter 1
+    6 label *label26
+    7 write :value bank1 :index
+    8 op add :index :index 1
+    9 label *label27
+   10 set :value 100
+   11 op add *tmp0 @counter 1
+   12 label *label30
+   13 write :value bank1 :index
+   14 op add :index :index 1
+   15 label *label31
+   16 set :value 50
+   17 op add *tmp0 @counter 1
+   18 label *label34
+   19 write :value bank1 :index
+   20 op add :index :index 1
+   21 label *label35
+   22 set :value 20
+   23 op add *tmp0 @counter 1
+   24 label *label38
+   25 write :value bank1 :index
+   26 op add :index :index 1
+   27 label *label39
+   28 set :value 10
+   29 op add *tmp0 @counter 1
+   30 label *label42
+   31 write :value bank1 :index
+   32 op add :index :index 1
+   33 label *label43
+   34 set :value 5
+   35 op add *tmp0 @counter 1
+   36 label *label46
+   37 write :value bank1 :index
+   38 op add :index :index 1
+   39 label *label47
+   40 set :value 2
+   41 op add *tmp0 @counter 1
+   42 label *label50
+   43 write :value bank1 :index
+   44 op add :index :index 1
+   45 label *label51
+   46 set :value 1
+   47 op add *tmp0 @counter 1
+   48 label *label54
+   49 write :value bank1 :index
+   50 op add :index :index 1
+   51 label *label55
+   52 label *label14
+   53 label *label4
    54 set :ways.0:amount 20
    55 set :ways.0:index 1
    56 callrec bank1 *label0 *label15 :ways.0*retval

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-8 instructions):
 
     2 set *sp 16
     3 set :index 0
     4 set :value 200
-    * op add *tmp0 @counter 1
     5 label *label26
-    * write :value bank1 :index
-    * op add :index :index 1
+    6 write 200 bank1 0
+    7 op add :index 0 1
     8 label *label27
     9 set :value 100
-    * op add *tmp0 @counter 1
    10 label *label30
-    * write :value bank1 :index
-    * op add :index :index 1
+   11 write 100 bank1 1
+   12 op add :index 1 1
    13 label *label31
    14 set :value 50
-    * op add *tmp0 @counter 1
    15 label *label34
-    * write :value bank1 :index
-    * op add :index :index 1
+   16 write 50 bank1 2
+   17 op add :index 2 1
    18 label *label35
    19 set :value 20
-    * op add *tmp0 @counter 1
    20 label *label38
-    * write :value bank1 :index
-    * op add :index :index 1
+   21 write 20 bank1 3
+   22 op add :index 3 1
    23 label *label39
    24 set :value 10
-    * op add *tmp0 @counter 1
    25 label *label42
-    * write :value bank1 :index
-    * op add :index :index 1
+   26 write 10 bank1 4
+   27 op add :index 4 1
    28 label *label43
    29 set :value 5
-    * op add *tmp0 @counter 1
    30 label *label46
-    * write :value bank1 :index
-    * op add :index :index 1
+   31 write 5 bank1 5
+   32 op add :index 5 1
    33 label *label47
    34 set :value 2
-    * op add *tmp0 @counter 1
    35 label *label50
-    * write :value bank1 :index
-    * op add :index :index 1
+   36 write 2 bank1 6
+   37 op add :index 6 1
    38 label *label51
    39 set :value 1
-    * op add *tmp0 @counter 1
    40 label *label54
-    * write :value bank1 :index
-    * op add :index :index 1
+   41 write 1 bank1 7
+   42 op add :index 7 1
    43 label *label55
    44 label *label14
    45 label *label4
 
    60 set :ways.0:result 0
    61 set :ways.0:i :ways.0:index
    62 label *label19
-    * jump *label21 greaterThanEq :ways.0:i 8
+   63 jump *label21 greaterThanEq :ways.0:index 8
    64 label *label25
    65 read :ways.0:p bank1 :ways.0:i
    66 jump *label22 greaterThan :ways.0:p :ways.0:amount

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-17 instructions):
     0 label *label1
     1 jump *label1 equal bank1 null
     2 set *sp 16
-    * set :index 0
-    * set :value 200
     3 label *label26
     4 write 200 bank1 0
-    * op add :index 0 1
     5 label *label27
-    * set :value 100
     6 label *label30
     7 write 100 bank1 1
-    * op add :index 1 1
     8 label *label31
-    * set :value 50
     9 label *label34
    10 write 50 bank1 2
-    * op add :index 2 1
    11 label *label35
-    * set :value 20
    12 label *label38
    13 write 20 bank1 3
-    * op add :index 3 1
    14 label *label39
-    * set :value 10
    15 label *label42
    16 write 10 bank1 4
-    * op add :index 4 1
    17 label *label43
-    * set :value 5
    18 label *label46
    19 write 5 bank1 5
-    * op add :index 5 1
    20 label *label47
-    * set :value 2
    21 label *label50
    22 write 2 bank1 6
-    * op add :index 6 1
    23 label *label51
-    * set :value 1
    24 label *label54
    25 write 1 bank1 7
-    * op add :index 7 1
    26 label *label55
    27 label *label14
    28 label *label4

Modifications by Optimize return at line 14:9 (+2 instructions):
 
    37 # "Function: def ways(in amount, in index)"
    38 jump *label17 notEqual :ways.0:amount 0
    39 set :ways.0*retval 1
-    * jump *label16 always
+   40 returnrec bank1
    41 label *label17
    42 label *label18
    43 set :ways.0:result 0

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
    73 set :ways.0*retval :ways.0:result
    74 label *label16
    75 returnrec bank1
-    * end

Modifications by Final phase, Stack Optimization, iteration 1 (-4 instructions):
 
    52 push bank1 :ways.0:result
    53 push bank1 :ways.0:i
    54 push bank1 :ways.0:p
-    * push bank1 *tmp5
    55 op sub :ways.0:amount :ways.0:amount :ways.0:p
    56 set :ways.0:index :ways.0:i
    57 callrec bank1 *label0 *label24 :ways.0*retval
    58 label *label24
-    * pop bank1 *tmp5
    59 pop bank1 :ways.0:p
    60 pop bank1 :ways.0:i
    61 pop bank1 :ways.0:result

Final code before resolving virtual instructions:

label *label1
jump *label1 equal bank1 null
set *sp 16
write 200 bank1 0
write 100 bank1 1
write 50 bank1 2
write 20 bank1 3
write 10 bank1 4
write 5 bank1 5
write 2 bank1 6
write 1 bank1 7
set :ways.0:amount 20
set :ways.0:index 1
callrec bank1 *label0 *label15 :ways.0*retval
label *label15
assertequals 41 :ways.0*retval "Project Euler 31"
stop
end
label *label0
# "Function: def ways(in amount, in index)"
jump *label17 notEqual :ways.0:amount 0
set :ways.0*retval 1
returnrec bank1
label *label17
set :ways.0:result 0
set :ways.0:i :ways.0:index
jump *label21 greaterThanEq :ways.0:index 8
label *label25
read :ways.0:p bank1 :ways.0:i
jump *label22 greaterThan :ways.0:p :ways.0:amount
push bank1 :ways.0:amount
push bank1 :ways.0:index
push bank1 :ways.0:result
push bank1 :ways.0:i
push bank1 :ways.0:p
op sub :ways.0:amount :ways.0:amount :ways.0:p
set :ways.0:index :ways.0:i
callrec bank1 *label0 *label24 :ways.0*retval
label *label24
pop bank1 :ways.0:p
pop bank1 :ways.0:i
pop bank1 :ways.0:result
pop bank1 :ways.0:index
pop bank1 :ways.0:amount
op add :ways.0:result :ways.0:result :ways.0*retval
label *label22
op add :ways.0:i :ways.0:i 1
jump *label25 lessThan :ways.0:i 8
label *label21
set :ways.0*retval :ways.0:result
returnrec bank1
