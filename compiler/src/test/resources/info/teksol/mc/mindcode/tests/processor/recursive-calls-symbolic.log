   153 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination.
    15 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Jump Optimization (3 iterations).
     3 instructions eliminated by Single Step Elimination (4 iterations).
     7 instructions eliminated by Data Flow Optimization (4 iterations).
     3 instructions eliminated by Unreachable Code Elimination.
    12 instructions eliminated by Stack Optimization.
   104 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-9 instructions):
 
     6 set :foo.0:b 0
     7 callrec bank1 *label0 *label4 :foo.0*retval
     8 label *label4
-    * set *tmp0 :foo.0*retval
     9 assertprints "0001111223221211" "foo"
    10 assertflush
    11 set :bar.0:n 3
 
    13 set :bar.0:b 0
    14 callrec bank1 *label1 *label5 :bar.0*retval
    15 label *label5
-    * set *tmp1 :bar.0*retval
    16 assertprints "0001111223333444" "bar"
    17 assertflush
    18 set :baz.0:n 3
 
    20 set :baz.0:b 0
    21 callrec bank1 *label2 *label6 :baz.0*retval
    22 label *label6
-    * set *tmp2 :baz.0*retval
    23 assertprints "0001111223221211" "baz"
    24 stop
    25 end
 
    46 pop bank1 :foo.0:a
    47 pop bank1 :foo.0:n
    48 set *tmp9 :foo.0*retval
-    * set *tmp5 *tmp9
    49 jump *label9 always
    50 label *label8
-    * set *tmp5 null
    51 label *label9
    52 op add *tmp10 :foo.0:b 1
    53 set :foo.0:b *tmp10
 
    80 set :bar.0:a *tmp18
    81 pop bank1 :bar.0:n
    82 set *tmp19 :bar.0*retval
-    * set *tmp13 *tmp19
    83 jump *label13 always
    84 label *label12
-    * set *tmp13 null
    85 label *label13
    86 op add *tmp20 :bar.0:b 1
    87 set :bar.0:b *tmp20
 
   114 pop bank1 :baz.0:b
   115 pop bank1 :baz.0:n
   116 set *tmp27 :baz.0*retval
-    * set *tmp23 *tmp27
   117 jump *label17 always
   118 label *label16
-    * set *tmp23 null
   119 label *label17
   120 op add *tmp28 :baz.0:b 1
   121 set :baz.0:b *tmp28

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-3 instructions):
 
    45 pop bank1 :foo.0:b
    46 pop bank1 :foo.0:a
    47 pop bank1 :foo.0:n
-    * set *tmp9 :foo.0*retval
    48 jump *label9 always
    49 label *label8
    50 label *label9
 
    78 set :bar.0:b *tmp17
    79 set :bar.0:a *tmp18
    80 pop bank1 :bar.0:n
-    * set *tmp19 :bar.0*retval
    81 jump *label13 always
    82 label *label12
    83 label *label13
 
   111 pop bank1 :baz.0:a
   112 pop bank1 :baz.0:b
   113 pop bank1 :baz.0:n
-    * set *tmp27 :baz.0*retval
   114 jump *label17 always
   115 label *label16
   116 label *label17

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-3 instructions):
 
    52 set :foo.0:b *tmp10
    53 print :foo.0:a
    54 print :foo.0:b
-    * set :foo.0*retval :foo.0:b
    55 label *label7
    56 returnrec bank1
    57 end
 
    84 set :bar.0:b *tmp20
    85 print :bar.0:a
    86 print :bar.0:b
-    * set :bar.0*retval :bar.0:b
    87 label *label11
    88 returnrec bank1
    89 end
 
   116 set :baz.0:b *tmp28
   117 print :baz.0:a
   118 print :baz.0:b
-    * set :baz.0*retval :baz.0:b
   119 label *label15
   120 returnrec bank1
   121 end

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
    27 # "Function: def foo(in n, in a, in b)"
    28 print :foo.0:a
    29 print :foo.0:b
-    * op add *tmp3 :foo.0:a 1
-    * set :foo.0:a *tmp3
+   30 op add :foo.0:a :foo.0:a 1
    31 op greaterThan *tmp4 :foo.0:n 0
    32 jump *label8 equal *tmp4 false
    33 op sub *tmp6 :foo.0:n 1
 
    47 jump *label9 always
    48 label *label8
    49 label *label9
-    * op add *tmp10 :foo.0:b 1
-    * set :foo.0:b *tmp10
+   50 op add :foo.0:b :foo.0:b 1
    51 print :foo.0:a
    52 print :foo.0:b
    53 label *label7
 
    57 # "Function: def bar(in n, in out a, in out b)"
    58 print :bar.0:a
    59 print :bar.0:b
-    * op add *tmp11 :bar.0:a 1
-    * set :bar.0:a *tmp11
+   60 op add :bar.0:a :bar.0:a 1
    61 op greaterThan *tmp12 :bar.0:n 0
    62 jump *label12 equal *tmp12 false
    63 op sub *tmp14 :bar.0:n 1
 
    77 jump *label13 always
    78 label *label12
    79 label *label13
-    * op add *tmp20 :bar.0:b 1
-    * set :bar.0:b *tmp20
+   80 op add :bar.0:b :bar.0:b 1
    81 print :bar.0:a
    82 print :bar.0:b
    83 label *label11
 
    87 # "Function: def baz(in n, in out a, in out b)"
    88 print :baz.0:a
    89 print :baz.0:b
-    * op add *tmp21 :baz.0:a 1
-    * set :baz.0:a *tmp21
+   90 op add :baz.0:a :baz.0:a 1
    91 op greaterThan *tmp22 :baz.0:n 0
    92 jump *label16 equal *tmp22 false
    93 op sub *tmp24 :baz.0:n 1
 
   107 jump *label17 always
   108 label *label16
   109 label *label17
-    * op add *tmp28 :baz.0:b 1
-    * set :baz.0:b *tmp28
+  110 op add :baz.0:b :baz.0:b 1
   111 print :baz.0:a
   112 print :baz.0:b
   113 label *label15

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-3 instructions):
 
    28 print :foo.0:a
    29 print :foo.0:b
    30 op add :foo.0:a :foo.0:a 1
-    * op greaterThan *tmp4 :foo.0:n 0
-    * jump *label8 equal *tmp4 false
+   31 jump *label8 lessThanEq :foo.0:n 0
    32 op sub *tmp6 :foo.0:n 1
    33 push bank1 :foo.0:n
    34 push bank1 :foo.0:a
 
    57 print :bar.0:a
    58 print :bar.0:b
    59 op add :bar.0:a :bar.0:a 1
-    * op greaterThan *tmp12 :bar.0:n 0
-    * jump *label12 equal *tmp12 false
+   60 jump *label12 lessThanEq :bar.0:n 0
    61 op sub *tmp14 :bar.0:n 1
    62 push bank1 :bar.0:n
    63 set *tmp15 :bar.0:b
 
    86 print :baz.0:a
    87 print :baz.0:b
    88 op add :baz.0:a :baz.0:a 1
-    * op greaterThan *tmp22 :baz.0:n 0
-    * jump *label16 equal *tmp22 false
+   89 jump *label16 lessThanEq :baz.0:n 0
    90 op sub *tmp24 :baz.0:n 1
    91 push bank1 :baz.0:n
    92 push bank1 :baz.0:b

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-3 instructions):
 
    43 pop bank1 :foo.0:b
    44 pop bank1 :foo.0:a
    45 pop bank1 :foo.0:n
-    * jump *label9 always
    46 label *label8
    47 label *label9
    48 op add :foo.0:b :foo.0:b 1
 
    71 set :bar.0:b *tmp17
    72 set :bar.0:a *tmp18
    73 pop bank1 :bar.0:n
-    * jump *label13 always
    74 label *label12
    75 label *label13
    76 op add :bar.0:b :bar.0:b 1
 
    99 pop bank1 :baz.0:a
   100 pop bank1 :baz.0:b
   101 pop bank1 :baz.0:n
-    * jump *label17 always
   102 label *label16
   103 label *label17
   104 op add :baz.0:b :baz.0:b 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    35 push bank1 :foo.0:b
    36 set *tmp7 :foo.0:b
    37 set *tmp8 :foo.0:a
-    * set :foo.0:n *tmp6
-    * set :foo.0:a *tmp7
+   38 op sub :foo.0:n :foo.0:n 1
+   39 set :foo.0:a :foo.0:b
    40 set :foo.0:b *tmp8
    41 callrec bank1 *label0 *label10 :foo.0*retval
    42 label *label10
 
    61 push bank1 :bar.0:n
    62 set *tmp15 :bar.0:b
    63 set *tmp16 :bar.0:a
-    * set :bar.0:n *tmp14
-    * set :bar.0:a *tmp15
+   64 op sub :bar.0:n :bar.0:n 1
+   65 set :bar.0:a :bar.0:b
    66 set :bar.0:b *tmp16
    67 callrec bank1 *label1 *label14 :bar.0*retval
    68 label *label14
    69 set *tmp17 :bar.0:a
    70 set *tmp18 :bar.0:b
-    * set :bar.0:b *tmp17
+   71 set :bar.0:b :bar.0:a
    72 set :bar.0:a *tmp18
    73 pop bank1 :bar.0:n
    74 label *label12
 
    91 push bank1 :baz.0:a
    92 set *tmp25 :baz.0:b
    93 set *tmp26 :baz.0:a
-    * set :baz.0:n *tmp24
-    * set :baz.0:a *tmp25
+   94 op sub :baz.0:n :baz.0:n 1
+   95 set :baz.0:a :baz.0:b
    96 set :baz.0:b *tmp26
    97 callrec bank1 *label2 *label18 :baz.0*retval
    98 label *label18

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
    29 print :foo.0:b
    30 op add :foo.0:a :foo.0:a 1
    31 jump *label8 lessThanEq :foo.0:n 0
-    * op sub *tmp6 :foo.0:n 1
    32 push bank1 :foo.0:n
    33 push bank1 :foo.0:a
    34 push bank1 :foo.0:b
-    * set *tmp7 :foo.0:b
    35 set *tmp8 :foo.0:a
    36 op sub :foo.0:n :foo.0:n 1
    37 set :foo.0:a :foo.0:b
 
    55 print :bar.0:b
    56 op add :bar.0:a :bar.0:a 1
    57 jump *label12 lessThanEq :bar.0:n 0
-    * op sub *tmp14 :bar.0:n 1
    58 push bank1 :bar.0:n
-    * set *tmp15 :bar.0:b
    59 set *tmp16 :bar.0:a
    60 op sub :bar.0:n :bar.0:n 1
    61 set :bar.0:a :bar.0:b
    62 set :bar.0:b *tmp16
    63 callrec bank1 *label1 *label14 :bar.0*retval
    64 label *label14
-    * set *tmp17 :bar.0:a
    65 set *tmp18 :bar.0:b
    66 set :bar.0:b :bar.0:a
    67 set :bar.0:a *tmp18
 
    80 print :baz.0:b
    81 op add :baz.0:a :baz.0:a 1
    82 jump *label16 lessThanEq :baz.0:n 0
-    * op sub *tmp24 :baz.0:n 1
    83 push bank1 :baz.0:n
    84 push bank1 :baz.0:b
    85 push bank1 :baz.0:a
-    * set *tmp25 :baz.0:b
    86 set *tmp26 :baz.0:a
    87 op sub :baz.0:n :baz.0:n 1
    88 set :baz.0:a :baz.0:b

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-3 instructions):
 
    48 print :foo.0:b
    49 label *label7
    50 returnrec bank1
-    * end
    51 label *label1
    52 # "Function: def bar(in n, in out a, in out b)"
    53 print :bar.0:a
 
    72 print :bar.0:b
    73 label *label11
    74 returnrec bank1
-    * end
    75 label *label2
    76 # "Function: def baz(in n, in out a, in out b)"
    77 print :baz.0:a
 
    97 print :baz.0:b
    98 label *label15
    99 returnrec bank1
-    * end

Modifications by Final phase, Stack Optimization, iteration 1 (-12 instructions):
 
    29 print :foo.0:b
    30 op add :foo.0:a :foo.0:a 1
    31 jump *label8 lessThanEq :foo.0:n 0
-    * push bank1 :foo.0:n
    32 push bank1 :foo.0:a
    33 push bank1 :foo.0:b
    34 set *tmp8 :foo.0:a
 
    39 label *label10
    40 pop bank1 :foo.0:b
    41 pop bank1 :foo.0:a
-    * pop bank1 :foo.0:n
    42 label *label8
    43 label *label9
    44 op add :foo.0:b :foo.0:b 1
 
    52 print :bar.0:b
    53 op add :bar.0:a :bar.0:a 1
    54 jump *label12 lessThanEq :bar.0:n 0
-    * push bank1 :bar.0:n
    55 set *tmp16 :bar.0:a
    56 op sub :bar.0:n :bar.0:n 1
    57 set :bar.0:a :bar.0:b
 
    61 set *tmp18 :bar.0:b
    62 set :bar.0:b :bar.0:a
    63 set :bar.0:a *tmp18
-    * pop bank1 :bar.0:n
    64 label *label12
    65 label *label13
    66 op add :bar.0:b :bar.0:b 1
 
    74 print :baz.0:b
    75 op add :baz.0:a :baz.0:a 1
    76 jump *label16 lessThanEq :baz.0:n 0
-    * push bank1 :baz.0:n
    77 push bank1 :baz.0:b
    78 push bank1 :baz.0:a
    79 set *tmp26 :baz.0:a
 
    84 label *label18
    85 pop bank1 :baz.0:a
    86 pop bank1 :baz.0:b
-    * pop bank1 :baz.0:n
    87 label *label16
    88 label *label17
    89 op add :baz.0:b :baz.0:b 1

Final code before resolving virtual instructions:

label *label3
jump *label3 equal bank1 null
set *sp 0
assertflush
set :foo.0:n 3
set :foo.0:a 0
set :foo.0:b 0
callrec bank1 *label0 *label4 :foo.0*retval
label *label4
assertprints "0001111223221211" "foo"
assertflush
set :bar.0:n 3
set :bar.0:a 0
set :bar.0:b 0
callrec bank1 *label1 *label5 :bar.0*retval
label *label5
assertprints "0001111223333444" "bar"
assertflush
set :baz.0:n 3
set :baz.0:a 0
set :baz.0:b 0
callrec bank1 *label2 *label6 :baz.0*retval
label *label6
assertprints "0001111223221211" "baz"
stop
end
label *label0
# "Function: def foo(in n, in a, in b)"
print :foo.0:a
print :foo.0:b
op add :foo.0:a :foo.0:a 1
jump *label8 lessThanEq :foo.0:n 0
push bank1 :foo.0:a
push bank1 :foo.0:b
set *tmp8 :foo.0:a
op sub :foo.0:n :foo.0:n 1
set :foo.0:a :foo.0:b
set :foo.0:b *tmp8
callrec bank1 *label0 *label10 :foo.0*retval
label *label10
pop bank1 :foo.0:b
pop bank1 :foo.0:a
label *label8
op add :foo.0:b :foo.0:b 1
print :foo.0:a
print :foo.0:b
returnrec bank1
label *label1
# "Function: def bar(in n, in out a, in out b)"
print :bar.0:a
print :bar.0:b
op add :bar.0:a :bar.0:a 1
jump *label12 lessThanEq :bar.0:n 0
set *tmp16 :bar.0:a
op sub :bar.0:n :bar.0:n 1
set :bar.0:a :bar.0:b
set :bar.0:b *tmp16
callrec bank1 *label1 *label14 :bar.0*retval
label *label14
set *tmp18 :bar.0:b
set :bar.0:b :bar.0:a
set :bar.0:a *tmp18
label *label12
op add :bar.0:b :bar.0:b 1
print :bar.0:a
print :bar.0:b
returnrec bank1
label *label2
# "Function: def baz(in n, in out a, in out b)"
print :baz.0:a
print :baz.0:b
op add :baz.0:a :baz.0:a 1
jump *label16 lessThanEq :baz.0:n 0
push bank1 :baz.0:b
push bank1 :baz.0:a
set *tmp26 :baz.0:a
op sub :baz.0:n :baz.0:n 1
set :baz.0:a :baz.0:b
set :baz.0:b *tmp26
callrec bank1 *label2 *label18 :baz.0*retval
label *label18
pop bank1 :baz.0:a
pop bank1 :baz.0:b
label *label16
op add :baz.0:b :baz.0:b 1
print :baz.0:a
print :baz.0:b
returnrec bank1
