   107 instructions before optimizations.
     4 instructions eliminated by Temp Variables Elimination (7 iterations).
     1 instructions eliminated by Dead Code Elimination (4 iterations).
     1 instructions eliminated by Single Step Elimination (7 iterations).
     5 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     3 instructions modified by Loop Optimization (4 iterations).
     3 loops improved by Loop Optimization.
     6 instructions eliminated by Array Optimization (4 iterations).
    47 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-1 instructions):
 
    24 label *label5
    25 set *tmp9 :lineLength
    26 writearr<internal:compact> 1 .currentLine[] *tmp9
-    * set *tmp11 :lineLength
    27 op add :lineLength :lineLength 1
    28 set *tmp12 :lineLength
    29 set :c 0

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-7 instructions):
 
    11 label *label3
    12 jump *label5 greaterThan :j *tmp0
    13 set *tmp1 :j
-    * op sub *tmp3 :j 1
-    * set *tmp4 *tmp3
+   14 op sub *tmp4 :j 1
    15 set *tmp6 :j
    16 readarr<internal:compact> *tmp5 .previousLine[] *tmp4
    17 readarr<internal:compact> *tmp7 .previousLine[] *tmp6
 
    21 op add :j :j 1
    22 jump *label3 always
    23 label *label5
-    * set *tmp9 :lineLength
-    * writearr<internal:compact> 1 .currentLine[] *tmp9
+   24 writearr<internal:compact> 1 .currentLine[] :lineLength
    25 op add :lineLength :lineLength 1
    26 set *tmp12 :lineLength
    27 set :c 0
    28 label *label6
    29 jump *label8 greaterThanEq :c *tmp12
-    * set *tmp13 :c
-    * readarr<internal:compact> *tmp14 .currentLine[] *tmp13
+   30 readarr<internal:compact:src> *tmp14 .currentLine[] :c
    31 op add :total :total *tmp14
    32 set *tmp15 :c
-    * set *tmp17 :c
-    * readarr<internal:compact> *tmp18 .currentLine[] *tmp17
+   33 readarr<internal:compact:dst> *tmp18 .currentLine[] :c
    34 writearr<internal:compact> *tmp18 .previousLine[] *tmp15
    35 label *label7
    36 op add :c :c 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     9 set *tmp0 :lineLength
    10 set :j 1
    11 label *label3
-    * jump *label5 greaterThan :j *tmp0
+   12 jump *label5 greaterThan :j :lineLength
    13 set *tmp1 :j
    14 op sub *tmp4 :j 1
    15 set *tmp6 :j
    16 readarr<internal:compact> *tmp5 .previousLine[] *tmp4
-    * readarr<internal:compact> *tmp7 .previousLine[] *tmp6
+   17 readarr<internal:compact> *tmp7 .previousLine[] :j
    18 op add *tmp8 *tmp5 *tmp7
-    * writearr<internal:compact> *tmp8 .currentLine[] *tmp1
+   19 writearr<internal:compact> *tmp8 .currentLine[] :j
    20 label *label4
    21 op add :j :j 1
    22 jump *label3 always
 
    26 set *tmp12 :lineLength
    27 set :c 0
    28 label *label6
-    * jump *label8 greaterThanEq :c *tmp12
+   29 jump *label8 greaterThanEq :c :lineLength
    30 readarr<internal:compact:src> *tmp14 .currentLine[] :c
    31 op add :total :total *tmp14
    32 set *tmp15 :c
    33 readarr<internal:compact:dst> *tmp18 .currentLine[] :c
-    * writearr<internal:compact> *tmp18 .previousLine[] *tmp15
+   34 writearr<internal:compact> *tmp18 .previousLine[] :c
    35 label *label7
    36 op add :c :c 1
    37 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-5 instructions):
 
     6 label *label0
     7 jump *label2 greaterThan :i TRIANGLE_SIZE
     8 set water 1
-    * set *tmp0 :lineLength
     9 set :j 1
    10 label *label3
    11 jump *label5 greaterThan :j :lineLength
-    * set *tmp1 :j
    12 op sub *tmp4 :j 1
-    * set *tmp6 :j
    13 readarr<internal:compact> *tmp5 .previousLine[] *tmp4
    14 readarr<internal:compact> *tmp7 .previousLine[] :j
    15 op add *tmp8 *tmp5 *tmp7
 
    20 label *label5
    21 writearr<internal:compact> 1 .currentLine[] :lineLength
    22 op add :lineLength :lineLength 1
-    * set *tmp12 :lineLength
    23 set :c 0
    24 label *label6
    25 jump *label8 greaterThanEq :c :lineLength
    26 readarr<internal:compact:src> *tmp14 .currentLine[] :c
    27 op add :total :total *tmp14
-    * set *tmp15 :c
    28 readarr<internal:compact:dst> *tmp18 .currentLine[] :c
    29 writearr<internal:compact> *tmp18 .previousLine[] :c
    30 label *label7

Modifications by Iterated phase, Array Optimization, pass 1, iteration 1 (-46 instructions):
 
    10 label *label3
    11 jump *label5 greaterThan :j :lineLength
    12 op sub *tmp4 :j 1
-    * readarr<internal:compact> *tmp5 .previousLine[] *tmp4
-    * readarr<internal:compact> *tmp7 .previousLine[] :j
+   13 readarr<lookup:item> *tmp5 .previousLine[] *tmp4
+   14 readarr<lookup:item> *tmp7 .previousLine[] :j
    15 op add *tmp8 *tmp5 *tmp7
-    * writearr<internal:compact> *tmp8 .currentLine[] :j
+   16 writearr<lookup:liquid> *tmp8 .currentLine[] :j
    17 label *label4
    18 op add :j :j 1
    19 jump *label3 always
    20 label *label5
-    * writearr<internal:compact> 1 .currentLine[] :lineLength
+   21 writearr<lookup:liquid> 1 .currentLine[] :lineLength
    22 op add :lineLength :lineLength 1
    23 set :c 0
    24 label *label6
    25 jump *label8 greaterThanEq :c :lineLength
-    * readarr<internal:compact:src> *tmp14 .currentLine[] :c
+   26 readarr<lookup:liquid> *tmp14 .currentLine[] :c
    27 op add :total :total *tmp14
-    * readarr<internal:compact:dst> *tmp18 .currentLine[] :c
-    * writearr<internal:compact> *tmp18 .previousLine[] :c
+   28 readarr<lookup:liquid> *tmp18 .currentLine[] :c
+   29 writearr<lookup:item> *tmp18 .previousLine[] :c
    30 label *label7
    31 op add :c :c 1
    32 jump *label6 always

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     5 set :i 3
     6 label *label0
     7 jump *label2 greaterThan :i TRIANGLE_SIZE
+    8 label *label9
     9 set water 1
    10 set :j 1
    11 label *label3
    12 jump *label5 greaterThan :j :lineLength
+   13 label *label10
    14 op sub *tmp4 :j 1
    15 readarr<lookup:item> *tmp5 .previousLine[] *tmp4
    16 readarr<lookup:item> *tmp7 .previousLine[] :j
 
    18 writearr<lookup:liquid> *tmp8 .currentLine[] :j
    19 label *label4
    20 op add :j :j 1
-    * jump *label3 always
+   21 jump *label10 lessThanEq :j :lineLength
    22 label *label5
    23 writearr<lookup:liquid> 1 .currentLine[] :lineLength
    24 op add :lineLength :lineLength 1
    25 set :c 0
    26 label *label6
    27 jump *label8 greaterThanEq :c :lineLength
+   28 label *label11
    29 readarr<lookup:liquid> *tmp14 .currentLine[] :c
    30 op add :total :total *tmp14
    31 readarr<lookup:liquid> *tmp18 .currentLine[] :c
    32 writearr<lookup:item> *tmp18 .previousLine[] :c
    33 label *label7
    34 op add :c :c 1
-    * jump *label6 always
+   35 jump *label11 lessThan :c :lineLength
    36 label *label8
    37 label *label1
    38 op add :i :i 1
-    * jump *label0 always
+   39 jump *label9 lessThanEq :i TRIANGLE_SIZE
    40 label *label2
    41 assertequals 1023 :total "Sum of Pascal triangle"
    42 stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
     4 set lead 1
     5 set :i 3
     6 label *label0
-    * jump *label2 greaterThan :i TRIANGLE_SIZE
+    7 jump *label2 greaterThan 3 TRIANGLE_SIZE
     8 label *label9
     9 set water 1
    10 set :j 1
    11 label *label3
-    * jump *label5 greaterThan :j :lineLength
+   12 jump *label5 greaterThan 1 :lineLength
    13 label *label10
    14 op sub *tmp4 :j 1
    15 readarr<lookup:item> *tmp5 .previousLine[] *tmp4
 
    24 op add :lineLength :lineLength 1
    25 set :c 0
    26 label *label6
-    * jump *label8 greaterThanEq :c :lineLength
+   27 jump *label8 greaterThanEq 0 :lineLength
    28 label *label11
    29 readarr<lookup:liquid> *tmp14 .currentLine[] :c
    30 op add :total :total *tmp14

Modifications by Virtual Instruction Expansion:
 
    12 jump *label5 greaterThan 1 :lineLength
    13 label *label10
    14 op sub *tmp4 :j 1
-    * readarr<lookup:item> *tmp5 .previousLine[] *tmp4
-    * readarr<lookup:item> *tmp7 .previousLine[] :j
+   15 lookup item *tmp19 *tmp4
+   16 sensor .previousLine*elem *tmp19 @name
+   17 read *tmp5 @this .previousLine*elem
+   18 lookup item *tmp20 :j
+   19 sensor .previousLine*elem *tmp20 @name
+   20 read *tmp7 @this .previousLine*elem
    21 op add *tmp8 *tmp5 *tmp7
-    * writearr<lookup:liquid> *tmp8 .currentLine[] :j
+   22 lookup liquid *tmp21 :j
+   23 sensor .currentLine*elem *tmp21 @name
+   24 write *tmp8 @this .currentLine*elem
    25 label *label4
    26 op add :j :j 1
    27 jump *label10 lessThanEq :j :lineLength
    28 label *label5
-    * writearr<lookup:liquid> 1 .currentLine[] :lineLength
+   29 lookup liquid *tmp22 :lineLength
+   30 sensor .currentLine*elem *tmp22 @name
+   31 write 1 @this .currentLine*elem
    32 op add :lineLength :lineLength 1
    33 set :c 0
    34 label *label6
    35 jump *label8 greaterThanEq 0 :lineLength
    36 label *label11
-    * readarr<lookup:liquid> *tmp14 .currentLine[] :c
+   37 lookup liquid *tmp23 :c
+   38 sensor .currentLine*elem *tmp23 @name
+   39 read *tmp14 @this .currentLine*elem
    40 op add :total :total *tmp14
-    * readarr<lookup:liquid> *tmp18 .currentLine[] :c
-    * writearr<lookup:item> *tmp18 .previousLine[] :c
+   41 read *tmp18 @this .currentLine*elem
+   42 lookup item *tmp25 :c
+   43 sensor .previousLine*elem *tmp25 @name
+   44 write *tmp18 @this .previousLine*elem
    45 label *label7
    46 op add :c :c 1
    47 jump *label11 lessThan :c :lineLength

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
     3 set copper 1
     4 set lead 1
     5 set :i 3
-    * label *label0
     6 jump *label2 greaterThan 3 TRIANGLE_SIZE
     7 label *label9
     8 set water 1
     9 set :j 1
-    * label *label3
    10 jump *label5 greaterThan 1 :lineLength
    11 label *label10
    12 op sub *tmp4 :j 1
 
    20 lookup liquid *tmp21 :j
    21 sensor .currentLine*elem *tmp21 @name
    22 write *tmp8 @this .currentLine*elem
-    * label *label4
    23 op add :j :j 1
    24 jump *label10 lessThanEq :j :lineLength
    25 label *label5
 
    28 write 1 @this .currentLine*elem
    29 op add :lineLength :lineLength 1
    30 set :c 0
-    * label *label6
    31 jump *label8 greaterThanEq 0 :lineLength
    32 label *label11
    33 lookup liquid *tmp23 :c
 
    38 lookup item *tmp25 :c
    39 sensor .previousLine*elem *tmp25 @name
    40 write *tmp18 @this .previousLine*elem
-    * label *label7
    41 op add :c :c 1
    42 jump *label11 lessThan :c :lineLength
    43 label *label8
-    * label *label1
    44 op add :i :i 1
    45 jump *label9 lessThanEq :i TRIANGLE_SIZE
    46 label *label2

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-1 instructions):
 
    46 label *label2
    47 assertequals 1023 :total "Sum of Pascal triangle"
    48 stop
-    * end

Final code before resolving virtual instructions:

set TRIANGLE_SIZE 10
set :total 3
set :lineLength 2
set copper 1
set lead 1
set :i 3
jump *label2 greaterThan 3 TRIANGLE_SIZE
label *label9
set water 1
set :j 1
jump *label5 greaterThan 1 :lineLength
label *label10
op sub *tmp4 :j 1
lookup item *tmp19 *tmp4
sensor .previousLine*elem *tmp19 @name
read *tmp5 @this .previousLine*elem
lookup item *tmp20 :j
sensor .previousLine*elem *tmp20 @name
read *tmp7 @this .previousLine*elem
op add *tmp8 *tmp5 *tmp7
lookup liquid *tmp21 :j
sensor .currentLine*elem *tmp21 @name
write *tmp8 @this .currentLine*elem
op add :j :j 1
jump *label10 lessThanEq :j :lineLength
label *label5
lookup liquid *tmp22 :lineLength
sensor .currentLine*elem *tmp22 @name
write 1 @this .currentLine*elem
op add :lineLength :lineLength 1
set :c 0
jump *label8 greaterThanEq 0 :lineLength
label *label11
lookup liquid *tmp23 :c
sensor .currentLine*elem *tmp23 @name
read *tmp14 @this .currentLine*elem
op add :total :total *tmp14
read *tmp18 @this .currentLine*elem
lookup item *tmp25 :c
sensor .previousLine*elem *tmp25 @name
write *tmp18 @this .previousLine*elem
op add :c :c 1
jump *label11 lessThan :c :lineLength
label *label8
op add :i :i 1
jump *label9 lessThanEq :i TRIANGLE_SIZE
label *label2
assertequals 1023 :total "Sum of Pascal triangle"
stop
