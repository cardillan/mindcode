   173 instructions before optimizations.
    25 instructions eliminated by Temp Variables Elimination (5 iterations).
     1 instructions eliminated by Case Expression Optimization.
    14 instructions eliminated by Dead Code Elimination (7 iterations).
    10 instructions eliminated by Condition Optimization (5 iterations).
     7 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     1 instructions eliminated by Expression Optimization (2 iterations).
     3 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     1 instructions added by Loop Rotation (2 iterations).
       4 loop conditions were partially rotated.
     3 instructions eliminated by Jump Straightening (5 iterations).
     1 instructions updated by Jump Threading.
    20 instructions eliminated by Print Merging.
    90 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 890):
  * Full loop rotation at line 39:1                              size    +1, benefit       26.0, efficiency     26.000 (+1 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    13 getlink *tmp3 :n
    14 set :block *tmp3
    15 sensor *tmp5 :block @type
-    * set *tmp6 *tmp5
-    * jump *label8 equal *tmp6 @memory-cell
+   16 jump *label8 equal *tmp5 @memory-cell
    17 jump *label7 always
    18 label *label8
    19 set .MEMORY :block
 
    21 set *tmp4 :lastCell
    22 jump *label6 always
    23 label *label7
-    * jump *label10 equal *tmp6 @memory-bank
+   24 jump *label10 equal *tmp5 @memory-bank
    25 jump *label9 always
    26 label *label10
    27 set .MEMORY :block
 
    29 set *tmp4 :lastCell
    30 jump *label6 always
    31 label *label9
-    * jump *label12 equal *tmp6 @plastanium-conveyor
+   32 jump *label12 equal *tmp5 @plastanium-conveyor
    33 jump *label11 always
    34 label *label12
    35 set .FIRST_BLOCK :n

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-8 instructions):
 
    18 label *label8
    19 set .MEMORY :block
    20 set :lastCell 63
-    * set *tmp4 :lastCell
    21 jump *label6 always
    22 label *label7
    23 jump *label10 equal *tmp5 @memory-bank
 
    25 label *label10
    26 set .MEMORY :block
    27 set :lastCell 511
-    * set *tmp4 :lastCell
    28 jump *label6 always
    29 label *label9
    30 jump *label12 equal *tmp5 @plastanium-conveyor
    31 jump *label11 always
    32 label *label12
    33 set .FIRST_BLOCK :n
-    * set *tmp4 .FIRST_BLOCK
    34 jump *label6 always
    35 label *label11
-    * set *tmp4 null
    36 label *label6
    37 label *label4
    38 jump *label3 always
 
   124 label *label21
   125 set *tmp34 null
   126 label *label22
-    * set *tmp26 *tmp34
   127 jump *label20 always
   128 label *label19
-    * set *tmp26 null
   129 label *label20
   130 label *label17
   131 jump *label16 always
 
   144 set :ratePerMin 0
   145 set *tmp59 @time
   146 set :startTime *tmp59
-    * set *tmp53 :startTime
   147 jump *label28 always
   148 label *label27
-    * set *tmp53 null
   149 label *label28
   150 print "Item Counter                  "
   151 print "\n"

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
   119 label *label23
   120 set *tmp37 null
   121 label *label24
-    * set *tmp34 *tmp37
   122 jump *label22 always
   123 label *label21
-    * set *tmp34 null
   124 label *label22
   125 jump *label20 always
   126 label *label19

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
   114 label *label25
   115 set *tmp47 null
   116 label *label26
-    * set *tmp37 *tmp47
   117 jump *label24 always
   118 label *label23
-    * set *tmp37 null
   119 label *label24
   120 jump *label22 always
   121 label *label21

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   109 op add *tmp48 :batch .BATCH_STEP
   110 op min *tmp49 *tmp48 .EFF_MAX_BATCH
   111 set :batch *tmp49
-    * set *tmp47 :batch
   112 jump *label26 always
   113 label *label25
-    * set *tmp47 null
   114 label *label26
   115 jump *label24 always
   116 label *label23

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-25 instructions):
 
     2 set :lastCell 0
     3 label *label0
     4 set .MEMORY null
-    * set *tmp0 @links
-    * set .FIRST_BLOCK *tmp0
-    * set *tmp1 @links
-    * set :n *tmp1
+    5 set .FIRST_BLOCK @links
+    6 set :n @links
     7 label *label3
     8 op greaterThan *tmp2 :n 0
     9 jump *label5 equal *tmp2 false
    10 op sub :n :n 1
-    * getlink *tmp3 :n
-    * set :block *tmp3
+   11 getlink :block :n
    12 sensor *tmp5 :block @type
    13 jump *label8 equal *tmp5 @memory-cell
    14 jump *label7 always
 
    40 op equal *tmp7 .MEMORY null
    41 jump *label0 notEqual *tmp7 false
    42 label *label2
-    * read *tmp9 .MEMORY 0
-    * set :total *tmp9
+   43 read :total .MEMORY 0
    44 set .BATCH_DURATION 2000
    45 op max *tmp10 MIN_BATCH 10
    46 op idiv *tmp11 *tmp10 10
-    * op mul *tmp12 *tmp11 10
-    * set .EFF_MIN_BATCH *tmp12
+   47 op mul .EFF_MIN_BATCH *tmp11 10
    48 op max *tmp13 MAX_BATCH .EFF_MIN_BATCH
    49 op idiv *tmp14 *tmp13 10
-    * op mul *tmp15 *tmp14 10
-    * set .EFF_MAX_BATCH *tmp15
+   50 op mul .EFF_MAX_BATCH *tmp14 10
    51 set .BATCH_STEP 10
    52 set :batch .EFF_MIN_BATCH
-    * set *tmp16 @time
-    * set :startTime *tmp16
+   53 set :startTime @time
    54 set :ratePerMin 0
-    * op add *tmp17 :total :batch
-    * set :limit *tmp17
+   55 op add :limit :total :batch
    56 control enabled switch1 0
    57 label *label13
    58 sensor *tmp19 switch1 @enabled
    59 op equal *tmp20 *tmp19 0
    60 jump *label15 equal *tmp20 false
-    * set *tmp21 @time
-    * set :start *tmp21
+   61 set :start @time
    62 set :n .FIRST_BLOCK
    63 label *label16
    64 op lessThan *tmp22 :n @links
    65 jump *label18 equal *tmp22 false
-    * getlink *tmp23 :n
-    * set :block *tmp23
+   66 getlink :block :n
    67 op add :n :n 1
    68 sensor *tmp24 :block @type
    69 op equal *tmp25 *tmp24 @plastanium-conveyor
    70 jump *label19 equal *tmp25 false
-    * set *tmp27 :n
-    * read *tmp29 .MEMORY *tmp27
-    * set :prev *tmp29
-    * sensor *tmp30 :block @totalItems
-    * set :curr *tmp30
-    * set *tmp31 :n
-    * write :curr .MEMORY *tmp31
+   71 read :prev .MEMORY :n
+   72 sensor :curr :block @totalItems
+   73 write :curr .MEMORY :n
    74 op lessThan *tmp33 :curr :prev
    75 jump *label21 equal *tmp33 false
    76 op add :total :total 10
    77 write :total .MEMORY 0
    78 op greaterThan *tmp36 :total :limit
    79 jump *label23 equal *tmp36 false
-    * op sub *tmp38 @time :startTime
-    * set :duration *tmp38
-    * set *tmp39 @time
-    * set :startTime *tmp39
+   80 op sub :duration @time :startTime
+   81 set :startTime @time
    82 op add :limit :limit :batch
-    * op div *tmp40 :batch :duration
-    * set :rate *tmp40
+   83 op div :rate :batch :duration
    84 set *tmp41 :lastCell
    85 op mul *tmp43 :rate 16.666666666666668
    86 write *tmp43 .MEMORY *tmp41
    87 op mul *tmp44 :rate 60000
-    * op floor *tmp45 *tmp44
-    * set :ratePerMin *tmp45
+   88 op floor :ratePerMin *tmp44
    89 op lessThanEq *tmp46 :duration .BATCH_DURATION
    90 jump *label25 equal *tmp46 false
    91 op add *tmp48 :batch .BATCH_STEP
-    * op min *tmp49 *tmp48 .EFF_MAX_BATCH
-    * set :batch *tmp49
+   92 op min :batch *tmp48 .EFF_MAX_BATCH
    93 jump *label26 always
    94 label *label25
    95 label *label26
 
   106 jump *label16 always
   107 label *label18
   108 op sub *tmp50 @time :startTime
-    * op floor *tmp51 *tmp50
-    * set :elapsed *tmp51
+  109 op floor :elapsed *tmp50
   110 op greaterThanEq *tmp52 :elapsed 10000
   111 jump *label27 equal *tmp52 false
   112 op idiv *tmp54 :batch 90
   113 op mul *tmp55 *tmp54 10
-    * op max *tmp56 *tmp55 .EFF_MIN_BATCH
-    * set :batch *tmp56
-    * set *tmp57 :lastCell
-    * write 0 .MEMORY *tmp57
+  114 op max :batch *tmp55 .EFF_MIN_BATCH
+  115 write 0 .MEMORY :lastCell
   116 set :ratePerMin 0
-    * set *tmp59 @time
-    * set :startTime *tmp59
+  117 set :startTime @time
   118 jump *label28 always
   119 label *label27
   120 label *label28
 
   151 jump *label13 always
   152 label *label15
   153 control enabled switch1 0
-    * set *tmp63 :lastCell
-    * write 0 .MEMORY *tmp63
+  154 write 0 .MEMORY :lastCell
   155 set :n 0
   156 label *label29
   157 op lessThan *tmp65 :n @links
   158 jump *label31 equal *tmp65 false
-    * set *tmp66 :n
-    * write 0 .MEMORY *tmp66
+  159 write 0 .MEMORY :n
   160 op add :n :n 1
   161 label *label30
   162 jump *label29 always

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
    10 op sub :n :n 1
    11 getlink :block :n
    12 sensor *tmp5 :block @type
-    * jump *label8 equal *tmp5 @memory-cell
-    * jump *label7 always
+   13 jump *label7 notEqual *tmp5 @memory-cell
    14 label *label8
    15 set .MEMORY :block
    16 set :lastCell 63
    17 jump *label6 always
    18 label *label7
-    * jump *label10 equal *tmp5 @memory-bank
-    * jump *label9 always
+   19 jump *label9 notEqual *tmp5 @memory-bank
    20 label *label10
    21 set .MEMORY :block
    22 set :lastCell 511
    23 jump *label6 always
    24 label *label9
-    * jump *label12 equal *tmp5 @plastanium-conveyor
-    * jump *label11 always
+   25 jump *label11 notEqual *tmp5 @plastanium-conveyor
    26 label *label12
    27 set .FIRST_BLOCK :n
    28 jump *label6 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-10 instructions):
 
     5 set .FIRST_BLOCK @links
     6 set :n @links
     7 label *label3
-    * op greaterThan *tmp2 :n 0
-    * jump *label5 equal *tmp2 false
+    8 jump *label5 lessThanEq :n 0
     9 op sub :n :n 1
    10 getlink :block :n
    11 sensor *tmp5 :block @type
 
    33 print "Item Counter\n[salmon]No memory attached."
    34 printflush message1
    35 label *label1
-    * op equal *tmp7 .MEMORY null
-    * jump *label0 notEqual *tmp7 false
+   36 jump *label0 equal .MEMORY null
    37 label *label2
    38 read :total .MEMORY 0
    39 set .BATCH_DURATION 2000
 
    51 control enabled switch1 0
    52 label *label13
    53 sensor *tmp19 switch1 @enabled
-    * op equal *tmp20 *tmp19 0
-    * jump *label15 equal *tmp20 false
+   54 jump *label15 notEqual *tmp19 0
    55 set :start @time
    56 set :n .FIRST_BLOCK
    57 label *label16
-    * op lessThan *tmp22 :n @links
-    * jump *label18 equal *tmp22 false
+   58 jump *label18 greaterThanEq :n @links
    59 getlink :block :n
    60 op add :n :n 1
    61 sensor *tmp24 :block @type
-    * op equal *tmp25 *tmp24 @plastanium-conveyor
-    * jump *label19 equal *tmp25 false
+   62 jump *label19 notEqual *tmp24 @plastanium-conveyor
    63 read :prev .MEMORY :n
    64 sensor :curr :block @totalItems
    65 write :curr .MEMORY :n
-    * op lessThan *tmp33 :curr :prev
-    * jump *label21 equal *tmp33 false
+   66 jump *label21 greaterThanEq :curr :prev
    67 op add :total :total 10
    68 write :total .MEMORY 0
-    * op greaterThan *tmp36 :total :limit
-    * jump *label23 equal *tmp36 false
+   69 jump *label23 lessThanEq :total :limit
    70 op sub :duration @time :startTime
    71 set :startTime @time
    72 op add :limit :limit :batch
 
    76 write *tmp43 .MEMORY *tmp41
    77 op mul *tmp44 :rate 60000
    78 op floor :ratePerMin *tmp44
-    * op lessThanEq *tmp46 :duration .BATCH_DURATION
-    * jump *label25 equal *tmp46 false
+   79 jump *label25 greaterThan :duration .BATCH_DURATION
    80 op add *tmp48 :batch .BATCH_STEP
    81 op min :batch *tmp48 .EFF_MAX_BATCH
    82 jump *label26 always
 
    96 label *label18
    97 op sub *tmp50 @time :startTime
    98 op floor :elapsed *tmp50
-    * op greaterThanEq *tmp52 :elapsed 10000
-    * jump *label27 equal *tmp52 false
+   99 jump *label27 lessThan :elapsed 10000
   100 op idiv *tmp54 :batch 90
   101 op mul *tmp55 *tmp54 10
   102 op max :batch *tmp55 .EFF_MIN_BATCH
 
   142 write 0 .MEMORY :lastCell
   143 set :n 0
   144 label *label29
-    * op lessThan *tmp65 :n @links
-    * jump *label31 equal *tmp65 false
+  145 jump *label31 greaterThanEq :n @links
   146 write 0 .MEMORY :n
   147 op add :n :n 1
   148 label *label30

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-6 instructions):
 
    24 jump *label11 notEqual *tmp5 @plastanium-conveyor
    25 label *label12
    26 set .FIRST_BLOCK :n
-    * jump *label6 always
    27 label *label11
    28 label *label6
    29 label *label4
 
    78 jump *label25 greaterThan :duration .BATCH_DURATION
    79 op add *tmp48 :batch .BATCH_STEP
    80 op min :batch *tmp48 .EFF_MAX_BATCH
-    * jump *label26 always
    81 label *label25
    82 label *label26
-    * jump *label24 always
    83 label *label23
    84 label *label24
-    * jump *label22 always
    85 label *label21
    86 label *label22
-    * jump *label20 always
    87 label *label19
    88 label *label20
    89 label *label17
 
    98 write 0 .MEMORY :lastCell
    99 set :ratePerMin 0
   100 set :startTime @time
-    * jump *label28 always
   101 label *label27
   102 label *label28
   103 print "Item Counter                  "

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    73 set *tmp41 :lastCell
    74 op mul *tmp43 :rate 16.666666666666668
    75 write *tmp43 .MEMORY *tmp41
-    * op mul *tmp44 :rate 60000
-    * op floor :ratePerMin *tmp44
+   76 op idiv :ratePerMin :rate 0.000016666666666666667
    77 jump *label25 greaterThan :duration .BATCH_DURATION
    78 op add *tmp48 :batch .BATCH_STEP
    79 op min :batch *tmp48 .EFF_MAX_BATCH

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    46 set :batch .EFF_MIN_BATCH
    47 set :startTime @time
    48 set :ratePerMin 0
-    * op add :limit :total :batch
+   49 op add :limit :total .EFF_MIN_BATCH
    50 control enabled switch1 0
    51 label *label13
    52 sensor *tmp19 switch1 @enabled
 
    72 op div :rate :batch :duration
    73 set *tmp41 :lastCell
    74 op mul *tmp43 :rate 16.666666666666668
-    * write *tmp43 .MEMORY *tmp41
+   75 write *tmp43 .MEMORY :lastCell
    76 op idiv :ratePerMin :rate 0.000016666666666666667
-    * jump *label25 greaterThan :duration .BATCH_DURATION
-    * op add *tmp48 :batch .BATCH_STEP
+   77 jump *label25 greaterThan :duration 2000
+   78 op add *tmp48 :batch 10
    79 op min :batch *tmp48 .EFF_MAX_BATCH
    80 label *label25
    81 label *label26

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    35 jump *label0 equal .MEMORY null
    36 label *label2
    37 read :total .MEMORY 0
-    * set .BATCH_DURATION 2000
    38 op max *tmp10 MIN_BATCH 10
    39 op idiv *tmp11 *tmp10 10
    40 op mul .EFF_MIN_BATCH *tmp11 10
    41 op max *tmp13 MAX_BATCH .EFF_MIN_BATCH
    42 op idiv *tmp14 *tmp13 10
    43 op mul .EFF_MAX_BATCH *tmp14 10
-    * set .BATCH_STEP 10
    44 set :batch .EFF_MIN_BATCH
    45 set :startTime @time
    46 set :ratePerMin 0
 
    68 set :startTime @time
    69 op add :limit :limit :batch
    70 op div :rate :batch :duration
-    * set *tmp41 :lastCell
    71 op mul *tmp43 :rate 16.666666666666668
    72 write *tmp43 .MEMORY :lastCell
    73 op idiv :ratePerMin :rate 0.000016666666666666667

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     6 set :n @links
     7 label *label3
     8 jump *label5 lessThanEq :n 0
+    9 label *label32
    10 op sub :n :n 1
    11 getlink :block :n
    12 sensor *tmp5 :block @type
 
    28 label *label11
    29 label *label6
    30 label *label4
-    * jump *label3 always
+   31 jump *label32 greaterThan :n 0
    32 label *label5
    33 print "Item Counter\n[salmon]No memory attached."
    34 printflush message1
 
    54 set :n .FIRST_BLOCK
    55 label *label16
    56 jump *label18 greaterThanEq :n @links
+   57 label *label33
    58 getlink :block :n
    59 op add :n :n 1
    60 sensor *tmp24 :block @type
 
    85 label *label19
    86 label *label20
    87 label *label17
-    * jump *label16 always
+   88 jump *label33 lessThan :n @links
    89 label *label18
    90 op sub *tmp50 @time :startTime
    91 op floor :elapsed *tmp50
 
   135 set :n 0
   136 label *label29
   137 jump *label31 greaterThanEq :n @links
+  138 label *label34
   139 write 0 .MEMORY :n
   140 op add :n :n 1
   141 label *label30
-    * jump *label29 always
+  142 jump *label34 lessThan :n @links
   143 label *label31
   144 end

Modifications by Full loop rotation at line 39:1 (+1 instructions):
 
    50 label *label13
    51 sensor *tmp19 switch1 @enabled
    52 jump *label15 notEqual *tmp19 0
+   53 label *label35
    54 set :start @time
    55 set :n .FIRST_BLOCK
    56 label *label16
 
   129 print "ms"
   130 printflush message1
   131 label *label14
-    * jump *label13 always
+  132 sensor *tmp19 switch1 @enabled
+  133 jump *label35 equal *tmp19 0
   134 label *label15
   135 control enabled switch1 0
   136 write 0 .MEMORY :lastCell

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    54 set :start @time
    55 set :n .FIRST_BLOCK
    56 label *label16
-    * jump *label18 greaterThanEq :n @links
+   57 jump *label18 greaterThanEq .FIRST_BLOCK @links
    58 label *label33
    59 getlink :block :n
    60 op add :n :n 1
 
   136 write 0 .MEMORY :lastCell
   137 set :n 0
   138 label *label29
-    * jump *label31 greaterThanEq :n @links
+  139 jump *label31 greaterThanEq 0 @links
   140 label *label34
   141 write 0 .MEMORY :n
   142 op add :n :n 1

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
+    0 label __start__
     1 set MIN_BATCH 10
     2 set MAX_BATCH 1000
     3 set :lastCell 0
 
   120 control enabled switch1 0
   121 write 0 .MEMORY :lastCell
   122 set :n 0
-    * jump *label31 greaterThanEq 0 @links
+  123 jump __start__ greaterThanEq 0 @links
   124 label *label34
   125 write 0 .MEMORY :n
   126 op add :n :n 1

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
   125 write 0 .MEMORY :n
   126 op add :n :n 1
   127 jump *label34 lessThan :n @links
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-20 instructions):
 
    85 set :ratePerMin 0
    86 set :startTime @time
    87 label *label27
-    * print "Item Counter                  "
-    * print "\n"
-    * print "Total items: [gold]"
-    * print :total
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "Rate: [green]"
-    * print :ratePerMin
-    * print "["
-    * print "] items/min"
-    * print "\n"
-    * print "Batch size: [green]"
-    * print :batch
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "Batch time: [gold]"
-    * print :elapsed
-    * print "["
-    * print "] ms"
-    * print "\n"
+   88 print "Item Counter                  \nTotal items: [gold]{0}[]\nRate: [green]{0}[] items/min\nBatch size: [green]{0}[]\nBatch time: [gold]{0}[] ms\n[lightgray]Loop time: {0} ms"
+   89 format :total
+   90 format :ratePerMin
+   91 format :batch
+   92 format :elapsed
    93 op sub *tmp60 @time :start
    94 op floor *tmp61 *tmp60
-    * print "[lightgray]Loop time: "
-    * print *tmp61
-    * print " "
-    * print "ms"
+   95 format *tmp61
    96 printflush message1
    97 sensor *tmp19 switch1 @enabled
    98 jump *label35 equal *tmp19 0

Final code before resolving virtual instructions:

label __start__
set MIN_BATCH 10
set MAX_BATCH 1000
set :lastCell 0
label *label0
set .MEMORY null
set .FIRST_BLOCK @links
set :n @links
jump *label5 lessThanEq :n 0
label *label32
op sub :n :n 1
getlink :block :n
sensor *tmp5 :block @type
jump *label7 notEqual *tmp5 @memory-cell
set .MEMORY :block
set :lastCell 63
jump *label6 always
label *label7
jump *label9 notEqual *tmp5 @memory-bank
set .MEMORY :block
set :lastCell 511
jump *label6 always
label *label9
jump *label11 notEqual *tmp5 @plastanium-conveyor
set .FIRST_BLOCK :n
label *label11
label *label6
jump *label32 greaterThan :n 0
label *label5
print "Item Counter\n[salmon]No memory attached."
printflush message1
jump *label0 equal .MEMORY null
read :total .MEMORY 0
op max *tmp10 MIN_BATCH 10
op idiv *tmp11 *tmp10 10
op mul .EFF_MIN_BATCH *tmp11 10
op max *tmp13 MAX_BATCH .EFF_MIN_BATCH
op idiv *tmp14 *tmp13 10
op mul .EFF_MAX_BATCH *tmp14 10
set :batch .EFF_MIN_BATCH
set :startTime @time
set :ratePerMin 0
op add :limit :total .EFF_MIN_BATCH
control enabled switch1 0
sensor *tmp19 switch1 @enabled
jump *label15 notEqual *tmp19 0
label *label35
set :start @time
set :n .FIRST_BLOCK
jump *label18 greaterThanEq .FIRST_BLOCK @links
label *label33
getlink :block :n
op add :n :n 1
sensor *tmp24 :block @type
jump *label19 notEqual *tmp24 @plastanium-conveyor
read :prev .MEMORY :n
sensor :curr :block @totalItems
write :curr .MEMORY :n
jump *label21 greaterThanEq :curr :prev
op add :total :total 10
write :total .MEMORY 0
jump *label23 lessThanEq :total :limit
op sub :duration @time :startTime
set :startTime @time
op add :limit :limit :batch
op div :rate :batch :duration
op mul *tmp43 :rate 16.666666666666668
write *tmp43 .MEMORY :lastCell
op idiv :ratePerMin :rate 0.000016666666666666667
jump *label25 greaterThan :duration 2000
op add *tmp48 :batch 10
op min :batch *tmp48 .EFF_MAX_BATCH
label *label25
label *label23
label *label21
label *label19
jump *label33 lessThan :n @links
label *label18
op sub *tmp50 @time :startTime
op floor :elapsed *tmp50
jump *label27 lessThan :elapsed 10000
op idiv *tmp54 :batch 90
op mul *tmp55 *tmp54 10
op max :batch *tmp55 .EFF_MIN_BATCH
write 0 .MEMORY :lastCell
set :ratePerMin 0
set :startTime @time
label *label27
print "Item Counter                  \nTotal items: [gold]{0}[]\nRate: [green]{0}[] items/min\nBatch size: [green]{0}[]\nBatch time: [gold]{0}[] ms\n[lightgray]Loop time: {0} ms"
format :total
format :ratePerMin
format :batch
format :elapsed
op sub *tmp60 @time :start
op floor *tmp61 *tmp60
format *tmp61
printflush message1
sensor *tmp19 switch1 @enabled
jump *label35 equal *tmp19 0
label *label15
control enabled switch1 0
write 0 .MEMORY :lastCell
set :n 0
jump __start__ greaterThanEq 0 @links
label *label34
write 0 .MEMORY :n
op add :n :n 1
jump *label34 lessThan :n @links
