   318 instructions before optimizations.
    39 instructions eliminated by Temp Variables Elimination (2 iterations).
     1 instructions eliminated by Case Expression Optimization.
    30 instructions eliminated by Dead Code Elimination (2 passes, 7 iterations).
    22 instructions eliminated by Jump Optimization (5 iterations).
    12 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     1 instructions modified by Expression Optimization (3 iterations).
     3 instructions eliminated by If Expression Optimization (3 iterations).
     9 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
     5 instructions modified by Loop Optimization (3 iterations).
     5 loops improved by Loop Optimization.
     3 instructions eliminated by Case Switching (5 iterations).
     1 case expressions converted to switched jumps Case Switching.
     4 instructions eliminated by Jump Straightening (5 iterations).
     1 instructions updated by Jump Threading.
    14 instructions eliminated by Print Merging.
   181 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 793):
  * Replicate loop condition at line 91:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  o Convert case at line 17:9 (segments: 1, padded low)          size    -3, benefit      312.5, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 792):
  * Convert case at line 17:9 (segments: 1, padded low)          size    -3, benefit      312.5, efficiency   Infinity (-3 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    22 print :block
    23 print "\n"
    24 sensor *tmp6 :block @type
-    * set *tmp7 *tmp6
-    * jump *label8 equal *tmp7 @message
+   25 jump *label8 equal *tmp6 @message
    26 jump *label7 always
    27 label *label8
    28 set .MESSAGE :block
    29 set *tmp5 .MESSAGE
    30 jump *label6 always
    31 label *label7
-    * jump *label10 equal *tmp7 @switch
+   32 jump *label10 equal *tmp6 @switch
    33 jump *label9 always
    34 label *label10
    35 set .SWITCH :block
    36 set *tmp5 .SWITCH
    37 jump *label6 always
    38 label *label9
-    * jump *label12 equal *tmp7 @logic-display
-    * jump *label12 equal *tmp7 @large-logic-display
+   39 jump *label12 equal *tmp6 @logic-display
+   40 jump *label12 equal *tmp6 @large-logic-display
    41 jump *label11 always
    42 label *label12
    43 set .DISPLAY :block
    44 set *tmp5 .DISPLAY
    45 jump *label6 always
    46 label *label11
-    * jump *label14 equal *tmp7 @memory-bank
-    * jump *label14 equal *tmp7 @memory-cell
+   47 jump *label14 equal *tmp6 @memory-bank
+   48 jump *label14 equal *tmp6 @memory-cell
    49 jump *label13 always
    50 label *label14
    51 set .MEMORY :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-21 instructions):
 
    26 jump *label7 always
    27 label *label8
    28 set .MESSAGE :block
-    * set *tmp5 .MESSAGE
    29 jump *label6 always
    30 label *label7
    31 jump *label10 equal *tmp6 @switch
    32 jump *label9 always
    33 label *label10
    34 set .SWITCH :block
-    * set *tmp5 .SWITCH
    35 jump *label6 always
    36 label *label9
    37 jump *label12 equal *tmp6 @logic-display
 
    39 jump *label11 always
    40 label *label12
    41 set .DISPLAY :block
-    * set *tmp5 .DISPLAY
    42 jump *label6 always
    43 label *label11
    44 jump *label14 equal *tmp6 @memory-bank
 
    46 jump *label13 always
    47 label *label14
    48 set .MEMORY :block
-    * set *tmp5 .MEMORY
    49 jump *label6 always
    50 label *label13
-    * set *tmp5 null
    51 label *label6
    52 label *label4
    53 jump *label3 always
 
    68 jump *label15 equal *tmp8 false
    69 print "No display."
    70 print "\n"
-    * set *tmp9 "No display."
    71 jump *label16 always
    72 label *label15
-    * set *tmp9 null
    73 label *label16
    74 printflush .MESSAGE
    75 label *label1
 
   113 op sub *tmp23 *tmp20 :cly
   114 set :clh *tmp23
   115 set :crh :clh
-    * set *tmp12 :crh
   116 jump *label18 always
   117 label *label17
   118 set .OFFSET_X 5
 
   219 label *label34
   220 set *tmp25 *tmp55
   221 label *label24
-    * set *tmp12 *tmp25
   222 label *label18
   223 op idiv *tmp67 .BAR_LENGTH 2
   224 set .HALF_BAR *tmp67
 
   237 op add :n :n 1
   238 jump *label39 always
   239 label *label41
-    * set *tmp70 null
   240 jump *label38 always
   241 label *label37
-    * set *tmp70 null
   242 label *label38
   243 set *tmp74 .SWITCH
   244 control enabled *tmp74 0
 
   296 set .MAX *tmp103
   297 op div *tmp104 .BAR_LENGTH .MAX
   298 set .MUL *tmp104
-    * set *tmp102 .MUL
   299 jump *label51 always
   300 label *label50
-    * set *tmp102 null
   301 label *label51
   302 op lessThanEq *tmp105 .MAX CAPACITY
   303 jump *label52 equal *tmp105 false
   304 draw color 0 128 0 255
-    * set *tmp106 null
   305 jump *label53 always
   306 label *label52
   307 draw color 128 128 0 255
-    * set *tmp106 null
   308 label *label53
   309 op mul *tmp107 :items .MUL
   310 draw rect :x :y *tmp107 .BAR_WIDTH
 
   313 draw color 220 220 220 255
   314 op mul *tmp110 :maxx .MUL
   315 draw lineRect :x :y *tmp110 .BAR_WIDTH
-    * set *tmp109 null
   316 jump *label55 always
   317 label *label54
-    * set *tmp109 null
   318 label *label55
   319 op lessThanEq *tmp111 .MAX CAPACITY
   320 jump *label56 equal *tmp111 false
   321 draw color 0 255 0 255
   322 draw lineRect :x :y .BAR_LENGTH .BAR_WIDTH
-    * set *tmp112 null
   323 jump *label57 always
   324 label *label56
   325 draw color 255 255 0 255
   326 draw lineRect :x :y .HALF_BAR .BAR_WIDTH
   327 op add *tmp113 :x .HALF_BAR
   328 draw lineRect *tmp113 :y .HALF_BAR .BAR_WIDTH
-    * set *tmp112 null
   329 label *label57
   330 op add *tmp114 :index 1
   331 set :index *tmp114
-    * set *tmp83 :index
   332 jump *label49 always
   333 label *label48
-    * set *tmp83 null
   334 label *label49
   335 label *label46
   336 op add *tmp115 :n 1

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
   158 op sub *tmp42 *tmp38 :cry
   159 set :clh *tmp42
   160 set :crh :clh
-    * set *tmp25 :crh
   161 jump *label24 always
   162 label *label23
   163 set :clx 0
 
   216 label *label33
   217 set *tmp55 null
   218 label *label34
-    * set *tmp25 *tmp55
   219 label *label24
   220 label *label18
   221 op idiv *tmp67 .BAR_LENGTH 2

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-2 instructions):
 
   211 label *label36
   212 op sub *tmp66 *tmp62 :cry
   213 set :crh *tmp66
-    * set *tmp55 :crh
   214 jump *label34 always
   215 label *label33
-    * set *tmp55 null
   216 label *label34
   217 label *label24
   218 label *label18

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-39 instructions):
 
     9 jump *label2 equal *tmp0 false
    10 print "Mass Driver Monitor"
    11 print "\n"
-    * set *tmp1 @links
-    * set :n *tmp1
+   12 set :n @links
    13 label *label3
    14 op greaterThan *tmp2 :n 0
    15 jump *label5 equal *tmp2 false
-    * op sub *tmp3 :n 1
-    * set :n *tmp3
-    * getlink *tmp4 :n
-    * set :block *tmp4
+   16 op sub :n :n 1
+   17 getlink :block :n
    18 print "Found: "
    19 print :block
    20 print "\n"
 
    84 set :clx 0
    85 set :crx :clx
    86 op add *tmp13 .OFFSET_X .BAR_SPACE
-    * op sub *tmp14 *tmp13 2
-    * set :clw *tmp14
+   87 op sub :clw *tmp13 2
    88 set :crw :clw
    89 op equal *tmp15 FROM_INDEX 0
    90 jump *label19 equal *tmp15 false
 
    92 jump *label20 always
    93 label *label19
    94 op mul *tmp17 FROM_INDEX .BAR_GAP
-    * op add *tmp18 .OFFSET_Y *tmp17
-    * set *tmp16 *tmp18
+   95 op add *tmp16 .OFFSET_Y *tmp17
    96 label *label20
    97 set :cly *tmp16
    98 set :cry :cly
    99 op lessThan *tmp19 TO_INDEX 8
   100 jump *label21 equal *tmp19 false
   101 op mul *tmp21 TO_INDEX .BAR_GAP
-    * op add *tmp22 .OFFSET_Y *tmp21
-    * set *tmp20 *tmp22
+  102 op add *tmp20 .OFFSET_Y *tmp21
   103 jump *label22 always
   104 label *label21
   105 set *tmp20 176
   106 label *label22
-    * op sub *tmp23 *tmp20 :cly
-    * set :clh *tmp23
+  107 op sub :clh *tmp20 :cly
   108 set :crh :clh
   109 jump *label18 always
   110 label *label17
 
   117 op greaterThanEq *tmp24 FROM_INDEX 8
   118 jump *label23 equal *tmp24 false
   119 op add *tmp26 .OFFSET_X .BAR_SPACE
-    * op sub *tmp27 *tmp26 2
-    * set :clx *tmp27
+  120 op sub :clx *tmp26 2
   121 set :crx :clx
   122 op add *tmp28 .OFFSET_X .BAR_SPACE
   123 op sub *tmp29 176 *tmp28
-    * op add *tmp30 *tmp29 1
-    * set :clw *tmp30
+  124 op add :clw *tmp29 1
   125 set :crw :clw
   126 op mod *tmp31 FROM_INDEX 8
   127 op equal *tmp32 *tmp31 0
 
   131 label *label25
   132 op mod *tmp34 FROM_INDEX 8
   133 op mul *tmp35 *tmp34 .BAR_GAP
-    * op add *tmp36 .OFFSET_Y *tmp35
-    * set *tmp33 *tmp36
+  134 op add *tmp33 .OFFSET_Y *tmp35
   135 label *label26
   136 set :cly *tmp33
   137 set :cry :cly
 
   139 jump *label27 equal *tmp37 false
   140 op mod *tmp39 TO_INDEX 8
   141 op mul *tmp40 *tmp39 .BAR_GAP
-    * op add *tmp41 .OFFSET_Y *tmp40
-    * set *tmp38 *tmp41
+  142 op add *tmp38 .OFFSET_Y *tmp40
   143 jump *label28 always
   144 label *label27
   145 set *tmp38 176
   146 label *label28
-    * op sub *tmp42 *tmp38 :cry
-    * set :clh *tmp42
+  147 op sub :clh *tmp38 :cry
   148 set :crh :clh
   149 jump *label24 always
   150 label *label23
   151 set :clx 0
   152 set :crx :clx
   153 op add *tmp43 .OFFSET_X .BAR_SPACE
-    * op sub *tmp44 *tmp43 2
-    * set :clw *tmp44
+  154 op sub :clw *tmp43 2
   155 set :crw :clw
   156 op equal *tmp45 FROM_INDEX 0
   157 jump *label29 equal *tmp45 false
 
   159 jump *label30 always
   160 label *label29
   161 op mul *tmp47 FROM_INDEX .BAR_GAP
-    * op add *tmp48 .OFFSET_Y *tmp47
-    * set *tmp46 *tmp48
+  162 op add *tmp46 .OFFSET_Y *tmp47
   163 label *label30
   164 set :cly *tmp46
   165 set :cry :cly
   166 op lessThan *tmp49 TO_INDEX 8
   167 jump *label31 equal *tmp49 false
   168 op mul *tmp51 TO_INDEX .BAR_GAP
-    * op add *tmp52 .OFFSET_Y *tmp51
-    * set *tmp50 *tmp52
+  169 op add *tmp50 .OFFSET_Y *tmp51
   170 jump *label32 always
   171 label *label31
   172 set *tmp50 176
   173 label *label32
-    * op sub *tmp53 *tmp50 :cly
-    * set :clh *tmp53
+  174 op sub :clh *tmp50 :cly
   175 set :crh :clh
   176 op greaterThanEq *tmp54 TO_INDEX 8
   177 jump *label33 equal *tmp54 false
   178 op add *tmp56 .OFFSET_X .BAR_SPACE
-    * op sub *tmp57 *tmp56 2
-    * set :crx *tmp57
+  179 op sub :crx *tmp56 2
   180 op add *tmp58 .OFFSET_X .BAR_SPACE
   181 op sub *tmp59 176 *tmp58
-    * op add *tmp60 *tmp59 1
-    * set :crw *tmp60
+  182 op add :crw *tmp59 1
   183 set :cry 0
   184 op lessThan *tmp61 TO_INDEX 16
   185 jump *label35 equal *tmp61 false
   186 op mod *tmp63 TO_INDEX 8
   187 op mul *tmp64 *tmp63 .BAR_GAP
-    * op add *tmp65 .OFFSET_Y *tmp64
-    * set *tmp62 *tmp65
+  188 op add *tmp62 .OFFSET_Y *tmp64
   189 jump *label36 always
   190 label *label35
   191 set *tmp62 176
   192 label *label36
-    * op sub *tmp66 *tmp62 :cry
-    * set :crh *tmp66
+  193 op sub :crh *tmp62 :cry
   194 jump *label34 always
   195 label *label33
   196 label *label34
   197 label *label24
   198 label *label18
-    * op idiv *tmp67 .BAR_LENGTH 2
-    * set .HALF_BAR *tmp67
+  199 op idiv .HALF_BAR .BAR_LENGTH 2
   200 set .MAX CAPACITY
-    * op div *tmp68 .BAR_LENGTH .MAX
-    * set .MUL *tmp68
+  201 op div .MUL .BAR_LENGTH .MAX
   202 op notEqual *tmp69 .MEMORY null
   203 jump *label37 equal *tmp69 false
   204 set :n 0
   205 label *label39
   206 op lessThan *tmp71 :n @links
   207 jump *label41 equal *tmp71 false
-    * set *tmp72 :n
-    * write 0 .MEMORY *tmp72
+  208 write 0 .MEMORY :n
   209 label *label40
   210 op add :n :n 1
   211 jump *label39 always
 
   213 jump *label38 always
   214 label *label37
   215 label *label38
-    * set *tmp74 .SWITCH
-    * control enabled *tmp74 0
+  216 control enabled .SWITCH 0
   217 label *label42
   218 sensor *tmp76 .SWITCH @enabled
   219 op equal *tmp77 *tmp76 0
   220 jump *label44 equal *tmp77 false
-    * set *tmp78 @time
-    * set :start *tmp78
+  221 set :start @time
   222 draw color 0 0 80 255
   223 draw rect :clx :cly :clw :clh
   224 draw rect :crx :cry :crw :crh
 
   228 label *label45
   229 op lessThan *tmp79 :n @links
   230 jump *label47 equal *tmp79 false
-    * getlink *tmp80 :n
-    * set :driver *tmp80
+  231 getlink :driver :n
   232 sensor *tmp81 :driver @type
   233 op equal *tmp82 *tmp81 @mass-driver
   234 jump *label48 equal *tmp82 false
-    * op idiv *tmp84 :index 8
-    * set :column *tmp84
-    * op mod *tmp85 :index 8
-    * set :row *tmp85
+  235 op idiv :column :index 8
+  236 op mod :row :index 8
   237 op mul *tmp86 :column .BAR_SPACE
-    * op add *tmp87 .OFFSET_X *tmp86
-    * set :x *tmp87
+  238 op add :x .OFFSET_X *tmp86
   239 op mul *tmp88 :row .BAR_GAP
-    * op add *tmp89 .OFFSET_Y *tmp88
-    * set :y *tmp89
+  240 op add :y .OFFSET_Y *tmp88
   241 draw color 0 0 80 255
   242 op sub *tmp90 :x 1
   243 op sub *tmp91 :y 1
 
   246 op add *tmp92 :x 7
   247 op add *tmp93 :y 7
   248 draw image *tmp92 *tmp93 @mass-driver 16 0
-    * op add *tmp94 :x 16
-    * set :x *tmp94
-    * sensor *tmp95 :driver @totalItems
-    * set :items *tmp95
-    * set *tmp96 :n
-    * read *tmp97 .MEMORY *tmp96
-    * op max *tmp98 *tmp97 :items
-    * set :maxx *tmp98
-    * set *tmp99 :n
-    * write :maxx .MEMORY *tmp99
+  249 op add :x :x 16
+  250 sensor :items :driver @totalItems
+  251 read *tmp97 .MEMORY :n
+  252 op max :maxx *tmp97 :items
+  253 write :maxx .MEMORY :n
   254 op greaterThan *tmp101 :maxx .MAX
   255 jump *label50 equal *tmp101 false
-    * op mul *tmp103 2 CAPACITY
-    * set .MAX *tmp103
-    * op div *tmp104 .BAR_LENGTH .MAX
-    * set .MUL *tmp104
+  256 op mul .MAX 2 CAPACITY
+  257 op div .MUL .BAR_LENGTH .MAX
   258 jump *label51 always
   259 label *label50
   260 label *label51
 
   286 op add *tmp113 :x .HALF_BAR
   287 draw lineRect *tmp113 :y .HALF_BAR .BAR_WIDTH
   288 label *label57
-    * op add *tmp114 :index 1
-    * set :index *tmp114
+  289 op add :index :index 1
   290 jump *label49 always
   291 label *label48
   292 label *label49
   293 label *label46
-    * op add *tmp115 :n 1
-    * set :n *tmp115
+  294 op add :n :n 1
   295 jump *label45 always
   296 label *label47
   297 drawflush .DISPLAY

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-4 instructions):
 
    19 print :block
    20 print "\n"
    21 sensor *tmp6 :block @type
-    * jump *label8 equal *tmp6 @message
-    * jump *label7 always
+   22 jump *label7 notEqual *tmp6 @message
    23 label *label8
    24 set .MESSAGE :block
    25 jump *label6 always
    26 label *label7
-    * jump *label10 equal *tmp6 @switch
-    * jump *label9 always
+   27 jump *label9 notEqual *tmp6 @switch
    28 label *label10
    29 set .SWITCH :block
    30 jump *label6 always
    31 label *label9
    32 jump *label12 equal *tmp6 @logic-display
-    * jump *label12 equal *tmp6 @large-logic-display
-    * jump *label11 always
+   33 jump *label11 notEqual *tmp6 @large-logic-display
    34 label *label12
    35 set .DISPLAY :block
    36 jump *label6 always
    37 label *label11
    38 jump *label14 equal *tmp6 @memory-bank
-    * jump *label14 equal *tmp6 @memory-cell
-    * jump *label13 always
+   39 jump *label13 notEqual *tmp6 @memory-cell
    40 label *label14
    41 set .MEMORY :block
    42 jump *label6 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-22 instructions):
 
     5 set .SWITCH null
     6 set .MESSAGE .SWITCH
     7 label *label0
-    * op equal *tmp0 .DISPLAY null
-    * jump *label2 equal *tmp0 false
+    8 jump *label2 notEqual .DISPLAY null
     9 print "Mass Driver Monitor"
    10 print "\n"
    11 set :n @links
    12 label *label3
-    * op greaterThan *tmp2 :n 0
-    * jump *label5 equal *tmp2 false
+   13 jump *label5 lessThanEq :n 0
    14 op sub :n :n 1
    15 getlink :block :n
    16 print "Found: "
 
    55 print "Display: "
    56 print .DISPLAY
    57 print "\n"
-    * op equal *tmp8 .DISPLAY null
-    * jump *label15 equal *tmp8 false
+   58 jump *label15 notEqual .DISPLAY null
    59 print "No display."
    60 print "\n"
    61 jump *label16 always
 
    66 jump *label0 always
    67 label *label2
    68 sensor *tmp10 .DISPLAY @type
-    * op equal *tmp11 *tmp10 @logic-display
-    * jump *label17 equal *tmp11 false
+   69 jump *label17 notEqual *tmp10 @logic-display
    70 set .OFFSET_X 2
    71 set .OFFSET_Y 2
    72 set .BAR_WIDTH 14
 
    78 op add *tmp13 .OFFSET_X .BAR_SPACE
    79 op sub :clw *tmp13 2
    80 set :crw :clw
-    * op equal *tmp15 FROM_INDEX 0
-    * jump *label19 equal *tmp15 false
+   81 jump *label19 notEqual FROM_INDEX 0
    82 set *tmp16 0
    83 jump *label20 always
    84 label *label19
 
    87 label *label20
    88 set :cly *tmp16
    89 set :cry :cly
-    * op lessThan *tmp19 TO_INDEX 8
-    * jump *label21 equal *tmp19 false
+   90 jump *label21 greaterThanEq TO_INDEX 8
    91 op mul *tmp21 TO_INDEX .BAR_GAP
    92 op add *tmp20 .OFFSET_Y *tmp21
    93 jump *label22 always
 
   104 set .BAR_LENGTH 60
   105 set .BAR_SPACE 88
   106 set .BAR_GAP 22
-    * op greaterThanEq *tmp24 FROM_INDEX 8
-    * jump *label23 equal *tmp24 false
+  107 jump *label23 lessThan FROM_INDEX 8
   108 op add *tmp26 .OFFSET_X .BAR_SPACE
   109 op sub :clx *tmp26 2
   110 set :crx :clx
 
   113 op add :clw *tmp29 1
   114 set :crw :clw
   115 op mod *tmp31 FROM_INDEX 8
-    * op equal *tmp32 *tmp31 0
-    * jump *label25 equal *tmp32 false
+  116 jump *label25 notEqual *tmp31 0
   117 set *tmp33 0
   118 jump *label26 always
   119 label *label25
 
   123 label *label26
   124 set :cly *tmp33
   125 set :cry :cly
-    * op lessThan *tmp37 TO_INDEX 16
-    * jump *label27 equal *tmp37 false
+  126 jump *label27 greaterThanEq TO_INDEX 16
   127 op mod *tmp39 TO_INDEX 8
   128 op mul *tmp40 *tmp39 .BAR_GAP
   129 op add *tmp38 .OFFSET_Y *tmp40
 
   140 op add *tmp43 .OFFSET_X .BAR_SPACE
   141 op sub :clw *tmp43 2
   142 set :crw :clw
-    * op equal *tmp45 FROM_INDEX 0
-    * jump *label29 equal *tmp45 false
+  143 jump *label29 notEqual FROM_INDEX 0
   144 set *tmp46 0
   145 jump *label30 always
   146 label *label29
 
   149 label *label30
   150 set :cly *tmp46
   151 set :cry :cly
-    * op lessThan *tmp49 TO_INDEX 8
-    * jump *label31 equal *tmp49 false
+  152 jump *label31 greaterThanEq TO_INDEX 8
   153 op mul *tmp51 TO_INDEX .BAR_GAP
   154 op add *tmp50 .OFFSET_Y *tmp51
   155 jump *label32 always
 
   158 label *label32
   159 op sub :clh *tmp50 :cly
   160 set :crh :clh
-    * op greaterThanEq *tmp54 TO_INDEX 8
-    * jump *label33 equal *tmp54 false
+  161 jump *label33 lessThan TO_INDEX 8
   162 op add *tmp56 .OFFSET_X .BAR_SPACE
   163 op sub :crx *tmp56 2
   164 op add *tmp58 .OFFSET_X .BAR_SPACE
   165 op sub *tmp59 176 *tmp58
   166 op add :crw *tmp59 1
   167 set :cry 0
-    * op lessThan *tmp61 TO_INDEX 16
-    * jump *label35 equal *tmp61 false
+  168 jump *label35 greaterThanEq TO_INDEX 16
   169 op mod *tmp63 TO_INDEX 8
   170 op mul *tmp64 *tmp63 .BAR_GAP
   171 op add *tmp62 .OFFSET_Y *tmp64
 
   182 op idiv .HALF_BAR .BAR_LENGTH 2
   183 set .MAX CAPACITY
   184 op div .MUL .BAR_LENGTH .MAX
-    * op notEqual *tmp69 .MEMORY null
-    * jump *label37 equal *tmp69 false
+  185 jump *label37 equal .MEMORY null
   186 set :n 0
   187 label *label39
-    * op lessThan *tmp71 :n @links
-    * jump *label41 equal *tmp71 false
+  188 jump *label41 greaterThanEq :n @links
   189 write 0 .MEMORY :n
   190 label *label40
   191 op add :n :n 1
 
   197 control enabled .SWITCH 0
   198 label *label42
   199 sensor *tmp76 .SWITCH @enabled
-    * op equal *tmp77 *tmp76 0
-    * jump *label44 equal *tmp77 false
+  200 jump *label44 notEqual *tmp76 0
   201 set :start @time
   202 draw color 0 0 80 255
   203 draw rect :clx :cly :clw :clh
 
   206 set :index FROM_INDEX
   207 set :n 0
   208 label *label45
-    * op lessThan *tmp79 :n @links
-    * jump *label47 equal *tmp79 false
+  209 jump *label47 greaterThanEq :n @links
   210 getlink :driver :n
   211 sensor *tmp81 :driver @type
-    * op equal *tmp82 *tmp81 @mass-driver
-    * jump *label48 equal *tmp82 false
+  212 jump *label48 notEqual *tmp81 @mass-driver
   213 op idiv :column :index 8
   214 op mod :row :index 8
   215 op mul *tmp86 :column .BAR_SPACE
 
   229 read *tmp97 .MEMORY :n
   230 op max :maxx *tmp97 :items
   231 write :maxx .MEMORY :n
-    * op greaterThan *tmp101 :maxx .MAX
-    * jump *label50 equal *tmp101 false
+  232 jump *label50 lessThanEq :maxx .MAX
   233 op mul .MAX 2 CAPACITY
   234 op div .MUL .BAR_LENGTH .MAX
   235 jump *label51 always
   236 label *label50
   237 label *label51
-    * op lessThanEq *tmp105 .MAX CAPACITY
-    * jump *label52 equal *tmp105 false
+  238 jump *label52 greaterThan .MAX CAPACITY
   239 draw color 0 128 0 255
   240 jump *label53 always
   241 label *label52
 
   243 label *label53
   244 op mul *tmp107 :items .MUL
   245 draw rect :x :y *tmp107 .BAR_WIDTH
-    * op notEqual *tmp108 .MEMORY null
-    * jump *label54 equal *tmp108 false
+  246 jump *label54 equal .MEMORY null
   247 draw color 220 220 220 255
   248 op mul *tmp110 :maxx .MUL
   249 draw lineRect :x :y *tmp110 .BAR_WIDTH
   250 jump *label55 always
   251 label *label54
   252 label *label55
-    * op lessThanEq *tmp111 .MAX CAPACITY
-    * jump *label56 equal *tmp111 false
+  253 jump *label56 greaterThan .MAX CAPACITY
   254 draw color 0 255 0 255
   255 draw lineRect :x :y .BAR_LENGTH .BAR_WIDTH
   256 jump *label57 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-7 instructions):
 
    37 jump *label13 notEqual *tmp6 @memory-cell
    38 label *label14
    39 set .MEMORY :block
-    * jump *label6 always
    40 label *label13
    41 label *label6
    42 label *label4
 
    57 jump *label15 notEqual .DISPLAY null
    58 print "No display."
    59 print "\n"
-    * jump *label16 always
    60 label *label15
    61 label *label16
    62 printflush .MESSAGE
 
   172 set *tmp62 176
   173 label *label36
   174 op sub :crh *tmp62 :cry
-    * jump *label34 always
   175 label *label33
   176 label *label34
   177 label *label24
 
   188 op add :n :n 1
   189 jump *label39 always
   190 label *label41
-    * jump *label38 always
   191 label *label37
   192 label *label38
   193 control enabled .SWITCH 0
 
   228 jump *label50 lessThanEq :maxx .MAX
   229 op mul .MAX 2 CAPACITY
   230 op div .MUL .BAR_LENGTH .MAX
-    * jump *label51 always
   231 label *label50
   232 label *label51
   233 jump *label52 greaterThan .MAX CAPACITY
 
   242 draw color 220 220 220 255
   243 op mul *tmp110 :maxx .MUL
   244 draw lineRect :x :y *tmp110 .BAR_WIDTH
-    * jump *label55 always
   245 label *label54
   246 label *label55
   247 jump *label56 greaterThan .MAX CAPACITY
 
   255 draw lineRect *tmp113 :y .HALF_BAR .BAR_WIDTH
   256 label *label57
   257 op add :index :index 1
-    * jump *label49 always
   258 label *label48
   259 label *label49
   260 label *label46

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 set .DISPLAY null
     4 set .MEMORY null
     5 set .SWITCH null
-    * set .MESSAGE .SWITCH
+    6 set .MESSAGE null
     7 label *label0
     8 jump *label2 notEqual .DISPLAY null
     9 print "Mass Driver Monitor"
 
    72 set .BAR_SPACE 80
    73 set .BAR_GAP 20
    74 set :clx 0
-    * set :crx :clx
-    * op add *tmp13 .OFFSET_X .BAR_SPACE
-    * op sub :clw *tmp13 2
-    * set :crw :clw
+   75 set :crx 0
+   76 op add *tmp13 2 80
+   77 op sub :clw 82 2
+   78 set :crw 80
    79 jump *label19 notEqual FROM_INDEX 0
    80 set *tmp16 0
    81 jump *label20 always
    82 label *label19
-    * op mul *tmp17 FROM_INDEX .BAR_GAP
-    * op add *tmp16 .OFFSET_Y *tmp17
+   83 op mul *tmp17 FROM_INDEX 20
+   84 op add *tmp16 2 *tmp17
    85 label *label20
    86 set :cly *tmp16
-    * set :cry :cly
+   87 set :cry *tmp16
    88 jump *label21 greaterThanEq TO_INDEX 8
-    * op mul *tmp21 TO_INDEX .BAR_GAP
-    * op add *tmp20 .OFFSET_Y *tmp21
+   89 op mul *tmp21 TO_INDEX 20
+   90 op add *tmp20 2 *tmp21
    91 jump *label22 always
    92 label *label21
    93 set *tmp20 176
    94 label *label22
-    * op sub :clh *tmp20 :cly
+   95 op sub :clh *tmp20 *tmp16
    96 set :crh :clh
    97 jump *label18 always
    98 label *label17
 
   103 set .BAR_SPACE 88
   104 set .BAR_GAP 22
   105 jump *label23 lessThan FROM_INDEX 8
-    * op add *tmp26 .OFFSET_X .BAR_SPACE
-    * op sub :clx *tmp26 2
-    * set :crx :clx
-    * op add *tmp28 .OFFSET_X .BAR_SPACE
-    * op sub *tmp29 176 *tmp28
-    * op add :clw *tmp29 1
-    * set :crw :clw
+  106 op add *tmp26 5 88
+  107 op sub :clx 93 2
+  108 set :crx 91
+  109 op add *tmp28 5 88
+  110 op sub *tmp29 176 93
+  111 op add :clw 83 1
+  112 set :crw 84
   113 op mod *tmp31 FROM_INDEX 8
   114 jump *label25 notEqual *tmp31 0
   115 set *tmp33 0
   116 jump *label26 always
   117 label *label25
   118 op mod *tmp34 FROM_INDEX 8
-    * op mul *tmp35 *tmp34 .BAR_GAP
-    * op add *tmp33 .OFFSET_Y *tmp35
+  119 op mul *tmp35 *tmp31 22
+  120 op add *tmp33 4 *tmp35
   121 label *label26
   122 set :cly *tmp33
-    * set :cry :cly
+  123 set :cry *tmp33
   124 jump *label27 greaterThanEq TO_INDEX 16
   125 op mod *tmp39 TO_INDEX 8
-    * op mul *tmp40 *tmp39 .BAR_GAP
-    * op add *tmp38 .OFFSET_Y *tmp40
+  126 op mul *tmp40 *tmp39 22
+  127 op add *tmp38 4 *tmp40
   128 jump *label28 always
   129 label *label27
   130 set *tmp38 176
   131 label *label28
-    * op sub :clh *tmp38 :cry
+  132 op sub :clh *tmp38 :cly
   133 set :crh :clh
   134 jump *label24 always
   135 label *label23
   136 set :clx 0
-    * set :crx :clx
-    * op add *tmp43 .OFFSET_X .BAR_SPACE
-    * op sub :clw *tmp43 2
-    * set :crw :clw
+  137 set :crx 0
+  138 op add *tmp43 5 88
+  139 op sub :clw 93 2
+  140 set :crw 91
   141 jump *label29 notEqual FROM_INDEX 0
   142 set *tmp46 0
   143 jump *label30 always
   144 label *label29
-    * op mul *tmp47 FROM_INDEX .BAR_GAP
-    * op add *tmp46 .OFFSET_Y *tmp47
+  145 op mul *tmp47 FROM_INDEX 22
+  146 op add *tmp46 4 *tmp47
   147 label *label30
   148 set :cly *tmp46
-    * set :cry :cly
+  149 set :cry *tmp46
   150 jump *label31 greaterThanEq TO_INDEX 8
-    * op mul *tmp51 TO_INDEX .BAR_GAP
-    * op add *tmp50 .OFFSET_Y *tmp51
+  151 op mul *tmp51 TO_INDEX 22
+  152 op add *tmp50 4 *tmp51
   153 jump *label32 always
   154 label *label31
   155 set *tmp50 176
   156 label *label32
-    * op sub :clh *tmp50 :cly
+  157 op sub :clh *tmp50 *tmp46
   158 set :crh :clh
   159 jump *label33 lessThan TO_INDEX 8
-    * op add *tmp56 .OFFSET_X .BAR_SPACE
-    * op sub :crx *tmp56 2
-    * op add *tmp58 .OFFSET_X .BAR_SPACE
-    * op sub *tmp59 176 *tmp58
-    * op add :crw *tmp59 1
+  160 op add *tmp56 5 88
+  161 op sub :crx 93 2
+  162 op add *tmp58 5 88
+  163 op sub *tmp59 176 93
+  164 op add :crw 83 1
   165 set :cry 0
   166 jump *label35 greaterThanEq TO_INDEX 16
   167 op mod *tmp63 TO_INDEX 8
-    * op mul *tmp64 *tmp63 .BAR_GAP
-    * op add *tmp62 .OFFSET_Y *tmp64
+  168 op mul *tmp64 *tmp63 22
+  169 op add *tmp62 4 *tmp64
   170 jump *label36 always
   171 label *label35
   172 set *tmp62 176
   173 label *label36
-    * op sub :crh *tmp62 :cry
+  174 op sub :crh *tmp62 0
   175 label *label33
   176 label *label34
   177 label *label24
   178 label *label18
-    * op idiv .HALF_BAR .BAR_LENGTH 2
+  179 op idiv .HALF_BAR 60 2
   180 set .MAX CAPACITY
-    * op div .MUL .BAR_LENGTH .MAX
+  181 op div .MUL 60 CAPACITY
   182 jump *label37 equal .MEMORY null
   183 set :n 0
   184 label *label39
 
   227 write :maxx .MEMORY :n
   228 jump *label50 lessThanEq :maxx .MAX
   229 op mul .MAX 2 CAPACITY
-    * op div .MUL .BAR_LENGTH .MAX
+  230 op div .MUL 60 .MAX
   231 label *label50
   232 label *label51
   233 jump *label52 greaterThan .MAX CAPACITY
 
   237 draw color 128 128 0 255
   238 label *label53
   239 op mul *tmp107 :items .MUL
-    * draw rect :x :y *tmp107 .BAR_WIDTH
+  240 draw rect :x :y *tmp107 14
   241 jump *label54 equal .MEMORY null
   242 draw color 220 220 220 255
   243 op mul *tmp110 :maxx .MUL
-    * draw lineRect :x :y *tmp110 .BAR_WIDTH
+  244 draw lineRect :x :y *tmp110 14
   245 label *label54
   246 label *label55
   247 jump *label56 greaterThan .MAX CAPACITY
   248 draw color 0 255 0 255
-    * draw lineRect :x :y .BAR_LENGTH .BAR_WIDTH
+  249 draw lineRect :x :y 60 14
   250 jump *label57 always
   251 label *label56
   252 draw color 255 255 0 255
-    * draw lineRect :x :y .HALF_BAR .BAR_WIDTH
-    * op add *tmp113 :x .HALF_BAR
-    * draw lineRect *tmp113 :y .HALF_BAR .BAR_WIDTH
+  253 draw lineRect :x :y 30 14
+  254 op add *tmp113 :x 30
+  255 draw lineRect *tmp113 :y 30 14
   256 label *label57
   257 op add :index :index 1
   258 label *label48

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-9 instructions):
 
    73 set .BAR_GAP 20
    74 set :clx 0
    75 set :crx 0
-    * op add *tmp13 2 80
    76 op sub :clw 82 2
    77 set :crw 80
    78 jump *label19 notEqual FROM_INDEX 0
 
   102 set .BAR_SPACE 88
   103 set .BAR_GAP 22
   104 jump *label23 lessThan FROM_INDEX 8
-    * op add *tmp26 5 88
   105 op sub :clx 93 2
   106 set :crx 91
-    * op add *tmp28 5 88
-    * op sub *tmp29 176 93
   107 op add :clw 83 1
   108 set :crw 84
   109 op mod *tmp31 FROM_INDEX 8
 
   111 set *tmp33 0
   112 jump *label26 always
   113 label *label25
-    * op mod *tmp34 FROM_INDEX 8
   114 op mul *tmp35 *tmp31 22
   115 op add *tmp33 4 *tmp35
   116 label *label26
 
   124 label *label27
   125 set *tmp38 176
   126 label *label28
-    * op sub :clh *tmp38 :cly
+  127 op sub :clh *tmp38 *tmp33
   128 set :crh :clh
   129 jump *label24 always
   130 label *label23
   131 set :clx 0
   132 set :crx 0
-    * op add *tmp43 5 88
   133 op sub :clw 93 2
   134 set :crw 91
   135 jump *label29 notEqual FROM_INDEX 0
 
   151 op sub :clh *tmp50 *tmp46
   152 set :crh :clh
   153 jump *label33 lessThan TO_INDEX 8
-    * op add *tmp56 5 88
   154 op sub :crx 93 2
-    * op add *tmp58 5 88
-    * op sub *tmp59 176 93
   155 op add :crw 83 1
   156 set :cry 0
   157 jump *label35 greaterThanEq TO_INDEX 16

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
 
     5 set .SWITCH null
     6 set .MESSAGE null
     7 label *label0
-    * jump *label2 notEqual .DISPLAY null
+    8 label *label58
     9 print "Mass Driver Monitor"
    10 print "\n"
    11 set :n @links
    12 label *label3
    13 jump *label5 lessThanEq :n 0
+   14 label *label59
    15 op sub :n :n 1
    16 getlink :block :n
    17 print "Found: "
 
    41 label *label13
    42 label *label6
    43 label *label4
-    * jump *label3 always
+   44 jump *label59 greaterThan :n 0
    45 label *label5
    46 print "Message: "
    47 print .MESSAGE
 
    62 label *label16
    63 printflush .MESSAGE
    64 label *label1
-    * jump *label0 always
+   65 jump *label58 equal .DISPLAY null
    66 label *label2
    67 sensor *tmp10 .DISPLAY @type
    68 jump *label17 notEqual *tmp10 @logic-display
 
   175 set :n 0
   176 label *label39
   177 jump *label41 greaterThanEq :n @links
+  178 label *label60
   179 write 0 .MEMORY :n
   180 label *label40
   181 op add :n :n 1
-    * jump *label39 always
+  182 jump *label60 lessThan :n @links
   183 label *label41
   184 label *label37
   185 label *label38
 
   196 set :n 0
   197 label *label45
   198 jump *label47 greaterThanEq :n @links
+  199 label *label61
   200 getlink :driver :n
   201 sensor *tmp81 :driver @type
   202 jump *label48 notEqual *tmp81 @mass-driver
 
   253 label *label49
   254 label *label46
   255 op add :n :n 1
-    * jump *label45 always
+  256 jump *label61 lessThan :n @links
   257 label *label47
   258 drawflush .DISPLAY
   259 print "Mass Driver Monitor"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
    76 set :crx 0
    77 op sub :clw 82 2
    78 set :crw 80
-    * jump *label19 notEqual FROM_INDEX 0
    79 set *tmp16 0
-    * jump *label20 always
+   80 jump *label20 equal FROM_INDEX 0
    81 label *label19
    82 op mul *tmp17 FROM_INDEX 20
    83 op add *tmp16 2 *tmp17
    84 label *label20
    85 set :cly *tmp16
    86 set :cry *tmp16
-    * jump *label21 greaterThanEq TO_INDEX 8
+   87 set *tmp20 176
+   88 jump *label22 greaterThanEq TO_INDEX 8
    89 op mul *tmp21 TO_INDEX 20
    90 op add *tmp20 2 *tmp21
    91 jump *label22 always
-    * label *label21
-    * set *tmp20 176
    92 label *label22
    93 op sub :clh *tmp20 *tmp16
    94 set :crh :clh
 
   105 set :crx 91
   106 op add :clw 83 1
   107 set :crw 84
+  108 set *tmp33 0
   109 op mod *tmp31 FROM_INDEX 8
-    * jump *label25 notEqual *tmp31 0
-    * set *tmp33 0
-    * jump *label26 always
+  110 jump *label26 equal *tmp31 0
   111 label *label25
   112 op mul *tmp35 *tmp31 22
   113 op add *tmp33 4 *tmp35
   114 label *label26
   115 set :cly *tmp33
   116 set :cry *tmp33
-    * jump *label27 greaterThanEq TO_INDEX 16
+  117 set *tmp38 176
+  118 jump *label28 greaterThanEq TO_INDEX 16
   119 op mod *tmp39 TO_INDEX 8
   120 op mul *tmp40 *tmp39 22
   121 op add *tmp38 4 *tmp40
   122 jump *label28 always
-    * label *label27
-    * set *tmp38 176
   123 label *label28
   124 op sub :clh *tmp38 *tmp33
   125 set :crh :clh
 
   129 set :crx 0
   130 op sub :clw 93 2
   131 set :crw 91
-    * jump *label29 notEqual FROM_INDEX 0
   132 set *tmp46 0
-    * jump *label30 always
+  133 jump *label30 equal FROM_INDEX 0
   134 label *label29
   135 op mul *tmp47 FROM_INDEX 22
   136 op add *tmp46 4 *tmp47
   137 label *label30
   138 set :cly *tmp46
   139 set :cry *tmp46
-    * jump *label31 greaterThanEq TO_INDEX 8
+  140 set *tmp50 176
+  141 jump *label32 greaterThanEq TO_INDEX 8
   142 op mul *tmp51 TO_INDEX 22
   143 op add *tmp50 4 *tmp51
   144 jump *label32 always
-    * label *label31
-    * set *tmp50 176
   145 label *label32
   146 op sub :clh *tmp50 *tmp46
   147 set :crh :clh
 
   149 op sub :crx 93 2
   150 op add :crw 83 1
   151 set :cry 0
-    * jump *label35 greaterThanEq TO_INDEX 16
+  152 set *tmp62 176
+  153 jump *label36 greaterThanEq TO_INDEX 16
   154 op mod *tmp63 TO_INDEX 8
   155 op mul *tmp64 *tmp63 22
   156 op add *tmp62 4 *tmp64
   157 jump *label36 always
-    * label *label35
-    * set *tmp62 176
   158 label *label36
   159 op sub :crh *tmp62 0
   160 label *label33

Modifications by Replicate loop condition at line 91:1 (+1 instructions):
 
   180 label *label42
   181 sensor *tmp76 .SWITCH @enabled
   182 jump *label44 notEqual *tmp76 0
+  183 label *label62
   184 set :start @time
   185 draw color 0 0 80 255
   186 draw rect :clx :cly :clw :clh
 
   260 print "ms"
   261 printflush .MESSAGE
   262 label *label43
-    * jump *label42 always
+  263 sensor *tmp76 .SWITCH @enabled
+  264 jump *label62 equal *tmp76 0
   265 label *label44
   266 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   167 jump *label37 equal .MEMORY null
   168 set :n 0
   169 label *label39
-    * jump *label41 greaterThanEq :n @links
+  170 jump *label41 greaterThanEq 0 @links
   171 label *label60
   172 write 0 .MEMORY :n
   173 label *label40
 
   189 set :index FROM_INDEX
   190 set :n 0
   191 label *label45
-    * jump *label47 greaterThanEq :n @links
+  192 jump *label47 greaterThanEq 0 @links
   193 label *label61
   194 getlink :driver :n
   195 sensor *tmp81 :driver @type

Modifications by Convert case at line 17:9 (segments: 1, padded low) (-3 instructions):
 
    18 print :block
    19 print "\n"
    20 sensor *tmp6 :block @type
-    * jump *label7 notEqual *tmp6 @message
+   21 sensor *tmp118 *tmp6 @id
+   22 jump *label63 greaterThanEq *tmp118 146
+   23 multijump *tmp118 0 0 (m:*label64)
+   24 multilabel *label66 (m:*label64)
    25 label *label8
    26 set .MESSAGE :block
    27 jump *label6 always
    28 label *label7
-    * jump *label9 notEqual *tmp6 @switch
+   29 multilabel *label67 (m:*label64)
    30 label *label10
    31 set .SWITCH :block
    32 jump *label6 always
    33 label *label9
-    * jump *label12 equal *tmp6 @logic-display
-    * jump *label11 notEqual *tmp6 @large-logic-display
+   34 multilabel *label69 (m:*label64)
    35 label *label12
    36 set .DISPLAY :block
    37 jump *label6 always
    38 label *label11
-    * jump *label14 equal *tmp6 @memory-bank
-    * jump *label13 notEqual *tmp6 @memory-cell
+   39 multilabel *label68 (m:*label64)
    40 label *label14
    41 set .MEMORY :block
    42 label *label13
+   43 multilabel *label65 (m:*label64)
+   44 label *label63
    45 label *label6
    46 label *label4
    47 jump *label59 greaterThan :n 0

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-4 instructions):
 
    91 jump *label22 greaterThanEq TO_INDEX 8
    92 op mul *tmp21 TO_INDEX 20
    93 op add *tmp20 2 *tmp21
-    * jump *label22 always
    94 label *label22
    95 op sub :clh *tmp20 *tmp16
    96 set :crh :clh
 
   121 op mod *tmp39 TO_INDEX 8
   122 op mul *tmp40 *tmp39 22
   123 op add *tmp38 4 *tmp40
-    * jump *label28 always
   124 label *label28
   125 op sub :clh *tmp38 *tmp33
   126 set :crh :clh
 
   142 jump *label32 greaterThanEq TO_INDEX 8
   143 op mul *tmp51 TO_INDEX 22
   144 op add *tmp50 4 *tmp51
-    * jump *label32 always
   145 label *label32
   146 op sub :clh *tmp50 *tmp46
   147 set :crh :clh
 
   154 op mod *tmp63 TO_INDEX 8
   155 op mul *tmp64 *tmp63 22
   156 op add *tmp62 4 *tmp64
-    * jump *label36 always
   157 label *label36
   158 op sub :crh *tmp62 0
   159 label *label33

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   155 op mul *tmp64 *tmp63 22
   156 op add *tmp62 4 *tmp64
   157 label *label36
-    * op sub :crh *tmp62 0
+  158 set :crh *tmp62
   159 label *label33
   160 label *label34
   161 label *label24

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     4 set .MEMORY null
     5 set .SWITCH null
     6 set .MESSAGE null
-    * label *label0
     7 label *label58
     8 print "Mass Driver Monitor"
     9 print "\n"
    10 set :n @links
-    * label *label3
    11 jump *label5 lessThanEq :n 0
    12 label *label59
    13 op sub :n :n 1
 
    20 jump *label63 greaterThanEq *tmp118 146
    21 multijump *tmp118 0 0 (m:*label64)
    22 multilabel *label66 (m:*label64)
-    * label *label8
    23 set .MESSAGE :block
    24 jump *label6 always
-    * label *label7
    25 multilabel *label67 (m:*label64)
-    * label *label10
    26 set .SWITCH :block
    27 jump *label6 always
-    * label *label9
    28 multilabel *label69 (m:*label64)
-    * label *label12
    29 set .DISPLAY :block
    30 jump *label6 always
-    * label *label11
    31 multilabel *label68 (m:*label64)
-    * label *label14
    32 set .MEMORY :block
-    * label *label13
    33 multilabel *label65 (m:*label64)
    34 label *label63
    35 label *label6
-    * label *label4
    36 jump *label59 greaterThan :n 0
    37 label *label5
    38 print "Message: "
 
    51 print "No display."
    52 print "\n"
    53 label *label15
-    * label *label16
    54 printflush .MESSAGE
-    * label *label1
    55 jump *label58 equal .DISPLAY null
-    * label *label2
    56 sensor *tmp10 .DISPLAY @type
    57 jump *label17 notEqual *tmp10 @logic-display
    58 set .OFFSET_X 2
 
    67 set :crw 80
    68 set *tmp16 0
    69 jump *label20 equal FROM_INDEX 0
-    * label *label19
    70 op mul *tmp17 FROM_INDEX 20
    71 op add *tmp16 2 *tmp17
    72 label *label20
 
    95 set *tmp33 0
    96 op mod *tmp31 FROM_INDEX 8
    97 jump *label26 equal *tmp31 0
-    * label *label25
    98 op mul *tmp35 *tmp31 22
    99 op add *tmp33 4 *tmp35
   100 label *label26
 
   116 set :crw 91
   117 set *tmp46 0
   118 jump *label30 equal FROM_INDEX 0
-    * label *label29
   119 op mul *tmp47 FROM_INDEX 22
   120 op add *tmp46 4 *tmp47
   121 label *label30
 
   140 label *label36
   141 set :crh *tmp62
   142 label *label33
-    * label *label34
   143 label *label24
   144 label *label18
   145 op idiv .HALF_BAR 60 2
 
   147 op div .MUL 60 CAPACITY
   148 jump *label37 equal .MEMORY null
   149 set :n 0
-    * label *label39
   150 jump *label41 greaterThanEq 0 @links
   151 label *label60
   152 write 0 .MEMORY :n
-    * label *label40
   153 op add :n :n 1
   154 jump *label60 lessThan :n @links
   155 label *label41
   156 label *label37
-    * label *label38
   157 control enabled .SWITCH 0
-    * label *label42
   158 sensor *tmp76 .SWITCH @enabled
   159 jump *label44 notEqual *tmp76 0
   160 label *label62
 
   165 draw stroke 2
   166 set :index FROM_INDEX
   167 set :n 0
-    * label *label45
   168 jump *label47 greaterThanEq 0 @links
   169 label *label61
   170 getlink :driver :n
 
   193 op mul .MAX 2 CAPACITY
   194 op div .MUL 60 .MAX
   195 label *label50
-    * label *label51
   196 jump *label52 greaterThan .MAX CAPACITY
   197 draw color 0 128 0 255
   198 jump *label53 always
 
   206 op mul *tmp110 :maxx .MUL
   207 draw lineRect :x :y *tmp110 14
   208 label *label54
-    * label *label55
   209 jump *label56 greaterThan .MAX CAPACITY
   210 draw color 0 255 0 255
   211 draw lineRect :x :y 60 14
 
   218 label *label57
   219 op add :index :index 1
   220 label *label48
-    * label *label49
-    * label *label46
   221 op add :n :n 1
   222 jump *label61 lessThan :n @links
   223 label *label47
 
   231 print " "
   232 print "ms"
   233 printflush .MESSAGE
-    * label *label43
   234 sensor *tmp76 .SWITCH @enabled
   235 jump *label62 equal *tmp76 0
   236 label *label44

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 set FROM_INDEX 0
     2 set TO_INDEX 16
     3 set CAPACITY 120
 
   157 label *label37
   158 control enabled .SWITCH 0
   159 sensor *tmp76 .SWITCH @enabled
-    * jump *label44 notEqual *tmp76 0
+  160 jump __start__ notEqual *tmp76 0
   161 label *label62
   162 set :start @time
   163 draw color 0 0 80 255

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1:
 
   234 printflush .MESSAGE
   235 sensor *tmp76 .SWITCH @enabled
   236 jump *label62 equal *tmp76 0
-    * label *label44
   237 end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1 (-5 instructions):
 
    58 jump *label17 notEqual *tmp10 @logic-display
    59 set .OFFSET_X 2
    60 set .OFFSET_Y 2
-    * set .BAR_WIDTH 14
-    * set .BAR_LENGTH 60
    61 set .BAR_SPACE 80
    62 set .BAR_GAP 20
    63 set :clx 0
 
    82 label *label17
    83 set .OFFSET_X 5
    84 set .OFFSET_Y 4
-    * set .BAR_WIDTH 14
-    * set .BAR_LENGTH 60
    85 set .BAR_SPACE 88
    86 set .BAR_GAP 22
    87 jump *label23 lessThan FROM_INDEX 8
 
   139 label *label33
   140 label *label24
   141 label *label18
-    * op idiv .HALF_BAR 60 2
   142 set .MAX CAPACITY
   143 op div .MUL 60 CAPACITY
   144 jump *label37 equal .MEMORY null

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   229 printflush .MESSAGE
   230 sensor *tmp76 .SWITCH @enabled
   231 jump *label62 equal *tmp76 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-14 instructions):
 
     6 set .SWITCH null
     7 set .MESSAGE null
     8 label *label58
-    * print "Mass Driver Monitor"
-    * print "\n"
+    9 print "Mass Driver Monitor\n"
    10 set :n @links
    11 jump *label5 lessThanEq :n 0
    12 label *label59
    13 op sub :n :n 1
    14 getlink :block :n
-    * print "Found: "
-    * print :block
-    * print "\n"
+   15 print "Found: {0}\n"
+   16 format :block
    17 sensor *tmp6 :block @type
    18 sensor *tmp118 *tmp6 @id
    19 jump *label63 greaterThanEq *tmp118 146
 
    34 label *label6
    35 jump *label59 greaterThan :n 0
    36 label *label5
-    * print "Message: "
-    * print .MESSAGE
-    * print "\n"
-    * print "Switch: "
-    * print .SWITCH
-    * print "\n"
-    * print "Memory: "
-    * print .MEMORY
-    * print "\n"
-    * print "Display: "
-    * print .DISPLAY
-    * print "\n"
+   37 print "Message: {0}\nSwitch: {0}\nMemory: {0}\nDisplay: {0}\n"
+   38 format .MESSAGE
+   39 format .SWITCH
+   40 format .MEMORY
+   41 format .DISPLAY
    42 jump *label15 notEqual .DISPLAY null
-    * print "No display."
-    * print "\n"
+   43 print "No display.\n"
    44 label *label15
    45 printflush .MESSAGE
    46 jump *label58 equal .DISPLAY null
 
   208 jump *label61 lessThan :n @links
   209 label *label47
   210 drawflush .DISPLAY
-    * print "Mass Driver Monitor"
-    * print "\n"
+  211 print "Mass Driver Monitor\n[lightgray]Draw time: {0} ms"
   212 op sub *tmp116 @time :start
   213 op floor *tmp117 *tmp116
-    * print "[lightgray]Draw time: "
-    * print *tmp117
-    * print " "
-    * print "ms"
+  214 format *tmp117
   215 printflush .MESSAGE
   216 sensor *tmp76 .SWITCH @enabled
   217 jump *label62 equal *tmp76 0

Final code before resolving virtual instructions:

label __start__
set FROM_INDEX 0
set TO_INDEX 16
set CAPACITY 120
set .DISPLAY null
set .MEMORY null
set .SWITCH null
set .MESSAGE null
label *label58
print "Mass Driver Monitor\n"
set :n @links
jump *label5 lessThanEq :n 0
label *label59
op sub :n :n 1
getlink :block :n
print "Found: {0}\n"
format :block
sensor *tmp6 :block @type
sensor *tmp118 *tmp6 @id
jump *label63 greaterThanEq *tmp118 146
multijump *tmp118 0 0
multilabel *label66
set .MESSAGE :block
jump *label6 always
multilabel *label67
set .SWITCH :block
jump *label6 always
multilabel *label69
set .DISPLAY :block
jump *label6 always
multilabel *label68
set .MEMORY :block
multilabel *label65
label *label63
label *label6
jump *label59 greaterThan :n 0
label *label5
print "Message: {0}\nSwitch: {0}\nMemory: {0}\nDisplay: {0}\n"
format .MESSAGE
format .SWITCH
format .MEMORY
format .DISPLAY
jump *label15 notEqual .DISPLAY null
print "No display.\n"
label *label15
printflush .MESSAGE
jump *label58 equal .DISPLAY null
sensor *tmp10 .DISPLAY @type
jump *label17 notEqual *tmp10 @logic-display
set .OFFSET_X 2
set .OFFSET_Y 2
set .BAR_SPACE 80
set .BAR_GAP 20
set :clx 0
set :crx 0
op sub :clw 82 2
set :crw 80
set *tmp16 0
jump *label20 equal FROM_INDEX 0
op mul *tmp17 FROM_INDEX 20
op add *tmp16 2 *tmp17
label *label20
set :cly *tmp16
set :cry *tmp16
set *tmp20 176
jump *label22 greaterThanEq TO_INDEX 8
op mul *tmp21 TO_INDEX 20
op add *tmp20 2 *tmp21
label *label22
op sub :clh *tmp20 *tmp16
set :crh :clh
jump *label18 always
label *label17
set .OFFSET_X 5
set .OFFSET_Y 4
set .BAR_SPACE 88
set .BAR_GAP 22
jump *label23 lessThan FROM_INDEX 8
op sub :clx 93 2
set :crx 91
op add :clw 83 1
set :crw 84
set *tmp33 0
op mod *tmp31 FROM_INDEX 8
jump *label26 equal *tmp31 0
op mul *tmp35 *tmp31 22
op add *tmp33 4 *tmp35
label *label26
set :cly *tmp33
set :cry *tmp33
set *tmp38 176
jump *label28 greaterThanEq TO_INDEX 16
op mod *tmp39 TO_INDEX 8
op mul *tmp40 *tmp39 22
op add *tmp38 4 *tmp40
label *label28
op sub :clh *tmp38 *tmp33
set :crh :clh
jump *label24 always
label *label23
set :clx 0
set :crx 0
op sub :clw 93 2
set :crw 91
set *tmp46 0
jump *label30 equal FROM_INDEX 0
op mul *tmp47 FROM_INDEX 22
op add *tmp46 4 *tmp47
label *label30
set :cly *tmp46
set :cry *tmp46
set *tmp50 176
jump *label32 greaterThanEq TO_INDEX 8
op mul *tmp51 TO_INDEX 22
op add *tmp50 4 *tmp51
label *label32
op sub :clh *tmp50 *tmp46
set :crh :clh
jump *label33 lessThan TO_INDEX 8
op sub :crx 93 2
op add :crw 83 1
set :cry 0
set *tmp62 176
jump *label36 greaterThanEq TO_INDEX 16
op mod *tmp63 TO_INDEX 8
op mul *tmp64 *tmp63 22
op add *tmp62 4 *tmp64
label *label36
set :crh *tmp62
label *label33
label *label24
label *label18
set .MAX CAPACITY
op div .MUL 60 CAPACITY
jump *label37 equal .MEMORY null
set :n 0
jump *label41 greaterThanEq 0 @links
label *label60
write 0 .MEMORY :n
op add :n :n 1
jump *label60 lessThan :n @links
label *label41
label *label37
control enabled .SWITCH 0
sensor *tmp76 .SWITCH @enabled
jump __start__ notEqual *tmp76 0
label *label62
set :start @time
draw color 0 0 80 255
draw rect :clx :cly :clw :clh
draw rect :crx :cry :crw :crh
draw stroke 2
set :index FROM_INDEX
set :n 0
jump *label47 greaterThanEq 0 @links
label *label61
getlink :driver :n
sensor *tmp81 :driver @type
jump *label48 notEqual *tmp81 @mass-driver
op idiv :column :index 8
op mod :row :index 8
op mul *tmp86 :column .BAR_SPACE
op add :x .OFFSET_X *tmp86
op mul *tmp88 :row .BAR_GAP
op add :y .OFFSET_Y *tmp88
draw color 0 0 80 255
op sub *tmp90 :x 1
op sub *tmp91 :y 1
draw rect *tmp90 *tmp91 .BAR_SPACE 16
draw color 255 255 255 255
op add *tmp92 :x 7
op add *tmp93 :y 7
draw image *tmp92 *tmp93 @mass-driver 16 0
op add :x :x 16
sensor :items :driver @totalItems
read *tmp97 .MEMORY :n
op max :maxx *tmp97 :items
write :maxx .MEMORY :n
jump *label50 lessThanEq :maxx .MAX
op mul .MAX 2 CAPACITY
op div .MUL 60 .MAX
label *label50
jump *label52 greaterThan .MAX CAPACITY
draw color 0 128 0 255
jump *label53 always
label *label52
draw color 128 128 0 255
label *label53
op mul *tmp107 :items .MUL
draw rect :x :y *tmp107 14
jump *label54 equal .MEMORY null
draw color 220 220 220 255
op mul *tmp110 :maxx .MUL
draw lineRect :x :y *tmp110 14
label *label54
jump *label56 greaterThan .MAX CAPACITY
draw color 0 255 0 255
draw lineRect :x :y 60 14
jump *label57 always
label *label56
draw color 255 255 0 255
draw lineRect :x :y 30 14
op add *tmp113 :x 30
draw lineRect *tmp113 :y 30 14
label *label57
op add :index :index 1
label *label48
op add :n :n 1
jump *label61 lessThan :n @links
label *label47
drawflush .DISPLAY
print "Mass Driver Monitor\n[lightgray]Draw time: {0} ms"
op sub *tmp116 @time :start
op floor *tmp117 *tmp116
format *tmp117
printflush .MESSAGE
sensor *tmp76 .SWITCH @enabled
jump *label62 equal *tmp76 0
