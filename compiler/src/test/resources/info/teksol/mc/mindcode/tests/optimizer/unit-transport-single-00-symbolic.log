   602 instructions before optimizations.
    38 instructions eliminated by Temp Variables Elimination.
    86 instructions eliminated by Dead Code Elimination (6 iterations).
     6 instructions eliminated by Jump Normalization (4 iterations).
    42 instructions eliminated by Jump Optimization (4 iterations).
    30 instructions eliminated by Single Step Elimination (3 passes, 7 iterations).
     1 instructions modified by Expression Optimization (3 iterations).
     2 instructions eliminated by If Expression Optimization (3 iterations).
     3 instructions eliminated by Data Flow Optimization (4 passes, 17 iterations).
    18 instructions added by Loop Optimization (3 iterations).
     9 loops improved by Loop Optimization.
     5 instructions eliminated by Jump Straightening (4 iterations).
     8 instructions updated by JumpThreading.
     3 instructions eliminated by Unreachable Code Elimination.
    50 instructions eliminated by Print Merging.
   355 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 596):
  * Replicate loop condition at line 43:1                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
    Replicate loop condition at line 51:1                        cost     2, benefit       25.0, efficiency       12.5
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
    Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3
    Replicate loop condition at line 304:1                       cost     2, benefit       25.0, efficiency       12.5
    Replicate loop condition at line 314:5                       cost     1, benefit       12.5, efficiency       12.5

Pass 1: speed optimization selection (cost limit 595):
    Replicate loop condition at line 51:1                        cost     2, benefit       25.0, efficiency       12.5
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
    Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3
    Replicate loop condition at line 304:1                       cost     2, benefit       25.0, efficiency       12.5
  * Replicate loop condition at line 314:5                       cost     1, benefit       12.5, efficiency       12.5 (+1 instructions)

Pass 1: speed optimization selection (cost limit 594):
  * Replicate loop condition at line 51:1                        cost     2, benefit       25.0, efficiency       12.5 (+2 instructions)
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
    Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3
    Replicate loop condition at line 304:1                       cost     2, benefit       25.0, efficiency       12.5

Pass 1: speed optimization selection (cost limit 592):
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
    Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3
  * Replicate loop condition at line 304:1                       cost     2, benefit       25.0, efficiency       12.5 (+1 instructions)

Pass 1: speed optimization selection (cost limit 591):
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
  * Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3 (+3 instructions)

Pass 1: speed optimization selection (cost limit 588):
  * Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1 (+4 instructions)
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3

Pass 1: speed optimization selection (cost limit 584):
  * Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3 (+5 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-52 instructions):
 
    33 set *tmp10 @unit
    34 set :rebindUnit.0:first_unit *tmp10
    35 jump *label9 always
-    * set *tmp9 null
    36 jump *label11 always
    37 label *label10
-    * set *tmp9 null
    38 label *label11
    39 print "[salmon]No unit of type "
    40 print UNIT
 
    48 sensor *tmp11 @unit @controller
    49 op equal *tmp12 *tmp11 @this
    50 jump *label15 equal *tmp12 false
-    * set *tmp7 null
    51 jump *label6 always
-    * set *tmp13 null
    52 jump *label16 always
    53 label *label15
-    * set *tmp13 null
    54 label *label16
    55 ubind UNIT
    56 print "[gold]Looking for old unit..."
 
    72 print UNIT
    73 print " "
    74 print "found. 2"
-    * set *tmp20 null
    75 jump *label22 always
    76 label *label21
    77 sensor *tmp21 @unit @controlled
 
    88 jump *label17 always
    89 set *tmp23 null
    90 label *label24
-    * set *tmp20 *tmp23
    91 label *label22
    92 printflush message1
    93 label *label19
 
    95 label *label20
    96 set *tmp18 null
    97 label *label17
-    * set *tmp7 *tmp18
    98 label *label6
    99 label *label4
   100 jump *label3 always
 
   123 jump *label31 equal *tmp32 false
   124 set .DROP_TARGET .CONTAINER
   125 set .CONTAINER :block
-    * set *tmp33 .CONTAINER
   126 jump *label32 always
   127 label *label31
-    * set *tmp33 null
   128 label *label32
   129 label *label29
   130 jump *label28 always
 
   133 jump *label33 equal *tmp34 false
   134 print "[salmon]No destination."
   135 print "\n"
-    * set *tmp35 "[salmon]No destination."
   136 jump *label34 always
   137 label *label33
   138 op notEqual *tmp36 .DROP_TARGET null
 
   155 jump *label27 always
   156 set *tmp40 null
   157 label *label36
-    * set *tmp35 *tmp40
   158 label *label34
   159 printflush message1
   160 label *label26
 
   169 printflush message1
   170 ulocate building core false @copper .CORE_X .CORE_Y *tmp44 *tmp43
   171 set .CORE *tmp43
-    * set *tmp42 .CORE
   172 jump *label38 always
   173 label *label37
   174 print "[gold]Locating vault #"
 
   226 label *label42
   227 set *tmp52 null
   228 label *label43
-    * set *tmp42 *tmp52
   229 label *label38
   230 op equal *tmp65 .CORE null
   231 jump *label49 equal *tmp65 false
   232 end
-    * set *tmp66 null
   233 jump *label50 always
   234 label *label49
-    * set *tmp66 null
   235 label *label50
   236 set .SORTER sorter1
   237 sensor *tmp67 .SORTER @type
 
   247 jump *label54 equal *tmp71 false
   248 print "Block found: "
   249 print .SORTER
-    * set *tmp72 .SORTER
   250 jump *label55 always
   251 label *label54
-    * set *tmp72 null
   252 label *label55
   253 printflush message1
   254 set .SORTER sorter1
 
   283 set *tmp84 "[] from vault #"
   284 label *label59
   285 set .DIRECTION *tmp84
-    * set *tmp75 .DIRECTION
   286 jump *label57 always
   287 label *label56
   288 op greaterThan *tmp85 LINK_ID 0
 
   313 set *tmp97 "[] to vault #"
   314 label *label61
   315 set .DIRECTION *tmp97
-    * set *tmp75 .DIRECTION
   316 label *label57
   317 op equal *tmp98 LINK_ID 0
   318 jump *label62 equal *tmp98 false
 
   335 set .DROP_TARGET .CORE
   336 set .DROP_X .CORE_X
   337 set .DROP_Y .CORE_Y
-    * set *tmp105 .DROP_Y
   338 jump *label65 always
   339 label *label64
   340 sensor *tmp106 .DROP_TARGET @x
   341 set .DROP_X *tmp106
   342 sensor *tmp107 .DROP_TARGET @y
   343 set .DROP_Y *tmp107
-    * set *tmp105 .DROP_Y
   344 label *label65
   345 set .LAST_ITEM @mono
   346 set :iter 0
 
   367 print UNIT
   368 print " "
   369 print "found. 2"
-    * set *tmp117 null
   370 jump *label76 always
   371 label *label75
   372 sensor *tmp118 @unit @controlled
 
   379 set *tmp120 null
   380 jump *label78 always
   381 label *label77
-    * set *tmp115 null
   382 jump *label71 always
   383 set *tmp120 null
   384 label *label78
-    * set *tmp117 *tmp120
   385 label *label76
   386 printflush message1
   387 label *label73
   388 jump *label72 always
   389 label *label74
-    * set *tmp115 null
   390 label *label71
   391 ucontrol flag 1
   392 set :state 1
-    * set *tmp114 :state
   393 jump *label70 always
   394 label *label69
-    * set *tmp114 null
   395 label *label70
   396 sensor *tmp121 .SORTER @config
   397 set .ITEM *tmp121
 
   409 label *label83
   410 set .LAST_ITEM .ITEM
   411 set :state 1
-    * set *tmp123 :state
   412 jump *label80 always
   413 label *label79
-    * set *tmp123 null
   414 label *label80
   415 set :show_state 0
   416 op equal *tmp126 :state 1
 
   443 label *label89
   444 set *tmp130 *tmp133
   445 label *label87
-    * set *tmp127 *tmp130
   446 jump *label85 always
   447 label *label84
-    * set *tmp127 null
   448 label *label85
   449 op equal *tmp136 :state 2
   450 jump *label92 equal *tmp136 false
 
   473 set :show_state 2
   474 set *tmp139 :show_state
   475 label *label95
-    * set *tmp137 *tmp139
   476 jump *label93 always
   477 label *label92
-    * set *tmp137 null
   478 label *label93
   479 op equal *tmp146 :state 3
   480 jump *label98 equal *tmp146 false
 
   504 set :show_state 3
   505 set *tmp149 :show_state
   506 label *label101
-    * set *tmp147 *tmp149
   507 jump *label99 always
   508 label *label98
-    * set *tmp147 null
   509 label *label99
   510 op greaterThan *tmp156 :iter 3
   511 jump *label104 equal *tmp156 false
 
   527 print .LOCAL_MARGIN
   528 print "["
   529 print "])"
-    * set *tmp160 null
   530 jump *label107 always
   531 label *label106
-    * set *tmp160 null
   532 label *label107
   533 jump *label108 equal .SHOW_REMOTE_LEVEL false
   534 sensor *tmp162 .CORE .ITEM
 
   548 label *label110
   549 set *tmp164 null
   550 label *label111
-    * set *tmp161 *tmp164
   551 jump *label109 always
   552 label *label108
-    * set *tmp161 null
   553 label *label109
   554 sensor *tmp165 @unit @totalItems
   555 print .MSG
 
   595 label *label117
   596 set *tmp168 *tmp177
   597 label *label115
-    * set *tmp166 *tmp168
   598 jump *label113 always
   599 label *label112
-    * set *tmp166 null
   600 label *label113
   601 op floor *tmp185 :loop_time
   602 print "[lightgray]Loop time: "
 
   608 op equal *tmp187 *tmp186 0
   609 jump *label118 equal *tmp187 false
   610 jump *label68 always
-    * set *tmp188 null
   611 jump *label119 always
   612 label *label118
-    * set *tmp188 null
   613 label *label119
   614 sensor *tmp189 .SRC @dead
   615 op notEqual *tmp190 *tmp189 0
   616 jump *label120 equal *tmp190 false
   617 jump *label68 always
-    * set *tmp191 null
   618 jump *label121 always
   619 label *label120
-    * set *tmp191 null
   620 label *label121
   621 sensor *tmp192 .DST @dead
   622 op notEqual *tmp193 *tmp192 0
   623 jump *label122 equal *tmp193 false
   624 jump *label68 always
-    * set *tmp194 null
   625 jump *label123 always
   626 label *label122
-    * set *tmp194 null
   627 label *label123
   628 sensor *tmp195 .SORTER @dead
   629 op notEqual *tmp196 *tmp195 0
 
   634 label *label124
   635 set *tmp197 null
   636 label *label125
-    * set *tmp157 *tmp197
   637 jump *label105 always
   638 label *label104
   639 op add :iter :iter 1
-    * set *tmp157 :iter
   640 label *label105
   641 op sub *tmp198 @time :start
   642 set :loop_time *tmp198
 
   680 label *label132
   681 jump *label131 always
   682 label *label133
-    * set *tmp209 null
   683 jump *label130 always
   684 label *label129
-    * set *tmp209 null
   685 label *label130
   686 end

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-22 instructions):
 
    81 print UNIT
    82 print "."
    83 print ".."
-    * set *tmp23 null
    84 jump *label24 always
    85 label *label23
-    * set *tmp18 null
    86 jump *label17 always
-    * set *tmp23 null
    87 label *label24
    88 label *label22
    89 printflush message1
    90 label *label19
    91 jump *label18 always
    92 label *label20
-    * set *tmp18 null
    93 label *label17
    94 label *label6
    95 label *label4
 
   145 print "\"
   146 print "n"
   147 print "[salmon]Item dump must be a container or a vault!"
-    * set *tmp40 null
   148 jump *label36 always
   149 label *label35
   150 jump *label27 always
-    * set *tmp40 null
   151 label *label36
   152 label *label34
   153 printflush message1
 
   215 label *label47
   216 set *tmp64 null
   217 label *label48
-    * set *tmp52 *tmp64
   218 jump *label43 always
   219 label *label42
-    * set *tmp52 null
   220 label *label43
   221 label *label38
   222 op equal *tmp65 .CORE null
 
   368 print UNIT
   369 print "."
   370 print ".."
-    * set *tmp120 null
   371 jump *label78 always
   372 label *label77
   373 jump *label71 always
-    * set *tmp120 null
   374 label *label78
   375 label *label76
   376 printflush message1
 
   409 op equal *tmp129 *tmp128 .ITEM
   410 jump *label86 equal *tmp129 false
   411 set :state 3
-    * set *tmp130 :state
   412 jump *label87 always
   413 label *label86
   414 sensor *tmp131 @unit @totalItems
 
   430 label *label91
   431 set *tmp133 *tmp135
   432 label *label89
-    * set *tmp130 *tmp133
   433 label *label87
   434 jump *label85 always
   435 label *label84
 
   453 set .MSG "\nLoading items: [green]"
   454 set *tmp145 .MSG
   455 label *label97
-    * set *tmp139 *tmp145
   456 jump *label95 always
   457 label *label94
   458 ucontrol approach .SRC_X .SRC_Y 6
   459 set .MSG "\nGoing to source: [green]"
   460 set :show_state 2
-    * set *tmp139 :show_state
   461 label *label95
   462 jump *label93 always
   463 label *label92
 
   482 set .MSG "\nDropping items: [green]"
   483 set *tmp155 .MSG
   484 label *label103
-    * set *tmp149 *tmp155
   485 jump *label101 always
   486 label *label100
   487 ucontrol approach .DST_X .DST_Y 6
   488 set .MSG "\nGoing to destination: [green]"
   489 set :show_state 3
-    * set *tmp149 :show_state
   490 label *label101
   491 jump *label99 always
   492 label *label98
 
   527 print .REMOTE_MARGIN
   528 print "["
   529 print "])"
-    * set *tmp164 null
   530 jump *label111 always
   531 label *label110
-    * set *tmp164 null
   532 label *label111
   533 jump *label109 always
   534 label *label108
 
   553 print " "
   554 print "sec[]"
   555 print "\n"
-    * set *tmp168 null
   556 jump *label115 always
   557 label *label114
   558 op equal *tmp176 :show_state 3
 
   574 label *label116
   575 set *tmp177 null
   576 label *label117
-    * set *tmp168 *tmp177
   577 label *label115
   578 jump *label113 always
   579 label *label112
 
   609 op notEqual *tmp196 *tmp195 0
   610 jump *label124 equal *tmp196 false
   611 jump *label68 always
-    * set *tmp197 null
   612 jump *label125 always
   613 label *label124
-    * set *tmp197 null
   614 label *label125
   615 jump *label105 always
   616 label *label104

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   210 op notEqual *tmp63 :b_type @vault
   211 jump *label47 equal *tmp63 false
   212 set .CORE null
-    * set *tmp64 .CORE
   213 jump *label48 always
   214 label *label47
-    * set *tmp64 null
   215 label *label48
   216 jump *label43 always
   217 label *label42
 
   413 op equal *tmp132 *tmp131 0
   414 jump *label88 equal *tmp132 false
   415 set :state 2
-    * set *tmp133 :state
   416 jump *label89 always
   417 label *label88
   418 set .MSG "\nUnloading previous items: [green]"
 
   425 label *label90
   426 set *tmp135 null
   427 label *label91
-    * set *tmp133 *tmp135
   428 label *label89
   429 label *label87
   430 jump *label85 always
 
   443 op greaterThanEq *tmp144 *tmp143 .UNIT_CAPACITY
   444 jump *label96 equal *tmp144 false
   445 set :state 3
-    * set *tmp145 :state
   446 jump *label97 always
   447 label *label96
   448 set .MSG "\nLoading items: [green]"
-    * set *tmp145 .MSG
   449 label *label97
   450 jump *label95 always
   451 label *label94
 
   470 jump *label102 equal *tmp154 false
   471 set :state 2
   472 ucontrol approach .SRC_X .SRC_Y 6
-    * set *tmp155 null
   473 jump *label103 always
   474 label *label102
   475 set .MSG "\nDropping items: [green]"
-    * set *tmp155 .MSG
   476 label *label103
   477 jump *label101 always
   478 label *label100
 
   561 print " "
   562 print "sec[]"
   563 print "\n"
-    * set *tmp177 null
   564 jump *label117 always
   565 label *label116
-    * set *tmp177 null
   566 label *label117
   567 label *label115
   568 jump *label113 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   420 ucontrol within .DROP_X .DROP_Y 8 *tmp134
   421 jump *label90 equal *tmp134 false
   422 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * set *tmp135 null
   423 jump *label91 always
   424 label *label90
-    * set *tmp135 null
   425 label *label91
   426 label *label89
   427 label *label87

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-38 instructions):
 
     1 set LINK_ID 0
     2 set LOCAL_LIMIT 100
     3 set REMOTE_LIMIT 100
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+    4 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+    5 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
 
    28 ubind UNIT
    29 op notEqual *tmp8 @unit null
    30 jump *label10 equal *tmp8 false
-    * set *tmp10 @unit
-    * set :rebindUnit.0:first_unit *tmp10
+   31 set :rebindUnit.0:first_unit @unit
    32 jump *label9 always
    33 jump *label11 always
    34 label *label10
 
    92 label *label4
    93 jump *label3 always
    94 label *label5
-    * sensor *tmp24 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp24
+   95 sensor .UNIT_CAPACITY @unit @itemCapacity
    96 sensor *tmp25 @unit @speed
-    * op div *tmp26 *tmp25 10
-    * set .SPEED_SEC *tmp26
+   97 op div .SPEED_SEC *tmp25 10
    98 ucontrol flag 1
    99 label *label25
   100 jump *label27 equal true false
   101 set .CONTAINER null
   102 set .DROP_TARGET null
-    * set *tmp27 @links
-    * set :n *tmp27
+  103 set :n @links
   104 label *label28
   105 op greaterThan *tmp28 :n 0
   106 jump *label30 equal *tmp28 false
-    * op sub *tmp29 :n 1
-    * set :n *tmp29
-    * getlink *tmp30 :n
-    * set :block *tmp30
+  107 op sub :n :n 1
+  108 getlink :block :n
   109 sensor *tmp31 :block @itemCapacity
   110 op greaterThan *tmp32 *tmp31 0
   111 jump *label31 equal *tmp32 false
 
   153 jump *label37 equal *tmp41 false
   154 print "[gold]Locating core..."
   155 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp44 *tmp43
-    * set .CORE *tmp43
+  156 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   157 jump *label38 always
   158 label *label37
   159 print "[gold]Locating vault #"
 
   161 print "."
   162 print ".."
   163 printflush message1
-    * op add *tmp45 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp45
+  164 op add .QUERY_FLAG 99999900 LINK_ID
   165 set :flag .QUERY_FLAG
   166 ucontrol flag :flag
   167 label *label39
 
   171 op land *tmp49 *tmp46 *tmp48
   172 jump *label41 equal *tmp49 false
   173 ucontrol stop
-    * sensor *tmp50 @unit @flag
-    * set :flag *tmp50
+  174 sensor :flag @unit @flag
   175 label *label40
   176 jump *label39 always
   177 label *label41
   178 op notEqual *tmp51 :flag .QUERY_FLAG
   179 jump *label42 equal *tmp51 false
-    * op idiv *tmp53 :flag 100
-    * set :position *tmp53
-    * op mod *tmp54 :position @mapw
-    * set .CORE_X *tmp54
-    * op idiv *tmp55 :position @mapw
-    * set .CORE_Y *tmp55
+  180 op idiv :position :flag 100
+  181 op mod .CORE_X :position @mapw
+  182 op idiv .CORE_Y :position @mapw
   183 label *label44
   184 ucontrol within .CORE_X .CORE_Y 8 *tmp56
   185 op equal *tmp57 *tmp56 false
 
   191 label *label45
   192 jump *label44 always
   193 label *label46
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp61 *tmp62
-    * set .CORE *tmp61
+  194 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   195 op notEqual *tmp63 :b_type @vault
   196 jump *label47 equal *tmp63 false
   197 set .CORE null
 
   209 label *label49
   210 label *label50
   211 set .SORTER sorter1
-    * sensor *tmp67 .SORTER @type
-    * set :sorter_type *tmp67
+  212 sensor :sorter_type .SORTER @type
   213 label *label51
   214 op notEqual *tmp68 :sorter_type @sorter
   215 op notEqual *tmp69 :sorter_type @inverted-sorter
 
   226 label *label55
   227 printflush message1
   228 set .SORTER sorter1
-    * sensor *tmp73 .SORTER @type
-    * set :sorter_type *tmp73
+  229 sensor :sorter_type .SORTER @type
   230 label *label52
   231 jump *label51 always
   232 label *label53
 
   235 set .SHOW_REMOTE_LEVEL true
   236 set .SRC .CORE
   237 set .DST .CONTAINER
-    * sensor *tmp76 .SRC @itemCapacity
-    * set :src_capacity *tmp76
-    * sensor *tmp77 .DST @itemCapacity
-    * set :dst_capacity *tmp77
+  238 sensor :src_capacity .SRC @itemCapacity
+  239 sensor :dst_capacity .DST @itemCapacity
   240 op sub *tmp78 100 .EFF_REMOTE_LIMIT
   241 op mul *tmp79 :src_capacity *tmp78
-    * op idiv *tmp80 *tmp79 100
-    * set .LOAD_LEVEL *tmp80
+  242 op idiv .LOAD_LEVEL *tmp79 100
   243 op mul *tmp81 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp82 *tmp81 100
-    * set .DROP_LEVEL *tmp82
+  244 op idiv .DROP_LEVEL *tmp81 100
   245 set .LOCAL_MARGIN .DROP_LEVEL
   246 set .REMOTE_MARGIN .LOAD_LEVEL
   247 op equal *tmp83 LINK_ID 0
 
   254 set .DIRECTION *tmp84
   255 jump *label57 always
   256 label *label56
-    * op greaterThan *tmp85 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp85
+  257 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   258 set .SRC .CONTAINER
   259 set .DST .CORE
-    * sensor *tmp86 .SRC @itemCapacity
-    * set :src_capacity *tmp86
-    * sensor *tmp87 .DST @itemCapacity
-    * set :dst_capacity *tmp87
+  260 sensor :src_capacity .SRC @itemCapacity
+  261 sensor :dst_capacity .DST @itemCapacity
   262 op sub *tmp88 100 .EFF_LOCAL_LIMIT
   263 op mul *tmp89 :src_capacity *tmp88
-    * op idiv *tmp90 *tmp89 100
-    * set .LOAD_LEVEL *tmp90
+  264 op idiv .LOAD_LEVEL *tmp89 100
   265 op mul *tmp91 :dst_capacity .EFF_REMOTE_LIMIT
   266 op idiv *tmp92 *tmp91 100
   267 op equal *tmp93 LINK_ID 0
   268 op mul *tmp94 *tmp93 .UNIT_CAPACITY
-    * op add *tmp95 *tmp92 *tmp94
-    * set .DROP_LEVEL *tmp95
+  269 op add .DROP_LEVEL *tmp92 *tmp94
   270 set .LOCAL_MARGIN .LOAD_LEVEL
   271 set .REMOTE_MARGIN .DROP_LEVEL
   272 op equal *tmp96 LINK_ID 0
 
   286 set *tmp99 LINK_ID
   287 label *label63
   288 set .LINK_TXT *tmp99
-    * sensor *tmp100 .SRC @x
-    * set .SRC_X *tmp100
-    * sensor *tmp101 .SRC @y
-    * set .SRC_Y *tmp101
-    * sensor *tmp102 .DST @x
-    * set .DST_X *tmp102
-    * sensor *tmp103 .DST @y
-    * set .DST_Y *tmp103
+  289 sensor .SRC_X .SRC @x
+  290 sensor .SRC_Y .SRC @y
+  291 sensor .DST_X .DST @x
+  292 sensor .DST_Y .DST @y
   293 op equal *tmp104 .DROP_TARGET null
   294 jump *label64 equal *tmp104 false
   295 set .DROP_TARGET .CORE
 
   297 set .DROP_Y .CORE_Y
   298 jump *label65 always
   299 label *label64
-    * sensor *tmp106 .DROP_TARGET @x
-    * set .DROP_X *tmp106
-    * sensor *tmp107 .DROP_TARGET @y
-    * set .DROP_Y *tmp107
+  300 sensor .DROP_X .DROP_TARGET @x
+  301 sensor .DROP_Y .DROP_TARGET @y
   302 label *label65
   303 set .LAST_ITEM @mono
   304 set :iter 0
 
   307 ucontrol stop
   308 label *label66
   309 jump *label68 equal true false
-    * set *tmp108 @time
-    * set :start *tmp108
+  310 set :start @time
   311 sensor *tmp109 @unit @dead
   312 op strictEqual *tmp110 *tmp109 0
   313 sensor *tmp111 @unit @controller
 
   348 jump *label70 always
   349 label *label69
   350 label *label70
-    * sensor *tmp121 .SORTER @config
-    * set .ITEM *tmp121
+  351 sensor .ITEM .SORTER @config
   352 op notEqual *tmp122 .ITEM .LAST_ITEM
   353 jump *label79 equal *tmp122 false
   354 label *label81
 
   356 jump *label83 equal *tmp124 false
   357 print "[salmon]No item type selected for transport."
   358 printflush message1
-    * sensor *tmp125 .SORTER @config
-    * set .ITEM *tmp125
+  359 sensor .ITEM .SORTER @config
   360 label *label82
   361 jump *label81 always
   362 label *label83
 
   399 jump *label94 equal *tmp138 false
   400 sensor *tmp140 .SRC .ITEM
   401 op sub *tmp141 *tmp140 .LOAD_LEVEL
-    * op max *tmp142 *tmp141 0
-    * set :max_load *tmp142
+  402 op max :max_load *tmp141 0
   403 ucontrol itemTake .SRC .ITEM :max_load
   404 sensor *tmp143 @unit @totalItems
   405 op greaterThanEq *tmp144 *tmp143 .UNIT_CAPACITY
 
   424 jump *label100 equal *tmp148 false
   425 sensor *tmp150 .DST .ITEM
   426 op sub *tmp151 .DROP_LEVEL *tmp150
-    * op max *tmp152 *tmp151 0
-    * set :max_drop *tmp152
+  427 op max :max_drop *tmp151 0
   428 ucontrol itemDrop .DST :max_drop
   429 sensor *tmp153 @unit @totalItems
   430 op lessThanEq *tmp154 *tmp153 0
 
   567 label *label104
   568 op add :iter :iter 1
   569 label *label105
-    * op sub *tmp198 @time :start
-    * set :loop_time *tmp198
+  570 op sub :loop_time @time :start
   571 label *label67
   572 jump *label66 always
   573 label *label68

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-6 instructions):
 
    24 # "Function: inline def rebindUnit()"
    25 set :rebindUnit.0:first_unit null
    26 label *label7
-    * jump *label9 equal true false
    27 ubind UNIT
    28 op notEqual *tmp8 @unit null
    29 jump *label10 equal *tmp8 false
 
    60 label *label14
    61 # "Function: inline def findUnit()"
    62 label *label18
-    * jump *label20 equal true false
    63 ubind UNIT
    64 op equal *tmp19 @unit null
    65 jump *label21 equal *tmp19 false
 
    95 op div .SPEED_SEC *tmp25 10
    96 ucontrol flag 1
    97 label *label25
-    * jump *label27 equal true false
    98 set .CONTAINER null
    99 set .DROP_TARGET null
   100 set :n @links
 
   303 set :state 1
   304 ucontrol stop
   305 label *label66
-    * jump *label68 equal true false
   306 set :start @time
   307 sensor *tmp109 @unit @dead
   308 op strictEqual *tmp110 *tmp109 0
 
   312 jump *label69 equal *tmp113 false
   313 # "Function: inline def findUnit()"
   314 label *label72
-    * jump *label74 equal true false
   315 ubind UNIT
   316 op equal *tmp116 @unit null
   317 jump *label75 equal *tmp116 false
 
   486 print *tmp165
   487 print "[]"
   488 print "\n"
-    * jump *label112 equal true false
   489 op equal *tmp167 :show_state 2
   490 jump *label114 equal *tmp167 false
   491 sensor *tmp169 @unit @x

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-42 instructions):
 
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
-    * op equal *tmp3 *tmp2 false
-    * jump *label2 equal *tmp3 false
+    9 jump *label2 notEqual *tmp2 false
    10 print "Unit Transport - Single"
    11 print "\n"
    12 print "Activate switch to start."
 
    18 label *label3
    19 sensor *tmp4 @unit @dead
    20 op strictEqual *tmp6 *tmp4 0
-    * op equal *tmp5 *tmp6 false
-    * jump *label5 equal *tmp5 false
+   21 jump *label5 notEqual *tmp6 false
    22 # "Function: inline def rebindUnit()"
    23 set :rebindUnit.0:first_unit null
    24 label *label7
    25 ubind UNIT
-    * op notEqual *tmp8 @unit null
-    * jump *label10 equal *tmp8 false
+   26 jump *label10 equal @unit null
    27 set :rebindUnit.0:first_unit @unit
    28 jump *label9 always
    29 jump *label11 always
 
    39 label *label9
    40 label *label12
    41 sensor *tmp11 @unit @controller
-    * op equal *tmp12 *tmp11 @this
-    * jump *label15 equal *tmp12 false
+   42 jump *label15 notEqual *tmp11 @this
    43 jump *label6 always
    44 jump *label16 always
    45 label *label15
 
    57 # "Function: inline def findUnit()"
    58 label *label18
    59 ubind UNIT
-    * op equal *tmp19 @unit null
-    * jump *label21 equal *tmp19 false
+   60 jump *label21 notEqual @unit null
    61 print "[salmon]No unit of type "
    62 print UNIT
    63 print " "
 
    65 jump *label22 always
    66 label *label21
    67 sensor *tmp21 @unit @controlled
-    * op notEqual *tmp22 *tmp21 0
-    * jump *label23 equal *tmp22 false
+   68 jump *label23 equal *tmp21 0
    69 print "[salmon]Looking for a free "
    70 print UNIT
    71 print "."
 
    93 set .DROP_TARGET null
    94 set :n @links
    95 label *label28
-    * op greaterThan *tmp28 :n 0
-    * jump *label30 equal *tmp28 false
+   96 jump *label30 lessThanEq :n 0
    97 op sub :n :n 1
    98 getlink :block :n
    99 sensor *tmp31 :block @itemCapacity
-    * op greaterThan *tmp32 *tmp31 0
-    * jump *label31 equal *tmp32 false
+  100 jump *label31 lessThanEq *tmp31 0
   101 set .DROP_TARGET .CONTAINER
   102 set .CONTAINER :block
   103 jump *label32 always
 
   106 label *label29
   107 jump *label28 always
   108 label *label30
-    * op equal *tmp34 .CONTAINER null
-    * jump *label33 equal *tmp34 false
+  109 jump *label33 notEqual .CONTAINER null
   110 print "[salmon]No destination."
   111 print "\n"
   112 jump *label34 always
 
   137 set .CORE_Y null
   138 set .CORE_X .CORE_Y
   139 set .CORE .CORE_X
-    * op equal *tmp41 LINK_ID 0
-    * jump *label37 equal *tmp41 false
+  140 jump *label37 notEqual LINK_ID 0
   141 print "[gold]Locating core..."
   142 printflush message1
   143 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
 
   162 label *label40
   163 jump *label39 always
   164 label *label41
-    * op notEqual *tmp51 :flag .QUERY_FLAG
-    * jump *label42 equal *tmp51 false
+  165 jump *label42 equal :flag .QUERY_FLAG
   166 op idiv :position :flag 100
   167 op mod .CORE_X :position @mapw
   168 op idiv .CORE_Y :position @mapw
 
   178 jump *label44 always
   179 label *label46
   180 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
-    * op notEqual *tmp63 :b_type @vault
-    * jump *label47 equal *tmp63 false
+  181 jump *label47 equal :b_type @vault
   182 set .CORE null
   183 jump *label48 always
   184 label *label47
 
   187 label *label42
   188 label *label43
   189 label *label38
-    * op equal *tmp65 .CORE null
-    * jump *label49 equal *tmp65 false
+  190 jump *label49 notEqual .CORE null
   191 end
   192 jump *label50 always
   193 label *label49
 
   201 jump *label53 equal *tmp70 false
   202 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   203 print "\n"
-    * op notEqual *tmp71 .SORTER null
-    * jump *label54 equal *tmp71 false
+  204 jump *label54 equal .SORTER null
   205 print "Block found: "
   206 print .SORTER
   207 jump *label55 always
 
   213 label *label52
   214 jump *label51 always
   215 label *label53
-    * op equal *tmp74 :sorter_type @sorter
-    * jump *label56 equal *tmp74 false
+  216 jump *label56 notEqual :sorter_type @sorter
   217 set .SHOW_REMOTE_LEVEL true
   218 set .SRC .CORE
   219 set .DST .CONTAINER
 
   226 op idiv .DROP_LEVEL *tmp81 100
   227 set .LOCAL_MARGIN .DROP_LEVEL
   228 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op equal *tmp83 LINK_ID 0
-    * jump *label58 equal *tmp83 false
+  229 jump *label58 notEqual LINK_ID 0
   230 set *tmp84 "[] from core"
   231 jump *label59 always
   232 label *label58
 
   250 op add .DROP_LEVEL *tmp92 *tmp94
   251 set .LOCAL_MARGIN .LOAD_LEVEL
   252 set .REMOTE_MARGIN .DROP_LEVEL
-    * op equal *tmp96 LINK_ID 0
-    * jump *label60 equal *tmp96 false
+  253 jump *label60 notEqual LINK_ID 0
   254 set *tmp97 "[] to core"
   255 jump *label61 always
   256 label *label60
 
   258 label *label61
   259 set .DIRECTION *tmp97
   260 label *label57
-    * op equal *tmp98 LINK_ID 0
-    * jump *label62 equal *tmp98 false
+  261 jump *label62 notEqual LINK_ID 0
   262 set *tmp99 ""
   263 jump *label63 always
   264 label *label62
 
   269 sensor .SRC_Y .SRC @y
   270 sensor .DST_X .DST @x
   271 sensor .DST_Y .DST @y
-    * op equal *tmp104 .DROP_TARGET null
-    * jump *label64 equal *tmp104 false
+  272 jump *label64 notEqual .DROP_TARGET null
   273 set .DROP_TARGET .CORE
   274 set .DROP_X .CORE_X
   275 set .DROP_Y .CORE_Y
 
   289 op strictEqual *tmp110 *tmp109 0
   290 sensor *tmp111 @unit @controller
   291 op notEqual *tmp112 *tmp111 @this
-    * op lessThanEq *tmp113 *tmp110 *tmp112
-    * jump *label69 equal *tmp113 false
+  292 jump *label69 greaterThan *tmp110 *tmp112
   293 # "Function: inline def findUnit()"
   294 label *label72
   295 ubind UNIT
-    * op equal *tmp116 @unit null
-    * jump *label75 equal *tmp116 false
+  296 jump *label75 notEqual @unit null
   297 print "[salmon]No unit of type "
   298 print UNIT
   299 print " "
 
   301 jump *label76 always
   302 label *label75
   303 sensor *tmp118 @unit @controlled
-    * op notEqual *tmp119 *tmp118 0
-    * jump *label77 equal *tmp119 false
+  304 jump *label77 equal *tmp118 0
   305 print "[salmon]Looking for a free "
   306 print UNIT
   307 print "."
 
   322 label *label69
   323 label *label70
   324 sensor .ITEM .SORTER @config
-    * op notEqual *tmp122 .ITEM .LAST_ITEM
-    * jump *label79 equal *tmp122 false
+  325 jump *label79 equal .ITEM .LAST_ITEM
   326 label *label81
-    * op equal *tmp124 .ITEM null
-    * jump *label83 equal *tmp124 false
+  327 jump *label83 notEqual .ITEM null
   328 print "[salmon]No item type selected for transport."
   329 printflush message1
   330 sensor .ITEM .SORTER @config
 
   337 label *label79
   338 label *label80
   339 set :show_state 0
-    * op equal *tmp126 :state 1
-    * jump *label84 equal *tmp126 false
+  340 jump *label84 notEqual :state 1
   341 sensor *tmp128 @unit @firstItem
-    * op equal *tmp129 *tmp128 .ITEM
-    * jump *label86 equal *tmp129 false
+  342 jump *label86 notEqual *tmp128 .ITEM
   343 set :state 3
   344 jump *label87 always
   345 label *label86
   346 sensor *tmp131 @unit @totalItems
-    * op equal *tmp132 *tmp131 0
-    * jump *label88 equal *tmp132 false
+  347 jump *label88 notEqual *tmp131 0
   348 set :state 2
   349 jump *label89 always
   350 label *label88
 
   361 jump *label85 always
   362 label *label84
   363 label *label85
-    * op equal *tmp136 :state 2
-    * jump *label92 equal *tmp136 false
+  364 jump *label92 notEqual :state 2
   365 ucontrol within .SRC_X .SRC_Y 8 *tmp138
   366 jump *label94 equal *tmp138 false
   367 sensor *tmp140 .SRC .ITEM
 
   369 op max :max_load *tmp141 0
   370 ucontrol itemTake .SRC .ITEM :max_load
   371 sensor *tmp143 @unit @totalItems
-    * op greaterThanEq *tmp144 *tmp143 .UNIT_CAPACITY
-    * jump *label96 equal *tmp144 false
+  372 jump *label96 lessThan *tmp143 .UNIT_CAPACITY
   373 set :state 3
   374 jump *label97 always
   375 label *label96
 
   384 jump *label93 always
   385 label *label92
   386 label *label93
-    * op equal *tmp146 :state 3
-    * jump *label98 equal *tmp146 false
+  387 jump *label98 notEqual :state 3
   388 ucontrol within .DST_X .DST_Y 8 *tmp148
   389 jump *label100 equal *tmp148 false
   390 sensor *tmp150 .DST .ITEM
 
   392 op max :max_drop *tmp151 0
   393 ucontrol itemDrop .DST :max_drop
   394 sensor *tmp153 @unit @totalItems
-    * op lessThanEq *tmp154 *tmp153 0
-    * jump *label102 equal *tmp154 false
+  395 jump *label102 greaterThan *tmp153 0
   396 set :state 2
   397 ucontrol approach .SRC_X .SRC_Y 6
   398 jump *label103 always
 
   408 jump *label99 always
   409 label *label98
   410 label *label99
-    * op greaterThan *tmp156 :iter 3
-    * jump *label104 equal *tmp156 false
+  411 jump *label104 lessThanEq :iter 3
   412 set :iter 0
   413 print "Moving [green]"
   414 print .ITEM
 
   421 print *tmp158
   422 print "["
   423 print "]"
-    * op lessThan *tmp159 .EFF_LOCAL_LIMIT 100
-    * jump *label106 equal *tmp159 false
+  424 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
   425 print " (limit [orange]"
   426 print .LOCAL_MARGIN
   427 print "["
 
   436 print *tmp162
   437 print "["
   438 print "]"
-    * op lessThan *tmp163 .EFF_REMOTE_LIMIT 100
-    * jump *label110 equal *tmp163 false
+  439 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
   440 print " (limit [orange]"
   441 print .REMOTE_MARGIN
   442 print "["
 
   452 print *tmp165
   453 print "[]"
   454 print "\n"
-    * op equal *tmp167 :show_state 2
-    * jump *label114 equal *tmp167 false
+  455 jump *label114 notEqual :show_state 2
   456 sensor *tmp169 @unit @x
   457 op sub *tmp170 .SRC_X *tmp169
   458 sensor *tmp171 @unit @y
 
   467 print "\n"
   468 jump *label115 always
   469 label *label114
-    * op equal *tmp176 :show_state 3
-    * jump *label116 equal *tmp176 false
+  470 jump *label116 notEqual :show_state 3
   471 sensor *tmp178 @unit @x
   472 op sub *tmp179 .DST_X *tmp178
   473 sensor *tmp180 @unit @y
 
   494 print "\n"
   495 printflush message1
   496 sensor *tmp186 switch1 @enabled
-    * op equal *tmp187 *tmp186 0
-    * jump *label118 equal *tmp187 false
+  497 jump *label118 notEqual *tmp186 0
   498 jump *label68 always
   499 jump *label119 always
   500 label *label118
   501 label *label119
   502 sensor *tmp189 .SRC @dead
-    * op notEqual *tmp190 *tmp189 0
-    * jump *label120 equal *tmp190 false
+  503 jump *label120 equal *tmp189 0
   504 jump *label68 always
   505 jump *label121 always
   506 label *label120
   507 label *label121
   508 sensor *tmp192 .DST @dead
-    * op notEqual *tmp193 *tmp192 0
-    * jump *label122 equal *tmp193 false
+  509 jump *label122 equal *tmp192 0
   510 jump *label68 always
   511 jump *label123 always
   512 label *label122
   513 label *label123
   514 sensor *tmp195 .SORTER @dead
-    * op notEqual *tmp196 *tmp195 0
-    * jump *label124 equal *tmp196 false
+  515 jump *label124 equal *tmp195 0
   516 jump *label68 always
   517 jump *label125 always
   518 label *label124
 
   528 label *label126
   529 sensor *tmp199 .SORTER @dead
   530 op strictEqual *tmp200 *tmp199 0
-    * op equal *tmp201 *tmp200 false
-    * jump *label128 equal *tmp201 false
+  531 jump *label128 notEqual *tmp200 false
   532 print "[salmon]sorter1 is missing!"
   533 print "\n"
   534 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   550 control enabled switch1 false
   551 label *label131
   552 sensor *tmp211 switch1 @enabled
-    * op equal *tmp212 *tmp211 false
-    * jump *label133 equal *tmp212 false
+  553 jump *label133 notEqual *tmp211 false
   554 print "[salmon]Local or remote container became invalid."
   555 print "\n"
   556 print "[gold]Please fix and press button to reinitialize."

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-23 instructions):
 
    26 jump *label10 equal @unit null
    27 set :rebindUnit.0:first_unit @unit
    28 jump *label9 always
-    * jump *label11 always
    29 label *label10
    30 label *label11
    31 print "[salmon]No unit of type "
 
    40 sensor *tmp11 @unit @controller
    41 jump *label15 notEqual *tmp11 @this
    42 jump *label6 always
-    * jump *label16 always
    43 label *label15
    44 label *label16
    45 ubind UNIT
 
    98 jump *label31 lessThanEq *tmp31 0
    99 set .DROP_TARGET .CONTAINER
   100 set .CONTAINER :block
-    * jump *label32 always
   101 label *label31
   102 label *label32
   103 label *label29
 
   177 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   178 jump *label47 equal :b_type @vault
   179 set .CORE null
-    * jump *label48 always
   180 label *label47
   181 label *label48
-    * jump *label43 always
   182 label *label42
   183 label *label43
   184 label *label38
   185 jump *label49 notEqual .CORE null
   186 end
-    * jump *label50 always
   187 label *label49
   188 label *label50
   189 set .SORTER sorter1
 
   198 jump *label54 equal .SORTER null
   199 print "Block found: "
   200 print .SORTER
-    * jump *label55 always
   201 label *label54
   202 label *label55
   203 printflush message1
 
   311 label *label71
   312 ucontrol flag 1
   313 set :state 1
-    * jump *label70 always
   314 label *label69
   315 label *label70
   316 sensor .ITEM .SORTER @config
 
   325 label *label83
   326 set .LAST_ITEM .ITEM
   327 set :state 1
-    * jump *label80 always
   328 label *label79
   329 label *label80
   330 set :show_state 0
 
   344 ucontrol within .DROP_X .DROP_Y 8 *tmp134
   345 jump *label90 equal *tmp134 false
   346 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * jump *label91 always
   347 label *label90
   348 label *label91
   349 label *label89
   350 label *label87
-    * jump *label85 always
   351 label *label84
   352 label *label85
   353 jump *label92 notEqual :state 2
 
   370 set .MSG "\nGoing to source: [green]"
   371 set :show_state 2
   372 label *label95
-    * jump *label93 always
   373 label *label92
   374 label *label93
   375 jump *label98 notEqual :state 3
 
   393 set .MSG "\nGoing to destination: [green]"
   394 set :show_state 3
   395 label *label101
-    * jump *label99 always
   396 label *label98
   397 label *label99
   398 jump *label104 lessThanEq :iter 3
 
   413 print .LOCAL_MARGIN
   414 print "["
   415 print "])"
-    * jump *label107 always
   416 label *label106
   417 label *label107
   418 jump *label108 equal .SHOW_REMOTE_LEVEL false
 
   427 print .REMOTE_MARGIN
   428 print "["
   429 print "])"
-    * jump *label111 always
   430 label *label110
   431 label *label111
-    * jump *label109 always
   432 label *label108
   433 label *label109
   434 sensor *tmp165 @unit @totalItems
 
   464 print " "
   465 print "sec[]"
   466 print "\n"
-    * jump *label117 always
   467 label *label116
   468 label *label117
   469 label *label115
-    * jump *label113 always
   470 label *label112
   471 label *label113
   472 op floor *tmp185 :loop_time
 
   478 sensor *tmp186 switch1 @enabled
   479 jump *label118 notEqual *tmp186 0
   480 jump *label68 always
-    * jump *label119 always
   481 label *label118
   482 label *label119
   483 sensor *tmp189 .SRC @dead
   484 jump *label120 equal *tmp189 0
   485 jump *label68 always
-    * jump *label121 always
   486 label *label120
   487 label *label121
   488 sensor *tmp192 .DST @dead
   489 jump *label122 equal *tmp192 0
   490 jump *label68 always
-    * jump *label123 always
   491 label *label122
   492 label *label123
   493 sensor *tmp195 .SORTER @dead
   494 jump *label124 equal *tmp195 0
   495 jump *label68 always
-    * jump *label125 always
   496 label *label124
   497 label *label125
   498 jump *label105 always
 
   538 label *label132
   539 jump *label131 always
   540 label *label133
-    * jump *label130 always
   541 label *label129
   542 label *label130
   543 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   132 jump *label25 always
   133 label *label27
   134 set .CORE_Y null
-    * set .CORE_X .CORE_Y
-    * set .CORE .CORE_X
+  135 set .CORE_X null
+  136 set .CORE .CORE_Y
   137 jump *label37 notEqual LINK_ID 0
   138 print "[gold]Locating core..."
   139 printflush message1
 
   147 printflush message1
   148 op add .QUERY_FLAG 99999900 LINK_ID
   149 set :flag .QUERY_FLAG
-    * ucontrol flag :flag
+  150 ucontrol flag .QUERY_FLAG
   151 label *label39
   152 op equal *tmp46 :flag .QUERY_FLAG
   153 sensor *tmp47 @unit @dead
 
   187 label *label49
   188 label *label50
   189 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  190 sensor :sorter_type sorter1 @type
   191 label *label51
   192 op notEqual *tmp68 :sorter_type @sorter
   193 op notEqual *tmp69 :sorter_type @inverted-sorter
 
   202 label *label55
   203 printflush message1
   204 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  205 sensor :sorter_type sorter1 @type
   206 label *label52
   207 jump *label51 always
   208 label *label53
 
   210 set .SHOW_REMOTE_LEVEL true
   211 set .SRC .CORE
   212 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  213 sensor :src_capacity .CORE @itemCapacity
+  214 sensor :dst_capacity .CONTAINER @itemCapacity
   215 op sub *tmp78 100 .EFF_REMOTE_LIMIT
   216 op mul *tmp79 :src_capacity *tmp78
   217 op idiv .LOAD_LEVEL *tmp79 100
 
   231 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   232 set .SRC .CONTAINER
   233 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  234 sensor :src_capacity .CONTAINER @itemCapacity
+  235 sensor :dst_capacity .CORE @itemCapacity
   236 op sub *tmp88 100 .EFF_LOCAL_LIMIT
   237 op mul *tmp89 :src_capacity *tmp88
   238 op idiv .LOAD_LEVEL *tmp89 100
 
   400 print "Moving [green]"
   401 print .ITEM
   402 print .DIRECTION
-    * print .LINK_TXT
+  403 print *tmp99
   404 print "\"
   405 print "n"
   406 sensor *tmp158 .CONTAINER .ITEM

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   133 label *label27
   134 set .CORE_Y null
   135 set .CORE_X null
-    * set .CORE .CORE_Y
+  136 set .CORE null
   137 jump *label37 notEqual LINK_ID 0
   138 print "[gold]Locating core..."
   139 printflush message1
 
   257 label *label62
   258 set *tmp99 LINK_ID
   259 label *label63
-    * set .LINK_TXT *tmp99
   260 sensor .SRC_X .SRC @x
   261 sensor .SRC_Y .SRC @y
   262 sensor .DST_X .DST @x

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    92 set :n @links
    93 label *label28
    94 jump *label30 lessThanEq :n 0
+   95 label *label134
    96 op sub :n :n 1
    97 getlink :block :n
    98 sensor *tmp31 :block @itemCapacity
 
   102 label *label31
   103 label *label32
   104 label *label29
-    * jump *label28 always
+  105 jump *label134 greaterThan :n 0
   106 label *label30
   107 jump *label33 notEqual .CONTAINER null
   108 print "[salmon]No destination."
 
   317 jump *label79 equal .ITEM .LAST_ITEM
   318 label *label81
   319 jump *label83 notEqual .ITEM null
+  320 label *label135
   321 print "[salmon]No item type selected for transport."
   322 printflush message1
   323 sensor .ITEM .SORTER @config
   324 label *label82
-    * jump *label81 always
+  325 jump *label135 equal .ITEM null
   326 label *label83
   327 set .LAST_ITEM .ITEM
   328 set :state 1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
   220 op idiv .DROP_LEVEL *tmp81 100
   221 set .LOCAL_MARGIN .DROP_LEVEL
   222 set .REMOTE_MARGIN .LOAD_LEVEL
-    * jump *label58 notEqual LINK_ID 0
-    * set *tmp84 "[] from core"
+  223 set .DIRECTION "[] from vault #"
+  224 jump *label59 notEqual LINK_ID 0
+  225 set .DIRECTION "[] from core"
   226 jump *label59 always
-    * label *label58
-    * set *tmp84 "[] from vault #"
   227 label *label59
-    * set .DIRECTION *tmp84
   228 jump *label57 always
   229 label *label56
   230 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   242 op add .DROP_LEVEL *tmp92 *tmp94
   243 set .LOCAL_MARGIN .LOAD_LEVEL
   244 set .REMOTE_MARGIN .DROP_LEVEL
-    * jump *label60 notEqual LINK_ID 0
-    * set *tmp97 "[] to core"
+  245 set .DIRECTION "[] to vault #"
+  246 jump *label61 notEqual LINK_ID 0
+  247 set .DIRECTION "[] to core"
   248 jump *label61 always
-    * label *label60
-    * set *tmp97 "[] to vault #"
   249 label *label61
-    * set .DIRECTION *tmp97
   250 label *label57
-    * jump *label62 notEqual LINK_ID 0
+  251 set *tmp99 LINK_ID
+  252 jump *label63 notEqual LINK_ID 0
   253 set *tmp99 ""
   254 jump *label63 always
-    * label *label62
-    * set *tmp99 LINK_ID
   255 label *label63
   256 sensor .SRC_X .SRC @x
   257 sensor .SRC_Y .SRC @y

Modifications by Replicate loop condition at line 43:1 (+1 instructions):
 
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
     9 jump *label2 notEqual *tmp2 false
+   10 label *label136
    11 print "Unit Transport - Single"
    12 print "\n"
    13 print "Activate switch to start."
    14 print "\n"
    15 printflush message1
    16 label *label1
-    * jump *label0 always
+   17 sensor *tmp2 switch1 @enabled
+   18 jump *label136 equal *tmp2 false
    19 label *label2
    20 label *label3
    21 sensor *tmp4 @unit @dead

Modifications by Replicate loop condition at line 314:5 (+1 instructions):
 
   527 label *label131
   528 sensor *tmp211 switch1 @enabled
   529 jump *label133 notEqual *tmp211 false
+  530 label *label137
   531 print "[salmon]Local or remote container became invalid."
   532 print "\n"
   533 print "[gold]Please fix and press button to reinitialize."
 
   535 printflush message1
   536 printflush message2
   537 label *label132
-    * jump *label131 always
+  538 sensor *tmp211 switch1 @enabled
+  539 jump *label137 equal *tmp211 false
   540 label *label133
   541 label *label129
   542 label *label130

Modifications by Replicate loop condition at line 51:1 (+2 instructions):
 
    21 sensor *tmp4 @unit @dead
    22 op strictEqual *tmp6 *tmp4 0
    23 jump *label5 notEqual *tmp6 false
+   24 label *label138
    25 # "Function: inline def rebindUnit()"
    26 set :rebindUnit.0:first_unit null
    27 label *label7
 
    83 label *label17
    84 label *label6
    85 label *label4
-    * jump *label3 always
+   86 sensor *tmp4 @unit @dead
+   87 op strictEqual *tmp6 *tmp4 0
+   88 jump *label138 equal *tmp6 false
    89 label *label5
    90 sensor .UNIT_CAPACITY @unit @itemCapacity
    91 sensor *tmp25 @unit @speed

Modifications by Replicate loop condition at line 304:1 (+2 instructions):
 
   508 sensor *tmp199 .SORTER @dead
   509 op strictEqual *tmp200 *tmp199 0
   510 jump *label128 notEqual *tmp200 false
+  511 label *label139
   512 print "[salmon]sorter1 is missing!"
   513 print "\n"
   514 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   517 printflush message2
   518 set .SORTER sorter1
   519 label *label127
-    * jump *label126 always
+  520 sensor *tmp199 .SORTER @dead
+  521 op strictEqual *tmp200 *tmp199 0
+  522 jump *label139 equal *tmp200 false
   523 label *label128
   524 sensor *tmp202 .SRC @dead
   525 op strictEqual *tmp204 *tmp202 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   517 printflush message2
   518 set .SORTER sorter1
   519 label *label127
-    * sensor *tmp199 .SORTER @dead
+  520 sensor *tmp199 sorter1 @dead
   521 op strictEqual *tmp200 *tmp199 0
   522 jump *label139 equal *tmp200 false
   523 label *label128

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   515 print "\n"
   516 printflush message1
   517 printflush message2
-    * set .SORTER sorter1
   518 label *label127
   519 sensor *tmp199 sorter1 @dead
   520 op strictEqual *tmp200 *tmp199 0

Modifications by Replicate loop condition at line 129:1 (+3 instructions):
 
   199 op notEqual *tmp69 :sorter_type @inverted-sorter
   200 op land *tmp70 *tmp68 *tmp69
   201 jump *label53 equal *tmp70 false
+  202 label *label140
   203 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   204 print "\n"
   205 jump *label54 equal .SORTER null
 
   211 set .SORTER sorter1
   212 sensor :sorter_type sorter1 @type
   213 label *label52
-    * jump *label51 always
+  214 op notEqual *tmp68 :sorter_type @sorter
+  215 op notEqual *tmp69 :sorter_type @inverted-sorter
+  216 op land *tmp70 *tmp68 *tmp69
+  217 jump *label140 notEqual *tmp70 false
   218 label *label53
   219 jump *label56 notEqual :sorter_type @sorter
   220 set .SHOW_REMOTE_LEVEL true

Modifications by Replicate loop condition at line 102:5 (+4 instructions):
 
   160 op strictEqual *tmp48 *tmp47 0
   161 op land *tmp49 *tmp46 *tmp48
   162 jump *label41 equal *tmp49 false
+  163 label *label141
   164 ucontrol stop
   165 sensor :flag @unit @flag
   166 label *label40
-    * jump *label39 always
+  167 op equal *tmp46 :flag .QUERY_FLAG
+  168 sensor *tmp47 @unit @dead
+  169 op strictEqual *tmp48 *tmp47 0
+  170 op land *tmp49 *tmp46 *tmp48
+  171 jump *label141 notEqual *tmp49 false
   172 label *label41
   173 jump *label42 equal :flag .QUERY_FLAG
   174 op idiv :position :flag 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   155 set :flag .QUERY_FLAG
   156 ucontrol flag .QUERY_FLAG
   157 label *label39
-    * op equal *tmp46 :flag .QUERY_FLAG
+  158 op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
   159 sensor *tmp47 @unit @dead
   160 op strictEqual *tmp48 *tmp47 0
   161 op land *tmp49 *tmp46 *tmp48

Modifications by Replicate loop condition at line 110:9 (+5 instructions):
 
   181 op equal *tmp59 *tmp58 0
   182 op land *tmp60 *tmp57 *tmp59
   183 jump *label46 equal *tmp60 false
+  184 label *label142
   185 ucontrol approach .CORE_X .CORE_Y 6
   186 label *label45
-    * jump *label44 always
+  187 ucontrol within .CORE_X .CORE_Y 8 *tmp56
+  188 op equal *tmp57 *tmp56 false
+  189 sensor *tmp58 @unit @dead
+  190 op equal *tmp59 *tmp58 0
+  191 op land *tmp60 *tmp57 *tmp59
+  192 jump *label142 notEqual *tmp60 false
   193 label *label46
   194 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   195 jump *label47 equal :b_type @vault

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
   243 set .DIRECTION "[] from vault #"
   244 jump *label59 notEqual LINK_ID 0
   245 set .DIRECTION "[] from core"
-    * jump *label59 always
   246 label *label59
   247 jump *label57 always
   248 label *label56
 
   264 set .DIRECTION "[] to vault #"
   265 jump *label61 notEqual LINK_ID 0
   266 set .DIRECTION "[] to core"
-    * jump *label61 always
   267 label *label61
   268 label *label57
   269 set *tmp99 LINK_ID
   270 jump *label63 notEqual LINK_ID 0
   271 set *tmp99 ""
-    * jump *label63 always
   272 label *label63
   273 sensor .SRC_X .SRC @x
   274 sensor .SRC_Y .SRC @y

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   155 set :flag .QUERY_FLAG
   156 ucontrol flag .QUERY_FLAG
   157 label *label39
-    * op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
+  158 set *tmp46 true
   159 sensor *tmp47 @unit @dead
   160 op strictEqual *tmp48 *tmp47 0
   161 op land *tmp49 *tmp46 *tmp48

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   158 set *tmp46 true
   159 sensor *tmp47 @unit @dead
   160 op strictEqual *tmp48 *tmp47 0
-    * op land *tmp49 *tmp46 *tmp48
+  161 op land *tmp49 true *tmp48
   162 jump *label41 equal *tmp49 false
   163 label *label141
   164 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
   155 set :flag .QUERY_FLAG
   156 ucontrol flag .QUERY_FLAG
   157 label *label39
-    * set *tmp46 true
   158 sensor *tmp47 @unit @dead
   159 op strictEqual *tmp48 *tmp47 0
   160 op land *tmp49 true *tmp48

Modifications by Final phase, Jump Straightening, iteration 1 (-5 instructions):
 
    41 label *label9
    42 label *label12
    43 sensor *tmp11 @unit @controller
-    * jump *label15 notEqual *tmp11 @this
-    * jump *label6 always
+   44 jump *label6 equal *tmp11 @this
    45 label *label15
    46 label *label16
    47 ubind UNIT
 
   487 print "\n"
   488 printflush message1
   489 sensor *tmp186 switch1 @enabled
-    * jump *label118 notEqual *tmp186 0
-    * jump *label68 always
+  490 jump *label68 equal *tmp186 0
   491 label *label118
   492 label *label119
   493 sensor *tmp189 .SRC @dead
-    * jump *label120 equal *tmp189 0
-    * jump *label68 always
+  494 jump *label68 notEqual *tmp189 0
   495 label *label120
   496 label *label121
   497 sensor *tmp192 .DST @dead
-    * jump *label122 equal *tmp192 0
-    * jump *label68 always
+  498 jump *label68 notEqual *tmp192 0
   499 label *label122
   500 label *label123
   501 sensor *tmp195 .SORTER @dead
-    * jump *label124 equal *tmp195 0
-    * jump *label68 always
+  502 jump *label68 notEqual *tmp195 0
   503 label *label124
   504 label *label125
   505 jump *label105 always

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 set UNIT @mega
     2 set LINK_ID 0
     3 set LOCAL_LIMIT 100
 
    66 jump *label22 always
    67 label *label21
    68 sensor *tmp21 @unit @controlled
-    * jump *label23 equal *tmp21 0
+   69 jump *label17 equal *tmp21 0
    70 print "[salmon]Looking for a free "
    71 print UNIT
    72 print "."
 
   118 sensor *tmp37 .DROP_TARGET @itemCapacity
   119 op lessThan *tmp38 *tmp37 300
   120 op land *tmp39 *tmp36 *tmp38
-    * jump *label35 equal *tmp39 false
+  121 jump *label27 equal *tmp39 false
   122 print "Destination: "
   123 print .CONTAINER
   124 print "\"
 
   240 set .LOCAL_MARGIN .DROP_LEVEL
   241 set .REMOTE_MARGIN .LOAD_LEVEL
   242 set .DIRECTION "[] from vault #"
-    * jump *label59 notEqual LINK_ID 0
+  243 jump *label57 notEqual LINK_ID 0
   244 set .DIRECTION "[] from core"
   245 label *label59
   246 jump *label57 always
 
   305 jump *label76 always
   306 label *label75
   307 sensor *tmp118 @unit @controlled
-    * jump *label77 equal *tmp118 0
+  308 jump *label71 equal *tmp118 0
   309 print "[salmon]Looking for a free "
   310 print UNIT
   311 print "."
 
   372 sensor *tmp143 @unit @totalItems
   373 jump *label96 lessThan *tmp143 .UNIT_CAPACITY
   374 set :state 3
-    * jump *label97 always
+  375 jump *label95 always
   376 label *label96
   377 set .MSG "\nLoading items: [green]"
   378 label *label97
 
   395 jump *label102 greaterThan *tmp153 0
   396 set :state 2
   397 ucontrol approach .SRC_X .SRC_Y 6
-    * jump *label103 always
+  398 jump *label101 always
   399 label *label102
   400 set .MSG "\nDropping items: [green]"
   401 label *label103
 
   534 op strictEqual *tmp207 *tmp205 0
   535 op equal *tmp206 *tmp207 false
   536 op or *tmp208 *tmp203 *tmp206
-    * jump *label129 equal *tmp208 false
+  537 jump __start__ equal *tmp208 false
   538 control enabled switch1 false
   539 label *label131
   540 sensor *tmp211 switch1 @enabled
-    * jump *label133 notEqual *tmp211 false
+  541 jump __start__ notEqual *tmp211 false
   542 label *label137
   543 print "[salmon]Local or remote container became invalid."
   544 print "\n"

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-3 instructions):
 
    72 print "."
    73 print ".."
    74 jump *label24 always
-    * label *label23
-    * jump *label17 always
    75 label *label24
    76 label *label22
    77 printflush message1
    78 label *label19
    79 jump *label18 always
-    * label *label20
    80 label *label17
    81 label *label6
    82 label *label4
 
   126 print "n"
   127 print "[salmon]Item dump must be a container or a vault!"
   128 jump *label36 always
-    * label *label35
-    * jump *label27 always
   129 label *label36
   130 label *label34
   131 printflush message1
 
   306 print "."
   307 print ".."
   308 jump *label78 always
-    * label *label77
-    * jump *label71 always
   309 label *label78
   310 label *label76
   311 printflush message1
   312 label *label73
   313 jump *label72 always
-    * label *label74
   314 label *label71
   315 ucontrol flag 1
   316 set :state 1

Modifications by Final phase, Single Step Elimination, iteration 1 (-4 instructions):
 
    71 print UNIT
    72 print "."
    73 print ".."
-    * jump *label24 always
    74 label *label24
    75 label *label22
    76 printflush message1
 
   124 print "\"
   125 print "n"
   126 print "[salmon]Item dump must be a container or a vault!"
-    * jump *label36 always
   127 label *label36
   128 label *label34
   129 printflush message1
 
   303 print UNIT
   304 print "."
   305 print ".."
-    * jump *label78 always
   306 label *label78
   307 label *label76
   308 printflush message1
 
   541 label *label133
   542 label *label129
   543 label *label130
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-50 instructions):
 
     9 sensor *tmp2 switch1 @enabled
    10 jump *label2 notEqual *tmp2 false
    11 label *label136
-    * print "Unit Transport - Single"
-    * print "\n"
-    * print "Activate switch to start."
-    * print "\n"
+   12 print "Unit Transport - Single\nActivate switch to start.\n"
    13 printflush message1
    14 label *label1
    15 sensor *tmp2 switch1 @enabled
 
    29 jump *label9 always
    30 label *label10
    31 label *label11
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 1"
+   32 print "[salmon]No unit of type {0} found. 1"
+   33 format UNIT
    34 printflush message1
    35 label *label8
    36 jump *label7 always
 
    54 label *label18
    55 ubind UNIT
    56 jump *label21 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+   57 print "[salmon]No unit of type {0} found. 2"
+   58 format UNIT
    59 jump *label22 always
    60 label *label21
    61 sensor *tmp21 @unit @controlled
    62 jump *label17 equal *tmp21 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+   63 print "[salmon]Looking for a free {0}..."
+   64 format UNIT
    65 label *label24
    66 label *label22
    67 printflush message1
 
    97 jump *label134 greaterThan :n 0
    98 label *label30
    99 jump *label33 notEqual .CONTAINER null
-    * print "[salmon]No destination."
-    * print "\n"
+  100 print "[salmon]No destination.\n"
   101 jump *label34 always
   102 label *label33
   103 op notEqual *tmp36 .DROP_TARGET null
 
   105 op lessThan *tmp38 *tmp37 300
   106 op land *tmp39 *tmp36 *tmp38
   107 jump *label27 equal *tmp39 false
-    * print "Destination: "
-    * print .CONTAINER
-    * print "\"
-    * print "n"
-    * print "Item dump: "
-    * print .DROP_TARGET
-    * print "\"
-    * print "n"
-    * print "[salmon]Item dump must be a container or a vault!"
+  108 print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
+  109 format .CONTAINER
+  110 format .DROP_TARGET
   111 label *label36
   112 label *label34
   113 printflush message1
 
   123 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   124 jump *label38 always
   125 label *label37
-    * print "[gold]Locating vault #"
-    * print LINK_ID
-    * print "."
-    * print ".."
+  126 print "[gold]Locating vault #{0}..."
+  127 format LINK_ID
   128 printflush message1
   129 op add .QUERY_FLAG 99999900 LINK_ID
   130 set :flag .QUERY_FLAG
 
   185 op land *tmp70 *tmp68 *tmp69
   186 jump *label53 equal *tmp70 false
   187 label *label140
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  188 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   189 jump *label54 equal .SORTER null
   190 print "Block found: "
   191 print .SORTER
 
   272 label *label72
   273 ubind UNIT
   274 jump *label75 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+  275 print "[salmon]No unit of type {0} found. 2"
+  276 format UNIT
   277 jump *label76 always
   278 label *label75
   279 sensor *tmp118 @unit @controlled
   280 jump *label71 equal *tmp118 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+  281 print "[salmon]Looking for a free {0}..."
+  282 format UNIT
   283 label *label78
   284 label *label76
   285 printflush message1
 
   375 label *label99
   376 jump *label104 lessThanEq :iter 3
   377 set :iter 0
-    * print "Moving [green]"
-    * print .ITEM
-    * print .DIRECTION
-    * print *tmp99
-    * print "\"
-    * print "n"
+  378 print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
+  379 format .ITEM
+  380 format .DIRECTION
+  381 format *tmp99
   382 sensor *tmp158 .CONTAINER .ITEM
-    * print "Local items: [gold]"
-    * print *tmp158
-    * print "["
-    * print "]"
+  383 format *tmp158
   384 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
-    * print " (limit [orange]"
-    * print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  385 print " (limit [orange]{0}[])"
+  386 format .LOCAL_MARGIN
   387 label *label106
   388 label *label107
   389 jump *label108 equal .SHOW_REMOTE_LEVEL false
   390 sensor *tmp162 .CORE .ITEM
-    * print "\n"
-    * print "Remote items: [gold]"
-    * print *tmp162
-    * print "["
-    * print "]"
+  391 print "\nRemote items: [gold]{0}[]"
+  392 format *tmp162
   393 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
-    * print " (limit [orange]"
-    * print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  394 print " (limit [orange]{0}[])"
+  395 format .REMOTE_MARGIN
   396 label *label110
   397 label *label111
   398 label *label108
 
   400 sensor *tmp165 @unit @totalItems
   401 print .MSG
   402 print *tmp165
-    * print "[]"
-    * print "\n"
+  403 print "[]\n"
   404 jump *label114 notEqual :show_state 2
   405 sensor *tmp169 @unit @x
   406 op sub *tmp170 .SRC_X *tmp169
 
   409 op len *tmp173 *tmp170 *tmp172
   410 op idiv *tmp174 *tmp173 .SPEED_SEC
   411 op div *tmp175 *tmp174 10
-    * print "[]  arriving in [gold]"
-    * print *tmp175
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  412 print "[]  arriving in [gold]{0} sec[]\n"
+  413 format *tmp175
   414 jump *label115 always
   415 label *label114
   416 jump *label116 notEqual :show_state 3
 
   421 op len *tmp182 *tmp179 *tmp181
   422 op idiv *tmp183 *tmp182 .SPEED_SEC
   423 op div *tmp184 *tmp183 10
-    * print "[]  arriving in [gold]"
-    * print *tmp184
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  424 print "[]  arriving in [gold]{0} sec[]\n"
+  425 format *tmp184
   426 label *label116
   427 label *label117
   428 label *label115
   429 label *label112
   430 label *label113
   431 op floor *tmp185 :loop_time
-    * print "[lightgray]Loop time: "
-    * print *tmp185
-    * print " ms[]"
-    * print "\n"
+  432 print "[lightgray]Loop time: {0} ms[]\n"
+  433 format *tmp185
   434 printflush message1
   435 sensor *tmp186 switch1 @enabled
   436 jump *label68 equal *tmp186 0
 
   461 op strictEqual *tmp200 *tmp199 0
   462 jump *label128 notEqual *tmp200 false
   463 label *label139
-    * print "[salmon]sorter1 is missing!"
-    * print "\n"
-    * print "[gold]Please place and link sorter or inverted sorter to the processor."
-    * print "\n"
+  464 print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
   465 printflush message1
   466 printflush message2
   467 label *label127
 
   482 sensor *tmp211 switch1 @enabled
   483 jump __start__ notEqual *tmp211 false
   484 label *label137
-    * print "[salmon]Local or remote container became invalid."
-    * print "\n"
-    * print "[gold]Please fix and press button to reinitialize."
-    * print "\n"
+  485 print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
   486 printflush message1
   487 printflush message2
   488 label *label132

Final code before resolving virtual instructions:

label __start__
set UNIT @mega
set LINK_ID 0
set LOCAL_LIMIT 100
set REMOTE_LIMIT 100
op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
set .MSG null
sensor *tmp2 switch1 @enabled
jump *label2 notEqual *tmp2 false
label *label136
print "Unit Transport - Single\nActivate switch to start.\n"
printflush message1
sensor *tmp2 switch1 @enabled
jump *label136 equal *tmp2 false
label *label2
sensor *tmp4 @unit @dead
op strictEqual *tmp6 *tmp4 0
jump *label5 notEqual *tmp6 false
label *label138
# "Function: inline def rebindUnit()"
set :rebindUnit.0:first_unit null
label *label7
ubind UNIT
jump *label10 equal @unit null
set :rebindUnit.0:first_unit @unit
jump *label9 always
label *label10
print "[salmon]No unit of type {0} found. 1"
format UNIT
printflush message1
jump *label7 always
label *label9
label *label12
sensor *tmp11 @unit @controller
jump *label6 equal *tmp11 @this
ubind UNIT
print "[gold]Looking for old unit..."
printflush message1
op notEqual *tmp14 @unit :rebindUnit.0:first_unit
sensor *tmp15 :rebindUnit.0:first_unit @dead
op strictEqual *tmp16 *tmp15 0
op land *tmp17 *tmp14 *tmp16
jump *label12 notEqual *tmp17 false
# "Function: inline def findUnit()"
label *label18
ubind UNIT
jump *label21 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label22 always
label *label21
sensor *tmp21 @unit @controlled
jump *label17 equal *tmp21 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label22
printflush message1
jump *label18 always
label *label17
label *label6
sensor *tmp4 @unit @dead
op strictEqual *tmp6 *tmp4 0
jump *label138 equal *tmp6 false
label *label5
sensor .UNIT_CAPACITY @unit @itemCapacity
sensor *tmp25 @unit @speed
op div .SPEED_SEC *tmp25 10
ucontrol flag 1
label *label25
set .CONTAINER null
set .DROP_TARGET null
set :n @links
jump *label30 lessThanEq :n 0
label *label134
op sub :n :n 1
getlink :block :n
sensor *tmp31 :block @itemCapacity
jump *label31 lessThanEq *tmp31 0
set .DROP_TARGET .CONTAINER
set .CONTAINER :block
label *label31
jump *label134 greaterThan :n 0
label *label30
jump *label33 notEqual .CONTAINER null
print "[salmon]No destination.\n"
jump *label34 always
label *label33
op notEqual *tmp36 .DROP_TARGET null
sensor *tmp37 .DROP_TARGET @itemCapacity
op lessThan *tmp38 *tmp37 300
op land *tmp39 *tmp36 *tmp38
jump *label27 equal *tmp39 false
print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
format .CONTAINER
format .DROP_TARGET
label *label34
printflush message1
jump *label25 always
label *label27
set .CORE_Y null
set .CORE_X null
set .CORE null
jump *label37 notEqual LINK_ID 0
print "[gold]Locating core..."
printflush message1
ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
jump *label38 always
label *label37
print "[gold]Locating vault #{0}..."
format LINK_ID
printflush message1
op add .QUERY_FLAG 99999900 LINK_ID
set :flag .QUERY_FLAG
ucontrol flag .QUERY_FLAG
sensor *tmp47 @unit @dead
op strictEqual *tmp48 *tmp47 0
op land *tmp49 true *tmp48
jump *label41 equal *tmp49 false
label *label141
ucontrol stop
sensor :flag @unit @flag
op equal *tmp46 :flag .QUERY_FLAG
sensor *tmp47 @unit @dead
op strictEqual *tmp48 *tmp47 0
op land *tmp49 *tmp46 *tmp48
jump *label141 notEqual *tmp49 false
label *label41
jump *label42 equal :flag .QUERY_FLAG
op idiv :position :flag 100
op mod .CORE_X :position @mapw
op idiv .CORE_Y :position @mapw
ucontrol within .CORE_X .CORE_Y 8 *tmp56
op equal *tmp57 *tmp56 false
sensor *tmp58 @unit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label46 equal *tmp60 false
label *label142
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp56
op equal *tmp57 *tmp56 false
sensor *tmp58 @unit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label142 notEqual *tmp60 false
label *label46
ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
jump *label47 equal :b_type @vault
set .CORE null
label *label47
label *label42
label *label38
jump *label49 notEqual .CORE null
end
label *label49
set .SORTER sorter1
sensor :sorter_type sorter1 @type
op notEqual *tmp68 :sorter_type @sorter
op notEqual *tmp69 :sorter_type @inverted-sorter
op land *tmp70 *tmp68 *tmp69
jump *label53 equal *tmp70 false
label *label140
print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
jump *label54 equal .SORTER null
print "Block found: "
print .SORTER
label *label54
printflush message1
set .SORTER sorter1
sensor :sorter_type sorter1 @type
op notEqual *tmp68 :sorter_type @sorter
op notEqual *tmp69 :sorter_type @inverted-sorter
op land *tmp70 *tmp68 *tmp69
jump *label140 notEqual *tmp70 false
label *label53
jump *label56 notEqual :sorter_type @sorter
set .SHOW_REMOTE_LEVEL true
set .SRC .CORE
set .DST .CONTAINER
sensor :src_capacity .CORE @itemCapacity
sensor :dst_capacity .CONTAINER @itemCapacity
op sub *tmp78 100 .EFF_REMOTE_LIMIT
op mul *tmp79 :src_capacity *tmp78
op idiv .LOAD_LEVEL *tmp79 100
op mul *tmp81 :dst_capacity .EFF_LOCAL_LIMIT
op idiv .DROP_LEVEL *tmp81 100
set .LOCAL_MARGIN .DROP_LEVEL
set .REMOTE_MARGIN .LOAD_LEVEL
set .DIRECTION "[] from vault #"
jump *label57 notEqual LINK_ID 0
set .DIRECTION "[] from core"
jump *label57 always
label *label56
op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
set .SRC .CONTAINER
set .DST .CORE
sensor :src_capacity .CONTAINER @itemCapacity
sensor :dst_capacity .CORE @itemCapacity
op sub *tmp88 100 .EFF_LOCAL_LIMIT
op mul *tmp89 :src_capacity *tmp88
op idiv .LOAD_LEVEL *tmp89 100
op mul *tmp91 :dst_capacity .EFF_REMOTE_LIMIT
op idiv *tmp92 *tmp91 100
op equal *tmp93 LINK_ID 0
op mul *tmp94 *tmp93 .UNIT_CAPACITY
op add .DROP_LEVEL *tmp92 *tmp94
set .LOCAL_MARGIN .LOAD_LEVEL
set .REMOTE_MARGIN .DROP_LEVEL
set .DIRECTION "[] to vault #"
jump *label61 notEqual LINK_ID 0
set .DIRECTION "[] to core"
label *label61
label *label57
set *tmp99 LINK_ID
jump *label63 notEqual LINK_ID 0
set *tmp99 ""
label *label63
sensor .SRC_X .SRC @x
sensor .SRC_Y .SRC @y
sensor .DST_X .DST @x
sensor .DST_Y .DST @y
jump *label64 notEqual .DROP_TARGET null
set .DROP_TARGET .CORE
set .DROP_X .CORE_X
set .DROP_Y .CORE_Y
jump *label65 always
label *label64
sensor .DROP_X .DROP_TARGET @x
sensor .DROP_Y .DROP_TARGET @y
label *label65
set .LAST_ITEM @mono
set :iter 0
set :loop_time 0
set :state 1
ucontrol stop
label *label66
set :start @time
sensor *tmp109 @unit @dead
op strictEqual *tmp110 *tmp109 0
sensor *tmp111 @unit @controller
op notEqual *tmp112 *tmp111 @this
jump *label69 greaterThan *tmp110 *tmp112
# "Function: inline def findUnit()"
label *label72
ubind UNIT
jump *label75 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label76 always
label *label75
sensor *tmp118 @unit @controlled
jump *label71 equal *tmp118 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label76
printflush message1
jump *label72 always
label *label71
ucontrol flag 1
set :state 1
label *label69
sensor .ITEM .SORTER @config
jump *label79 equal .ITEM .LAST_ITEM
jump *label83 notEqual .ITEM null
label *label135
print "[salmon]No item type selected for transport."
printflush message1
sensor .ITEM .SORTER @config
jump *label135 equal .ITEM null
label *label83
set .LAST_ITEM .ITEM
set :state 1
label *label79
set :show_state 0
jump *label84 notEqual :state 1
sensor *tmp128 @unit @firstItem
jump *label86 notEqual *tmp128 .ITEM
set :state 3
jump *label87 always
label *label86
sensor *tmp131 @unit @totalItems
jump *label88 notEqual *tmp131 0
set :state 2
jump *label89 always
label *label88
set .MSG "\nUnloading previous items: [green]"
ucontrol approach .DROP_X .DROP_Y 6
ucontrol within .DROP_X .DROP_Y 8 *tmp134
jump *label90 equal *tmp134 false
ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
label *label90
label *label89
label *label87
label *label84
jump *label92 notEqual :state 2
ucontrol within .SRC_X .SRC_Y 8 *tmp138
jump *label94 equal *tmp138 false
sensor *tmp140 .SRC .ITEM
op sub *tmp141 *tmp140 .LOAD_LEVEL
op max :max_load *tmp141 0
ucontrol itemTake .SRC .ITEM :max_load
sensor *tmp143 @unit @totalItems
jump *label96 lessThan *tmp143 .UNIT_CAPACITY
set :state 3
jump *label95 always
label *label96
set .MSG "\nLoading items: [green]"
jump *label95 always
label *label94
ucontrol approach .SRC_X .SRC_Y 6
set .MSG "\nGoing to source: [green]"
set :show_state 2
label *label95
label *label92
jump *label98 notEqual :state 3
ucontrol within .DST_X .DST_Y 8 *tmp148
jump *label100 equal *tmp148 false
sensor *tmp150 .DST .ITEM
op sub *tmp151 .DROP_LEVEL *tmp150
op max :max_drop *tmp151 0
ucontrol itemDrop .DST :max_drop
sensor *tmp153 @unit @totalItems
jump *label102 greaterThan *tmp153 0
set :state 2
ucontrol approach .SRC_X .SRC_Y 6
jump *label101 always
label *label102
set .MSG "\nDropping items: [green]"
jump *label101 always
label *label100
ucontrol approach .DST_X .DST_Y 6
set .MSG "\nGoing to destination: [green]"
set :show_state 3
label *label101
label *label98
jump *label104 lessThanEq :iter 3
set :iter 0
print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
format .ITEM
format .DIRECTION
format *tmp99
sensor *tmp158 .CONTAINER .ITEM
format *tmp158
jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
print " (limit [orange]{0}[])"
format .LOCAL_MARGIN
label *label106
jump *label108 equal .SHOW_REMOTE_LEVEL false
sensor *tmp162 .CORE .ITEM
print "\nRemote items: [gold]{0}[]"
format *tmp162
jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
print " (limit [orange]{0}[])"
format .REMOTE_MARGIN
label *label110
label *label108
sensor *tmp165 @unit @totalItems
print .MSG
print *tmp165
print "[]\n"
jump *label114 notEqual :show_state 2
sensor *tmp169 @unit @x
op sub *tmp170 .SRC_X *tmp169
sensor *tmp171 @unit @y
op sub *tmp172 .SRC_Y *tmp171
op len *tmp173 *tmp170 *tmp172
op idiv *tmp174 *tmp173 .SPEED_SEC
op div *tmp175 *tmp174 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp175
jump *label115 always
label *label114
jump *label116 notEqual :show_state 3
sensor *tmp178 @unit @x
op sub *tmp179 .DST_X *tmp178
sensor *tmp180 @unit @y
op sub *tmp181 .DST_Y *tmp180
op len *tmp182 *tmp179 *tmp181
op idiv *tmp183 *tmp182 .SPEED_SEC
op div *tmp184 *tmp183 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp184
label *label116
label *label115
op floor *tmp185 :loop_time
print "[lightgray]Loop time: {0} ms[]\n"
format *tmp185
printflush message1
sensor *tmp186 switch1 @enabled
jump *label68 equal *tmp186 0
sensor *tmp189 .SRC @dead
jump *label68 notEqual *tmp189 0
sensor *tmp192 .DST @dead
jump *label68 notEqual *tmp192 0
sensor *tmp195 .SORTER @dead
jump *label68 notEqual *tmp195 0
jump *label105 always
label *label104
op add :iter :iter 1
label *label105
op sub :loop_time @time :start
jump *label66 always
label *label68
sensor *tmp199 .SORTER @dead
op strictEqual *tmp200 *tmp199 0
jump *label128 notEqual *tmp200 false
label *label139
print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
printflush message1
printflush message2
sensor *tmp199 sorter1 @dead
op strictEqual *tmp200 *tmp199 0
jump *label139 equal *tmp200 false
label *label128
sensor *tmp202 .SRC @dead
op strictEqual *tmp204 *tmp202 0
op equal *tmp203 *tmp204 false
sensor *tmp205 .DST @dead
op strictEqual *tmp207 *tmp205 0
op equal *tmp206 *tmp207 false
op or *tmp208 *tmp203 *tmp206
jump __start__ equal *tmp208 false
control enabled switch1 false
sensor *tmp211 switch1 @enabled
jump __start__ notEqual *tmp211 false
label *label137
print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
printflush message1
printflush message2
sensor *tmp211 switch1 @enabled
jump *label137 equal *tmp211 false
