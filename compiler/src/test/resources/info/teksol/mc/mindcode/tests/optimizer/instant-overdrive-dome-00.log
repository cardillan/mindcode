  1432 instructions before optimizations.
    52 instructions eliminated by Temp Variables Elimination.
   263 instructions eliminated by Dead Code Elimination (2 passes, 8 iterations).
     3 instructions eliminated by Jump Normalization (3 passes, 5 iterations).
    71 instructions eliminated by Jump Optimization (2 passes, 5 iterations).
   104 instructions eliminated by Single Step Elimination (4 passes, 9 iterations).
     2 instructions modified by Expression Optimization (4 iterations).
     2 instructions eliminated by If Expression Optimization (4 iterations).
    94 instructions eliminated by Data Flow Optimization (4 passes, 17 iterations).
     2 instructions added by Loop Optimization (4 iterations).
     3 loops improved by Loop Optimization.
   139 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
    17 instructions eliminated by Jump Straightening (5 iterations).
    24 instructions updated by JumpThreading.
    18 instructions eliminated by Unreachable Code Elimination.
    83 instructions eliminated by Print Merging.
   866 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 203):
  * Replicate loop condition at line 44:1                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
    Replicate loop condition at line 127:1                       cost     1, benefit       25.0, efficiency       25.0
  ! Unroll iteration loop at line 177:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 1: speed optimization selection (cost limit 202):
  * Replicate loop condition at line 127:1                       cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
  ! Unroll iteration loop at line 177:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 1: speed optimization selection (cost limit 201):
  ! Unroll iteration loop at line 177:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 2: speed optimization selection (cost limit 232):
  * Unroll iteration loop at line 177:9                          cost   181, benefit      375.0, efficiency        2.1 (+135 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-166 instructions):
 
    79 label *label21
    80 set *tmp24 null
    81 label *label22
-    * set *tmp22 *tmp24
    82 jump *label20 always
    83 label *label19
    84 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
-    * set *tmp22 :areUnitsAvailable.0:occupied
    85 label *label20
    86 ubind :areUnitsAvailable.0:type
    87 label *label17
 
    91 op land *tmp28 *tmp25 *tmp27
    92 jump *label16 notEqual *tmp28 false
    93 label *label18
-    * set *tmp7 null
    94 jump *label12 always
    95 label *label11
-    * set *tmp7 null
    96 label *label12
    97 jump *label23 equal :areUnitsAvailable.0:output false
    98 print :areUnitsAvailable.0:type
 
   106 jump *label25 equal *tmp30 false
   107 print ", needed: "
   108 print :areUnitsAvailable.0:needed
-    * set *tmp31 null
   109 jump *label26 always
   110 label *label25
-    * set *tmp31 null
   111 label *label26
   112 print "\n"
-    * set *tmp29 null
   113 jump *label24 always
   114 label *label23
-    * set *tmp29 null
   115 label *label24
   116 set *tmp4 false
   117 jump *label10 always
 
   120 jump *label27 equal *tmp4 false
   121 set *tmp3 UNIT_TYPE
   122 jump *label6 always
-    * set *tmp32 null
   123 jump *label28 always
   124 label *label27
-    * set *tmp32 null
   125 label *label28
   126 set :chooseUnitType.0:type @flare
   127 setaddr *tmp33 *label32
 
   189 label *label49
   190 set *tmp56 null
   191 label *label50
-    * set *tmp54 *tmp56
   192 jump *label48 always
   193 label *label47
   194 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp54 :areUnitsAvailable.1:occupied
   195 label *label48
   196 ubind :areUnitsAvailable.1:type
   197 label *label45
 
   201 op land *tmp60 *tmp57 *tmp59
   202 jump *label44 notEqual *tmp60 false
   203 label *label46
-    * set *tmp39 null
   204 jump *label40 always
   205 label *label39
-    * set *tmp39 null
   206 label *label40
   207 jump *label51 equal :areUnitsAvailable.1:output false
   208 print :areUnitsAvailable.1:type
 
   216 jump *label53 equal *tmp62 false
   217 print ", needed: "
   218 print :areUnitsAvailable.1:needed
-    * set *tmp63 null
   219 jump *label54 always
   220 label *label53
-    * set *tmp63 null
   221 label *label54
   222 print "\n"
-    * set *tmp61 null
   223 jump *label52 always
   224 label *label51
-    * set *tmp61 null
   225 label *label52
   226 set *tmp36 false
   227 jump *label38 always
 
   236 label *label55
   237 set *tmp64 null
   238 label *label56
-    * set *tmp35 *tmp64
   239 jump *label37 always
   240 label *label36
-    * set *tmp35 null
   241 label *label37
   242 label *label30
   243 multijump *tmp33 0 0
 
   263 op equal *tmp67 :rebindUnits.0:firstUnit null
   264 jump *label58 equal *tmp67 false
   265 end
-    * set *tmp68 null
   266 jump *label59 always
   267 label *label58
-    * set *tmp68 null
   268 label *label59
   269 label *label60
   270 sensor *tmp69 @unit @controller
 
   285 label *label65
   286 set *tmp74 null
   287 label *label66
-    * set *tmp71 *tmp74
   288 jump *label64 always
   289 label *label63
-    * set *tmp71 null
   290 label *label64
   291 ubind .TYPE
   292 label *label61
 
   296 op land *tmp78 *tmp75 *tmp77
   297 jump *label60 notEqual *tmp78 false
   298 label *label62
-    * set *tmp65 :rebindUnits.0:count
   299 jump *label57 always
-    * set *tmp65 null
   300 label *label57
   301 set :acquireUnit.0:currentUnit .UNIT_S1
   302 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
 
   309 op equal *tmp86 *tmp85 @this
   310 op land *tmp87 *tmp84 *tmp86
   311 jump *label71 equal *tmp87 false
-    * set *tmp80 :rebindUnit.0:currentUnit
   312 jump *label68 always
   313 set *tmp88 null
   314 jump *label72 always
   315 label *label71
   316 set *tmp88 null
   317 label *label72
-    * set *tmp82 *tmp88
   318 jump *label70 always
   319 label *label69
-    * set *tmp82 null
   320 label *label70
   321 ubind .TYPE
   322 set *tmp89 @unit
 
   327 sensor *tmp92 @unit @controlled
   328 op equal *tmp93 *tmp92 0
   329 jump *label78 equal *tmp93 false
-    * set *tmp80 @unit
   330 jump *label68 always
-    * set *tmp94 null
   331 jump *label79 always
   332 label *label78
-    * set *tmp94 null
   333 label *label79
   334 ubind .TYPE
   335 label *label76
 
   339 op land *tmp98 *tmp95 *tmp97
   340 jump *label75 notEqual *tmp98 false
   341 label *label77
-    * set *tmp91 null
   342 jump *label74 always
   343 label *label73
-    * set *tmp91 null
   344 label *label74
   345 end
-    * set *tmp80 null
   346 label *label68
   347 ucontrol flag 1
   348 set *tmp79 @unit
 
   361 op equal *tmp106 *tmp105 @this
   362 op land *tmp107 *tmp104 *tmp106
   363 jump *label84 equal *tmp107 false
-    * set *tmp100 :rebindUnit.1:currentUnit
   364 jump *label81 always
   365 set *tmp108 null
   366 jump *label85 always
   367 label *label84
   368 set *tmp108 null
   369 label *label85
-    * set *tmp102 *tmp108
   370 jump *label83 always
   371 label *label82
-    * set *tmp102 null
   372 label *label83
   373 ubind .TYPE
   374 set *tmp109 @unit
 
   379 sensor *tmp112 @unit @controlled
   380 op equal *tmp113 *tmp112 0
   381 jump *label91 equal *tmp113 false
-    * set *tmp100 @unit
   382 jump *label81 always
-    * set *tmp114 null
   383 jump *label92 always
   384 label *label91
-    * set *tmp114 null
   385 label *label92
   386 ubind .TYPE
   387 label *label89
 
   391 op land *tmp118 *tmp115 *tmp117
   392 jump *label88 notEqual *tmp118 false
   393 label *label90
-    * set *tmp111 null
   394 jump *label87 always
   395 label *label86
-    * set *tmp111 null
   396 label *label87
   397 end
-    * set *tmp100 null
   398 label *label81
   399 ucontrol flag 1
   400 set *tmp99 @unit
 
   411 set :u .UNIT_S1
   412 set .UNIT_S1 .UNIT_P1
   413 set .UNIT_P1 :u
-    * set *tmp124 .UNIT_P1
   414 jump *label94 always
   415 label *label93
-    * set *tmp124 null
   416 label *label94
   417 sensor *tmp125 .UNIT_S1 @itemCapacity
   418 set .UNIT_CAPACITY *tmp125
 
   423 op strictEqual *tmp128 .SPEED null
   424 jump *label95 equal *tmp128 false
   425 stop
-    * set *tmp129 null
   426 jump *label96 always
   427 label *label95
-    * set *tmp129 null
   428 label *label96
   429 print "[gold]Locating core..."
   430 printflush message1
 
   469 op equal *tmp155 *tmp154 @this
   470 op land *tmp156 *tmp153 *tmp155
   471 jump *label107 equal *tmp156 false
-    * set *tmp149 :rebindUnit.2:currentUnit
   472 jump *label104 always
   473 set *tmp157 null
   474 jump *label108 always
   475 label *label107
   476 set *tmp157 null
   477 label *label108
-    * set *tmp151 *tmp157
   478 jump *label106 always
   479 label *label105
-    * set *tmp151 null
   480 label *label106
   481 ubind .TYPE
   482 set *tmp158 @unit
 
   487 sensor *tmp161 @unit @controlled
   488 op equal *tmp162 *tmp161 0
   489 jump *label114 equal *tmp162 false
-    * set *tmp149 @unit
   490 jump *label104 always
-    * set *tmp163 null
   491 jump *label115 always
   492 label *label114
-    * set *tmp163 null
   493 label *label115
   494 ubind .TYPE
   495 label *label112
 
   499 op land *tmp167 *tmp164 *tmp166
   500 jump *label111 notEqual *tmp167 false
   501 label *label113
-    * set *tmp160 null
   502 jump *label110 always
   503 label *label109
-    * set *tmp160 null
   504 label *label110
   505 end
-    * set *tmp149 null
   506 label *label104
   507 ucontrol flag 1
   508 set *tmp148 @unit
 
   521 op equal *tmp175 *tmp174 @this
   522 op land *tmp176 *tmp173 *tmp175
   523 jump *label120 equal *tmp176 false
-    * set *tmp169 :rebindUnit.3:currentUnit
   524 jump *label117 always
   525 set *tmp177 null
   526 jump *label121 always
   527 label *label120
   528 set *tmp177 null
   529 label *label121
-    * set *tmp171 *tmp177
   530 jump *label119 always
   531 label *label118
-    * set *tmp171 null
   532 label *label119
   533 ubind .TYPE
   534 set *tmp178 @unit
 
   539 sensor *tmp181 @unit @controlled
   540 op equal *tmp182 *tmp181 0
   541 jump *label127 equal *tmp182 false
-    * set *tmp169 @unit
   542 jump *label117 always
-    * set *tmp183 null
   543 jump *label128 always
   544 label *label127
-    * set *tmp183 null
   545 label *label128
   546 ubind .TYPE
   547 label *label125
 
   551 op land *tmp187 *tmp184 *tmp186
   552 jump *label124 notEqual *tmp187 false
   553 label *label126
-    * set *tmp180 null
   554 jump *label123 always
   555 label *label122
-    * set *tmp180 null
   556 label *label123
   557 end
-    * set *tmp169 null
   558 label *label117
   559 ucontrol flag 1
   560 set *tmp168 @unit
 
   571 set :u .UNIT_S1
   572 set .UNIT_S1 .UNIT_P2
   573 set .UNIT_P2 :u
-    * set *tmp193 .UNIT_P2
   574 jump *label130 always
   575 label *label129
-    * set *tmp193 null
   576 label *label130
   577 sensor *tmp194 .UNIT_S2 @firstItem
   578 op equal *tmp195 *tmp194 @phase-fabric
 
   583 set :u .UNIT_S2
   584 set .UNIT_S2 .UNIT_P2
   585 set .UNIT_P2 :u
-    * set *tmp199 .UNIT_P2
   586 jump *label132 always
   587 label *label131
-    * set *tmp199 null
   588 label *label132
   589 set .GROUP1 "unit  1"
   590 set .GROUP2 "unit 2"
-    * set *tmp147 .GROUP2
   591 jump *label102 always
   592 label *label101
   593 ubind .UNIT_S2
 
   598 set .UNIT_P2 null
   599 set .GROUP1 "unit"
   600 set .GROUP2 ""
-    * set *tmp147 .GROUP2
   601 label *label102
   602 op equal *tmp200 .FOUR_UNITS false
   603 sensor *tmp201 .UNIT_S1 @totalItems
 
   648 print "\n"
   649 set *tmp216 null
   650 label *label138
-    * set *tmp213 *tmp216
   651 label *label136
   652 set :processUnit.0:unit .UNIT_S1
   653 set :processUnit.0:item @silicon
 
   663 op equal *tmp224 *tmp223 @this
   664 op land *tmp225 *tmp222 *tmp224
   665 jump *label143 equal *tmp225 false
-    * set *tmp218 :rebindUnit.4:currentUnit
   666 jump *label140 always
   667 set *tmp226 null
   668 jump *label144 always
   669 label *label143
   670 set *tmp226 null
   671 label *label144
-    * set *tmp220 *tmp226
   672 jump *label142 always
   673 label *label141
-    * set *tmp220 null
   674 label *label142
   675 ubind .TYPE
   676 set *tmp227 @unit
 
   681 sensor *tmp230 @unit @controlled
   682 op equal *tmp231 *tmp230 0
   683 jump *label150 equal *tmp231 false
-    * set *tmp218 @unit
   684 jump *label140 always
-    * set *tmp232 null
   685 jump *label151 always
   686 label *label150
-    * set *tmp232 null
   687 label *label151
   688 ubind .TYPE
   689 label *label148
 
   693 op land *tmp236 *tmp233 *tmp235
   694 jump *label147 notEqual *tmp236 false
   695 label *label149
-    * set *tmp229 null
   696 jump *label146 always
   697 label *label145
-    * set *tmp229 null
   698 label *label146
   699 end
-    * set *tmp218 null
   700 label *label140
   701 set :processUnit.0:msg ""
   702 sensor *tmp237 @unit @flag
 
   735 label *label157
   736 set *tmp244 *tmp247
   737 label *label155
-    * set *tmp241 *tmp244
   738 jump *label153 always
   739 label *label152
-    * set *tmp241 null
   740 label *label153
   741 op equal *tmp250 :processUnit.0:state 2
   742 jump *label160 equal *tmp250 false
 
   769 set :processUnit.0:distance *tmp263
   770 set *tmp253 :processUnit.0:distance
   771 label *label163
-    * set *tmp251 *tmp253
   772 jump *label161 always
   773 label *label160
-    * set *tmp251 null
   774 label *label161
   775 op equal *tmp264 :processUnit.0:state 3
   776 jump *label166 equal *tmp264 false
 
   779 jump *label170 equal :processUnit.0:supply false
   780 ucontrol itemDrop .DOME .UNIT_CAPACITY
   781 set :processUnit.0:msg ", supplying\n"
-    * set *tmp268 :processUnit.0:msg
   782 jump *label171 always
   783 label *label170
   784 ucontrol approach .DOME_X .DOME_Y 6
   785 set :processUnit.0:msg ", waiting\n"
-    * set *tmp268 :processUnit.0:msg
   786 label *label171
   787 sensor *tmp269 @unit @totalItems
   788 op lessThanEq *tmp270 *tmp269 0
 
   809 set :processUnit.0:distance *tmp278
   810 set *tmp267 :processUnit.0:distance
   811 label *label169
-    * set *tmp265 *tmp267
   812 jump *label167 always
   813 label *label166
-    * set *tmp265 null
   814 label *label167
   815 ucontrol flag :processUnit.0:state
   816 sensor *tmp279 @unit @totalItems
 
   830 print "["
   831 print "] sec"
   832 print "\n"
-    * set *tmp281 null
   833 jump *label175 always
   834 label *label174
   835 print :processUnit.0:msg
-    * set *tmp281 :processUnit.0:msg
   836 label *label175
   837 set *tmp217 @unit
   838 jump *label139 always
 
   855 op equal *tmp291 *tmp290 @this
   856 op land *tmp292 *tmp289 *tmp291
   857 jump *label182 equal *tmp292 false
-    * set *tmp285 :rebindUnit.5:currentUnit
   858 jump *label179 always
   859 set *tmp293 null
   860 jump *label183 always
   861 label *label182
   862 set *tmp293 null
   863 label *label183
-    * set *tmp287 *tmp293
   864 jump *label181 always
   865 label *label180
-    * set *tmp287 null
   866 label *label181
   867 ubind .TYPE
   868 set *tmp294 @unit
 
   873 sensor *tmp297 @unit @controlled
   874 op equal *tmp298 *tmp297 0
   875 jump *label189 equal *tmp298 false
-    * set *tmp285 @unit
   876 jump *label179 always
-    * set *tmp299 null
   877 jump *label190 always
   878 label *label189
-    * set *tmp299 null
   879 label *label190
   880 ubind .TYPE
   881 label *label187
 
   885 op land *tmp303 *tmp300 *tmp302
   886 jump *label186 notEqual *tmp303 false
   887 label *label188
-    * set *tmp296 null
   888 jump *label185 always
   889 label *label184
-    * set *tmp296 null
   890 label *label185
   891 end
-    * set *tmp285 null
   892 label *label179
   893 set :processUnit.1:msg ""
   894 sensor *tmp304 @unit @flag
 
   927 label *label196
   928 set *tmp311 *tmp314
   929 label *label194
-    * set *tmp308 *tmp311
   930 jump *label192 always
   931 label *label191
-    * set *tmp308 null
   932 label *label192
   933 op equal *tmp317 :processUnit.1:state 2
   934 jump *label199 equal *tmp317 false
 
   961 set :processUnit.1:distance *tmp330
   962 set *tmp320 :processUnit.1:distance
   963 label *label202
-    * set *tmp318 *tmp320
   964 jump *label200 always
   965 label *label199
-    * set *tmp318 null
   966 label *label200
   967 op equal *tmp331 :processUnit.1:state 3
   968 jump *label205 equal *tmp331 false
 
   971 jump *label209 equal :processUnit.1:supply false
   972 ucontrol itemDrop .DOME .UNIT_CAPACITY
   973 set :processUnit.1:msg ", supplying\n"
-    * set *tmp335 :processUnit.1:msg
   974 jump *label210 always
   975 label *label209
   976 ucontrol approach .DOME_X .DOME_Y 6
   977 set :processUnit.1:msg ", waiting\n"
-    * set *tmp335 :processUnit.1:msg
   978 label *label210
   979 sensor *tmp336 @unit @totalItems
   980 op lessThanEq *tmp337 *tmp336 0
 
  1001 set :processUnit.1:distance *tmp345
  1002 set *tmp334 :processUnit.1:distance
  1003 label *label208
-    * set *tmp332 *tmp334
  1004 jump *label206 always
  1005 label *label205
-    * set *tmp332 null
  1006 label *label206
  1007 ucontrol flag :processUnit.1:state
  1008 sensor *tmp346 @unit @totalItems
 
  1022 print "["
  1023 print "] sec"
  1024 print "\n"
-    * set *tmp348 null
  1025 jump *label214 always
  1026 label *label213
  1027 print :processUnit.1:msg
-    * set *tmp348 :processUnit.1:msg
  1028 label *label214
  1029 set *tmp284 @unit
  1030 jump *label178 always
 
  1042 set *tmp349 *tmp353
  1043 label *label216
  1044 set .SUPPLY_S_FIRST *tmp349
-    * set *tmp282 .SUPPLY_S_FIRST
  1045 jump *label177 always
  1046 label *label176
-    * set *tmp282 null
  1047 label *label177
  1048 set :printDomeStatus.1:item @phase-fabric
  1049 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
 
  1067 print "\n"
  1068 set *tmp357 null
  1069 label *label219
-    * set *tmp354 *tmp357
  1070 label *label217
  1071 set :processUnit.2:unit .UNIT_P1
  1072 set :processUnit.2:item @phase-fabric
 
  1082 op equal *tmp365 *tmp364 @this
  1083 op land *tmp366 *tmp363 *tmp365
  1084 jump *label224 equal *tmp366 false
-    * set *tmp359 :rebindUnit.6:currentUnit
  1085 jump *label221 always
  1086 set *tmp367 null
  1087 jump *label225 always
  1088 label *label224
  1089 set *tmp367 null
  1090 label *label225
-    * set *tmp361 *tmp367
  1091 jump *label223 always
  1092 label *label222
-    * set *tmp361 null
  1093 label *label223
  1094 ubind .TYPE
  1095 set *tmp368 @unit
 
  1100 sensor *tmp371 @unit @controlled
  1101 op equal *tmp372 *tmp371 0
  1102 jump *label231 equal *tmp372 false
-    * set *tmp359 @unit
  1103 jump *label221 always
-    * set *tmp373 null
  1104 jump *label232 always
  1105 label *label231
-    * set *tmp373 null
  1106 label *label232
  1107 ubind .TYPE
  1108 label *label229
 
  1112 op land *tmp377 *tmp374 *tmp376
  1113 jump *label228 notEqual *tmp377 false
  1114 label *label230
-    * set *tmp370 null
  1115 jump *label227 always
  1116 label *label226
-    * set *tmp370 null
  1117 label *label227
  1118 end
-    * set *tmp359 null
  1119 label *label221
  1120 set :processUnit.2:msg ""
  1121 sensor *tmp378 @unit @flag
 
  1154 label *label238
  1155 set *tmp385 *tmp388
  1156 label *label236
-    * set *tmp382 *tmp385
  1157 jump *label234 always
  1158 label *label233
-    * set *tmp382 null
  1159 label *label234
  1160 op equal *tmp391 :processUnit.2:state 2
  1161 jump *label241 equal *tmp391 false
 
  1188 set :processUnit.2:distance *tmp404
  1189 set *tmp394 :processUnit.2:distance
  1190 label *label244
-    * set *tmp392 *tmp394
  1191 jump *label242 always
  1192 label *label241
-    * set *tmp392 null
  1193 label *label242
  1194 op equal *tmp405 :processUnit.2:state 3
  1195 jump *label247 equal *tmp405 false
 
  1198 jump *label251 equal :processUnit.2:supply false
  1199 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1200 set :processUnit.2:msg ", supplying\n"
-    * set *tmp409 :processUnit.2:msg
  1201 jump *label252 always
  1202 label *label251
  1203 ucontrol approach .DOME_X .DOME_Y 6
  1204 set :processUnit.2:msg ", waiting\n"
-    * set *tmp409 :processUnit.2:msg
  1205 label *label252
  1206 sensor *tmp410 @unit @totalItems
  1207 op lessThanEq *tmp411 *tmp410 0
 
  1228 set :processUnit.2:distance *tmp419
  1229 set *tmp408 :processUnit.2:distance
  1230 label *label250
-    * set *tmp406 *tmp408
  1231 jump *label248 always
  1232 label *label247
-    * set *tmp406 null
  1233 label *label248
  1234 ucontrol flag :processUnit.2:state
  1235 sensor *tmp420 @unit @totalItems
 
  1249 print "["
  1250 print "] sec"
  1251 print "\n"
-    * set *tmp422 null
  1252 jump *label256 always
  1253 label *label255
  1254 print :processUnit.2:msg
-    * set *tmp422 :processUnit.2:msg
  1255 label *label256
  1256 set *tmp358 @unit
  1257 jump *label220 always
 
  1274 op equal *tmp432 *tmp431 @this
  1275 op land *tmp433 *tmp430 *tmp432
  1276 jump *label263 equal *tmp433 false
-    * set *tmp426 :rebindUnit.7:currentUnit
  1277 jump *label260 always
  1278 set *tmp434 null
  1279 jump *label264 always
  1280 label *label263
  1281 set *tmp434 null
  1282 label *label264
-    * set *tmp428 *tmp434
  1283 jump *label262 always
  1284 label *label261
-    * set *tmp428 null
  1285 label *label262
  1286 ubind .TYPE
  1287 set *tmp435 @unit
 
  1292 sensor *tmp438 @unit @controlled
  1293 op equal *tmp439 *tmp438 0
  1294 jump *label270 equal *tmp439 false
-    * set *tmp426 @unit
  1295 jump *label260 always
-    * set *tmp440 null
  1296 jump *label271 always
  1297 label *label270
-    * set *tmp440 null
  1298 label *label271
  1299 ubind .TYPE
  1300 label *label268
 
  1304 op land *tmp444 *tmp441 *tmp443
  1305 jump *label267 notEqual *tmp444 false
  1306 label *label269
-    * set *tmp437 null
  1307 jump *label266 always
  1308 label *label265
-    * set *tmp437 null
  1309 label *label266
  1310 end
-    * set *tmp426 null
  1311 label *label260
  1312 set :processUnit.3:msg ""
  1313 sensor *tmp445 @unit @flag
 
  1346 label *label277
  1347 set *tmp452 *tmp455
  1348 label *label275
-    * set *tmp449 *tmp452
  1349 jump *label273 always
  1350 label *label272
-    * set *tmp449 null
  1351 label *label273
  1352 op equal *tmp458 :processUnit.3:state 2
  1353 jump *label280 equal *tmp458 false
 
  1380 set :processUnit.3:distance *tmp471
  1381 set *tmp461 :processUnit.3:distance
  1382 label *label283
-    * set *tmp459 *tmp461
  1383 jump *label281 always
  1384 label *label280
-    * set *tmp459 null
  1385 label *label281
  1386 op equal *tmp472 :processUnit.3:state 3
  1387 jump *label286 equal *tmp472 false
 
  1390 jump *label290 equal :processUnit.3:supply false
  1391 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1392 set :processUnit.3:msg ", supplying\n"
-    * set *tmp476 :processUnit.3:msg
  1393 jump *label291 always
  1394 label *label290
  1395 ucontrol approach .DOME_X .DOME_Y 6
  1396 set :processUnit.3:msg ", waiting\n"
-    * set *tmp476 :processUnit.3:msg
  1397 label *label291
  1398 sensor *tmp477 @unit @totalItems
  1399 op lessThanEq *tmp478 *tmp477 0
 
  1420 set :processUnit.3:distance *tmp486
  1421 set *tmp475 :processUnit.3:distance
  1422 label *label289
-    * set *tmp473 *tmp475
  1423 jump *label287 always
  1424 label *label286
-    * set *tmp473 null
  1425 label *label287
  1426 ucontrol flag :processUnit.3:state
  1427 sensor *tmp487 @unit @totalItems
 
  1441 print "["
  1442 print "] sec"
  1443 print "\n"
-    * set *tmp489 null
  1444 jump *label295 always
  1445 label *label294
  1446 print :processUnit.3:msg
-    * set *tmp489 :processUnit.3:msg
  1447 label *label295
  1448 set *tmp425 @unit
  1449 jump *label259 always
 
  1461 set *tmp490 *tmp494
  1462 label *label297
  1463 set .SUPPLY_P_FIRST *tmp490
-    * set *tmp423 .SUPPLY_P_FIRST
  1464 jump *label258 always
  1465 label *label257
-    * set *tmp423 null
  1466 label *label258
  1467 op sub *tmp495 @time :start
  1468 op floor *tmp496 *tmp495
 
  1523 label *label311
  1524 set *tmp521 null
  1525 label *label312
-    * set *tmp519 *tmp521
  1526 jump *label310 always
  1527 label *label309
  1528 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp519 :areUnitsAvailable.2:occupied
  1529 label *label310
  1530 ubind :areUnitsAvailable.2:type
  1531 label *label307
 
  1535 op land *tmp525 *tmp522 *tmp524
  1536 jump *label306 notEqual *tmp525 false
  1537 label *label308
-    * set *tmp504 null
  1538 jump *label302 always
  1539 label *label301
-    * set *tmp504 null
  1540 label *label302
  1541 jump *label313 equal :areUnitsAvailable.2:output false
  1542 print :areUnitsAvailable.2:type
 
  1550 jump *label315 equal *tmp527 false
  1551 print ", needed: "
  1552 print :areUnitsAvailable.2:needed
-    * set *tmp528 null
  1553 jump *label316 always
  1554 label *label315
-    * set *tmp528 null
  1555 label *label316
  1556 print "\n"
-    * set *tmp526 null
  1557 jump *label314 always
  1558 label *label313
-    * set *tmp526 null
  1559 label *label314
  1560 set *tmp501 false
  1561 jump *label300 always
 
  1563 label *label300
  1564 jump *label317 equal *tmp501 false
  1565 end
-    * set *tmp529 null
  1566 jump *label318 always
  1567 label *label317
-    * set *tmp529 null
  1568 label *label318
  1569 op add *tmp530 @time 5000
  1570 set :unitCheck *tmp530
-    * set *tmp500 :unitCheck
  1571 jump *label299 always
  1572 label *label298
-    * set *tmp500 null
  1573 label *label299
  1574 label *label134
  1575 jump *label133 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-54 instructions):
 
    74 jump *label21 equal *tmp23 false
    75 set *tmp4 true
    76 jump *label10 always
-    * set *tmp24 null
    77 jump *label22 always
    78 label *label21
-    * set *tmp24 null
    79 label *label22
    80 jump *label20 always
    81 label *label19
 
   182 jump *label49 equal *tmp55 false
   183 set *tmp36 true
   184 jump *label38 always
-    * set *tmp56 null
   185 jump *label50 always
   186 label *label49
-    * set *tmp56 null
   187 label *label50
   188 jump *label48 always
   189 label *label47
 
   227 printflush null
   228 set *tmp3 :chooseUnitType.0:type
   229 jump *label6 always
-    * set *tmp64 null
   230 jump *label56 always
   231 label *label55
-    * set *tmp64 null
   232 label *label56
   233 jump *label37 always
   234 label *label36
 
   274 op notEqual *tmp73 .UNIT_S2 null
   275 jump *label65 equal *tmp73 false
   276 jump *label62 always
-    * set *tmp74 null
   277 jump *label66 always
   278 label *label65
-    * set *tmp74 null
   279 label *label66
   280 jump *label64 always
   281 label *label63
 
   302 op land *tmp87 *tmp84 *tmp86
   303 jump *label71 equal *tmp87 false
   304 jump *label68 always
-    * set *tmp88 null
   305 jump *label72 always
   306 label *label71
-    * set *tmp88 null
   307 label *label72
   308 jump *label70 always
   309 label *label69
 
   352 op land *tmp107 *tmp104 *tmp106
   353 jump *label84 equal *tmp107 false
   354 jump *label81 always
-    * set *tmp108 null
   355 jump *label85 always
   356 label *label84
-    * set *tmp108 null
   357 label *label85
   358 jump *label83 always
   359 label *label82
 
   458 op land *tmp156 *tmp153 *tmp155
   459 jump *label107 equal *tmp156 false
   460 jump *label104 always
-    * set *tmp157 null
   461 jump *label108 always
   462 label *label107
-    * set *tmp157 null
   463 label *label108
   464 jump *label106 always
   465 label *label105
 
   508 op land *tmp176 *tmp173 *tmp175
   509 jump *label120 equal *tmp176 false
   510 jump *label117 always
-    * set *tmp177 null
   511 jump *label121 always
   512 label *label120
-    * set *tmp177 null
   513 label *label121
   514 jump *label119 always
   515 label *label118
 
   622 print "["
   623 print "]"
   624 print "\n"
-    * set *tmp216 null
   625 jump *label138 always
   626 label *label137
   627 print "  dome:  [coral]"
 
   629 print "["
   630 print "]"
   631 print "\n"
-    * set *tmp216 null
   632 label *label138
   633 label *label136
   634 set :processUnit.0:unit .UNIT_S1
 
   646 op land *tmp225 *tmp222 *tmp224
   647 jump *label143 equal *tmp225 false
   648 jump *label140 always
-    * set *tmp226 null
   649 jump *label144 always
   650 label *label143
-    * set *tmp226 null
   651 label *label144
   652 jump *label142 always
   653 label *label141
 
   691 op equal *tmp243 *tmp242 :processUnit.0:item
   692 jump *label154 equal *tmp243 false
   693 set :processUnit.0:state 3
-    * set *tmp244 :processUnit.0:state
   694 jump *label155 always
   695 label *label154
   696 sensor *tmp245 @unit @totalItems
 
   712 label *label159
   713 set *tmp247 *tmp249
   714 label *label157
-    * set *tmp244 *tmp247
   715 label *label155
   716 jump *label153 always
   717 label *label152
 
   732 set :processUnit.0:msg ", loading\n"
   733 set *tmp256 :processUnit.0:msg
   734 label *label165
-    * set *tmp253 *tmp256
   735 jump *label163 always
   736 label *label162
   737 ucontrol approach .CORE_X .CORE_Y 6
 
   744 op idiv *tmp262 *tmp261 .SPEED_TENTHS
   745 op div *tmp263 *tmp262 10
   746 set :processUnit.0:distance *tmp263
-    * set *tmp253 :processUnit.0:distance
   747 label *label163
   748 jump *label161 always
   749 label *label160
 
   770 label *label172
   771 set *tmp271 null
   772 label *label173
-    * set *tmp267 *tmp271
   773 jump *label169 always
   774 label *label168
   775 ucontrol approach .DOME_X .DOME_Y 6
 
   782 op idiv *tmp277 *tmp276 .SPEED_TENTHS
   783 op div *tmp278 *tmp277 10
   784 set :processUnit.0:distance *tmp278
-    * set *tmp267 :processUnit.0:distance
   785 label *label169
   786 jump *label167 always
   787 label *label166
 
   830 op land *tmp292 *tmp289 *tmp291
   831 jump *label182 equal *tmp292 false
   832 jump *label179 always
-    * set *tmp293 null
   833 jump *label183 always
   834 label *label182
-    * set *tmp293 null
   835 label *label183
   836 jump *label181 always
   837 label *label180
 
   875 op equal *tmp310 *tmp309 :processUnit.1:item
   876 jump *label193 equal *tmp310 false
   877 set :processUnit.1:state 3
-    * set *tmp311 :processUnit.1:state
   878 jump *label194 always
   879 label *label193
   880 sensor *tmp312 @unit @totalItems
 
   896 label *label198
   897 set *tmp314 *tmp316
   898 label *label196
-    * set *tmp311 *tmp314
   899 label *label194
   900 jump *label192 always
   901 label *label191
 
   916 set :processUnit.1:msg ", loading\n"
   917 set *tmp323 :processUnit.1:msg
   918 label *label204
-    * set *tmp320 *tmp323
   919 jump *label202 always
   920 label *label201
   921 ucontrol approach .CORE_X .CORE_Y 6
 
   928 op idiv *tmp329 *tmp328 .SPEED_TENTHS
   929 op div *tmp330 *tmp329 10
   930 set :processUnit.1:distance *tmp330
-    * set *tmp320 :processUnit.1:distance
   931 label *label202
   932 jump *label200 always
   933 label *label199
 
   954 label *label211
   955 set *tmp338 null
   956 label *label212
-    * set *tmp334 *tmp338
   957 jump *label208 always
   958 label *label207
   959 ucontrol approach .DOME_X .DOME_Y 6
 
   966 op idiv *tmp344 *tmp343 .SPEED_TENTHS
   967 op div *tmp345 *tmp344 10
   968 set :processUnit.1:distance *tmp345
-    * set *tmp334 :processUnit.1:distance
   969 label *label208
   970 jump *label206 always
   971 label *label205
 
  1023 print "["
  1024 print "]"
  1025 print "\n"
-    * set *tmp357 null
  1026 jump *label219 always
  1027 label *label218
  1028 print "  dome:  [coral]"
 
  1030 print "["
  1031 print "]"
  1032 print "\n"
-    * set *tmp357 null
  1033 label *label219
  1034 label *label217
  1035 set :processUnit.2:unit .UNIT_P1
 
  1047 op land *tmp366 *tmp363 *tmp365
  1048 jump *label224 equal *tmp366 false
  1049 jump *label221 always
-    * set *tmp367 null
  1050 jump *label225 always
  1051 label *label224
-    * set *tmp367 null
  1052 label *label225
  1053 jump *label223 always
  1054 label *label222
 
  1092 op equal *tmp384 *tmp383 :processUnit.2:item
  1093 jump *label235 equal *tmp384 false
  1094 set :processUnit.2:state 3
-    * set *tmp385 :processUnit.2:state
  1095 jump *label236 always
  1096 label *label235
  1097 sensor *tmp386 @unit @totalItems
 
  1113 label *label240
  1114 set *tmp388 *tmp390
  1115 label *label238
-    * set *tmp385 *tmp388
  1116 label *label236
  1117 jump *label234 always
  1118 label *label233
 
  1133 set :processUnit.2:msg ", loading\n"
  1134 set *tmp397 :processUnit.2:msg
  1135 label *label246
-    * set *tmp394 *tmp397
  1136 jump *label244 always
  1137 label *label243
  1138 ucontrol approach .CORE_X .CORE_Y 6
 
  1145 op idiv *tmp403 *tmp402 .SPEED_TENTHS
  1146 op div *tmp404 *tmp403 10
  1147 set :processUnit.2:distance *tmp404
-    * set *tmp394 :processUnit.2:distance
  1148 label *label244
  1149 jump *label242 always
  1150 label *label241
 
  1171 label *label253
  1172 set *tmp412 null
  1173 label *label254
-    * set *tmp408 *tmp412
  1174 jump *label250 always
  1175 label *label249
  1176 ucontrol approach .DOME_X .DOME_Y 6
 
  1183 op idiv *tmp418 *tmp417 .SPEED_TENTHS
  1184 op div *tmp419 *tmp418 10
  1185 set :processUnit.2:distance *tmp419
-    * set *tmp408 :processUnit.2:distance
  1186 label *label250
  1187 jump *label248 always
  1188 label *label247
 
  1231 op land *tmp433 *tmp430 *tmp432
  1232 jump *label263 equal *tmp433 false
  1233 jump *label260 always
-    * set *tmp434 null
  1234 jump *label264 always
  1235 label *label263
-    * set *tmp434 null
  1236 label *label264
  1237 jump *label262 always
  1238 label *label261
 
  1276 op equal *tmp451 *tmp450 :processUnit.3:item
  1277 jump *label274 equal *tmp451 false
  1278 set :processUnit.3:state 3
-    * set *tmp452 :processUnit.3:state
  1279 jump *label275 always
  1280 label *label274
  1281 sensor *tmp453 @unit @totalItems
 
  1297 label *label279
  1298 set *tmp455 *tmp457
  1299 label *label277
-    * set *tmp452 *tmp455
  1300 label *label275
  1301 jump *label273 always
  1302 label *label272
 
  1317 set :processUnit.3:msg ", loading\n"
  1318 set *tmp464 :processUnit.3:msg
  1319 label *label285
-    * set *tmp461 *tmp464
  1320 jump *label283 always
  1321 label *label282
  1322 ucontrol approach .CORE_X .CORE_Y 6
 
  1329 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1330 op div *tmp471 *tmp470 10
  1331 set :processUnit.3:distance *tmp471
-    * set *tmp461 :processUnit.3:distance
  1332 label *label283
  1333 jump *label281 always
  1334 label *label280
 
  1355 label *label292
  1356 set *tmp479 null
  1357 label *label293
-    * set *tmp475 *tmp479
  1358 jump *label289 always
  1359 label *label288
  1360 ucontrol approach .DOME_X .DOME_Y 6
 
  1367 op idiv *tmp485 *tmp484 .SPEED_TENTHS
  1368 op div *tmp486 *tmp485 10
  1369 set :processUnit.3:distance *tmp486
-    * set *tmp475 :processUnit.3:distance
  1370 label *label289
  1371 jump *label287 always
  1372 label *label286
 
  1466 jump *label311 equal *tmp520 false
  1467 set *tmp501 true
  1468 jump *label300 always
-    * set *tmp521 null
  1469 jump *label312 always
  1470 label *label311
-    * set *tmp521 null
  1471 label *label312
  1472 jump *label310 always
  1473 label *label309

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-24 instructions):
 
   697 op equal *tmp246 *tmp245 0
   698 jump *label156 equal *tmp246 false
   699 set :processUnit.0:state 2
-    * set *tmp247 :processUnit.0:state
   700 jump *label157 always
   701 label *label156
   702 set :processUnit.0:msg ", initializing\n"
 
   709 label *label158
   710 set *tmp249 null
   711 label *label159
-    * set *tmp247 *tmp249
   712 label *label157
   713 label *label155
   714 jump *label153 always
 
   724 jump *label164 equal *tmp255 false
   725 ucontrol approach .DOME_X .DOME_Y 6
   726 set :processUnit.0:state 3
-    * set *tmp256 :processUnit.0:state
   727 jump *label165 always
   728 label *label164
   729 set :processUnit.0:msg ", loading\n"
-    * set *tmp256 :processUnit.0:msg
   730 label *label165
   731 jump *label163 always
   732 label *label162
 
   761 jump *label172 equal *tmp270 false
   762 ucontrol approach .CORE_X .CORE_Y 6
   763 set :processUnit.0:state 2
-    * set *tmp271 :processUnit.0:state
   764 jump *label173 always
   765 label *label172
-    * set *tmp271 null
   766 label *label173
   767 jump *label169 always
   768 label *label168
 
   875 op equal *tmp313 *tmp312 0
   876 jump *label195 equal *tmp313 false
   877 set :processUnit.1:state 2
-    * set *tmp314 :processUnit.1:state
   878 jump *label196 always
   879 label *label195
   880 set :processUnit.1:msg ", initializing\n"
 
   887 label *label197
   888 set *tmp316 null
   889 label *label198
-    * set *tmp314 *tmp316
   890 label *label196
   891 label *label194
   892 jump *label192 always
 
   902 jump *label203 equal *tmp322 false
   903 ucontrol approach .DOME_X .DOME_Y 6
   904 set :processUnit.1:state 3
-    * set *tmp323 :processUnit.1:state
   905 jump *label204 always
   906 label *label203
   907 set :processUnit.1:msg ", loading\n"
-    * set *tmp323 :processUnit.1:msg
   908 label *label204
   909 jump *label202 always
   910 label *label201
 
   939 jump *label211 equal *tmp337 false
   940 ucontrol approach .CORE_X .CORE_Y 6
   941 set :processUnit.1:state 2
-    * set *tmp338 :processUnit.1:state
   942 jump *label212 always
   943 label *label211
-    * set *tmp338 null
   944 label *label212
   945 jump *label208 always
   946 label *label207
 
  1086 op equal *tmp387 *tmp386 0
  1087 jump *label237 equal *tmp387 false
  1088 set :processUnit.2:state 2
-    * set *tmp388 :processUnit.2:state
  1089 jump *label238 always
  1090 label *label237
  1091 set :processUnit.2:msg ", initializing\n"
 
  1098 label *label239
  1099 set *tmp390 null
  1100 label *label240
-    * set *tmp388 *tmp390
  1101 label *label238
  1102 label *label236
  1103 jump *label234 always
 
  1113 jump *label245 equal *tmp396 false
  1114 ucontrol approach .DOME_X .DOME_Y 6
  1115 set :processUnit.2:state 3
-    * set *tmp397 :processUnit.2:state
  1116 jump *label246 always
  1117 label *label245
  1118 set :processUnit.2:msg ", loading\n"
-    * set *tmp397 :processUnit.2:msg
  1119 label *label246
  1120 jump *label244 always
  1121 label *label243
 
  1150 jump *label253 equal *tmp411 false
  1151 ucontrol approach .CORE_X .CORE_Y 6
  1152 set :processUnit.2:state 2
-    * set *tmp412 :processUnit.2:state
  1153 jump *label254 always
  1154 label *label253
-    * set *tmp412 null
  1155 label *label254
  1156 jump *label250 always
  1157 label *label249
 
  1264 op equal *tmp454 *tmp453 0
  1265 jump *label276 equal *tmp454 false
  1266 set :processUnit.3:state 2
-    * set *tmp455 :processUnit.3:state
  1267 jump *label277 always
  1268 label *label276
  1269 set :processUnit.3:msg ", initializing\n"
 
  1276 label *label278
  1277 set *tmp457 null
  1278 label *label279
-    * set *tmp455 *tmp457
  1279 label *label277
  1280 label *label275
  1281 jump *label273 always
 
  1291 jump *label284 equal *tmp463 false
  1292 ucontrol approach .DOME_X .DOME_Y 6
  1293 set :processUnit.3:state 3
-    * set *tmp464 :processUnit.3:state
  1294 jump *label285 always
  1295 label *label284
  1296 set :processUnit.3:msg ", loading\n"
-    * set *tmp464 :processUnit.3:msg
  1297 label *label285
  1298 jump *label283 always
  1299 label *label282
 
  1328 jump *label292 equal *tmp478 false
  1329 ucontrol approach .CORE_X .CORE_Y 6
  1330 set :processUnit.3:state 2
-    * set *tmp479 :processUnit.3:state
  1331 jump *label293 always
  1332 label *label292
-    * set *tmp479 null
  1333 label *label293
  1334 jump *label289 always
  1335 label *label288

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
   704 ucontrol within .CORE_X .CORE_Y 8 *tmp248
   705 jump *label158 equal *tmp248 false
   706 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp249 null
   707 jump *label159 always
   708 label *label158
-    * set *tmp249 null
   709 label *label159
   710 label *label157
   711 label *label155
 
   880 ucontrol within .CORE_X .CORE_Y 8 *tmp315
   881 jump *label197 equal *tmp315 false
   882 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp316 null
   883 jump *label198 always
   884 label *label197
-    * set *tmp316 null
   885 label *label198
   886 label *label196
   887 label *label194
 
  1089 ucontrol within .CORE_X .CORE_Y 8 *tmp389
  1090 jump *label239 equal *tmp389 false
  1091 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp390 null
  1092 jump *label240 always
  1093 label *label239
-    * set *tmp390 null
  1094 label *label240
  1095 label *label238
  1096 label *label236
 
  1265 ucontrol within .CORE_X .CORE_Y 8 *tmp456
  1266 jump *label278 equal *tmp456 false
  1267 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp457 null
  1268 jump *label279 always
  1269 label *label278
-    * set *tmp457 null
  1270 label *label279
  1271 label *label277
  1272 label *label275

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-52 instructions):
 
    38 set :areUnitsAvailable.0:occupied :areUnitsAvailable.0:needed
    39 set :areUnitsAvailable.0:free :areUnitsAvailable.0:occupied
    40 ubind :areUnitsAvailable.0:type
-    * set *tmp5 @unit
-    * set :areUnitsAvailable.0:firstUnit *tmp5
+   41 set :areUnitsAvailable.0:firstUnit @unit
    42 op notEqual *tmp6 :areUnitsAvailable.0:firstUnit null
    43 jump *label11 equal *tmp6 false
    44 set :needsFourUnits.0:unit @unit
 
    47 op len *tmp11 *tmp9 *tmp10
    48 op mul *tmp12 2 *tmp11
    49 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * op div *tmp14 *tmp12 *tmp13
-    * set :needsFourUnits.0:travel_time *tmp14
-    * op greaterThanEq *tmp15 :needsFourUnits.0:travel_time 47
-    * set *tmp8 *tmp15
+   50 op div :needsFourUnits.0:travel_time *tmp12 *tmp13
+   51 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    52 jump *label13 always
    53 set *tmp8 null
    54 label *label13
 
   143 set :areUnitsAvailable.1:occupied :areUnitsAvailable.1:needed
   144 set :areUnitsAvailable.1:free :areUnitsAvailable.1:occupied
   145 ubind :areUnitsAvailable.1:type
-    * set *tmp37 @unit
-    * set :areUnitsAvailable.1:firstUnit *tmp37
+  146 set :areUnitsAvailable.1:firstUnit @unit
   147 op notEqual *tmp38 :areUnitsAvailable.1:firstUnit null
   148 jump *label39 equal *tmp38 false
   149 set :needsFourUnits.1:unit @unit
 
   152 op len *tmp43 *tmp41 *tmp42
   153 op mul *tmp44 2 *tmp43
   154 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * op div *tmp46 *tmp44 *tmp45
-    * set :needsFourUnits.1:travel_time *tmp46
-    * op greaterThanEq *tmp47 :needsFourUnits.1:travel_time 47
-    * set *tmp40 *tmp47
+  155 op div :needsFourUnits.1:travel_time *tmp44 *tmp45
+  156 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   157 jump *label41 always
   158 set *tmp40 null
   159 label *label41
 
   246 set .UNIT_S1 .UNIT_P1
   247 set :rebindUnits.0:count 0
   248 ubind .TYPE
-    * set *tmp66 @unit
-    * set :rebindUnits.0:firstUnit *tmp66
+  249 set :rebindUnits.0:firstUnit @unit
   250 op equal *tmp67 :rebindUnits.0:firstUnit null
   251 jump *label58 equal *tmp67 false
   252 end
 
   262 set .UNIT_S2 .UNIT_P2
   263 set .UNIT_P2 .UNIT_S1
   264 set .UNIT_S1 .UNIT_P1
-    * set *tmp72 @unit
-    * set .UNIT_P1 *tmp72
+  265 set .UNIT_P1 @unit
   266 op notEqual *tmp73 .UNIT_S2 null
   267 jump *label65 equal *tmp73 false
   268 jump *label62 always
 
   301 label *label69
   302 label *label70
   303 ubind .TYPE
-    * set *tmp89 @unit
-    * set :rebindUnit.0:firstUnit *tmp89
+  304 set :rebindUnit.0:firstUnit @unit
   305 op notEqual *tmp90 :rebindUnit.0:firstUnit null
   306 jump *label73 equal *tmp90 false
   307 label *label75
 
   350 label *label82
   351 label *label83
   352 ubind .TYPE
-    * set *tmp109 @unit
-    * set :rebindUnit.1:firstUnit *tmp109
+  353 set :rebindUnit.1:firstUnit @unit
   354 op notEqual *tmp110 :rebindUnit.1:firstUnit null
   355 jump *label86 equal *tmp110 false
   356 label *label88
 
   392 jump *label94 always
   393 label *label93
   394 label *label94
-    * sensor *tmp125 .UNIT_S1 @itemCapacity
-    * set .UNIT_CAPACITY *tmp125
-    * sensor *tmp126 .UNIT_S1 @speed
-    * set .SPEED *tmp126
-    * op div *tmp127 .SPEED 10
-    * set .SPEED_TENTHS *tmp127
+  395 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
+  396 sensor .SPEED .UNIT_S1 @speed
+  397 op div .SPEED_TENTHS .SPEED 10
   398 op strictEqual *tmp128 .SPEED null
   399 jump *label95 equal *tmp128 false
   400 stop
 
   404 print "[gold]Locating core..."
   405 printflush message1
   406 label *label97
-    * ulocate building core false @copper *tmp131 *tmp132 *tmp133 *tmp130
-    * set .CORE *tmp130
+  407 ulocate building core false @copper 0 0 0 .CORE
   408 label *label98
   409 op equal *tmp134 .CORE null
   410 jump *label97 notEqual *tmp134 false
   411 label *label99
-    * sensor *tmp135 .CORE @x
-    * set .CORE_X *tmp135
-    * sensor *tmp136 .CORE @y
-    * set .CORE_Y *tmp136
-    * sensor *tmp137 .DOME @x
-    * set .DOME_X *tmp137
-    * sensor *tmp138 .DOME @y
-    * set .DOME_Y *tmp138
+  412 sensor .CORE_X .CORE @x
+  413 sensor .CORE_Y .CORE @y
+  414 sensor .DOME_X .DOME @x
+  415 sensor .DOME_Y .DOME @y
   416 set :needsFourUnits.2:unit .UNIT_S1
   417 op sub *tmp140 .DOME_X .CORE_X
   418 op sub *tmp141 .DOME_Y .CORE_Y
   419 op len *tmp142 *tmp140 *tmp141
   420 op mul *tmp143 2 *tmp142
   421 sensor *tmp144 :needsFourUnits.2:unit @speed
-    * op div *tmp145 *tmp143 *tmp144
-    * set :needsFourUnits.2:travel_time *tmp145
-    * op greaterThanEq *tmp146 :needsFourUnits.2:travel_time 47
-    * set *tmp139 *tmp146
+  422 op div :needsFourUnits.2:travel_time *tmp143 *tmp144
+  423 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   424 jump *label100 always
   425 set *tmp139 null
   426 label *label100
 
   445 label *label105
   446 label *label106
   447 ubind .TYPE
-    * set *tmp158 @unit
-    * set :rebindUnit.2:firstUnit *tmp158
+  448 set :rebindUnit.2:firstUnit @unit
   449 op notEqual *tmp159 :rebindUnit.2:firstUnit null
   450 jump *label109 equal *tmp159 false
   451 label *label111
 
   494 label *label118
   495 label *label119
   496 ubind .TYPE
-    * set *tmp178 @unit
-    * set :rebindUnit.3:firstUnit *tmp178
+  497 set :rebindUnit.3:firstUnit @unit
   498 op notEqual *tmp179 :rebindUnit.3:firstUnit null
   499 jump *label122 equal *tmp179 false
   500 label *label124
 
   565 sensor *tmp201 .UNIT_S1 @totalItems
   566 sensor *tmp202 .UNIT_S2 @totalItems
   567 op lessThan *tmp203 *tmp201 *tmp202
-    * op or *tmp204 *tmp200 *tmp203
-    * set .SUPPLY_S_FIRST *tmp204
+  568 op or .SUPPLY_S_FIRST *tmp200 *tmp203
   569 op equal *tmp205 .FOUR_UNITS false
   570 sensor *tmp206 .UNIT_P1 @totalItems
   571 sensor *tmp207 .UNIT_P2 @totalItems
   572 op lessThan *tmp208 *tmp206 *tmp207
-    * op or *tmp209 *tmp205 *tmp208
-    * set .SUPPLY_P_FIRST *tmp209
-    * op add *tmp210 @time 5000
-    * set :unitCheck *tmp210
+  573 op or .SUPPLY_P_FIRST *tmp205 *tmp208
+  574 op add :unitCheck @time 5000
   575 label *label133
   576 sensor *tmp211 switch1 @enabled
   577 jump *label135 equal *tmp211 false
-    * set *tmp212 @time
-    * set :start *tmp212
+  578 set :start @time
   579 print " === [gold]Supplying Overdrive Dome[] === "
   580 print "\n"
   581 print "\n"
 
   587 set :printDomeStatus.0:item @silicon
   588 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   589 print :printDomeStatus.0:text
-    * sensor *tmp214 .DOME :printDomeStatus.0:item
-    * set :printDomeStatus.0:level *tmp214
+  590 sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
   591 op greaterThan *tmp215 :printDomeStatus.0:level 3
   592 jump *label137 equal *tmp215 false
   593 print "  dome:  [green]"
 
   626 label *label141
   627 label *label142
   628 ubind .TYPE
-    * set *tmp227 @unit
-    * set :rebindUnit.4:firstUnit *tmp227
+  629 set :rebindUnit.4:firstUnit @unit
   630 op notEqual *tmp228 :rebindUnit.4:firstUnit null
   631 jump *label145 equal *tmp228 false
   632 label *label147
 
   651 end
   652 label *label140
   653 set :processUnit.0:msg ""
-    * sensor *tmp237 @unit @flag
-    * set :processUnit.0:state *tmp237
+  654 sensor :processUnit.0:state @unit @flag
   655 set :processUnit.0:distance -1
   656 set :processUnit.0:color "gold"
   657 op lessThan *tmp238 :processUnit.0:state 2
 
   707 op sub *tmp260 .CORE_Y *tmp259
   708 op len *tmp261 *tmp258 *tmp260
   709 op idiv *tmp262 *tmp261 .SPEED_TENTHS
-    * op div *tmp263 *tmp262 10
-    * set :processUnit.0:distance *tmp263
+  710 op div :processUnit.0:distance *tmp262 10
   711 label *label163
   712 jump *label161 always
   713 label *label160
 
   742 op sub *tmp275 .DOME_Y *tmp274
   743 op len *tmp276 *tmp273 *tmp275
   744 op idiv *tmp277 *tmp276 .SPEED_TENTHS
-    * op div *tmp278 *tmp277 10
-    * set :processUnit.0:distance *tmp278
+  745 op div :processUnit.0:distance *tmp277 10
   746 label *label169
   747 jump *label167 always
   748 label *label166
 
   798 label *label180
   799 label *label181
   800 ubind .TYPE
-    * set *tmp294 @unit
-    * set :rebindUnit.5:firstUnit *tmp294
+  801 set :rebindUnit.5:firstUnit @unit
   802 op notEqual *tmp295 :rebindUnit.5:firstUnit null
   803 jump *label184 equal *tmp295 false
   804 label *label186
 
   823 end
   824 label *label179
   825 set :processUnit.1:msg ""
-    * sensor *tmp304 @unit @flag
-    * set :processUnit.1:state *tmp304
+  826 sensor :processUnit.1:state @unit @flag
   827 set :processUnit.1:distance -1
   828 set :processUnit.1:color "gold"
   829 op lessThan *tmp305 :processUnit.1:state 2
 
   879 op sub *tmp327 .CORE_Y *tmp326
   880 op len *tmp328 *tmp325 *tmp327
   881 op idiv *tmp329 *tmp328 .SPEED_TENTHS
-    * op div *tmp330 *tmp329 10
-    * set :processUnit.1:distance *tmp330
+  882 op div :processUnit.1:distance *tmp329 10
   883 label *label202
   884 jump *label200 always
   885 label *label199
 
   914 op sub *tmp342 .DOME_Y *tmp341
   915 op len *tmp343 *tmp340 *tmp342
   916 op idiv *tmp344 *tmp343 .SPEED_TENTHS
-    * op div *tmp345 *tmp344 10
-    * set :processUnit.1:distance *tmp345
+  917 op div :processUnit.1:distance *tmp344 10
   918 label *label208
   919 jump *label206 always
   920 label *label205
 
   948 set .UNIT_S2 *tmp284
   949 jump *label215 equal .SUPPLY_S_FIRST false
   950 sensor *tmp350 .UNIT_S1 @totalItems
-    * op greaterThan *tmp351 *tmp350 0
-    * set *tmp349 *tmp351
+  951 op greaterThan *tmp349 *tmp350 0
   952 jump *label216 always
   953 label *label215
   954 sensor *tmp352 .UNIT_S2 @totalItems
-    * op equal *tmp353 *tmp352 0
-    * set *tmp349 *tmp353
+  955 op equal *tmp349 *tmp352 0
   956 label *label216
   957 set .SUPPLY_S_FIRST *tmp349
   958 jump *label177 always
 
   961 set :printDomeStatus.1:item @phase-fabric
   962 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   963 print :printDomeStatus.1:text
-    * sensor *tmp355 .DOME :printDomeStatus.1:item
-    * set :printDomeStatus.1:level *tmp355
+  964 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
   965 op greaterThan *tmp356 :printDomeStatus.1:level 3
   966 jump *label218 equal *tmp356 false
   967 print "  dome:  [green]"
 
  1000 label *label222
  1001 label *label223
  1002 ubind .TYPE
-    * set *tmp368 @unit
-    * set :rebindUnit.6:firstUnit *tmp368
+ 1003 set :rebindUnit.6:firstUnit @unit
  1004 op notEqual *tmp369 :rebindUnit.6:firstUnit null
  1005 jump *label226 equal *tmp369 false
  1006 label *label228
 
  1025 end
  1026 label *label221
  1027 set :processUnit.2:msg ""
-    * sensor *tmp378 @unit @flag
-    * set :processUnit.2:state *tmp378
+ 1028 sensor :processUnit.2:state @unit @flag
  1029 set :processUnit.2:distance -1
  1030 set :processUnit.2:color "gold"
  1031 op lessThan *tmp379 :processUnit.2:state 2
 
  1081 op sub *tmp401 .CORE_Y *tmp400
  1082 op len *tmp402 *tmp399 *tmp401
  1083 op idiv *tmp403 *tmp402 .SPEED_TENTHS
-    * op div *tmp404 *tmp403 10
-    * set :processUnit.2:distance *tmp404
+ 1084 op div :processUnit.2:distance *tmp403 10
  1085 label *label244
  1086 jump *label242 always
  1087 label *label241
 
  1116 op sub *tmp416 .DOME_Y *tmp415
  1117 op len *tmp417 *tmp414 *tmp416
  1118 op idiv *tmp418 *tmp417 .SPEED_TENTHS
-    * op div *tmp419 *tmp418 10
-    * set :processUnit.2:distance *tmp419
+ 1119 op div :processUnit.2:distance *tmp418 10
  1120 label *label250
  1121 jump *label248 always
  1122 label *label247
 
  1172 label *label261
  1173 label *label262
  1174 ubind .TYPE
-    * set *tmp435 @unit
-    * set :rebindUnit.7:firstUnit *tmp435
+ 1175 set :rebindUnit.7:firstUnit @unit
  1176 op notEqual *tmp436 :rebindUnit.7:firstUnit null
  1177 jump *label265 equal *tmp436 false
  1178 label *label267
 
  1197 end
  1198 label *label260
  1199 set :processUnit.3:msg ""
-    * sensor *tmp445 @unit @flag
-    * set :processUnit.3:state *tmp445
+ 1200 sensor :processUnit.3:state @unit @flag
  1201 set :processUnit.3:distance -1
  1202 set :processUnit.3:color "gold"
  1203 op lessThan *tmp446 :processUnit.3:state 2
 
  1253 op sub *tmp468 .CORE_Y *tmp467
  1254 op len *tmp469 *tmp466 *tmp468
  1255 op idiv *tmp470 *tmp469 .SPEED_TENTHS
-    * op div *tmp471 *tmp470 10
-    * set :processUnit.3:distance *tmp471
+ 1256 op div :processUnit.3:distance *tmp470 10
  1257 label *label283
  1258 jump *label281 always
  1259 label *label280
 
  1288 op sub *tmp483 .DOME_Y *tmp482
  1289 op len *tmp484 *tmp481 *tmp483
  1290 op idiv *tmp485 *tmp484 .SPEED_TENTHS
-    * op div *tmp486 *tmp485 10
-    * set :processUnit.3:distance *tmp486
+ 1291 op div :processUnit.3:distance *tmp485 10
  1292 label *label289
  1293 jump *label287 always
  1294 label *label286
 
  1322 set .UNIT_P2 *tmp425
  1323 jump *label296 equal .SUPPLY_P_FIRST false
  1324 sensor *tmp491 .UNIT_P1 @totalItems
-    * op greaterThan *tmp492 *tmp491 0
-    * set *tmp490 *tmp492
+ 1325 op greaterThan *tmp490 *tmp491 0
  1326 jump *label297 always
  1327 label *label296
  1328 sensor *tmp493 .UNIT_P2 @totalItems
-    * op equal *tmp494 *tmp493 0
-    * set *tmp490 *tmp494
+ 1329 op equal *tmp490 *tmp493 0
  1330 label *label297
  1331 set .SUPPLY_P_FIRST *tmp490
  1332 jump *label258 always
 
  1350 set :areUnitsAvailable.2:occupied :areUnitsAvailable.2:needed
  1351 set :areUnitsAvailable.2:free :areUnitsAvailable.2:occupied
  1352 ubind :areUnitsAvailable.2:type
-    * set *tmp502 @unit
-    * set :areUnitsAvailable.2:firstUnit *tmp502
+ 1353 set :areUnitsAvailable.2:firstUnit @unit
  1354 op notEqual *tmp503 :areUnitsAvailable.2:firstUnit null
  1355 jump *label301 equal *tmp503 false
  1356 set :needsFourUnits.3:unit @unit
 
  1359 op len *tmp508 *tmp506 *tmp507
  1360 op mul *tmp509 2 *tmp508
  1361 sensor *tmp510 :needsFourUnits.3:unit @speed
-    * op div *tmp511 *tmp509 *tmp510
-    * set :needsFourUnits.3:travel_time *tmp511
-    * op greaterThanEq *tmp512 :needsFourUnits.3:travel_time 47
-    * set *tmp505 *tmp512
+ 1362 op div :needsFourUnits.3:travel_time *tmp509 *tmp510
+ 1363 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1364 jump *label303 always
  1365 set *tmp505 null
  1366 label *label303
 
  1429 jump *label318 always
  1430 label *label317
  1431 label *label318
-    * op add *tmp530 @time 5000
-    * set :unitCheck *tmp530
+ 1432 op add :unitCheck @time 5000
  1433 jump *label299 always
  1434 label *label298
  1435 label *label299

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    26 jump *label3 always
    27 label *label5
    28 label *label7
-    * jump *label9 equal true false
    29 printflush null
    30 print "[gold]Looking for suitable unit type:[]"
    31 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-70 instructions):
 
     7 set .CORE_X .CORE_Y
     8 set .DOME dome1
     9 label *label0
-    * op equal *tmp0 .DOME null
-    * jump *label2 equal *tmp0 false
+   10 jump *label2 notEqual .DOME null
    11 print "[gold]Waiting for an overdrive dome to be connected..."
    12 printflush message1
    13 set .DOME dome1
 
    16 label *label2
    17 label *label3
    18 sensor *tmp1 switch1 @enabled
-    * op equal *tmp2 *tmp1 false
-    * jump *label5 equal *tmp2 false
+   19 jump *label5 notEqual *tmp1 false
    20 print "[coral]Activate switch to begin supplying overdrive dome..."
    21 print "\n"
    22 printflush message1
 
    36 set :areUnitsAvailable.0:free :areUnitsAvailable.0:occupied
    37 ubind :areUnitsAvailable.0:type
    38 set :areUnitsAvailable.0:firstUnit @unit
-    * op notEqual *tmp6 :areUnitsAvailable.0:firstUnit null
-    * jump *label11 equal *tmp6 false
+   39 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    40 set :needsFourUnits.0:unit @unit
    41 op sub *tmp9 .DOME_X .CORE_X
    42 op sub *tmp10 .DOME_Y .CORE_Y
 
    63 op or *tmp21 *tmp18 *tmp20
    64 jump *label19 equal *tmp21 false
    65 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * op greaterThanEq *tmp23 :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
-    * jump *label21 equal *tmp23 false
+   66 jump *label21 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
    67 set *tmp4 true
    68 jump *label10 always
    69 jump *label22 always
 
    92 print ","
    93 print " free: "
    94 print :areUnitsAvailable.0:free
-    * op greaterThan *tmp30 :areUnitsAvailable.0:needed 0
-    * jump *label25 equal *tmp30 false
+   95 jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
    96 print ", needed: "
    97 print :areUnitsAvailable.0:needed
    98 jump *label26 always
 
   127 set :chooseUnitType.0:type @mono
   128 setaddr *tmp33 *label35
   129 label *label29
-    * op notEqual *tmp34 :chooseUnitType.0:type UNIT_TYPE
-    * jump *label36 equal *tmp34 false
+  130 jump *label36 equal :chooseUnitType.0:type UNIT_TYPE
   131 remark "chooseUnitType: "
   132 remark :chooseUnitType.0:type
   133 set :areUnitsAvailable.1:type :chooseUnitType.0:type
 
   137 set :areUnitsAvailable.1:free :areUnitsAvailable.1:occupied
   138 ubind :areUnitsAvailable.1:type
   139 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp38 :areUnitsAvailable.1:firstUnit null
-    * jump *label39 equal *tmp38 false
+  140 jump *label39 equal :areUnitsAvailable.1:firstUnit null
   141 set :needsFourUnits.1:unit @unit
   142 op sub *tmp41 .DOME_X .CORE_X
   143 op sub *tmp42 .DOME_Y .CORE_Y
 
   164 op or *tmp53 *tmp50 *tmp52
   165 jump *label47 equal *tmp53 false
   166 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * op greaterThanEq *tmp55 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
-    * jump *label49 equal *tmp55 false
+  167 jump *label49 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   168 set *tmp36 true
   169 jump *label38 always
   170 jump *label50 always
 
   193 print ","
   194 print " free: "
   195 print :areUnitsAvailable.1:free
-    * op greaterThan *tmp62 :areUnitsAvailable.1:needed 0
-    * jump *label53 equal *tmp62 false
+  196 jump *label53 lessThanEq :areUnitsAvailable.1:needed 0
   197 print ", needed: "
   198 print :areUnitsAvailable.1:needed
   199 jump *label54 always
 
   237 set :rebindUnits.0:count 0
   238 ubind .TYPE
   239 set :rebindUnits.0:firstUnit @unit
-    * op equal *tmp67 :rebindUnits.0:firstUnit null
-    * jump *label58 equal *tmp67 false
+  240 jump *label58 notEqual :rebindUnits.0:firstUnit null
   241 end
   242 jump *label59 always
   243 label *label58
   244 label *label59
   245 label *label60
   246 sensor *tmp69 @unit @controller
-    * op equal *tmp70 *tmp69 @this
-    * jump *label63 equal *tmp70 false
+  247 jump *label63 notEqual *tmp69 @this
   248 op add :rebindUnits.0:count :rebindUnits.0:count 1
   249 ucontrol flag 1
   250 set .UNIT_S2 .UNIT_P2
   251 set .UNIT_P2 .UNIT_S1
   252 set .UNIT_S1 .UNIT_P1
   253 set .UNIT_P1 @unit
-    * op notEqual *tmp73 .UNIT_S2 null
-    * jump *label65 equal *tmp73 false
+  254 jump *label65 equal .UNIT_S2 null
   255 jump *label62 always
   256 jump *label66 always
   257 label *label65
 
   271 label *label57
   272 set :acquireUnit.0:currentUnit .UNIT_S1
   273 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * op notEqual *tmp81 :rebindUnit.0:currentUnit null
-    * jump *label69 equal *tmp81 false
+  274 jump *label69 equal :rebindUnit.0:currentUnit null
   275 ubind :rebindUnit.0:currentUnit
   276 sensor *tmp83 @unit @dead
   277 op strictEqual *tmp84 *tmp83 0
 
   288 label *label70
   289 ubind .TYPE
   290 set :rebindUnit.0:firstUnit @unit
-    * op notEqual *tmp90 :rebindUnit.0:firstUnit null
-    * jump *label73 equal *tmp90 false
+  291 jump *label73 equal :rebindUnit.0:firstUnit null
   292 label *label75
   293 sensor *tmp92 @unit @controlled
-    * op equal *tmp93 *tmp92 0
-    * jump *label78 equal *tmp93 false
+  294 jump *label78 notEqual *tmp92 0
   295 jump *label68 always
   296 jump *label79 always
   297 label *label78
 
   317 set .UNIT_S1 *tmp79
   318 set :acquireUnit.1:currentUnit .UNIT_P1
   319 set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * op notEqual *tmp101 :rebindUnit.1:currentUnit null
-    * jump *label82 equal *tmp101 false
+  320 jump *label82 equal :rebindUnit.1:currentUnit null
   321 ubind :rebindUnit.1:currentUnit
   322 sensor *tmp103 @unit @dead
   323 op strictEqual *tmp104 *tmp103 0
 
   334 label *label83
   335 ubind .TYPE
   336 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp110 :rebindUnit.1:firstUnit null
-    * jump *label86 equal *tmp110 false
+  337 jump *label86 equal :rebindUnit.1:firstUnit null
   338 label *label88
   339 sensor *tmp112 @unit @controlled
-    * op equal *tmp113 *tmp112 0
-    * jump *label91 equal *tmp113 false
+  340 jump *label91 notEqual *tmp112 0
   341 jump *label81 always
   342 jump *label92 always
   343 label *label91
 
   387 label *label97
   388 ulocate building core false @copper 0 0 0 .CORE
   389 label *label98
-    * op equal *tmp134 .CORE null
-    * jump *label97 notEqual *tmp134 false
+  390 jump *label97 equal .CORE null
   391 label *label99
   392 sensor .CORE_X .CORE @x
   393 sensor .CORE_Y .CORE @y
 
   408 jump *label101 equal .FOUR_UNITS false
   409 set :acquireUnit.2:currentUnit .UNIT_S2
   410 set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * op notEqual *tmp150 :rebindUnit.2:currentUnit null
-    * jump *label105 equal *tmp150 false
+  411 jump *label105 equal :rebindUnit.2:currentUnit null
   412 ubind :rebindUnit.2:currentUnit
   413 sensor *tmp152 @unit @dead
   414 op strictEqual *tmp153 *tmp152 0
 
   425 label *label106
   426 ubind .TYPE
   427 set :rebindUnit.2:firstUnit @unit
-    * op notEqual *tmp159 :rebindUnit.2:firstUnit null
-    * jump *label109 equal *tmp159 false
+  428 jump *label109 equal :rebindUnit.2:firstUnit null
   429 label *label111
   430 sensor *tmp161 @unit @controlled
-    * op equal *tmp162 *tmp161 0
-    * jump *label114 equal *tmp162 false
+  431 jump *label114 notEqual *tmp161 0
   432 jump *label104 always
   433 jump *label115 always
   434 label *label114
 
   454 set .UNIT_S2 *tmp148
   455 set :acquireUnit.3:currentUnit .UNIT_P2
   456 set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * op notEqual *tmp170 :rebindUnit.3:currentUnit null
-    * jump *label118 equal *tmp170 false
+  457 jump *label118 equal :rebindUnit.3:currentUnit null
   458 ubind :rebindUnit.3:currentUnit
   459 sensor *tmp172 @unit @dead
   460 op strictEqual *tmp173 *tmp172 0
 
   471 label *label119
   472 ubind .TYPE
   473 set :rebindUnit.3:firstUnit @unit
-    * op notEqual *tmp179 :rebindUnit.3:firstUnit null
-    * jump *label122 equal *tmp179 false
+  474 jump *label122 equal :rebindUnit.3:firstUnit null
   475 label *label124
   476 sensor *tmp181 @unit @controlled
-    * op equal *tmp182 *tmp181 0
-    * jump *label127 equal *tmp182 false
+  477 jump *label127 notEqual *tmp181 0
   478 jump *label117 always
   479 jump *label128 always
   480 label *label127
 
   562 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   563 print :printDomeStatus.0:text
   564 sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
-    * op greaterThan *tmp215 :printDomeStatus.0:level 3
-    * jump *label137 equal *tmp215 false
+  565 jump *label137 lessThanEq :printDomeStatus.0:level 3
   566 print "  dome:  [green]"
   567 print :printDomeStatus.0:level
   568 print "["
 
   582 set :processUnit.0:group .GROUP1
   583 set :processUnit.0:supply .SUPPLY_S_FIRST
   584 set :rebindUnit.4:currentUnit :processUnit.0:unit
-    * op notEqual *tmp219 :rebindUnit.4:currentUnit null
-    * jump *label141 equal *tmp219 false
+  585 jump *label141 equal :rebindUnit.4:currentUnit null
   586 ubind :rebindUnit.4:currentUnit
   587 sensor *tmp221 @unit @dead
   588 op strictEqual *tmp222 *tmp221 0
 
   599 label *label142
   600 ubind .TYPE
   601 set :rebindUnit.4:firstUnit @unit
-    * op notEqual *tmp228 :rebindUnit.4:firstUnit null
-    * jump *label145 equal *tmp228 false
+  602 jump *label145 equal :rebindUnit.4:firstUnit null
   603 label *label147
   604 sensor *tmp230 @unit @controlled
-    * op equal *tmp231 *tmp230 0
-    * jump *label150 equal *tmp231 false
+  605 jump *label150 notEqual *tmp230 0
   606 jump *label140 always
   607 jump *label151 always
   608 label *label150
 
   629 op or *tmp240 *tmp238 *tmp239
   630 jump *label152 equal *tmp240 false
   631 sensor *tmp242 @unit @firstItem
-    * op equal *tmp243 *tmp242 :processUnit.0:item
-    * jump *label154 equal *tmp243 false
+  632 jump *label154 notEqual *tmp242 :processUnit.0:item
   633 set :processUnit.0:state 3
   634 jump *label155 always
   635 label *label154
   636 sensor *tmp245 @unit @totalItems
-    * op equal *tmp246 *tmp245 0
-    * jump *label156 equal *tmp246 false
+  637 jump *label156 notEqual *tmp245 0
   638 set :processUnit.0:state 2
   639 jump *label157 always
   640 label *label156
 
   651 jump *label153 always
   652 label *label152
   653 label *label153
-    * op equal *tmp250 :processUnit.0:state 2
-    * jump *label160 equal *tmp250 false
+  654 jump *label160 notEqual :processUnit.0:state 2
   655 ucontrol within .CORE_X .CORE_Y 8 *tmp252
   656 jump *label162 equal *tmp252 false
   657 ucontrol itemTake .CORE :processUnit.0:item .UNIT_CAPACITY
   658 sensor *tmp254 @unit @totalItems
-    * op greaterThanEq *tmp255 *tmp254 .UNIT_CAPACITY
-    * jump *label164 equal *tmp255 false
+  659 jump *label164 lessThan *tmp254 .UNIT_CAPACITY
   660 ucontrol approach .DOME_X .DOME_Y 6
   661 set :processUnit.0:state 3
   662 jump *label165 always
 
   678 jump *label161 always
   679 label *label160
   680 label *label161
-    * op equal *tmp264 :processUnit.0:state 3
-    * jump *label166 equal *tmp264 false
+  681 jump *label166 notEqual :processUnit.0:state 3
   682 ucontrol within .DOME_X .DOME_Y 8 *tmp266
   683 jump *label168 equal *tmp266 false
   684 jump *label170 equal :processUnit.0:supply false
 
   690 set :processUnit.0:msg ", waiting\n"
   691 label *label171
   692 sensor *tmp269 @unit @totalItems
-    * op lessThanEq *tmp270 *tmp269 0
-    * jump *label172 equal *tmp270 false
+  693 jump *label172 greaterThan *tmp269 0
   694 ucontrol approach .CORE_X .CORE_Y 6
   695 set :processUnit.0:state 2
   696 jump *label173 always
 
   722 print *tmp279
   723 print "["
   724 print "]"
-    * op greaterThanEq *tmp280 :processUnit.0:distance 0
-    * jump *label174 equal *tmp280 false
+  725 jump *label174 lessThan :processUnit.0:distance 0
   726 print :processUnit.0:msg
   727 print :processUnit.0:distance
   728 print "["
 
   744 set :processUnit.1:group .GROUP2
   745 set :processUnit.1:supply *tmp283
   746 set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * op notEqual *tmp286 :rebindUnit.5:currentUnit null
-    * jump *label180 equal *tmp286 false
+  747 jump *label180 equal :rebindUnit.5:currentUnit null
   748 ubind :rebindUnit.5:currentUnit
   749 sensor *tmp288 @unit @dead
   750 op strictEqual *tmp289 *tmp288 0
 
   761 label *label181
   762 ubind .TYPE
   763 set :rebindUnit.5:firstUnit @unit
-    * op notEqual *tmp295 :rebindUnit.5:firstUnit null
-    * jump *label184 equal *tmp295 false
+  764 jump *label184 equal :rebindUnit.5:firstUnit null
   765 label *label186
   766 sensor *tmp297 @unit @controlled
-    * op equal *tmp298 *tmp297 0
-    * jump *label189 equal *tmp298 false
+  767 jump *label189 notEqual *tmp297 0
   768 jump *label179 always
   769 jump *label190 always
   770 label *label189
 
   791 op or *tmp307 *tmp305 *tmp306
   792 jump *label191 equal *tmp307 false
   793 sensor *tmp309 @unit @firstItem
-    * op equal *tmp310 *tmp309 :processUnit.1:item
-    * jump *label193 equal *tmp310 false
+  794 jump *label193 notEqual *tmp309 :processUnit.1:item
   795 set :processUnit.1:state 3
   796 jump *label194 always
   797 label *label193
   798 sensor *tmp312 @unit @totalItems
-    * op equal *tmp313 *tmp312 0
-    * jump *label195 equal *tmp313 false
+  799 jump *label195 notEqual *tmp312 0
   800 set :processUnit.1:state 2
   801 jump *label196 always
   802 label *label195
 
   813 jump *label192 always
   814 label *label191
   815 label *label192
-    * op equal *tmp317 :processUnit.1:state 2
-    * jump *label199 equal *tmp317 false
+  816 jump *label199 notEqual :processUnit.1:state 2
   817 ucontrol within .CORE_X .CORE_Y 8 *tmp319
   818 jump *label201 equal *tmp319 false
   819 ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
   820 sensor *tmp321 @unit @totalItems
-    * op greaterThanEq *tmp322 *tmp321 .UNIT_CAPACITY
-    * jump *label203 equal *tmp322 false
+  821 jump *label203 lessThan *tmp321 .UNIT_CAPACITY
   822 ucontrol approach .DOME_X .DOME_Y 6
   823 set :processUnit.1:state 3
   824 jump *label204 always
 
   840 jump *label200 always
   841 label *label199
   842 label *label200
-    * op equal *tmp331 :processUnit.1:state 3
-    * jump *label205 equal *tmp331 false
+  843 jump *label205 notEqual :processUnit.1:state 3
   844 ucontrol within .DOME_X .DOME_Y 8 *tmp333
   845 jump *label207 equal *tmp333 false
   846 jump *label209 equal :processUnit.1:supply false
 
   852 set :processUnit.1:msg ", waiting\n"
   853 label *label210
   854 sensor *tmp336 @unit @totalItems
-    * op lessThanEq *tmp337 *tmp336 0
-    * jump *label211 equal *tmp337 false
+  855 jump *label211 greaterThan *tmp336 0
   856 ucontrol approach .CORE_X .CORE_Y 6
   857 set :processUnit.1:state 2
   858 jump *label212 always
 
   884 print *tmp346
   885 print "["
   886 print "]"
-    * op greaterThanEq *tmp347 :processUnit.1:distance 0
-    * jump *label213 equal *tmp347 false
+  887 jump *label213 lessThan :processUnit.1:distance 0
   888 print :processUnit.1:msg
   889 print :processUnit.1:distance
   890 print "["
 
   915 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   916 print :printDomeStatus.1:text
   917 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
-    * op greaterThan *tmp356 :printDomeStatus.1:level 3
-    * jump *label218 equal *tmp356 false
+  918 jump *label218 lessThanEq :printDomeStatus.1:level 3
   919 print "  dome:  [green]"
   920 print :printDomeStatus.1:level
   921 print "["
 
   935 set :processUnit.2:group .GROUP1
   936 set :processUnit.2:supply .SUPPLY_P_FIRST
   937 set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * op notEqual *tmp360 :rebindUnit.6:currentUnit null
-    * jump *label222 equal *tmp360 false
+  938 jump *label222 equal :rebindUnit.6:currentUnit null
   939 ubind :rebindUnit.6:currentUnit
   940 sensor *tmp362 @unit @dead
   941 op strictEqual *tmp363 *tmp362 0
 
   952 label *label223
   953 ubind .TYPE
   954 set :rebindUnit.6:firstUnit @unit
-    * op notEqual *tmp369 :rebindUnit.6:firstUnit null
-    * jump *label226 equal *tmp369 false
+  955 jump *label226 equal :rebindUnit.6:firstUnit null
   956 label *label228
   957 sensor *tmp371 @unit @controlled
-    * op equal *tmp372 *tmp371 0
-    * jump *label231 equal *tmp372 false
+  958 jump *label231 notEqual *tmp371 0
   959 jump *label221 always
   960 jump *label232 always
   961 label *label231
 
   982 op or *tmp381 *tmp379 *tmp380
   983 jump *label233 equal *tmp381 false
   984 sensor *tmp383 @unit @firstItem
-    * op equal *tmp384 *tmp383 :processUnit.2:item
-    * jump *label235 equal *tmp384 false
+  985 jump *label235 notEqual *tmp383 :processUnit.2:item
   986 set :processUnit.2:state 3
   987 jump *label236 always
   988 label *label235
   989 sensor *tmp386 @unit @totalItems
-    * op equal *tmp387 *tmp386 0
-    * jump *label237 equal *tmp387 false
+  990 jump *label237 notEqual *tmp386 0
   991 set :processUnit.2:state 2
   992 jump *label238 always
   993 label *label237
 
  1004 jump *label234 always
  1005 label *label233
  1006 label *label234
-    * op equal *tmp391 :processUnit.2:state 2
-    * jump *label241 equal *tmp391 false
+ 1007 jump *label241 notEqual :processUnit.2:state 2
  1008 ucontrol within .CORE_X .CORE_Y 8 *tmp393
  1009 jump *label243 equal *tmp393 false
  1010 ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
  1011 sensor *tmp395 @unit @totalItems
-    * op greaterThanEq *tmp396 *tmp395 .UNIT_CAPACITY
-    * jump *label245 equal *tmp396 false
+ 1012 jump *label245 lessThan *tmp395 .UNIT_CAPACITY
  1013 ucontrol approach .DOME_X .DOME_Y 6
  1014 set :processUnit.2:state 3
  1015 jump *label246 always
 
  1031 jump *label242 always
  1032 label *label241
  1033 label *label242
-    * op equal *tmp405 :processUnit.2:state 3
-    * jump *label247 equal *tmp405 false
+ 1034 jump *label247 notEqual :processUnit.2:state 3
  1035 ucontrol within .DOME_X .DOME_Y 8 *tmp407
  1036 jump *label249 equal *tmp407 false
  1037 jump *label251 equal :processUnit.2:supply false
 
  1043 set :processUnit.2:msg ", waiting\n"
  1044 label *label252
  1045 sensor *tmp410 @unit @totalItems
-    * op lessThanEq *tmp411 *tmp410 0
-    * jump *label253 equal *tmp411 false
+ 1046 jump *label253 greaterThan *tmp410 0
  1047 ucontrol approach .CORE_X .CORE_Y 6
  1048 set :processUnit.2:state 2
  1049 jump *label254 always
 
  1075 print *tmp420
  1076 print "["
  1077 print "]"
-    * op greaterThanEq *tmp421 :processUnit.2:distance 0
-    * jump *label255 equal *tmp421 false
+ 1078 jump *label255 lessThan :processUnit.2:distance 0
  1079 print :processUnit.2:msg
  1080 print :processUnit.2:distance
  1081 print "["
 
  1097 set :processUnit.3:group .GROUP2
  1098 set :processUnit.3:supply *tmp424
  1099 set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * op notEqual *tmp427 :rebindUnit.7:currentUnit null
-    * jump *label261 equal *tmp427 false
+ 1100 jump *label261 equal :rebindUnit.7:currentUnit null
  1101 ubind :rebindUnit.7:currentUnit
  1102 sensor *tmp429 @unit @dead
  1103 op strictEqual *tmp430 *tmp429 0
 
  1114 label *label262
  1115 ubind .TYPE
  1116 set :rebindUnit.7:firstUnit @unit
-    * op notEqual *tmp436 :rebindUnit.7:firstUnit null
-    * jump *label265 equal *tmp436 false
+ 1117 jump *label265 equal :rebindUnit.7:firstUnit null
  1118 label *label267
  1119 sensor *tmp438 @unit @controlled
-    * op equal *tmp439 *tmp438 0
-    * jump *label270 equal *tmp439 false
+ 1120 jump *label270 notEqual *tmp438 0
  1121 jump *label260 always
  1122 jump *label271 always
  1123 label *label270
 
  1144 op or *tmp448 *tmp446 *tmp447
  1145 jump *label272 equal *tmp448 false
  1146 sensor *tmp450 @unit @firstItem
-    * op equal *tmp451 *tmp450 :processUnit.3:item
-    * jump *label274 equal *tmp451 false
+ 1147 jump *label274 notEqual *tmp450 :processUnit.3:item
  1148 set :processUnit.3:state 3
  1149 jump *label275 always
  1150 label *label274
  1151 sensor *tmp453 @unit @totalItems
-    * op equal *tmp454 *tmp453 0
-    * jump *label276 equal *tmp454 false
+ 1152 jump *label276 notEqual *tmp453 0
  1153 set :processUnit.3:state 2
  1154 jump *label277 always
  1155 label *label276
 
  1166 jump *label273 always
  1167 label *label272
  1168 label *label273
-    * op equal *tmp458 :processUnit.3:state 2
-    * jump *label280 equal *tmp458 false
+ 1169 jump *label280 notEqual :processUnit.3:state 2
  1170 ucontrol within .CORE_X .CORE_Y 8 *tmp460
  1171 jump *label282 equal *tmp460 false
  1172 ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
  1173 sensor *tmp462 @unit @totalItems
-    * op greaterThanEq *tmp463 *tmp462 .UNIT_CAPACITY
-    * jump *label284 equal *tmp463 false
+ 1174 jump *label284 lessThan *tmp462 .UNIT_CAPACITY
  1175 ucontrol approach .DOME_X .DOME_Y 6
  1176 set :processUnit.3:state 3
  1177 jump *label285 always
 
  1193 jump *label281 always
  1194 label *label280
  1195 label *label281
-    * op equal *tmp472 :processUnit.3:state 3
-    * jump *label286 equal *tmp472 false
+ 1196 jump *label286 notEqual :processUnit.3:state 3
  1197 ucontrol within .DOME_X .DOME_Y 8 *tmp474
  1198 jump *label288 equal *tmp474 false
  1199 jump *label290 equal :processUnit.3:supply false
 
  1205 set :processUnit.3:msg ", waiting\n"
  1206 label *label291
  1207 sensor *tmp477 @unit @totalItems
-    * op lessThanEq *tmp478 *tmp477 0
-    * jump *label292 equal *tmp478 false
+ 1208 jump *label292 greaterThan *tmp477 0
  1209 ucontrol approach .CORE_X .CORE_Y 6
  1210 set :processUnit.3:state 2
  1211 jump *label293 always
 
  1237 print *tmp487
  1238 print "["
  1239 print "]"
-    * op greaterThanEq *tmp488 :processUnit.3:distance 0
-    * jump *label294 equal *tmp488 false
+ 1240 jump *label294 lessThan :processUnit.3:distance 0
  1241 print :processUnit.3:msg
  1242 print :processUnit.3:distance
  1243 print "["
 
  1283 set :areUnitsAvailable.2:free :areUnitsAvailable.2:occupied
  1284 ubind :areUnitsAvailable.2:type
  1285 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp503 :areUnitsAvailable.2:firstUnit null
-    * jump *label301 equal *tmp503 false
+ 1286 jump *label301 equal :areUnitsAvailable.2:firstUnit null
  1287 set :needsFourUnits.3:unit @unit
  1288 op sub *tmp506 .DOME_X .CORE_X
  1289 op sub *tmp507 .DOME_Y .CORE_Y
 
  1310 op or *tmp518 *tmp515 *tmp517
  1311 jump *label309 equal *tmp518 false
  1312 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * op greaterThanEq *tmp520 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
-    * jump *label311 equal *tmp520 false
+ 1313 jump *label311 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1314 set *tmp501 true
  1315 jump *label300 always
  1316 jump *label312 always
 
  1339 print ","
  1340 print " free: "
  1341 print :areUnitsAvailable.2:free
-    * op greaterThan *tmp527 :areUnitsAvailable.2:needed 0
-    * jump *label315 equal *tmp527 false
+ 1342 jump *label315 lessThanEq :areUnitsAvailable.2:needed 0
  1343 print ", needed: "
  1344 print :areUnitsAvailable.2:needed
  1345 jump *label316 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-79 instructions):
 
    66 jump *label21 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
    67 set *tmp4 true
    68 jump *label10 always
-    * jump *label22 always
    69 label *label21
    70 label *label22
    71 jump *label20 always
 
    80 op land *tmp28 *tmp25 *tmp27
    81 jump *label16 notEqual *tmp28 false
    82 label *label18
-    * jump *label12 always
    83 label *label11
    84 label *label12
    85 jump *label23 equal :areUnitsAvailable.0:output false
 
    93 jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
    94 print ", needed: "
    95 print :areUnitsAvailable.0:needed
-    * jump *label26 always
    96 label *label25
    97 label *label26
    98 print "\n"
-    * jump *label24 always
    99 label *label23
   100 label *label24
   101 set *tmp4 false
 
   105 jump *label27 equal *tmp4 false
   106 set *tmp3 UNIT_TYPE
   107 jump *label6 always
-    * jump *label28 always
   108 label *label27
   109 label *label28
   110 set :chooseUnitType.0:type @flare
 
   162 jump *label49 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   163 set *tmp36 true
   164 jump *label38 always
-    * jump *label50 always
   165 label *label49
   166 label *label50
   167 jump *label48 always
 
   176 op land *tmp60 *tmp57 *tmp59
   177 jump *label44 notEqual *tmp60 false
   178 label *label46
-    * jump *label40 always
   179 label *label39
   180 label *label40
   181 jump *label51 equal :areUnitsAvailable.1:output false
 
   189 jump *label53 lessThanEq :areUnitsAvailable.1:needed 0
   190 print ", needed: "
   191 print :areUnitsAvailable.1:needed
-    * jump *label54 always
   192 label *label53
   193 label *label54
   194 print "\n"
-    * jump *label52 always
   195 label *label51
   196 label *label52
   197 set *tmp36 false
 
   202 printflush null
   203 set *tmp3 :chooseUnitType.0:type
   204 jump *label6 always
-    * jump *label56 always
   205 label *label55
   206 label *label56
-    * jump *label37 always
   207 label *label36
   208 label *label37
   209 label *label30
 
   228 set :rebindUnits.0:firstUnit @unit
   229 jump *label58 notEqual :rebindUnits.0:firstUnit null
   230 end
-    * jump *label59 always
   231 label *label58
   232 label *label59
   233 label *label60
 
   241 set .UNIT_P1 @unit
   242 jump *label65 equal .UNIT_S2 null
   243 jump *label62 always
-    * jump *label66 always
   244 label *label65
   245 label *label66
-    * jump *label64 always
   246 label *label63
   247 label *label64
   248 ubind .TYPE
 
   253 op land *tmp78 *tmp75 *tmp77
   254 jump *label60 notEqual *tmp78 false
   255 label *label62
-    * jump *label57 always
   256 label *label57
   257 set :acquireUnit.0:currentUnit .UNIT_S1
   258 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
 
   265 op land *tmp87 *tmp84 *tmp86
   266 jump *label71 equal *tmp87 false
   267 jump *label68 always
-    * jump *label72 always
   268 label *label71
   269 label *label72
-    * jump *label70 always
   270 label *label69
   271 label *label70
   272 ubind .TYPE
 
   276 sensor *tmp92 @unit @controlled
   277 jump *label78 notEqual *tmp92 0
   278 jump *label68 always
-    * jump *label79 always
   279 label *label78
   280 label *label79
   281 ubind .TYPE
 
   286 op land *tmp98 *tmp95 *tmp97
   287 jump *label75 notEqual *tmp98 false
   288 label *label77
-    * jump *label74 always
   289 label *label73
   290 label *label74
   291 end
 
   307 op land *tmp107 *tmp104 *tmp106
   308 jump *label84 equal *tmp107 false
   309 jump *label81 always
-    * jump *label85 always
   310 label *label84
   311 label *label85
-    * jump *label83 always
   312 label *label82
   313 label *label83
   314 ubind .TYPE
 
   318 sensor *tmp112 @unit @controlled
   319 jump *label91 notEqual *tmp112 0
   320 jump *label81 always
-    * jump *label92 always
   321 label *label91
   322 label *label92
   323 ubind .TYPE
 
   328 op land *tmp118 *tmp115 *tmp117
   329 jump *label88 notEqual *tmp118 false
   330 label *label90
-    * jump *label87 always
   331 label *label86
   332 label *label87
   333 end
 
   347 set :u .UNIT_S1
   348 set .UNIT_S1 .UNIT_P1
   349 set .UNIT_P1 :u
-    * jump *label94 always
   350 label *label93
   351 label *label94
   352 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   355 op strictEqual *tmp128 .SPEED null
   356 jump *label95 equal *tmp128 false
   357 stop
-    * jump *label96 always
   358 label *label95
   359 label *label96
   360 print "[gold]Locating core..."
 
   392 op land *tmp156 *tmp153 *tmp155
   393 jump *label107 equal *tmp156 false
   394 jump *label104 always
-    * jump *label108 always
   395 label *label107
   396 label *label108
-    * jump *label106 always
   397 label *label105
   398 label *label106
   399 ubind .TYPE
 
   403 sensor *tmp161 @unit @controlled
   404 jump *label114 notEqual *tmp161 0
   405 jump *label104 always
-    * jump *label115 always
   406 label *label114
   407 label *label115
   408 ubind .TYPE
 
   413 op land *tmp167 *tmp164 *tmp166
   414 jump *label111 notEqual *tmp167 false
   415 label *label113
-    * jump *label110 always
   416 label *label109
   417 label *label110
   418 end
 
   434 op land *tmp176 *tmp173 *tmp175
   435 jump *label120 equal *tmp176 false
   436 jump *label117 always
-    * jump *label121 always
   437 label *label120
   438 label *label121
-    * jump *label119 always
   439 label *label118
   440 label *label119
   441 ubind .TYPE
 
   445 sensor *tmp181 @unit @controlled
   446 jump *label127 notEqual *tmp181 0
   447 jump *label117 always
-    * jump *label128 always
   448 label *label127
   449 label *label128
   450 ubind .TYPE
 
   455 op land *tmp187 *tmp184 *tmp186
   456 jump *label124 notEqual *tmp187 false
   457 label *label126
-    * jump *label123 always
   458 label *label122
   459 label *label123
   460 end
 
   474 set :u .UNIT_S1
   475 set .UNIT_S1 .UNIT_P2
   476 set .UNIT_P2 :u
-    * jump *label130 always
   477 label *label129
   478 label *label130
   479 sensor *tmp194 .UNIT_S2 @firstItem
 
   485 set :u .UNIT_S2
   486 set .UNIT_S2 .UNIT_P2
   487 set .UNIT_P2 :u
-    * jump *label132 always
   488 label *label131
   489 label *label132
   490 set .GROUP1 "unit  1"
 
   556 op land *tmp225 *tmp222 *tmp224
   557 jump *label143 equal *tmp225 false
   558 jump *label140 always
-    * jump *label144 always
   559 label *label143
   560 label *label144
-    * jump *label142 always
   561 label *label141
   562 label *label142
   563 ubind .TYPE
 
   567 sensor *tmp230 @unit @controlled
   568 jump *label150 notEqual *tmp230 0
   569 jump *label140 always
-    * jump *label151 always
   570 label *label150
   571 label *label151
   572 ubind .TYPE
 
   577 op land *tmp236 *tmp233 *tmp235
   578 jump *label147 notEqual *tmp236 false
   579 label *label149
-    * jump *label146 always
   580 label *label145
   581 label *label146
   582 end
 
   604 ucontrol within .CORE_X .CORE_Y 8 *tmp248
   605 jump *label158 equal *tmp248 false
   606 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label159 always
   607 label *label158
   608 label *label159
   609 label *label157
   610 label *label155
-    * jump *label153 always
   611 label *label152
   612 label *label153
   613 jump *label160 notEqual :processUnit.0:state 2
 
   634 op idiv *tmp262 *tmp261 .SPEED_TENTHS
   635 op div :processUnit.0:distance *tmp262 10
   636 label *label163
-    * jump *label161 always
   637 label *label160
   638 label *label161
   639 jump *label166 notEqual :processUnit.0:state 3
 
   651 jump *label172 greaterThan *tmp269 0
   652 ucontrol approach .CORE_X .CORE_Y 6
   653 set :processUnit.0:state 2
-    * jump *label173 always
   654 label *label172
   655 label *label173
   656 jump *label169 always
 
   665 op idiv *tmp277 *tmp276 .SPEED_TENTHS
   666 op div :processUnit.0:distance *tmp277 10
   667 label *label169
-    * jump *label167 always
   668 label *label166
   669 label *label167
   670 ucontrol flag :processUnit.0:state
 
   709 op land *tmp292 *tmp289 *tmp291
   710 jump *label182 equal *tmp292 false
   711 jump *label179 always
-    * jump *label183 always
   712 label *label182
   713 label *label183
-    * jump *label181 always
   714 label *label180
   715 label *label181
   716 ubind .TYPE
 
   720 sensor *tmp297 @unit @controlled
   721 jump *label189 notEqual *tmp297 0
   722 jump *label179 always
-    * jump *label190 always
   723 label *label189
   724 label *label190
   725 ubind .TYPE
 
   730 op land *tmp303 *tmp300 *tmp302
   731 jump *label186 notEqual *tmp303 false
   732 label *label188
-    * jump *label185 always
   733 label *label184
   734 label *label185
   735 end
 
   757 ucontrol within .CORE_X .CORE_Y 8 *tmp315
   758 jump *label197 equal *tmp315 false
   759 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label198 always
   760 label *label197
   761 label *label198
   762 label *label196
   763 label *label194
-    * jump *label192 always
   764 label *label191
   765 label *label192
   766 jump *label199 notEqual :processUnit.1:state 2
 
   787 op idiv *tmp329 *tmp328 .SPEED_TENTHS
   788 op div :processUnit.1:distance *tmp329 10
   789 label *label202
-    * jump *label200 always
   790 label *label199
   791 label *label200
   792 jump *label205 notEqual :processUnit.1:state 3
 
   804 jump *label211 greaterThan *tmp336 0
   805 ucontrol approach .CORE_X .CORE_Y 6
   806 set :processUnit.1:state 2
-    * jump *label212 always
   807 label *label211
   808 label *label212
   809 jump *label208 always
 
   818 op idiv *tmp344 *tmp343 .SPEED_TENTHS
   819 op div :processUnit.1:distance *tmp344 10
   820 label *label208
-    * jump *label206 always
   821 label *label205
   822 label *label206
   823 ucontrol flag :processUnit.1:state
 
   855 op equal *tmp349 *tmp352 0
   856 label *label216
   857 set .SUPPLY_S_FIRST *tmp349
-    * jump *label177 always
   858 label *label176
   859 label *label177
   860 set :printDomeStatus.1:item @phase-fabric
 
   890 op land *tmp366 *tmp363 *tmp365
   891 jump *label224 equal *tmp366 false
   892 jump *label221 always
-    * jump *label225 always
   893 label *label224
   894 label *label225
-    * jump *label223 always
   895 label *label222
   896 label *label223
   897 ubind .TYPE
 
   901 sensor *tmp371 @unit @controlled
   902 jump *label231 notEqual *tmp371 0
   903 jump *label221 always
-    * jump *label232 always
   904 label *label231
   905 label *label232
   906 ubind .TYPE
 
   911 op land *tmp377 *tmp374 *tmp376
   912 jump *label228 notEqual *tmp377 false
   913 label *label230
-    * jump *label227 always
   914 label *label226
   915 label *label227
   916 end
 
   938 ucontrol within .CORE_X .CORE_Y 8 *tmp389
   939 jump *label239 equal *tmp389 false
   940 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label240 always
   941 label *label239
   942 label *label240
   943 label *label238
   944 label *label236
-    * jump *label234 always
   945 label *label233
   946 label *label234
   947 jump *label241 notEqual :processUnit.2:state 2
 
   968 op idiv *tmp403 *tmp402 .SPEED_TENTHS
   969 op div :processUnit.2:distance *tmp403 10
   970 label *label244
-    * jump *label242 always
   971 label *label241
   972 label *label242
   973 jump *label247 notEqual :processUnit.2:state 3
 
   985 jump *label253 greaterThan *tmp410 0
   986 ucontrol approach .CORE_X .CORE_Y 6
   987 set :processUnit.2:state 2
-    * jump *label254 always
   988 label *label253
   989 label *label254
   990 jump *label250 always
 
   999 op idiv *tmp418 *tmp417 .SPEED_TENTHS
  1000 op div :processUnit.2:distance *tmp418 10
  1001 label *label250
-    * jump *label248 always
  1002 label *label247
  1003 label *label248
  1004 ucontrol flag :processUnit.2:state
 
  1043 op land *tmp433 *tmp430 *tmp432
  1044 jump *label263 equal *tmp433 false
  1045 jump *label260 always
-    * jump *label264 always
  1046 label *label263
  1047 label *label264
-    * jump *label262 always
  1048 label *label261
  1049 label *label262
  1050 ubind .TYPE
 
  1054 sensor *tmp438 @unit @controlled
  1055 jump *label270 notEqual *tmp438 0
  1056 jump *label260 always
-    * jump *label271 always
  1057 label *label270
  1058 label *label271
  1059 ubind .TYPE
 
  1064 op land *tmp444 *tmp441 *tmp443
  1065 jump *label267 notEqual *tmp444 false
  1066 label *label269
-    * jump *label266 always
  1067 label *label265
  1068 label *label266
  1069 end
 
  1091 ucontrol within .CORE_X .CORE_Y 8 *tmp456
  1092 jump *label278 equal *tmp456 false
  1093 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label279 always
  1094 label *label278
  1095 label *label279
  1096 label *label277
  1097 label *label275
-    * jump *label273 always
  1098 label *label272
  1099 label *label273
  1100 jump *label280 notEqual :processUnit.3:state 2
 
  1121 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1122 op div :processUnit.3:distance *tmp470 10
  1123 label *label283
-    * jump *label281 always
  1124 label *label280
  1125 label *label281
  1126 jump *label286 notEqual :processUnit.3:state 3
 
  1138 jump *label292 greaterThan *tmp477 0
  1139 ucontrol approach .CORE_X .CORE_Y 6
  1140 set :processUnit.3:state 2
-    * jump *label293 always
  1141 label *label292
  1142 label *label293
  1143 jump *label289 always
 
  1152 op idiv *tmp485 *tmp484 .SPEED_TENTHS
  1153 op div :processUnit.3:distance *tmp485 10
  1154 label *label289
-    * jump *label287 always
  1155 label *label286
  1156 label *label287
  1157 ucontrol flag :processUnit.3:state
 
  1189 op equal *tmp490 *tmp493 0
  1190 label *label297
  1191 set .SUPPLY_P_FIRST *tmp490
-    * jump *label258 always
  1192 label *label257
  1193 label *label258
  1194 op sub *tmp495 @time :start
 
  1240 jump *label311 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1241 set *tmp501 true
  1242 jump *label300 always
-    * jump *label312 always
  1243 label *label311
  1244 label *label312
  1245 jump *label310 always
 
  1254 op land *tmp525 *tmp522 *tmp524
  1255 jump *label306 notEqual *tmp525 false
  1256 label *label308
-    * jump *label302 always
  1257 label *label301
  1258 label *label302
  1259 jump *label313 equal :areUnitsAvailable.2:output false
 
  1267 jump *label315 lessThanEq :areUnitsAvailable.2:needed 0
  1268 print ", needed: "
  1269 print :areUnitsAvailable.2:needed
-    * jump *label316 always
  1270 label *label315
  1271 label *label316
  1272 print "\n"
-    * jump *label314 always
  1273 label *label313
  1274 label *label314
  1275 set *tmp501 false
 
  1278 label *label300
  1279 jump *label317 equal *tmp501 false
  1280 end
-    * jump *label318 always
  1281 label *label317
  1282 label *label318
  1283 op add :unitCheck @time 5000
-    * jump *label299 always
  1284 label *label298
  1285 label *label299
  1286 label *label134

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
     4 set .DOME_Y null
-    * set .DOME_X .DOME_Y
-    * set .CORE_Y .DOME_X
-    * set .CORE_X .CORE_Y
+    5 set .DOME_X null
+    6 set .CORE_Y .DOME_Y
+    7 set .CORE_X .DOME_X
     8 set .DOME dome1
     9 label *label0
    10 jump *label2 notEqual .DOME null
 
    32 set :areUnitsAvailable.0:type UNIT_TYPE
    33 set :areUnitsAvailable.0:output true
    34 set :areUnitsAvailable.0:needed 0
-    * set :areUnitsAvailable.0:occupied :areUnitsAvailable.0:needed
-    * set :areUnitsAvailable.0:free :areUnitsAvailable.0:occupied
-    * ubind :areUnitsAvailable.0:type
+   35 set :areUnitsAvailable.0:occupied 0
+   36 set :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   37 ubind UNIT_TYPE
    38 set :areUnitsAvailable.0:firstUnit @unit
    39 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    40 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 .DOME_X .CORE_X
-    * op sub *tmp10 .DOME_Y .CORE_Y
+   41 op sub *tmp9 .DOME_Y .CORE_Y
+   42 op sub *tmp10 null .DOME_X
    43 op len *tmp11 *tmp9 *tmp10
    44 op mul *tmp12 2 *tmp11
    45 sensor *tmp13 :needsFourUnits.0:unit @speed
    46 op div :needsFourUnits.0:travel_time *tmp12 *tmp13
    47 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    48 jump *label13 always
-    * set *tmp8 null
    49 label *label13
    50 jump *label14 equal *tmp8 false
    51 set *tmp16 4
 
    62 op or *tmp21 *tmp18 *tmp20
    63 jump *label19 equal *tmp21 false
    64 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label21 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   65 jump *label21 lessThan :areUnitsAvailable.0:free *tmp16
    66 set *tmp4 true
    67 jump *label10 always
    68 label *label21
 
    71 label *label19
    72 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
    73 label *label20
-    * ubind :areUnitsAvailable.0:type
+   74 ubind UNIT_TYPE
    75 label *label17
    76 op notEqual *tmp25 @unit :areUnitsAvailable.0:firstUnit
    77 sensor *tmp26 :areUnitsAvailable.0:firstUnit @dead
 
    81 label *label18
    82 label *label11
    83 label *label12
-    * jump *label23 equal :areUnitsAvailable.0:output false
-    * print :areUnitsAvailable.0:type
+   84 jump *label23 equal true false
+   85 print UNIT_TYPE
    86 print ":"
    87 print " occupied: "
    88 print :areUnitsAvailable.0:occupied
 
    99 label *label24
   100 set *tmp4 false
   101 jump *label10 always
-    * set *tmp4 null
   102 label *label10
   103 jump *label27 equal *tmp4 false
   104 set *tmp3 UNIT_TYPE
 
   126 set :areUnitsAvailable.1:type :chooseUnitType.0:type
   127 set :areUnitsAvailable.1:output true
   128 set :areUnitsAvailable.1:needed 0
-    * set :areUnitsAvailable.1:occupied :areUnitsAvailable.1:needed
-    * set :areUnitsAvailable.1:free :areUnitsAvailable.1:occupied
-    * ubind :areUnitsAvailable.1:type
+  129 set :areUnitsAvailable.1:occupied 0
+  130 set :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  131 ubind :chooseUnitType.0:type
   132 set :areUnitsAvailable.1:firstUnit @unit
   133 jump *label39 equal :areUnitsAvailable.1:firstUnit null
   134 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 .DOME_X .CORE_X
-    * op sub *tmp42 .DOME_Y .CORE_Y
+  135 op sub *tmp41 .DOME_Y .CORE_Y
+  136 op sub *tmp42 null .DOME_X
   137 op len *tmp43 *tmp41 *tmp42
   138 op mul *tmp44 2 *tmp43
   139 sensor *tmp45 :needsFourUnits.1:unit @speed
   140 op div :needsFourUnits.1:travel_time *tmp44 *tmp45
   141 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   142 jump *label41 always
-    * set *tmp40 null
   143 label *label41
   144 jump *label42 equal *tmp40 false
   145 set *tmp48 4
 
   156 op or *tmp53 *tmp50 *tmp52
   157 jump *label47 equal *tmp53 false
   158 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label49 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  159 jump *label49 lessThan :areUnitsAvailable.1:free *tmp48
   160 set *tmp36 true
   161 jump *label38 always
   162 label *label49
 
   165 label *label47
   166 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   167 label *label48
-    * ubind :areUnitsAvailable.1:type
+  168 ubind :chooseUnitType.0:type
   169 label *label45
   170 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   171 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   175 label *label46
   176 label *label39
   177 label *label40
-    * jump *label51 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  178 jump *label51 equal true false
+  179 print :chooseUnitType.0:type
   180 print ":"
   181 print " occupied: "
   182 print :areUnitsAvailable.1:occupied
 
   193 label *label52
   194 set *tmp36 false
   195 jump *label38 always
-    * set *tmp36 null
   196 label *label38
   197 jump *label55 equal *tmp36 false
   198 printflush null
 
   216 print "[gold]Binding units..."
   217 printflush message1
   218 set .UNIT_P2 null
-    * set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P1 .UNIT_S2
-    * set .UNIT_S1 .UNIT_P1
+  219 set .UNIT_S2 null
+  220 set .UNIT_P1 .UNIT_P2
+  221 set .UNIT_S1 .UNIT_S2
   222 set :rebindUnits.0:count 0
-    * ubind .TYPE
+  223 ubind *tmp3
   224 set :rebindUnits.0:firstUnit @unit
   225 jump *label58 notEqual :rebindUnits.0:firstUnit null
   226 end
 
   241 label *label66
   242 label *label63
   243 label *label64
-    * ubind .TYPE
+  244 ubind *tmp3
   245 label *label61
   246 op notEqual *tmp75 @unit :rebindUnits.0:firstUnit
   247 sensor *tmp76 :rebindUnits.0:firstUnit @dead
 
   251 label *label62
   252 label *label57
   253 set :acquireUnit.0:currentUnit .UNIT_S1
-    * set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * jump *label69 equal :rebindUnit.0:currentUnit null
-    * ubind :rebindUnit.0:currentUnit
+  254 set :rebindUnit.0:currentUnit .UNIT_S1
+  255 jump *label69 equal :acquireUnit.0:currentUnit null
+  256 ubind :acquireUnit.0:currentUnit
   257 sensor *tmp83 @unit @dead
   258 op strictEqual *tmp84 *tmp83 0
   259 sensor *tmp85 @unit @controller
 
   265 label *label72
   266 label *label69
   267 label *label70
-    * ubind .TYPE
+  268 ubind *tmp3
   269 set :rebindUnit.0:firstUnit @unit
   270 jump *label73 equal :rebindUnit.0:firstUnit null
   271 label *label75
 
   274 jump *label68 always
   275 label *label78
   276 label *label79
-    * ubind .TYPE
+  277 ubind *tmp3
   278 label *label76
   279 op notEqual *tmp95 @unit :rebindUnit.0:firstUnit
   280 sensor *tmp96 :rebindUnit.0:firstUnit @dead
 
   289 ucontrol flag 1
   290 set *tmp79 @unit
   291 jump *label67 always
-    * set *tmp79 null
   292 label *label67
   293 set .UNIT_S1 *tmp79
   294 set :acquireUnit.1:currentUnit .UNIT_P1
-    * set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * jump *label82 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  295 set :rebindUnit.1:currentUnit .UNIT_P1
+  296 jump *label82 equal :acquireUnit.1:currentUnit null
+  297 ubind :acquireUnit.1:currentUnit
   298 sensor *tmp103 @unit @dead
   299 op strictEqual *tmp104 *tmp103 0
   300 sensor *tmp105 @unit @controller
 
   306 label *label85
   307 label *label82
   308 label *label83
-    * ubind .TYPE
+  309 ubind *tmp3
   310 set :rebindUnit.1:firstUnit @unit
   311 jump *label86 equal :rebindUnit.1:firstUnit null
   312 label *label88
 
   315 jump *label81 always
   316 label *label91
   317 label *label92
-    * ubind .TYPE
+  318 ubind *tmp3
   319 label *label89
   320 op notEqual *tmp115 @unit :rebindUnit.1:firstUnit
   321 sensor *tmp116 :rebindUnit.1:firstUnit @dead
 
   330 ucontrol flag 1
   331 set *tmp99 @unit
   332 jump *label80 always
-    * set *tmp99 null
   333 label *label80
   334 set .UNIT_P1 *tmp99
-    * sensor *tmp119 .UNIT_S1 @firstItem
+  335 sensor *tmp119 *tmp79 @firstItem
   336 op equal *tmp120 *tmp119 @phase-fabric
-    * sensor *tmp121 .UNIT_P1 @firstItem
+  337 sensor *tmp121 *tmp99 @firstItem
   338 op equal *tmp122 *tmp121 @silicon
   339 op or *tmp123 *tmp120 *tmp122
   340 jump *label93 equal *tmp123 false
-    * set :u .UNIT_S1
-    * set .UNIT_S1 .UNIT_P1
+  341 set :u *tmp79
+  342 set .UNIT_S1 *tmp99
   343 set .UNIT_P1 :u
   344 label *label93
   345 label *label94
 
   367 op sub *tmp141 .DOME_Y .CORE_Y
   368 op len *tmp142 *tmp140 *tmp141
   369 op mul *tmp143 2 *tmp142
-    * sensor *tmp144 :needsFourUnits.2:unit @speed
-    * op div :needsFourUnits.2:travel_time *tmp143 *tmp144
+  370 sensor *tmp144 .UNIT_S1 @speed
+  371 op div :needsFourUnits.2:travel_time *tmp143 .SPEED
   372 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   373 jump *label100 always
-    * set *tmp139 null
   374 label *label100
   375 set .FOUR_UNITS *tmp139
-    * jump *label101 equal .FOUR_UNITS false
+  376 jump *label101 equal *tmp139 false
   377 set :acquireUnit.2:currentUnit .UNIT_S2
-    * set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * jump *label105 equal :rebindUnit.2:currentUnit null
-    * ubind :rebindUnit.2:currentUnit
+  378 set :rebindUnit.2:currentUnit .UNIT_S2
+  379 jump *label105 equal :acquireUnit.2:currentUnit null
+  380 ubind :acquireUnit.2:currentUnit
   381 sensor *tmp152 @unit @dead
   382 op strictEqual *tmp153 *tmp152 0
   383 sensor *tmp154 @unit @controller
 
   389 label *label108
   390 label *label105
   391 label *label106
-    * ubind .TYPE
+  392 ubind *tmp3
   393 set :rebindUnit.2:firstUnit @unit
   394 jump *label109 equal :rebindUnit.2:firstUnit null
   395 label *label111
 
   398 jump *label104 always
   399 label *label114
   400 label *label115
-    * ubind .TYPE
+  401 ubind *tmp3
   402 label *label112
   403 op notEqual *tmp164 @unit :rebindUnit.2:firstUnit
   404 sensor *tmp165 :rebindUnit.2:firstUnit @dead
 
   413 ucontrol flag 1
   414 set *tmp148 @unit
   415 jump *label103 always
-    * set *tmp148 null
   416 label *label103
   417 set .UNIT_S2 *tmp148
   418 set :acquireUnit.3:currentUnit .UNIT_P2
-    * set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * jump *label118 equal :rebindUnit.3:currentUnit null
-    * ubind :rebindUnit.3:currentUnit
+  419 set :rebindUnit.3:currentUnit .UNIT_P2
+  420 jump *label118 equal :acquireUnit.3:currentUnit null
+  421 ubind :acquireUnit.3:currentUnit
   422 sensor *tmp172 @unit @dead
   423 op strictEqual *tmp173 *tmp172 0
   424 sensor *tmp174 @unit @controller
 
   430 label *label121
   431 label *label118
   432 label *label119
-    * ubind .TYPE
+  433 ubind *tmp3
   434 set :rebindUnit.3:firstUnit @unit
   435 jump *label122 equal :rebindUnit.3:firstUnit null
   436 label *label124
 
   439 jump *label117 always
   440 label *label127
   441 label *label128
-    * ubind .TYPE
+  442 ubind *tmp3
   443 label *label125
   444 op notEqual *tmp184 @unit :rebindUnit.3:firstUnit
   445 sensor *tmp185 :rebindUnit.3:firstUnit @dead
 
   454 ucontrol flag 1
   455 set *tmp168 @unit
   456 jump *label116 always
-    * set *tmp168 null
   457 label *label116
   458 set .UNIT_P2 *tmp168
   459 sensor *tmp188 .UNIT_S1 @firstItem
   460 op equal *tmp189 *tmp188 @phase-fabric
-    * sensor *tmp190 .UNIT_P2 @firstItem
+  461 sensor *tmp190 *tmp168 @firstItem
   462 op notEqual *tmp191 *tmp190 @phase-fabric
   463 op land *tmp192 *tmp189 *tmp191
   464 jump *label129 equal *tmp192 false
   465 set :u .UNIT_S1
-    * set .UNIT_S1 .UNIT_P2
+  466 set .UNIT_S1 *tmp168
   467 set .UNIT_P2 :u
   468 label *label129
   469 label *label130
-    * sensor *tmp194 .UNIT_S2 @firstItem
+  470 sensor *tmp194 *tmp148 @firstItem
   471 op equal *tmp195 *tmp194 @phase-fabric
   472 sensor *tmp196 .UNIT_P2 @firstItem
   473 op equal *tmp197 *tmp196 @silicon
   474 op or *tmp198 *tmp195 *tmp197
   475 jump *label131 equal *tmp198 false
-    * set :u .UNIT_S2
+  476 set :u *tmp148
   477 set .UNIT_S2 .UNIT_P2
   478 set .UNIT_P2 :u
   479 label *label131
 
   491 set .GROUP1 "unit"
   492 set .GROUP2 ""
   493 label *label102
-    * op equal *tmp200 .FOUR_UNITS false
+  494 op equal *tmp200 *tmp139 false
   495 sensor *tmp201 .UNIT_S1 @totalItems
   496 sensor *tmp202 .UNIT_S2 @totalItems
   497 op lessThan *tmp203 *tmp201 *tmp202
   498 op or .SUPPLY_S_FIRST *tmp200 *tmp203
-    * op equal *tmp205 .FOUR_UNITS false
+  499 op equal *tmp205 *tmp139 false
   500 sensor *tmp206 .UNIT_P1 @totalItems
   501 sensor *tmp207 .UNIT_P2 @totalItems
   502 op lessThan *tmp208 *tmp206 *tmp207
-    * op or .SUPPLY_P_FIRST *tmp205 *tmp208
+  503 op or .SUPPLY_P_FIRST *tmp200 *tmp208
   504 op add :unitCheck @time 5000
   505 label *label133
   506 sensor *tmp211 switch1 @enabled
 
   510 print "\n"
   511 print "\n"
   512 print "Unit type: [green]"
-    * print .TYPE
+  513 print *tmp3
   514 print "["
   515 print "]"
   516 print "\n"
   517 set :printDomeStatus.0:item @silicon
   518 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
-    * print :printDomeStatus.0:text
-    * sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
+  519 print "\n[green]Silicon[] status:\n"
+  520 sensor :printDomeStatus.0:level .DOME @silicon
   521 jump *label137 lessThanEq :printDomeStatus.0:level 3
   522 print "  dome:  [green]"
   523 print :printDomeStatus.0:level
 
   537 set :processUnit.0:item @silicon
   538 set :processUnit.0:group .GROUP1
   539 set :processUnit.0:supply .SUPPLY_S_FIRST
-    * set :rebindUnit.4:currentUnit :processUnit.0:unit
-    * jump *label141 equal :rebindUnit.4:currentUnit null
-    * ubind :rebindUnit.4:currentUnit
+  540 set :rebindUnit.4:currentUnit .UNIT_S1
+  541 jump *label141 equal :processUnit.0:unit null
+  542 ubind :processUnit.0:unit
   543 sensor *tmp221 @unit @dead
   544 op strictEqual *tmp222 *tmp221 0
   545 sensor *tmp223 @unit @controller
 
   551 label *label144
   552 label *label141
   553 label *label142
-    * ubind .TYPE
+  554 ubind *tmp3
   555 set :rebindUnit.4:firstUnit @unit
   556 jump *label145 equal :rebindUnit.4:firstUnit null
   557 label *label147
 
   560 jump *label140 always
   561 label *label150
   562 label *label151
-    * ubind .TYPE
+  563 ubind *tmp3
   564 label *label148
   565 op notEqual *tmp233 @unit :rebindUnit.4:firstUnit
   566 sensor *tmp234 :rebindUnit.4:firstUnit @dead
 
   581 op or *tmp240 *tmp238 *tmp239
   582 jump *label152 equal *tmp240 false
   583 sensor *tmp242 @unit @firstItem
-    * jump *label154 notEqual *tmp242 :processUnit.0:item
+  584 jump *label154 notEqual *tmp242 @silicon
   585 set :processUnit.0:state 3
   586 jump *label155 always
   587 label *label154
 
   604 jump *label160 notEqual :processUnit.0:state 2
   605 ucontrol within .CORE_X .CORE_Y 8 *tmp252
   606 jump *label162 equal *tmp252 false
-    * ucontrol itemTake .CORE :processUnit.0:item .UNIT_CAPACITY
+  607 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   608 sensor *tmp254 @unit @totalItems
   609 jump *label164 lessThan *tmp254 .UNIT_CAPACITY
   610 ucontrol approach .DOME_X .DOME_Y 6
 
   630 jump *label166 notEqual :processUnit.0:state 3
   631 ucontrol within .DOME_X .DOME_Y 8 *tmp266
   632 jump *label168 equal *tmp266 false
-    * jump *label170 equal :processUnit.0:supply false
+  633 jump *label170 equal .SUPPLY_S_FIRST false
   634 ucontrol itemDrop .DOME .UNIT_CAPACITY
   635 set :processUnit.0:msg ", supplying\n"
   636 jump *label171 always
 
   661 ucontrol flag :processUnit.0:state
   662 sensor *tmp279 @unit @totalItems
   663 print "  "
-    * print :processUnit.0:group
+  664 print .GROUP1
   665 print ":"
   666 print " ["
-    * print :processUnit.0:color
+  667 print "gold"
   668 print "]"
   669 print *tmp279
   670 print "["
 
   681 label *label175
   682 set *tmp217 @unit
   683 jump *label139 always
-    * set *tmp217 null
   684 label *label139
   685 set .UNIT_S1 *tmp217
-    * jump *label176 equal .FOUR_UNITS false
+  686 jump *label176 equal *tmp139 false
   687 op equal *tmp283 .SUPPLY_S_FIRST false
   688 set :processUnit.1:unit .UNIT_S2
   689 set :processUnit.1:item @silicon
   690 set :processUnit.1:group .GROUP2
   691 set :processUnit.1:supply *tmp283
-    * set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * jump *label180 equal :rebindUnit.5:currentUnit null
-    * ubind :rebindUnit.5:currentUnit
+  692 set :rebindUnit.5:currentUnit .UNIT_S2
+  693 jump *label180 equal :processUnit.1:unit null
+  694 ubind :processUnit.1:unit
   695 sensor *tmp288 @unit @dead
   696 op strictEqual *tmp289 *tmp288 0
   697 sensor *tmp290 @unit @controller
 
   703 label *label183
   704 label *label180
   705 label *label181
-    * ubind .TYPE
+  706 ubind *tmp3
   707 set :rebindUnit.5:firstUnit @unit
   708 jump *label184 equal :rebindUnit.5:firstUnit null
   709 label *label186
 
   712 jump *label179 always
   713 label *label189
   714 label *label190
-    * ubind .TYPE
+  715 ubind *tmp3
   716 label *label187
   717 op notEqual *tmp300 @unit :rebindUnit.5:firstUnit
   718 sensor *tmp301 :rebindUnit.5:firstUnit @dead
 
   733 op or *tmp307 *tmp305 *tmp306
   734 jump *label191 equal *tmp307 false
   735 sensor *tmp309 @unit @firstItem
-    * jump *label193 notEqual *tmp309 :processUnit.1:item
+  736 jump *label193 notEqual *tmp309 @silicon
   737 set :processUnit.1:state 3
   738 jump *label194 always
   739 label *label193
 
   756 jump *label199 notEqual :processUnit.1:state 2
   757 ucontrol within .CORE_X .CORE_Y 8 *tmp319
   758 jump *label201 equal *tmp319 false
-    * ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
+  759 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   760 sensor *tmp321 @unit @totalItems
   761 jump *label203 lessThan *tmp321 .UNIT_CAPACITY
   762 ucontrol approach .DOME_X .DOME_Y 6
 
   782 jump *label205 notEqual :processUnit.1:state 3
   783 ucontrol within .DOME_X .DOME_Y 8 *tmp333
   784 jump *label207 equal *tmp333 false
-    * jump *label209 equal :processUnit.1:supply false
+  785 jump *label209 equal *tmp283 false
   786 ucontrol itemDrop .DOME .UNIT_CAPACITY
   787 set :processUnit.1:msg ", supplying\n"
   788 jump *label210 always
 
   813 ucontrol flag :processUnit.1:state
   814 sensor *tmp346 @unit @totalItems
   815 print "  "
-    * print :processUnit.1:group
+  816 print .GROUP2
   817 print ":"
   818 print " ["
-    * print :processUnit.1:color
+  819 print "gold"
   820 print "]"
   821 print *tmp346
   822 print "["
 
   833 label *label214
   834 set *tmp284 @unit
   835 jump *label178 always
-    * set *tmp284 null
   836 label *label178
   837 set .UNIT_S2 *tmp284
   838 jump *label215 equal .SUPPLY_S_FIRST false
-    * sensor *tmp350 .UNIT_S1 @totalItems
+  839 sensor *tmp350 *tmp217 @totalItems
   840 op greaterThan *tmp349 *tmp350 0
   841 jump *label216 always
   842 label *label215
-    * sensor *tmp352 .UNIT_S2 @totalItems
+  843 sensor *tmp352 *tmp284 @totalItems
   844 op equal *tmp349 *tmp352 0
   845 label *label216
   846 set .SUPPLY_S_FIRST *tmp349
 
   848 label *label177
   849 set :printDomeStatus.1:item @phase-fabric
   850 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
-    * print :printDomeStatus.1:text
-    * sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
+  851 print "\n[green]Phase fabric[] status:\n"
+  852 sensor :printDomeStatus.1:level .DOME @phase-fabric
   853 jump *label218 lessThanEq :printDomeStatus.1:level 3
   854 print "  dome:  [green]"
   855 print :printDomeStatus.1:level
 
   869 set :processUnit.2:item @phase-fabric
   870 set :processUnit.2:group .GROUP1
   871 set :processUnit.2:supply .SUPPLY_P_FIRST
-    * set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * jump *label222 equal :rebindUnit.6:currentUnit null
-    * ubind :rebindUnit.6:currentUnit
+  872 set :rebindUnit.6:currentUnit .UNIT_P1
+  873 jump *label222 equal :processUnit.2:unit null
+  874 ubind :processUnit.2:unit
   875 sensor *tmp362 @unit @dead
   876 op strictEqual *tmp363 *tmp362 0
   877 sensor *tmp364 @unit @controller
 
   883 label *label225
   884 label *label222
   885 label *label223
-    * ubind .TYPE
+  886 ubind *tmp3
   887 set :rebindUnit.6:firstUnit @unit
   888 jump *label226 equal :rebindUnit.6:firstUnit null
   889 label *label228
 
   892 jump *label221 always
   893 label *label231
   894 label *label232
-    * ubind .TYPE
+  895 ubind *tmp3
   896 label *label229
   897 op notEqual *tmp374 @unit :rebindUnit.6:firstUnit
   898 sensor *tmp375 :rebindUnit.6:firstUnit @dead
 
   913 op or *tmp381 *tmp379 *tmp380
   914 jump *label233 equal *tmp381 false
   915 sensor *tmp383 @unit @firstItem
-    * jump *label235 notEqual *tmp383 :processUnit.2:item
+  916 jump *label235 notEqual *tmp383 @phase-fabric
   917 set :processUnit.2:state 3
   918 jump *label236 always
   919 label *label235
 
   936 jump *label241 notEqual :processUnit.2:state 2
   937 ucontrol within .CORE_X .CORE_Y 8 *tmp393
   938 jump *label243 equal *tmp393 false
-    * ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
+  939 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
   940 sensor *tmp395 @unit @totalItems
   941 jump *label245 lessThan *tmp395 .UNIT_CAPACITY
   942 ucontrol approach .DOME_X .DOME_Y 6
 
   962 jump *label247 notEqual :processUnit.2:state 3
   963 ucontrol within .DOME_X .DOME_Y 8 *tmp407
   964 jump *label249 equal *tmp407 false
-    * jump *label251 equal :processUnit.2:supply false
+  965 jump *label251 equal .SUPPLY_P_FIRST false
   966 ucontrol itemDrop .DOME .UNIT_CAPACITY
   967 set :processUnit.2:msg ", supplying\n"
   968 jump *label252 always
 
   993 ucontrol flag :processUnit.2:state
   994 sensor *tmp420 @unit @totalItems
   995 print "  "
-    * print :processUnit.2:group
+  996 print .GROUP1
   997 print ":"
   998 print " ["
-    * print :processUnit.2:color
+  999 print "gold"
  1000 print "]"
  1001 print *tmp420
  1002 print "["
 
  1013 label *label256
  1014 set *tmp358 @unit
  1015 jump *label220 always
-    * set *tmp358 null
  1016 label *label220
  1017 set .UNIT_P1 *tmp358
-    * jump *label257 equal .FOUR_UNITS false
+ 1018 jump *label257 equal *tmp139 false
  1019 op equal *tmp424 .SUPPLY_P_FIRST false
  1020 set :processUnit.3:unit .UNIT_P2
  1021 set :processUnit.3:item @phase-fabric
  1022 set :processUnit.3:group .GROUP2
  1023 set :processUnit.3:supply *tmp424
-    * set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * jump *label261 equal :rebindUnit.7:currentUnit null
-    * ubind :rebindUnit.7:currentUnit
+ 1024 set :rebindUnit.7:currentUnit .UNIT_P2
+ 1025 jump *label261 equal :processUnit.3:unit null
+ 1026 ubind :processUnit.3:unit
  1027 sensor *tmp429 @unit @dead
  1028 op strictEqual *tmp430 *tmp429 0
  1029 sensor *tmp431 @unit @controller
 
  1035 label *label264
  1036 label *label261
  1037 label *label262
-    * ubind .TYPE
+ 1038 ubind *tmp3
  1039 set :rebindUnit.7:firstUnit @unit
  1040 jump *label265 equal :rebindUnit.7:firstUnit null
  1041 label *label267
 
  1044 jump *label260 always
  1045 label *label270
  1046 label *label271
-    * ubind .TYPE
+ 1047 ubind *tmp3
  1048 label *label268
  1049 op notEqual *tmp441 @unit :rebindUnit.7:firstUnit
  1050 sensor *tmp442 :rebindUnit.7:firstUnit @dead
 
  1065 op or *tmp448 *tmp446 *tmp447
  1066 jump *label272 equal *tmp448 false
  1067 sensor *tmp450 @unit @firstItem
-    * jump *label274 notEqual *tmp450 :processUnit.3:item
+ 1068 jump *label274 notEqual *tmp450 @phase-fabric
  1069 set :processUnit.3:state 3
  1070 jump *label275 always
  1071 label *label274
 
  1088 jump *label280 notEqual :processUnit.3:state 2
  1089 ucontrol within .CORE_X .CORE_Y 8 *tmp460
  1090 jump *label282 equal *tmp460 false
-    * ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
+ 1091 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1092 sensor *tmp462 @unit @totalItems
  1093 jump *label284 lessThan *tmp462 .UNIT_CAPACITY
  1094 ucontrol approach .DOME_X .DOME_Y 6
 
  1114 jump *label286 notEqual :processUnit.3:state 3
  1115 ucontrol within .DOME_X .DOME_Y 8 *tmp474
  1116 jump *label288 equal *tmp474 false
-    * jump *label290 equal :processUnit.3:supply false
+ 1117 jump *label290 equal *tmp424 false
  1118 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1119 set :processUnit.3:msg ", supplying\n"
  1120 jump *label291 always
 
  1145 ucontrol flag :processUnit.3:state
  1146 sensor *tmp487 @unit @totalItems
  1147 print "  "
-    * print :processUnit.3:group
+ 1148 print .GROUP2
  1149 print ":"
  1150 print " ["
-    * print :processUnit.3:color
+ 1151 print "gold"
  1152 print "]"
  1153 print *tmp487
  1154 print "["
 
  1165 label *label295
  1166 set *tmp425 @unit
  1167 jump *label259 always
-    * set *tmp425 null
  1168 label *label259
  1169 set .UNIT_P2 *tmp425
  1170 jump *label296 equal .SUPPLY_P_FIRST false
-    * sensor *tmp491 .UNIT_P1 @totalItems
+ 1171 sensor *tmp491 *tmp358 @totalItems
  1172 op greaterThan *tmp490 *tmp491 0
  1173 jump *label297 always
  1174 label *label296
-    * sensor *tmp493 .UNIT_P2 @totalItems
+ 1175 sensor *tmp493 *tmp425 @totalItems
  1176 op equal *tmp490 *tmp493 0
  1177 label *label297
  1178 set .SUPPLY_P_FIRST *tmp490
 
  1186 print " "
  1187 print "ms"
  1188 printflush message1
-    * op notEqual *tmp497 .TYPE UNIT_TYPE
+ 1189 op notEqual *tmp497 *tmp3 UNIT_TYPE
  1190 op greaterThan *tmp498 :unitCheck @time
  1191 op land *tmp499 *tmp497 *tmp498
  1192 jump *label298 equal *tmp499 false
  1193 set :areUnitsAvailable.2:type UNIT_TYPE
  1194 set :areUnitsAvailable.2:output false
  1195 set :areUnitsAvailable.2:needed 0
-    * set :areUnitsAvailable.2:occupied :areUnitsAvailable.2:needed
-    * set :areUnitsAvailable.2:free :areUnitsAvailable.2:occupied
-    * ubind :areUnitsAvailable.2:type
+ 1196 set :areUnitsAvailable.2:occupied 0
+ 1197 set :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1198 ubind UNIT_TYPE
  1199 set :areUnitsAvailable.2:firstUnit @unit
  1200 jump *label301 equal :areUnitsAvailable.2:firstUnit null
  1201 set :needsFourUnits.3:unit @unit
  1202 op sub *tmp506 .DOME_X .CORE_X
  1203 op sub *tmp507 .DOME_Y .CORE_Y
-    * op len *tmp508 *tmp506 *tmp507
-    * op mul *tmp509 2 *tmp508
+ 1204 op len *tmp508 *tmp140 *tmp141
+ 1205 op mul *tmp509 2 *tmp142
  1206 sensor *tmp510 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp509 *tmp510
+ 1207 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1208 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1209 jump *label303 always
-    * set *tmp505 null
  1210 label *label303
  1211 jump *label304 equal *tmp505 false
  1212 set *tmp513 4
 
  1223 op or *tmp518 *tmp515 *tmp517
  1224 jump *label309 equal *tmp518 false
  1225 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label311 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1226 jump *label311 lessThan :areUnitsAvailable.2:free *tmp513
  1227 set *tmp501 true
  1228 jump *label300 always
  1229 label *label311
 
  1232 label *label309
  1233 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1234 label *label310
-    * ubind :areUnitsAvailable.2:type
+ 1235 ubind UNIT_TYPE
  1236 label *label307
  1237 op notEqual *tmp522 @unit :areUnitsAvailable.2:firstUnit
  1238 sensor *tmp523 :areUnitsAvailable.2:firstUnit @dead
 
  1242 label *label308
  1243 label *label301
  1244 label *label302
-    * jump *label313 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+ 1245 jump *label313 equal false false
+ 1246 print UNIT_TYPE
  1247 print ":"
  1248 print " occupied: "
  1249 print :areUnitsAvailable.2:occupied
 
  1260 label *label314
  1261 set *tmp501 false
  1262 jump *label300 always
-    * set *tmp501 null
  1263 label *label300
  1264 jump *label317 equal *tmp501 false
  1265 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-42 instructions):
 
     3 remark "Do not modify anything below this line."
     4 set .DOME_Y null
     5 set .DOME_X null
-    * set .CORE_Y .DOME_Y
-    * set .CORE_X .DOME_X
+    6 set .CORE_Y null
+    7 set .CORE_X null
     8 set .DOME dome1
     9 label *label0
    10 jump *label2 notEqual .DOME null
 
    29 print "\n"
    30 remark "chooseUnitType: "
    31 remark UNIT_TYPE
-    * set :areUnitsAvailable.0:type UNIT_TYPE
-    * set :areUnitsAvailable.0:output true
    32 set :areUnitsAvailable.0:needed 0
    33 set :areUnitsAvailable.0:occupied 0
-    * set :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   34 set :areUnitsAvailable.0:free 0
    35 ubind UNIT_TYPE
    36 set :areUnitsAvailable.0:firstUnit @unit
    37 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    38 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 .DOME_Y .CORE_Y
-    * op sub *tmp10 null .DOME_X
-    * op len *tmp11 *tmp9 *tmp10
+   39 op sub *tmp9 null .DOME_Y
+   40 op sub *tmp10 null null
+   41 op len *tmp11 *tmp9 0
    42 op mul *tmp12 2 *tmp11
    43 sensor *tmp13 :needsFourUnits.0:unit @speed
    44 op div :needsFourUnits.0:travel_time *tmp12 *tmp13
 
   121 jump *label36 equal :chooseUnitType.0:type UNIT_TYPE
   122 remark "chooseUnitType: "
   123 remark :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:type :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:output true
   124 set :areUnitsAvailable.1:needed 0
   125 set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  126 set :areUnitsAvailable.1:free 0
   127 ubind :chooseUnitType.0:type
   128 set :areUnitsAvailable.1:firstUnit @unit
   129 jump *label39 equal :areUnitsAvailable.1:firstUnit null
   130 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 .DOME_Y .CORE_Y
-    * op sub *tmp42 null .DOME_X
-    * op len *tmp43 *tmp41 *tmp42
+  131 op sub *tmp41 null .DOME_Y
+  132 op sub *tmp42 null null
+  133 op len *tmp43 *tmp41 0
   134 op mul *tmp44 2 *tmp43
   135 sensor *tmp45 :needsFourUnits.1:unit @speed
   136 op div :needsFourUnits.1:travel_time *tmp44 *tmp45
 
   208 label *label9
   209 set *tmp3 null
   210 label *label6
-    * set .TYPE *tmp3
   211 print "[gold]Binding units..."
   212 printflush message1
   213 set .UNIT_P2 null
   214 set .UNIT_S2 null
-    * set .UNIT_P1 .UNIT_P2
-    * set .UNIT_S1 .UNIT_S2
+  215 set .UNIT_P1 null
+  216 set .UNIT_S1 null
   217 set :rebindUnits.0:count 0
   218 ubind *tmp3
   219 set :rebindUnits.0:firstUnit @unit
 
   246 label *label62
   247 label *label57
   248 set :acquireUnit.0:currentUnit .UNIT_S1
-    * set :rebindUnit.0:currentUnit .UNIT_S1
-    * jump *label69 equal :acquireUnit.0:currentUnit null
-    * ubind :acquireUnit.0:currentUnit
+  249 jump *label69 equal .UNIT_S1 null
+  250 ubind .UNIT_S1
   251 sensor *tmp83 @unit @dead
   252 op strictEqual *tmp84 *tmp83 0
   253 sensor *tmp85 @unit @controller
 
   286 label *label67
   287 set .UNIT_S1 *tmp79
   288 set :acquireUnit.1:currentUnit .UNIT_P1
-    * set :rebindUnit.1:currentUnit .UNIT_P1
-    * jump *label82 equal :acquireUnit.1:currentUnit null
-    * ubind :acquireUnit.1:currentUnit
+  289 jump *label82 equal .UNIT_P1 null
+  290 ubind .UNIT_P1
   291 sensor *tmp103 @unit @dead
   292 op strictEqual *tmp104 *tmp103 0
   293 sensor *tmp105 @unit @controller
 
   333 jump *label93 equal *tmp123 false
   334 set :u *tmp79
   335 set .UNIT_S1 *tmp99
-    * set .UNIT_P1 :u
+  336 set .UNIT_P1 *tmp79
   337 label *label93
   338 label *label94
   339 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   355 sensor .CORE_Y .CORE @y
   356 sensor .DOME_X .DOME @x
   357 sensor .DOME_Y .DOME @y
-    * set :needsFourUnits.2:unit .UNIT_S1
   358 op sub *tmp140 .DOME_X .CORE_X
   359 op sub *tmp141 .DOME_Y .CORE_Y
   360 op len *tmp142 *tmp140 *tmp141
 
   364 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   365 jump *label100 always
   366 label *label100
-    * set .FOUR_UNITS *tmp139
   367 jump *label101 equal *tmp139 false
   368 set :acquireUnit.2:currentUnit .UNIT_S2
-    * set :rebindUnit.2:currentUnit .UNIT_S2
-    * jump *label105 equal :acquireUnit.2:currentUnit null
-    * ubind :acquireUnit.2:currentUnit
+  369 jump *label105 equal .UNIT_S2 null
+  370 ubind .UNIT_S2
   371 sensor *tmp152 @unit @dead
   372 op strictEqual *tmp153 *tmp152 0
   373 sensor *tmp154 @unit @controller
 
   406 label *label103
   407 set .UNIT_S2 *tmp148
   408 set :acquireUnit.3:currentUnit .UNIT_P2
-    * set :rebindUnit.3:currentUnit .UNIT_P2
-    * jump *label118 equal :acquireUnit.3:currentUnit null
-    * ubind :acquireUnit.3:currentUnit
+  409 jump *label118 equal .UNIT_P2 null
+  410 ubind .UNIT_P2
   411 sensor *tmp172 @unit @dead
   412 op strictEqual *tmp173 *tmp172 0
   413 sensor *tmp174 @unit @controller
 
   464 jump *label131 equal *tmp198 false
   465 set :u *tmp148
   466 set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P2 :u
+  467 set .UNIT_P2 *tmp148
   468 label *label131
   469 label *label132
   470 set .GROUP1 "unit  1"
 
   485 sensor *tmp202 .UNIT_S2 @totalItems
   486 op lessThan *tmp203 *tmp201 *tmp202
   487 op or .SUPPLY_S_FIRST *tmp200 *tmp203
-    * op equal *tmp205 *tmp139 false
   488 sensor *tmp206 .UNIT_P1 @totalItems
   489 sensor *tmp207 .UNIT_P2 @totalItems
   490 op lessThan *tmp208 *tmp206 *tmp207
 
   502 print "["
   503 print "]"
   504 print "\n"
-    * set :printDomeStatus.0:item @silicon
-    * set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   505 print "\n[green]Silicon[] status:\n"
   506 sensor :printDomeStatus.0:level .DOME @silicon
   507 jump *label137 lessThanEq :printDomeStatus.0:level 3
 
   520 label *label138
   521 label *label136
   522 set :processUnit.0:unit .UNIT_S1
-    * set :processUnit.0:item @silicon
-    * set :processUnit.0:group .GROUP1
-    * set :processUnit.0:supply .SUPPLY_S_FIRST
-    * set :rebindUnit.4:currentUnit .UNIT_S1
-    * jump *label141 equal :processUnit.0:unit null
-    * ubind :processUnit.0:unit
+  523 jump *label141 equal .UNIT_S1 null
+  524 ubind .UNIT_S1
   525 sensor *tmp221 @unit @dead
   526 op strictEqual *tmp222 *tmp221 0
   527 sensor *tmp223 @unit @controller
 
   557 set :processUnit.0:msg ""
   558 sensor :processUnit.0:state @unit @flag
   559 set :processUnit.0:distance -1
-    * set :processUnit.0:color "gold"
   560 op lessThan *tmp238 :processUnit.0:state 2
   561 op greaterThan *tmp239 :processUnit.0:state 3
   562 op or *tmp240 *tmp238 *tmp239
 
   667 jump *label176 equal *tmp139 false
   668 op equal *tmp283 .SUPPLY_S_FIRST false
   669 set :processUnit.1:unit .UNIT_S2
-    * set :processUnit.1:item @silicon
-    * set :processUnit.1:group .GROUP2
-    * set :processUnit.1:supply *tmp283
-    * set :rebindUnit.5:currentUnit .UNIT_S2
-    * jump *label180 equal :processUnit.1:unit null
-    * ubind :processUnit.1:unit
+  670 jump *label180 equal .UNIT_S2 null
+  671 ubind .UNIT_S2
   672 sensor *tmp288 @unit @dead
   673 op strictEqual *tmp289 *tmp288 0
   674 sensor *tmp290 @unit @controller
 
   704 set :processUnit.1:msg ""
   705 sensor :processUnit.1:state @unit @flag
   706 set :processUnit.1:distance -1
-    * set :processUnit.1:color "gold"
   707 op lessThan *tmp305 :processUnit.1:state 2
   708 op greaterThan *tmp306 :processUnit.1:state 3
   709 op or *tmp307 *tmp305 *tmp306
 
   822 set .SUPPLY_S_FIRST *tmp349
   823 label *label176
   824 label *label177
-    * set :printDomeStatus.1:item @phase-fabric
-    * set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   825 print "\n[green]Phase fabric[] status:\n"
   826 sensor :printDomeStatus.1:level .DOME @phase-fabric
   827 jump *label218 lessThanEq :printDomeStatus.1:level 3
 
   840 label *label219
   841 label *label217
   842 set :processUnit.2:unit .UNIT_P1
-    * set :processUnit.2:item @phase-fabric
-    * set :processUnit.2:group .GROUP1
-    * set :processUnit.2:supply .SUPPLY_P_FIRST
-    * set :rebindUnit.6:currentUnit .UNIT_P1
-    * jump *label222 equal :processUnit.2:unit null
-    * ubind :processUnit.2:unit
+  843 jump *label222 equal .UNIT_P1 null
+  844 ubind .UNIT_P1
   845 sensor *tmp362 @unit @dead
   846 op strictEqual *tmp363 *tmp362 0
   847 sensor *tmp364 @unit @controller
 
   877 set :processUnit.2:msg ""
   878 sensor :processUnit.2:state @unit @flag
   879 set :processUnit.2:distance -1
-    * set :processUnit.2:color "gold"
   880 op lessThan *tmp379 :processUnit.2:state 2
   881 op greaterThan *tmp380 :processUnit.2:state 3
   882 op or *tmp381 *tmp379 *tmp380
 
   987 jump *label257 equal *tmp139 false
   988 op equal *tmp424 .SUPPLY_P_FIRST false
   989 set :processUnit.3:unit .UNIT_P2
-    * set :processUnit.3:item @phase-fabric
-    * set :processUnit.3:group .GROUP2
-    * set :processUnit.3:supply *tmp424
-    * set :rebindUnit.7:currentUnit .UNIT_P2
-    * jump *label261 equal :processUnit.3:unit null
-    * ubind :processUnit.3:unit
+  990 jump *label261 equal .UNIT_P2 null
+  991 ubind .UNIT_P2
   992 sensor *tmp429 @unit @dead
   993 op strictEqual *tmp430 *tmp429 0
   994 sensor *tmp431 @unit @controller
 
  1024 set :processUnit.3:msg ""
  1025 sensor :processUnit.3:state @unit @flag
  1026 set :processUnit.3:distance -1
-    * set :processUnit.3:color "gold"
  1027 op lessThan *tmp446 :processUnit.3:state 2
  1028 op greaterThan *tmp447 :processUnit.3:state 3
  1029 op or *tmp448 *tmp446 *tmp447
 
  1154 op greaterThan *tmp498 :unitCheck @time
  1155 op land *tmp499 *tmp497 *tmp498
  1156 jump *label298 equal *tmp499 false
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
  1157 set :areUnitsAvailable.2:needed 0
  1158 set :areUnitsAvailable.2:occupied 0
-    * set :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1159 set :areUnitsAvailable.2:free 0
  1160 ubind UNIT_TYPE
  1161 set :areUnitsAvailable.2:firstUnit @unit
  1162 jump *label301 equal :areUnitsAvailable.2:firstUnit null
  1163 set :needsFourUnits.3:unit @unit
-    * op sub *tmp506 .DOME_X .CORE_X
-    * op sub *tmp507 .DOME_Y .CORE_Y
-    * op len *tmp508 *tmp140 *tmp141
-    * op mul *tmp509 2 *tmp142
  1164 sensor *tmp510 :needsFourUnits.3:unit @speed
  1165 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1166 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-15 instructions):
 
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
     4 set .DOME_Y null
-    * set .DOME_X null
-    * set .CORE_Y null
-    * set .CORE_X null
     5 set .DOME dome1
     6 label *label0
     7 jump *label2 notEqual .DOME null
 
    33 set :areUnitsAvailable.0:firstUnit @unit
    34 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    35 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 null .DOME_Y
-    * op sub *tmp10 null null
-    * op len *tmp11 *tmp9 0
-    * op mul *tmp12 2 *tmp11
+   36 op sub *tmp9 null null
+   37 op len *tmp11 0 0
+   38 op mul *tmp12 2 0
    39 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * op div :needsFourUnits.0:travel_time *tmp12 *tmp13
+   40 op div :needsFourUnits.0:travel_time 0 *tmp13
    41 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    42 jump *label13 always
    43 label *label13
 
   124 set :areUnitsAvailable.1:firstUnit @unit
   125 jump *label39 equal :areUnitsAvailable.1:firstUnit null
   126 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 null .DOME_Y
-    * op sub *tmp42 null null
-    * op len *tmp43 *tmp41 0
-    * op mul *tmp44 2 *tmp43
+  127 op sub *tmp41 null null
+  128 op len *tmp43 0 0
+  129 op mul *tmp44 2 0
   130 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp44 *tmp45
+  131 op div :needsFourUnits.1:travel_time 0 *tmp45
   132 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   133 jump *label41 always
   134 label *label41
 
   240 jump *label60 notEqual *tmp78 false
   241 label *label62
   242 label *label57
-    * set :acquireUnit.0:currentUnit .UNIT_S1
   243 jump *label69 equal .UNIT_S1 null
   244 ubind .UNIT_S1
   245 sensor *tmp83 @unit @dead
 
   279 jump *label67 always
   280 label *label67
   281 set .UNIT_S1 *tmp79
-    * set :acquireUnit.1:currentUnit .UNIT_P1
   282 jump *label82 equal .UNIT_P1 null
   283 ubind .UNIT_P1
   284 sensor *tmp103 @unit @dead
 
   324 op equal *tmp122 *tmp121 @silicon
   325 op or *tmp123 *tmp120 *tmp122
   326 jump *label93 equal *tmp123 false
-    * set :u *tmp79
   327 set .UNIT_S1 *tmp99
   328 set .UNIT_P1 *tmp79
   329 label *label93
 
   357 jump *label100 always
   358 label *label100
   359 jump *label101 equal *tmp139 false
-    * set :acquireUnit.2:currentUnit .UNIT_S2
   360 jump *label105 equal .UNIT_S2 null
   361 ubind .UNIT_S2
   362 sensor *tmp152 @unit @dead
 
   396 jump *label103 always
   397 label *label103
   398 set .UNIT_S2 *tmp148
-    * set :acquireUnit.3:currentUnit .UNIT_P2
   399 jump *label118 equal .UNIT_P2 null
   400 ubind .UNIT_P2
   401 sensor *tmp172 @unit @dead
 
   452 op equal *tmp197 *tmp196 @silicon
   453 op or *tmp198 *tmp195 *tmp197
   454 jump *label131 equal *tmp198 false
-    * set :u *tmp148
   455 set .UNIT_S2 .UNIT_P2
   456 set .UNIT_P2 *tmp148
   457 label *label131
 
   508 print "\n"
   509 label *label138
   510 label *label136
-    * set :processUnit.0:unit .UNIT_S1
   511 jump *label141 equal .UNIT_S1 null
   512 ubind .UNIT_S1
   513 sensor *tmp221 @unit @dead
 
   654 set .UNIT_S1 *tmp217
   655 jump *label176 equal *tmp139 false
   656 op equal *tmp283 .SUPPLY_S_FIRST false
-    * set :processUnit.1:unit .UNIT_S2
   657 jump *label180 equal .UNIT_S2 null
   658 ubind .UNIT_S2
   659 sensor *tmp288 @unit @dead
 
   826 print "\n"
   827 label *label219
   828 label *label217
-    * set :processUnit.2:unit .UNIT_P1
   829 jump *label222 equal .UNIT_P1 null
   830 ubind .UNIT_P1
   831 sensor *tmp362 @unit @dead
 
   972 set .UNIT_P1 *tmp358
   973 jump *label257 equal *tmp139 false
   974 op equal *tmp424 .SUPPLY_P_FIRST false
-    * set :processUnit.3:unit .UNIT_P2
   975 jump *label261 equal .UNIT_P2 null
   976 ubind .UNIT_P2
   977 sensor *tmp429 @unit @dead

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-7 instructions):
 
     1 remark "If no units of this type exist, we'll try using other types."
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
-    * set .DOME_Y null
     4 set .DOME dome1
     5 label *label0
     6 jump *label2 notEqual .DOME null
 
    32 set :areUnitsAvailable.0:firstUnit @unit
    33 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    34 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 null null
-    * op len *tmp11 0 0
-    * op mul *tmp12 2 0
    35 sensor *tmp13 :needsFourUnits.0:unit @speed
    36 op div :needsFourUnits.0:travel_time 0 *tmp13
    37 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
 
   120 set :areUnitsAvailable.1:firstUnit @unit
   121 jump *label39 equal :areUnitsAvailable.1:firstUnit null
   122 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 null null
-    * op len *tmp43 0 0
-    * op mul *tmp44 2 0
   123 sensor *tmp45 :needsFourUnits.1:unit @speed
   124 op div :needsFourUnits.1:travel_time 0 *tmp45
   125 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     4 set .DOME dome1
     5 label *label0
     6 jump *label2 notEqual .DOME null
+    7 label *label319
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label1
-    * jump *label0 always
+   12 jump *label319 equal .DOME null
    13 label *label2
    14 label *label3
    15 sensor *tmp1 switch1 @enabled

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    32 ubind UNIT_TYPE
    33 set :areUnitsAvailable.0:firstUnit @unit
    34 jump *label11 equal :areUnitsAvailable.0:firstUnit null
+   35 set *tmp16 2
    36 set :needsFourUnits.0:unit @unit
    37 sensor *tmp13 :needsFourUnits.0:unit @speed
    38 op div :needsFourUnits.0:travel_time 0 *tmp13
    39 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    40 jump *label13 always
    41 label *label13
-    * jump *label14 equal *tmp8 false
+   42 jump *label15 equal *tmp8 false
    43 set *tmp16 4
    44 jump *label15 always
-    * label *label14
-    * set *tmp16 2
    45 label *label15
    46 set :areUnitsAvailable.0:needed *tmp16
    47 label *label16
 
   119 ubind :chooseUnitType.0:type
   120 set :areUnitsAvailable.1:firstUnit @unit
   121 jump *label39 equal :areUnitsAvailable.1:firstUnit null
+  122 set *tmp48 2
   123 set :needsFourUnits.1:unit @unit
   124 sensor *tmp45 :needsFourUnits.1:unit @speed
   125 op div :needsFourUnits.1:travel_time 0 *tmp45
   126 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   127 jump *label41 always
   128 label *label41
-    * jump *label42 equal *tmp40 false
+  129 jump *label43 equal *tmp40 false
   130 set *tmp48 4
   131 jump *label43 always
-    * label *label42
-    * set *tmp48 2
   132 label *label43
   133 set :areUnitsAvailable.1:needed *tmp48
   134 label *label44
 
   792 set .UNIT_S2 *tmp284
   793 jump *label215 equal .SUPPLY_S_FIRST false
   794 sensor *tmp350 *tmp217 @totalItems
-    * op greaterThan *tmp349 *tmp350 0
+  795 op greaterThan .SUPPLY_S_FIRST *tmp350 0
   796 jump *label216 always
   797 label *label215
   798 sensor *tmp352 *tmp284 @totalItems
-    * op equal *tmp349 *tmp352 0
+  799 op equal .SUPPLY_S_FIRST *tmp352 0
   800 label *label216
-    * set .SUPPLY_S_FIRST *tmp349
   801 label *label176
   802 label *label177
   803 print "\n[green]Phase fabric[] status:\n"
 
  1109 set .UNIT_P2 *tmp425
  1110 jump *label296 equal .SUPPLY_P_FIRST false
  1111 sensor *tmp491 *tmp358 @totalItems
-    * op greaterThan *tmp490 *tmp491 0
+ 1112 op greaterThan .SUPPLY_P_FIRST *tmp491 0
  1113 jump *label297 always
  1114 label *label296
  1115 sensor *tmp493 *tmp425 @totalItems
-    * op equal *tmp490 *tmp493 0
+ 1116 op equal .SUPPLY_P_FIRST *tmp493 0
  1117 label *label297
-    * set .SUPPLY_P_FIRST *tmp490
  1118 label *label257
  1119 label *label258
  1120 op sub *tmp495 @time :start
 
  1135 ubind UNIT_TYPE
  1136 set :areUnitsAvailable.2:firstUnit @unit
  1137 jump *label301 equal :areUnitsAvailable.2:firstUnit null
+ 1138 set *tmp513 2
  1139 set :needsFourUnits.3:unit @unit
  1140 sensor *tmp510 :needsFourUnits.3:unit @speed
  1141 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1142 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1143 jump *label303 always
  1144 label *label303
-    * jump *label304 equal *tmp505 false
+ 1145 jump *label305 equal *tmp505 false
  1146 set *tmp513 4
  1147 jump *label305 always
-    * label *label304
-    * set *tmp513 2
  1148 label *label305
  1149 set :areUnitsAvailable.2:needed *tmp513
  1150 label *label306

Modifications by Replicate loop condition at line 44:1 (+1 instructions):
 
    14 label *label3
    15 sensor *tmp1 switch1 @enabled
    16 jump *label5 notEqual *tmp1 false
+   17 label *label320
    18 print "[coral]Activate switch to begin supplying overdrive dome..."
    19 print "\n"
    20 printflush message1
    21 label *label4
-    * jump *label3 always
+   22 sensor *tmp1 switch1 @enabled
+   23 jump *label320 equal *tmp1 false
    24 label *label5
    25 label *label7
    26 printflush null

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 remark "Do not modify anything below this line."
     4 set .DOME dome1
     5 label *label0
-    * jump *label2 notEqual .DOME null
+    6 jump *label2 notEqual dome1 null
     7 label *label319
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label1
-    * jump *label319 equal .DOME null
+   12 jump *label319 equal dome1 null
    13 label *label2
    14 label *label3
    15 sensor *tmp1 switch1 @enabled

Modifications by Replicate loop condition at line 127:1 (+1 instructions):
 
   476 label *label133
   477 sensor *tmp211 switch1 @enabled
   478 jump *label135 equal *tmp211 false
+  479 label *label321
   480 set :start @time
   481 print " === [gold]Supplying Overdrive Dome[] === "
   482 print "\n"
 
  1204 label *label298
  1205 label *label299
  1206 label *label134
-    * jump *label133 always
+ 1207 sensor *tmp211 switch1 @enabled
+ 1208 jump *label321 notEqual *tmp211 false
  1209 label *label135
  1210 end

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    73 label *label18
    74 label *label11
    75 label *label12
-    * jump *label23 equal true false
    76 print UNIT_TYPE
    77 print ":"
    78 print " occupied: "
 
   159 label *label46
   160 label *label39
   161 label *label40
-    * jump *label51 equal true false
   162 print :chooseUnitType.0:type
   163 print ":"
   164 print " occupied: "
 
  1175 label *label308
  1176 label *label301
  1177 label *label302
-    * jump *label313 equal false false
+ 1178 jump *label313 always
  1179 print UNIT_TYPE
  1180 print ":"
  1181 print " occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-18 instructions):
 
    39 sensor *tmp13 :needsFourUnits.0:unit @speed
    40 op div :needsFourUnits.0:travel_time 0 *tmp13
    41 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
-    * jump *label13 always
    42 label *label13
    43 jump *label15 equal *tmp8 false
    44 set *tmp16 4
-    * jump *label15 always
    45 label *label15
    46 set :areUnitsAvailable.0:needed *tmp16
    47 label *label16
 
    87 label *label23
    88 label *label24
    89 set *tmp4 false
-    * jump *label10 always
    90 label *label10
    91 jump *label27 equal *tmp4 false
    92 set *tmp3 UNIT_TYPE
 
   122 sensor *tmp45 :needsFourUnits.1:unit @speed
   123 op div :needsFourUnits.1:travel_time 0 *tmp45
   124 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
-    * jump *label41 always
   125 label *label41
   126 jump *label43 equal *tmp40 false
   127 set *tmp48 4
-    * jump *label43 always
   128 label *label43
   129 set :areUnitsAvailable.1:needed *tmp48
   130 label *label44
 
   170 label *label51
   171 label *label52
   172 set *tmp36 false
-    * jump *label38 always
   173 label *label38
   174 jump *label55 equal *tmp36 false
   175 printflush null
 
   262 label *label68
   263 ucontrol flag 1
   264 set *tmp79 @unit
-    * jump *label67 always
   265 label *label67
   266 set .UNIT_S1 *tmp79
   267 jump *label82 equal .UNIT_P1 null
 
   300 label *label81
   301 ucontrol flag 1
   302 set *tmp99 @unit
-    * jump *label80 always
   303 label *label80
   304 set .UNIT_P1 *tmp99
   305 sensor *tmp119 *tmp79 @firstItem
 
   338 sensor *tmp144 .UNIT_S1 @speed
   339 op div :needsFourUnits.2:travel_time *tmp143 .SPEED
   340 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
-    * jump *label100 always
   341 label *label100
   342 jump *label101 equal *tmp139 false
   343 jump *label105 equal .UNIT_S2 null
 
   376 label *label104
   377 ucontrol flag 1
   378 set *tmp148 @unit
-    * jump *label103 always
   379 label *label103
   380 set .UNIT_S2 *tmp148
   381 jump *label118 equal .UNIT_P2 null
 
   414 label *label117
   415 ucontrol flag 1
   416 set *tmp168 @unit
-    * jump *label116 always
   417 label *label116
   418 set .UNIT_P2 *tmp168
   419 sensor *tmp188 .UNIT_S1 @firstItem
 
   631 print :processUnit.0:msg
   632 label *label175
   633 set *tmp217 @unit
-    * jump *label139 always
   634 label *label139
   635 set .UNIT_S1 *tmp217
   636 jump *label176 equal *tmp139 false
 
   776 print :processUnit.1:msg
   777 label *label214
   778 set *tmp284 @unit
-    * jump *label178 always
   779 label *label178
   780 set .UNIT_S2 *tmp284
   781 jump *label215 equal .SUPPLY_S_FIRST false
 
   946 print :processUnit.2:msg
   947 label *label256
   948 set *tmp358 @unit
-    * jump *label220 always
   949 label *label220
   950 set .UNIT_P1 *tmp358
   951 jump *label257 equal *tmp139 false
 
  1091 print :processUnit.3:msg
  1092 label *label295
  1093 set *tmp425 @unit
-    * jump *label259 always
  1094 label *label259
  1095 set .UNIT_P2 *tmp425
  1096 jump *label296 equal .SUPPLY_P_FIRST false
 
  1126 sensor *tmp510 :needsFourUnits.3:unit @speed
  1127 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1128 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
-    * jump *label303 always
  1129 label *label303
  1130 jump *label305 equal *tmp505 false
  1131 set *tmp513 4
-    * jump *label305 always
  1132 label *label305
  1133 set :areUnitsAvailable.2:needed *tmp513
  1134 label *label306
 
  1175 label *label313
  1176 label *label314
  1177 set *tmp501 false
-    * jump *label300 always
  1178 label *label300
  1179 jump *label317 equal *tmp501 false
  1180 end

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    37 set *tmp16 2
    38 set :needsFourUnits.0:unit @unit
    39 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * op div :needsFourUnits.0:travel_time 0 *tmp13
+   40 set :needsFourUnits.0:travel_time 0
    41 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    42 label *label13
    43 jump *label15 equal *tmp8 false
 
   120 set *tmp48 2
   121 set :needsFourUnits.1:unit @unit
   122 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time 0 *tmp45
+  123 set :needsFourUnits.1:travel_time 0
   124 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   125 label *label41
   126 jump *label43 equal *tmp40 false

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   422 op notEqual *tmp191 *tmp190 @phase-fabric
   423 op land *tmp192 *tmp189 *tmp191
   424 jump *label129 equal *tmp192 false
-    * set :u .UNIT_S1
+  425 set .UNIT_P2 .UNIT_S1
   426 set .UNIT_S1 *tmp168
-    * set .UNIT_P2 :u
   427 label *label129
   428 label *label130
   429 sensor *tmp194 *tmp148 @firstItem

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-2 instructions):
 
    38 set :needsFourUnits.0:unit @unit
    39 sensor *tmp13 :needsFourUnits.0:unit @speed
    40 set :needsFourUnits.0:travel_time 0
-    * op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
+   41 op greaterThanEq *tmp8 0 47
    42 label *label13
-    * jump *label15 equal *tmp8 false
+   43 jump *label15 equal false false
    44 set *tmp16 4
    45 label *label15
-    * set :areUnitsAvailable.0:needed *tmp16
+   46 set :areUnitsAvailable.0:needed 2
    47 label *label16
    48 sensor *tmp17 @unit @controlled
    49 op equal *tmp18 *tmp17 0
 
    52 op or *tmp21 *tmp18 *tmp20
    53 jump *label19 equal *tmp21 false
    54 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label21 lessThan :areUnitsAvailable.0:free *tmp16
+   55 jump *label21 lessThan :areUnitsAvailable.0:free 2
    56 set *tmp4 true
    57 jump *label10 always
    58 label *label21
 
   121 set :needsFourUnits.1:unit @unit
   122 sensor *tmp45 :needsFourUnits.1:unit @speed
   123 set :needsFourUnits.1:travel_time 0
-    * op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
+  124 op greaterThanEq *tmp40 0 47
   125 label *label41
-    * jump *label43 equal *tmp40 false
+  126 jump *label43 equal false false
   127 set *tmp48 4
   128 label *label43
-    * set :areUnitsAvailable.1:needed *tmp48
+  129 set :areUnitsAvailable.1:needed 2
   130 label *label44
   131 sensor *tmp49 @unit @controlled
   132 op equal *tmp50 *tmp49 0
 
   135 op or *tmp53 *tmp50 *tmp52
   136 jump *label47 equal *tmp53 false
   137 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label49 lessThan :areUnitsAvailable.1:free *tmp48
+  138 jump *label49 lessThan :areUnitsAvailable.1:free 2
   139 set *tmp36 true
   140 jump *label38 always
   141 label *label49
 
  1114 op greaterThan *tmp498 :unitCheck @time
  1115 op land *tmp499 *tmp497 *tmp498
  1116 jump *label298 equal *tmp499 false
-    * set :areUnitsAvailable.2:needed 0
  1117 set :areUnitsAvailable.2:occupied 0
  1118 set :areUnitsAvailable.2:free 0
  1119 ubind UNIT_TYPE
 
  1128 jump *label305 equal *tmp505 false
  1129 set *tmp513 4
  1130 label *label305
-    * set :areUnitsAvailable.2:needed *tmp513
  1131 label *label306
  1132 sensor *tmp514 @unit @controlled
  1133 op equal *tmp515 *tmp514 0

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-8 instructions):
 
    34 ubind UNIT_TYPE
    35 set :areUnitsAvailable.0:firstUnit @unit
    36 jump *label11 equal :areUnitsAvailable.0:firstUnit null
-    * set *tmp16 2
    37 set :needsFourUnits.0:unit @unit
    38 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * set :needsFourUnits.0:travel_time 0
-    * op greaterThanEq *tmp8 0 47
    39 label *label13
    40 jump *label15 equal false false
-    * set *tmp16 4
    41 label *label15
    42 set :areUnitsAvailable.0:needed 2
    43 label *label16
 
   113 ubind :chooseUnitType.0:type
   114 set :areUnitsAvailable.1:firstUnit @unit
   115 jump *label39 equal :areUnitsAvailable.1:firstUnit null
-    * set *tmp48 2
   116 set :needsFourUnits.1:unit @unit
   117 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * set :needsFourUnits.1:travel_time 0
-    * op greaterThanEq *tmp40 0 47
   118 label *label41
   119 jump *label43 equal false false
-    * set *tmp48 4
   120 label *label43
   121 set :areUnitsAvailable.1:needed 2
   122 label *label44

Modifications by Unroll iteration loop at line 177:9 (+139 instructions):
 
    89 jump *label6 always
    90 label *label27
    91 label *label28
-    * set :chooseUnitType.0:type @flare
-    * setaddr *tmp33 *label32
-    * jump *label29 always
-    * multilabel *label32
-    * set :chooseUnitType.0:type @poly
-    * setaddr *tmp33 *label33
-    * jump *label29 always
-    * multilabel *label33
-    * set :chooseUnitType.0:type @mega
-    * setaddr *tmp33 *label34
-    * jump *label29 always
-    * multilabel *label34
-    * set :chooseUnitType.0:type @mono
-    * setaddr *tmp33 *label35
-    * label *label29
-    * jump *label36 equal :chooseUnitType.0:type UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:needed 0
-    * set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label39 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
-    * label *label41
-    * jump *label43 equal false false
-    * label *label43
-    * set :areUnitsAvailable.1:needed 2
-    * label *label44
-    * sensor *tmp49 @unit @controlled
-    * op equal *tmp50 *tmp49 0
-    * sensor *tmp51 @unit @controller
-    * op equal *tmp52 *tmp51 @this
-    * op or *tmp53 *tmp50 *tmp52
-    * jump *label47 equal *tmp53 false
-    * op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label49 lessThan :areUnitsAvailable.1:free 2
-    * set *tmp36 true
-    * jump *label38 always
-    * label *label49
-    * label *label50
-    * jump *label48 always
-    * label *label47
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label48
-    * ubind :chooseUnitType.0:type
-    * label *label45
-    * op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp59 *tmp58 0
-    * op land *tmp60 *tmp57 *tmp59
-    * jump *label44 notEqual *tmp60 false
-    * label *label46
-    * label *label39
-    * label *label40
-    * print :chooseUnitType.0:type
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.1:free
-    * jump *label53 lessThanEq :areUnitsAvailable.1:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.1:needed
-    * label *label53
-    * label *label54
-    * print "\n"
-    * label *label51
-    * label *label52
-    * set *tmp36 false
-    * label *label38
-    * jump *label55 equal *tmp36 false
-    * printflush null
-    * set *tmp3 :chooseUnitType.0:type
-    * jump *label6 always
-    * label *label55
-    * label *label56
-    * label *label36
-    * label *label37
-    * label *label30
-    * multijump *tmp33 0 0
-    * multilabel *label35
-    * label *label31
+   92 set :chooseUnitType.0:type @flare
+   93 label *label322
+   94 jump *label341 equal :chooseUnitType.0:type UNIT_TYPE
+   95 remark "chooseUnitType: "
+   96 remark :chooseUnitType.0:type
+   97 set :areUnitsAvailable.1:needed 0
+   98 set :areUnitsAvailable.1:occupied 0
+   99 set :areUnitsAvailable.1:free 0
+  100 ubind :chooseUnitType.0:type
+  101 set :areUnitsAvailable.1:firstUnit @unit
+  102 jump *label332 equal :areUnitsAvailable.1:firstUnit null
+  103 set :needsFourUnits.1:unit @unit
+  104 sensor *tmp45 :needsFourUnits.1:unit @speed
+  105 label *label323
+  106 jump *label324 equal false false
+  107 label *label324
+  108 set :areUnitsAvailable.1:needed 2
+  109 label *label325
+  110 sensor *tmp49 @unit @controlled
+  111 op equal *tmp50 *tmp49 0
+  112 sensor *tmp51 @unit @controller
+  113 op equal *tmp52 *tmp51 @this
+  114 op or *tmp53 *tmp50 *tmp52
+  115 jump *label328 equal *tmp53 false
+  116 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  117 jump *label326 lessThan :areUnitsAvailable.1:free 2
+  118 set *tmp36 true
+  119 jump *label338 always
+  120 label *label326
+  121 label *label327
+  122 jump *label329 always
+  123 label *label328
+  124 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  125 label *label329
+  126 ubind :chooseUnitType.0:type
+  127 label *label330
+  128 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  129 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  130 op equal *tmp59 *tmp58 0
+  131 op land *tmp60 *tmp57 *tmp59
+  132 jump *label325 notEqual *tmp60 false
+  133 label *label331
+  134 label *label332
+  135 label *label333
+  136 print :chooseUnitType.0:type
+  137 print ":"
+  138 print " occupied: "
+  139 print :areUnitsAvailable.1:occupied
+  140 print ","
+  141 print " free: "
+  142 print :areUnitsAvailable.1:free
+  143 jump *label334 lessThanEq :areUnitsAvailable.1:needed 0
+  144 print ", needed: "
+  145 print :areUnitsAvailable.1:needed
+  146 label *label334
+  147 label *label335
+  148 print "\n"
+  149 label *label336
+  150 label *label337
+  151 set *tmp36 false
+  152 label *label338
+  153 jump *label339 equal *tmp36 false
+  154 printflush null
+  155 set *tmp3 :chooseUnitType.0:type
+  156 jump *label6 always
+  157 label *label339
+  158 label *label340
+  159 label *label341
+  160 label *label342
+  161 label *label343
+  162 set :chooseUnitType.0:type @poly
+  163 label *label346
+  164 jump *label365 equal :chooseUnitType.0:type UNIT_TYPE
+  165 remark "chooseUnitType: "
+  166 remark :chooseUnitType.0:type
+  167 set :areUnitsAvailable.1:needed 0
+  168 set :areUnitsAvailable.1:occupied 0
+  169 set :areUnitsAvailable.1:free 0
+  170 ubind :chooseUnitType.0:type
+  171 set :areUnitsAvailable.1:firstUnit @unit
+  172 jump *label356 equal :areUnitsAvailable.1:firstUnit null
+  173 set :needsFourUnits.1:unit @unit
+  174 sensor *tmp45 :needsFourUnits.1:unit @speed
+  175 label *label347
+  176 jump *label348 equal false false
+  177 label *label348
+  178 set :areUnitsAvailable.1:needed 2
+  179 label *label349
+  180 sensor *tmp49 @unit @controlled
+  181 op equal *tmp50 *tmp49 0
+  182 sensor *tmp51 @unit @controller
+  183 op equal *tmp52 *tmp51 @this
+  184 op or *tmp53 *tmp50 *tmp52
+  185 jump *label352 equal *tmp53 false
+  186 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  187 jump *label350 lessThan :areUnitsAvailable.1:free 2
+  188 set *tmp36 true
+  189 jump *label362 always
+  190 label *label350
+  191 label *label351
+  192 jump *label353 always
+  193 label *label352
+  194 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  195 label *label353
+  196 ubind :chooseUnitType.0:type
+  197 label *label354
+  198 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  199 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  200 op equal *tmp59 *tmp58 0
+  201 op land *tmp60 *tmp57 *tmp59
+  202 jump *label349 notEqual *tmp60 false
+  203 label *label355
+  204 label *label356
+  205 label *label357
+  206 print :chooseUnitType.0:type
+  207 print ":"
+  208 print " occupied: "
+  209 print :areUnitsAvailable.1:occupied
+  210 print ","
+  211 print " free: "
+  212 print :areUnitsAvailable.1:free
+  213 jump *label358 lessThanEq :areUnitsAvailable.1:needed 0
+  214 print ", needed: "
+  215 print :areUnitsAvailable.1:needed
+  216 label *label358
+  217 label *label359
+  218 print "\n"
+  219 label *label360
+  220 label *label361
+  221 set *tmp36 false
+  222 label *label362
+  223 jump *label363 equal *tmp36 false
+  224 printflush null
+  225 set *tmp3 :chooseUnitType.0:type
+  226 jump *label6 always
+  227 label *label363
+  228 label *label364
+  229 label *label365
+  230 label *label366
+  231 label *label367
+  232 set :chooseUnitType.0:type @mega
+  233 label *label370
+  234 jump *label389 equal :chooseUnitType.0:type UNIT_TYPE
+  235 remark "chooseUnitType: "
+  236 remark :chooseUnitType.0:type
+  237 set :areUnitsAvailable.1:needed 0
+  238 set :areUnitsAvailable.1:occupied 0
+  239 set :areUnitsAvailable.1:free 0
+  240 ubind :chooseUnitType.0:type
+  241 set :areUnitsAvailable.1:firstUnit @unit
+  242 jump *label380 equal :areUnitsAvailable.1:firstUnit null
+  243 set :needsFourUnits.1:unit @unit
+  244 sensor *tmp45 :needsFourUnits.1:unit @speed
+  245 label *label371
+  246 jump *label372 equal false false
+  247 label *label372
+  248 set :areUnitsAvailable.1:needed 2
+  249 label *label373
+  250 sensor *tmp49 @unit @controlled
+  251 op equal *tmp50 *tmp49 0
+  252 sensor *tmp51 @unit @controller
+  253 op equal *tmp52 *tmp51 @this
+  254 op or *tmp53 *tmp50 *tmp52
+  255 jump *label376 equal *tmp53 false
+  256 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  257 jump *label374 lessThan :areUnitsAvailable.1:free 2
+  258 set *tmp36 true
+  259 jump *label386 always
+  260 label *label374
+  261 label *label375
+  262 jump *label377 always
+  263 label *label376
+  264 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  265 label *label377
+  266 ubind :chooseUnitType.0:type
+  267 label *label378
+  268 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  269 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  270 op equal *tmp59 *tmp58 0
+  271 op land *tmp60 *tmp57 *tmp59
+  272 jump *label373 notEqual *tmp60 false
+  273 label *label379
+  274 label *label380
+  275 label *label381
+  276 print :chooseUnitType.0:type
+  277 print ":"
+  278 print " occupied: "
+  279 print :areUnitsAvailable.1:occupied
+  280 print ","
+  281 print " free: "
+  282 print :areUnitsAvailable.1:free
+  283 jump *label382 lessThanEq :areUnitsAvailable.1:needed 0
+  284 print ", needed: "
+  285 print :areUnitsAvailable.1:needed
+  286 label *label382
+  287 label *label383
+  288 print "\n"
+  289 label *label384
+  290 label *label385
+  291 set *tmp36 false
+  292 label *label386
+  293 jump *label387 equal *tmp36 false
+  294 printflush null
+  295 set *tmp3 :chooseUnitType.0:type
+  296 jump *label6 always
+  297 label *label387
+  298 label *label388
+  299 label *label389
+  300 label *label390
+  301 label *label391
+  302 set :chooseUnitType.0:type @mono
+  303 label *label394
+  304 jump *label413 equal :chooseUnitType.0:type UNIT_TYPE
+  305 remark "chooseUnitType: "
+  306 remark :chooseUnitType.0:type
+  307 set :areUnitsAvailable.1:needed 0
+  308 set :areUnitsAvailable.1:occupied 0
+  309 set :areUnitsAvailable.1:free 0
+  310 ubind :chooseUnitType.0:type
+  311 set :areUnitsAvailable.1:firstUnit @unit
+  312 jump *label404 equal :areUnitsAvailable.1:firstUnit null
+  313 set :needsFourUnits.1:unit @unit
+  314 sensor *tmp45 :needsFourUnits.1:unit @speed
+  315 label *label395
+  316 jump *label396 equal false false
+  317 label *label396
+  318 set :areUnitsAvailable.1:needed 2
+  319 label *label397
+  320 sensor *tmp49 @unit @controlled
+  321 op equal *tmp50 *tmp49 0
+  322 sensor *tmp51 @unit @controller
+  323 op equal *tmp52 *tmp51 @this
+  324 op or *tmp53 *tmp50 *tmp52
+  325 jump *label400 equal *tmp53 false
+  326 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  327 jump *label398 lessThan :areUnitsAvailable.1:free 2
+  328 set *tmp36 true
+  329 jump *label410 always
+  330 label *label398
+  331 label *label399
+  332 jump *label401 always
+  333 label *label400
+  334 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  335 label *label401
+  336 ubind :chooseUnitType.0:type
+  337 label *label402
+  338 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  339 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  340 op equal *tmp59 *tmp58 0
+  341 op land *tmp60 *tmp57 *tmp59
+  342 jump *label397 notEqual *tmp60 false
+  343 label *label403
+  344 label *label404
+  345 label *label405
+  346 print :chooseUnitType.0:type
+  347 print ":"
+  348 print " occupied: "
+  349 print :areUnitsAvailable.1:occupied
+  350 print ","
+  351 print " free: "
+  352 print :areUnitsAvailable.1:free
+  353 jump *label406 lessThanEq :areUnitsAvailable.1:needed 0
+  354 print ", needed: "
+  355 print :areUnitsAvailable.1:needed
+  356 label *label406
+  357 label *label407
+  358 print "\n"
+  359 label *label408
+  360 label *label409
+  361 set *tmp36 false
+  362 label *label410
+  363 jump *label411 equal *tmp36 false
+  364 printflush null
+  365 set *tmp3 :chooseUnitType.0:type
+  366 jump *label6 always
+  367 label *label411
+  368 label *label412
+  369 label *label413
+  370 label *label414
+  371 label *label415
+  372 label *label31
   373 printflush message1
   374 label *label8
   375 jump *label7 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    91 label *label28
    92 set :chooseUnitType.0:type @flare
    93 label *label322
-    * jump *label341 equal :chooseUnitType.0:type UNIT_TYPE
+   94 jump *label341 equal @flare UNIT_TYPE
    95 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+   96 remark @flare
    97 set :areUnitsAvailable.1:needed 0
    98 set :areUnitsAvailable.1:occupied 0
    99 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  100 ubind @flare
   101 set :areUnitsAvailable.1:firstUnit @unit
   102 jump *label332 equal :areUnitsAvailable.1:firstUnit null
   103 set :needsFourUnits.1:unit @unit
 
   123 label *label328
   124 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   125 label *label329
-    * ubind :chooseUnitType.0:type
+  126 ubind @flare
   127 label *label330
   128 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   129 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   133 label *label331
   134 label *label332
   135 label *label333
-    * print :chooseUnitType.0:type
+  136 print @flare
   137 print ":"
   138 print " occupied: "
   139 print :areUnitsAvailable.1:occupied
 
   152 label *label338
   153 jump *label339 equal *tmp36 false
   154 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  155 set *tmp3 @flare
   156 jump *label6 always
   157 label *label339
   158 label *label340
 
   161 label *label343
   162 set :chooseUnitType.0:type @poly
   163 label *label346
-    * jump *label365 equal :chooseUnitType.0:type UNIT_TYPE
+  164 jump *label365 equal @poly UNIT_TYPE
   165 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+  166 remark @poly
   167 set :areUnitsAvailable.1:needed 0
   168 set :areUnitsAvailable.1:occupied 0
   169 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  170 ubind @poly
   171 set :areUnitsAvailable.1:firstUnit @unit
   172 jump *label356 equal :areUnitsAvailable.1:firstUnit null
   173 set :needsFourUnits.1:unit @unit
 
   193 label *label352
   194 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   195 label *label353
-    * ubind :chooseUnitType.0:type
+  196 ubind @poly
   197 label *label354
   198 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   199 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   203 label *label355
   204 label *label356
   205 label *label357
-    * print :chooseUnitType.0:type
+  206 print @poly
   207 print ":"
   208 print " occupied: "
   209 print :areUnitsAvailable.1:occupied
 
   222 label *label362
   223 jump *label363 equal *tmp36 false
   224 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  225 set *tmp3 @poly
   226 jump *label6 always
   227 label *label363
   228 label *label364
 
   231 label *label367
   232 set :chooseUnitType.0:type @mega
   233 label *label370
-    * jump *label389 equal :chooseUnitType.0:type UNIT_TYPE
+  234 jump *label389 equal @mega UNIT_TYPE
   235 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+  236 remark @mega
   237 set :areUnitsAvailable.1:needed 0
   238 set :areUnitsAvailable.1:occupied 0
   239 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  240 ubind @mega
   241 set :areUnitsAvailable.1:firstUnit @unit
   242 jump *label380 equal :areUnitsAvailable.1:firstUnit null
   243 set :needsFourUnits.1:unit @unit
 
   263 label *label376
   264 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   265 label *label377
-    * ubind :chooseUnitType.0:type
+  266 ubind @mega
   267 label *label378
   268 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   269 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   273 label *label379
   274 label *label380
   275 label *label381
-    * print :chooseUnitType.0:type
+  276 print @mega
   277 print ":"
   278 print " occupied: "
   279 print :areUnitsAvailable.1:occupied
 
   292 label *label386
   293 jump *label387 equal *tmp36 false
   294 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  295 set *tmp3 @mega
   296 jump *label6 always
   297 label *label387
   298 label *label388
 
   301 label *label391
   302 set :chooseUnitType.0:type @mono
   303 label *label394
-    * jump *label413 equal :chooseUnitType.0:type UNIT_TYPE
+  304 jump *label413 equal @mono UNIT_TYPE
   305 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+  306 remark @mono
   307 set :areUnitsAvailable.1:needed 0
   308 set :areUnitsAvailable.1:occupied 0
   309 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  310 ubind @mono
   311 set :areUnitsAvailable.1:firstUnit @unit
   312 jump *label404 equal :areUnitsAvailable.1:firstUnit null
   313 set :needsFourUnits.1:unit @unit
 
   333 label *label400
   334 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   335 label *label401
-    * ubind :chooseUnitType.0:type
+  336 ubind @mono
   337 label *label402
   338 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   339 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   343 label *label403
   344 label *label404
   345 label *label405
-    * print :chooseUnitType.0:type
+  346 print @mono
   347 print ":"
   348 print " occupied: "
   349 print :areUnitsAvailable.1:occupied
 
   362 label *label410
   363 jump *label411 equal *tmp36 false
   364 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  365 set *tmp3 @mono
   366 jump *label6 always
   367 label *label411
   368 label *label412

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-4 instructions):
 
    89 jump *label6 always
    90 label *label27
    91 label *label28
-    * set :chooseUnitType.0:type @flare
    92 label *label322
    93 jump *label341 equal @flare UNIT_TYPE
    94 remark "chooseUnitType: "
 
   158 label *label341
   159 label *label342
   160 label *label343
-    * set :chooseUnitType.0:type @poly
   161 label *label346
   162 jump *label365 equal @poly UNIT_TYPE
   163 remark "chooseUnitType: "
 
   227 label *label365
   228 label *label366
   229 label *label367
-    * set :chooseUnitType.0:type @mega
   230 label *label370
   231 jump *label389 equal @mega UNIT_TYPE
   232 remark "chooseUnitType: "
 
   296 label *label389
   297 label *label390
   298 label *label391
-    * set :chooseUnitType.0:type @mono
   299 label *label394
   300 jump *label413 equal @mono UNIT_TYPE
   301 remark "chooseUnitType: "

Modifications by Iterated phase, Jump Normalization, pass 3, iteration 1:
 
    37 set :needsFourUnits.0:unit @unit
    38 sensor *tmp13 :needsFourUnits.0:unit @speed
    39 label *label13
-    * jump *label15 equal false false
+   40 jump *label15 always
    41 label *label15
    42 set :areUnitsAvailable.0:needed 2
    43 label *label16
 
   102 set :needsFourUnits.1:unit @unit
   103 sensor *tmp45 :needsFourUnits.1:unit @speed
   104 label *label323
-    * jump *label324 equal false false
+  105 jump *label324 always
   106 label *label324
   107 set :areUnitsAvailable.1:needed 2
   108 label *label325
 
   171 set :needsFourUnits.1:unit @unit
   172 sensor *tmp45 :needsFourUnits.1:unit @speed
   173 label *label347
-    * jump *label348 equal false false
+  174 jump *label348 always
   175 label *label348
   176 set :areUnitsAvailable.1:needed 2
   177 label *label349
 
   240 set :needsFourUnits.1:unit @unit
   241 sensor *tmp45 :needsFourUnits.1:unit @speed
   242 label *label371
-    * jump *label372 equal false false
+  243 jump *label372 always
   244 label *label372
   245 set :areUnitsAvailable.1:needed 2
   246 label *label373
 
   309 set :needsFourUnits.1:unit @unit
   310 sensor *tmp45 :needsFourUnits.1:unit @speed
   311 label *label395
-    * jump *label396 equal false false
+  312 jump *label396 always
   313 label *label396
   314 set :areUnitsAvailable.1:needed 2
   315 label *label397

Modifications by Iterated phase, Jump Optimization, pass 3, iteration 1 (-1 instructions):
 
  1306 set :needsFourUnits.3:unit @unit
  1307 sensor *tmp510 :needsFourUnits.3:unit @speed
  1308 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
-    * op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1309 label *label303
-    * jump *label305 equal *tmp505 false
+ 1310 jump *label305 lessThan :needsFourUnits.3:travel_time 47
  1311 set *tmp513 4
  1312 label *label305
  1313 label *label306

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-5 instructions):
 
    37 set :needsFourUnits.0:unit @unit
    38 sensor *tmp13 :needsFourUnits.0:unit @speed
    39 label *label13
-    * jump *label15 always
    40 label *label15
    41 set :areUnitsAvailable.0:needed 2
    42 label *label16
 
   101 set :needsFourUnits.1:unit @unit
   102 sensor *tmp45 :needsFourUnits.1:unit @speed
   103 label *label323
-    * jump *label324 always
   104 label *label324
   105 set :areUnitsAvailable.1:needed 2
   106 label *label325
 
   169 set :needsFourUnits.1:unit @unit
   170 sensor *tmp45 :needsFourUnits.1:unit @speed
   171 label *label347
-    * jump *label348 always
   172 label *label348
   173 set :areUnitsAvailable.1:needed 2
   174 label *label349
 
   237 set :needsFourUnits.1:unit @unit
   238 sensor *tmp45 :needsFourUnits.1:unit @speed
   239 label *label371
-    * jump *label372 always
   240 label *label372
   241 set :areUnitsAvailable.1:needed 2
   242 label *label373
 
   305 set :needsFourUnits.1:unit @unit
   306 sensor *tmp45 :needsFourUnits.1:unit @speed
   307 label *label395
-    * jump *label396 always
   308 label *label396
   309 set :areUnitsAvailable.1:needed 2
   310 label *label397

Modifications by Final phase, Jump Straightening, iteration 1 (-17 instructions):
 
   389 set .UNIT_P2 .UNIT_S1
   390 set .UNIT_S1 .UNIT_P1
   391 set .UNIT_P1 @unit
-    * jump *label65 equal .UNIT_S2 null
-    * jump *label62 always
+  392 jump *label62 notEqual .UNIT_S2 null
   393 label *label65
   394 label *label66
   395 label *label63
 
   410 sensor *tmp85 @unit @controller
   411 op equal *tmp86 *tmp85 @this
   412 op land *tmp87 *tmp84 *tmp86
-    * jump *label71 equal *tmp87 false
-    * jump *label68 always
+  413 jump *label68 notEqual *tmp87 false
   414 label *label71
   415 label *label72
   416 label *label69
 
   420 jump *label73 equal :rebindUnit.0:firstUnit null
   421 label *label75
   422 sensor *tmp92 @unit @controlled
-    * jump *label78 notEqual *tmp92 0
-    * jump *label68 always
+  423 jump *label68 equal *tmp92 0
   424 label *label78
   425 label *label79
   426 ubind *tmp3
 
   446 sensor *tmp105 @unit @controller
   447 op equal *tmp106 *tmp105 @this
   448 op land *tmp107 *tmp104 *tmp106
-    * jump *label84 equal *tmp107 false
-    * jump *label81 always
+  449 jump *label81 notEqual *tmp107 false
   450 label *label84
   451 label *label85
   452 label *label82
 
   456 jump *label86 equal :rebindUnit.1:firstUnit null
   457 label *label88
   458 sensor *tmp112 @unit @controlled
-    * jump *label91 notEqual *tmp112 0
-    * jump *label81 always
+  459 jump *label81 equal *tmp112 0
   460 label *label91
   461 label *label92
   462 ubind *tmp3
 
   520 sensor *tmp154 @unit @controller
   521 op equal *tmp155 *tmp154 @this
   522 op land *tmp156 *tmp153 *tmp155
-    * jump *label107 equal *tmp156 false
-    * jump *label104 always
+  523 jump *label104 notEqual *tmp156 false
   524 label *label107
   525 label *label108
   526 label *label105
 
   530 jump *label109 equal :rebindUnit.2:firstUnit null
   531 label *label111
   532 sensor *tmp161 @unit @controlled
-    * jump *label114 notEqual *tmp161 0
-    * jump *label104 always
+  533 jump *label104 equal *tmp161 0
   534 label *label114
   535 label *label115
   536 ubind *tmp3
 
   556 sensor *tmp174 @unit @controller
   557 op equal *tmp175 *tmp174 @this
   558 op land *tmp176 *tmp173 *tmp175
-    * jump *label120 equal *tmp176 false
-    * jump *label117 always
+  559 jump *label117 notEqual *tmp176 false
   560 label *label120
   561 label *label121
   562 label *label118
 
   566 jump *label122 equal :rebindUnit.3:firstUnit null
   567 label *label124
   568 sensor *tmp181 @unit @controlled
-    * jump *label127 notEqual *tmp181 0
-    * jump *label117 always
+  569 jump *label117 equal *tmp181 0
   570 label *label127
   571 label *label128
   572 ubind *tmp3
 
   665 sensor *tmp223 @unit @controller
   666 op equal *tmp224 *tmp223 @this
   667 op land *tmp225 *tmp222 *tmp224
-    * jump *label143 equal *tmp225 false
-    * jump *label140 always
+  668 jump *label140 notEqual *tmp225 false
   669 label *label143
   670 label *label144
   671 label *label141
 
   675 jump *label145 equal :rebindUnit.4:firstUnit null
   676 label *label147
   677 sensor *tmp230 @unit @controlled
-    * jump *label150 notEqual *tmp230 0
-    * jump *label140 always
+  678 jump *label140 equal *tmp230 0
   679 label *label150
   680 label *label151
   681 ubind *tmp3
 
   808 sensor *tmp290 @unit @controller
   809 op equal *tmp291 *tmp290 @this
   810 op land *tmp292 *tmp289 *tmp291
-    * jump *label182 equal *tmp292 false
-    * jump *label179 always
+  811 jump *label179 notEqual *tmp292 false
   812 label *label182
   813 label *label183
   814 label *label180
 
   818 jump *label184 equal :rebindUnit.5:firstUnit null
   819 label *label186
   820 sensor *tmp297 @unit @controlled
-    * jump *label189 notEqual *tmp297 0
-    * jump *label179 always
+  821 jump *label179 equal *tmp297 0
   822 label *label189
   823 label *label190
   824 ubind *tmp3
 
   976 sensor *tmp364 @unit @controller
   977 op equal *tmp365 *tmp364 @this
   978 op land *tmp366 *tmp363 *tmp365
-    * jump *label224 equal *tmp366 false
-    * jump *label221 always
+  979 jump *label221 notEqual *tmp366 false
   980 label *label224
   981 label *label225
   982 label *label222
 
   986 jump *label226 equal :rebindUnit.6:firstUnit null
   987 label *label228
   988 sensor *tmp371 @unit @controlled
-    * jump *label231 notEqual *tmp371 0
-    * jump *label221 always
+  989 jump *label221 equal *tmp371 0
   990 label *label231
   991 label *label232
   992 ubind *tmp3
 
  1119 sensor *tmp431 @unit @controller
  1120 op equal *tmp432 *tmp431 @this
  1121 op land *tmp433 *tmp430 *tmp432
-    * jump *label263 equal *tmp433 false
-    * jump *label260 always
+ 1122 jump *label260 notEqual *tmp433 false
  1123 label *label263
  1124 label *label264
  1125 label *label261
 
  1129 jump *label265 equal :rebindUnit.7:firstUnit null
  1130 label *label267
  1131 sensor *tmp438 @unit @controlled
-    * jump *label270 notEqual *tmp438 0
-    * jump *label260 always
+ 1132 jump *label260 equal *tmp438 0
  1133 label *label270
  1134 label *label271
  1135 ubind *tmp3

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @flare
 
    48 op or *tmp21 *tmp18 *tmp20
    49 jump *label19 equal *tmp21 false
    50 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label21 lessThan :areUnitsAvailable.0:free 2
+   51 jump *label20 lessThan :areUnitsAvailable.0:free 2
    52 set *tmp4 true
    53 jump *label10 always
    54 label *label21
 
   112 op or *tmp53 *tmp50 *tmp52
   113 jump *label328 equal *tmp53 false
   114 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label326 lessThan :areUnitsAvailable.1:free 2
+  115 jump *label329 lessThan :areUnitsAvailable.1:free 2
   116 set *tmp36 true
   117 jump *label338 always
   118 label *label326
 
   180 op or *tmp53 *tmp50 *tmp52
   181 jump *label352 equal *tmp53 false
   182 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label350 lessThan :areUnitsAvailable.1:free 2
+  183 jump *label353 lessThan :areUnitsAvailable.1:free 2
   184 set *tmp36 true
   185 jump *label362 always
   186 label *label350
 
   248 op or *tmp53 *tmp50 *tmp52
   249 jump *label376 equal *tmp53 false
   250 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label374 lessThan :areUnitsAvailable.1:free 2
+  251 jump *label377 lessThan :areUnitsAvailable.1:free 2
   252 set *tmp36 true
   253 jump *label386 always
   254 label *label374
 
   316 op or *tmp53 *tmp50 *tmp52
   317 jump *label400 equal *tmp53 false
   318 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label398 lessThan :areUnitsAvailable.1:free 2
+  319 jump *label401 lessThan :areUnitsAvailable.1:free 2
   320 set *tmp36 true
   321 jump *label410 always
   322 label *label398
 
   418 label *label70
   419 ubind *tmp3
   420 set :rebindUnit.0:firstUnit @unit
-    * jump *label73 equal :rebindUnit.0:firstUnit null
+  421 jump __start__ equal :rebindUnit.0:firstUnit null
   422 label *label75
   423 sensor *tmp92 @unit @controlled
   424 jump *label68 equal *tmp92 0
 
   454 label *label83
   455 ubind *tmp3
   456 set :rebindUnit.1:firstUnit @unit
-    * jump *label86 equal :rebindUnit.1:firstUnit null
+  457 jump __start__ equal :rebindUnit.1:firstUnit null
   458 label *label88
   459 sensor *tmp112 @unit @controlled
   460 jump *label81 equal *tmp112 0
 
   528 label *label106
   529 ubind *tmp3
   530 set :rebindUnit.2:firstUnit @unit
-    * jump *label109 equal :rebindUnit.2:firstUnit null
+  531 jump __start__ equal :rebindUnit.2:firstUnit null
   532 label *label111
   533 sensor *tmp161 @unit @controlled
   534 jump *label104 equal *tmp161 0
 
   564 label *label119
   565 ubind *tmp3
   566 set :rebindUnit.3:firstUnit @unit
-    * jump *label122 equal :rebindUnit.3:firstUnit null
+  567 jump __start__ equal :rebindUnit.3:firstUnit null
   568 label *label124
   569 sensor *tmp181 @unit @controlled
   570 jump *label117 equal *tmp181 0
 
   631 op add :unitCheck @time 5000
   632 label *label133
   633 sensor *tmp211 switch1 @enabled
-    * jump *label135 equal *tmp211 false
+  634 jump __start__ equal *tmp211 false
   635 label *label321
   636 set :start @time
   637 print " === [gold]Supplying Overdrive Dome[] === "
 
   673 label *label142
   674 ubind *tmp3
   675 set :rebindUnit.4:firstUnit @unit
-    * jump *label145 equal :rebindUnit.4:firstUnit null
+  676 jump __start__ equal :rebindUnit.4:firstUnit null
   677 label *label147
   678 sensor *tmp230 @unit @controlled
   679 jump *label140 equal *tmp230 0
 
   727 jump *label164 lessThan *tmp254 .UNIT_CAPACITY
   728 ucontrol approach .DOME_X .DOME_Y 6
   729 set :processUnit.0:state 3
-    * jump *label165 always
+  730 jump *label163 always
   731 label *label164
   732 set :processUnit.0:msg ", loading\n"
   733 label *label165
 
   757 set :processUnit.0:msg ", waiting\n"
   758 label *label171
   759 sensor *tmp269 @unit @totalItems
-    * jump *label172 greaterThan *tmp269 0
+  760 jump *label169 greaterThan *tmp269 0
   761 ucontrol approach .CORE_X .CORE_Y 6
   762 set :processUnit.0:state 2
   763 label *label172
 
   816 label *label181
   817 ubind *tmp3
   818 set :rebindUnit.5:firstUnit @unit
-    * jump *label184 equal :rebindUnit.5:firstUnit null
+  819 jump __start__ equal :rebindUnit.5:firstUnit null
   820 label *label186
   821 sensor *tmp297 @unit @controlled
   822 jump *label179 equal *tmp297 0
 
   870 jump *label203 lessThan *tmp321 .UNIT_CAPACITY
   871 ucontrol approach .DOME_X .DOME_Y 6
   872 set :processUnit.1:state 3
-    * jump *label204 always
+  873 jump *label202 always
   874 label *label203
   875 set :processUnit.1:msg ", loading\n"
   876 label *label204
 
   900 set :processUnit.1:msg ", waiting\n"
   901 label *label210
   902 sensor *tmp336 @unit @totalItems
-    * jump *label211 greaterThan *tmp336 0
+  903 jump *label208 greaterThan *tmp336 0
   904 ucontrol approach .CORE_X .CORE_Y 6
   905 set :processUnit.1:state 2
   906 label *label211
 
   984 label *label223
   985 ubind *tmp3
   986 set :rebindUnit.6:firstUnit @unit
-    * jump *label226 equal :rebindUnit.6:firstUnit null
+  987 jump __start__ equal :rebindUnit.6:firstUnit null
   988 label *label228
   989 sensor *tmp371 @unit @controlled
   990 jump *label221 equal *tmp371 0
 
  1038 jump *label245 lessThan *tmp395 .UNIT_CAPACITY
  1039 ucontrol approach .DOME_X .DOME_Y 6
  1040 set :processUnit.2:state 3
-    * jump *label246 always
+ 1041 jump *label244 always
  1042 label *label245
  1043 set :processUnit.2:msg ", loading\n"
  1044 label *label246
 
  1068 set :processUnit.2:msg ", waiting\n"
  1069 label *label252
  1070 sensor *tmp410 @unit @totalItems
-    * jump *label253 greaterThan *tmp410 0
+ 1071 jump *label250 greaterThan *tmp410 0
  1072 ucontrol approach .CORE_X .CORE_Y 6
  1073 set :processUnit.2:state 2
  1074 label *label253
 
  1127 label *label262
  1128 ubind *tmp3
  1129 set :rebindUnit.7:firstUnit @unit
-    * jump *label265 equal :rebindUnit.7:firstUnit null
+ 1130 jump __start__ equal :rebindUnit.7:firstUnit null
  1131 label *label267
  1132 sensor *tmp438 @unit @controlled
  1133 jump *label260 equal *tmp438 0
 
  1181 jump *label284 lessThan *tmp462 .UNIT_CAPACITY
  1182 ucontrol approach .DOME_X .DOME_Y 6
  1183 set :processUnit.3:state 3
-    * jump *label285 always
+ 1184 jump *label283 always
  1185 label *label284
  1186 set :processUnit.3:msg ", loading\n"
  1187 label *label285
 
  1211 set :processUnit.3:msg ", waiting\n"
  1212 label *label291
  1213 sensor *tmp477 @unit @totalItems
-    * jump *label292 greaterThan *tmp477 0
+ 1214 jump *label289 greaterThan *tmp477 0
  1215 ucontrol approach .CORE_X .CORE_Y 6
  1216 set :processUnit.3:state 2
  1217 label *label292
 
  1280 set :areUnitsAvailable.2:free 0
  1281 ubind UNIT_TYPE
  1282 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label301 equal :areUnitsAvailable.2:firstUnit null
+ 1283 jump *label313 equal :areUnitsAvailable.2:firstUnit null
  1284 set *tmp513 2
  1285 set :needsFourUnits.3:unit @unit
  1286 sensor *tmp510 :needsFourUnits.3:unit @speed
 
  1297 op or *tmp518 *tmp515 *tmp517
  1298 jump *label309 equal *tmp518 false
  1299 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label311 lessThan :areUnitsAvailable.2:free *tmp513
+ 1300 jump *label310 lessThan :areUnitsAvailable.2:free *tmp513
  1301 set *tmp501 true
  1302 jump *label300 always
  1303 label *label311

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-18 instructions):
 
    51 jump *label20 lessThan :areUnitsAvailable.0:free 2
    52 set *tmp4 true
    53 jump *label10 always
-    * label *label21
-    * label *label22
-    * jump *label20 always
    54 label *label19
    55 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
    56 label *label20
 
   112 jump *label329 lessThan :areUnitsAvailable.1:free 2
   113 set *tmp36 true
   114 jump *label338 always
-    * label *label326
-    * label *label327
-    * jump *label329 always
   115 label *label328
   116 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   117 label *label329
 
   177 jump *label353 lessThan :areUnitsAvailable.1:free 2
   178 set *tmp36 true
   179 jump *label362 always
-    * label *label350
-    * label *label351
-    * jump *label353 always
   180 label *label352
   181 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   182 label *label353
 
   242 jump *label377 lessThan :areUnitsAvailable.1:free 2
   243 set *tmp36 true
   244 jump *label386 always
-    * label *label374
-    * label *label375
-    * jump *label377 always
   245 label *label376
   246 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   247 label *label377
 
   307 jump *label401 lessThan :areUnitsAvailable.1:free 2
   308 set *tmp36 true
   309 jump *label410 always
-    * label *label398
-    * label *label399
-    * jump *label401 always
   310 label *label400
   311 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   312 label *label401
 
   350 printflush message1
   351 label *label8
   352 jump *label7 always
-    * label *label9
-    * set *tmp3 null
   353 label *label6
   354 print "[gold]Binding units..."
   355 printflush message1
 
  1283 jump *label310 lessThan :areUnitsAvailable.2:free *tmp513
  1284 set *tmp501 true
  1285 jump *label300 always
-    * label *label311
-    * label *label312
-    * jump *label310 always
  1286 label *label309
  1287 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1288 label *label310
 
  1297 label *label301
  1298 label *label302
  1299 jump *label313 always
-    * print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.2:free
-    * jump *label315 lessThanEq :areUnitsAvailable.2:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.2:needed
-    * label *label315
-    * label *label316
-    * print "\n"
  1300 label *label313
  1301 label *label314
  1302 set *tmp501 false

Modifications by Final phase, Dead Code Elimination, iteration 1 (-6 instructions):
 
    36 set :areUnitsAvailable.0:firstUnit @unit
    37 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    38 set :needsFourUnits.0:unit @unit
-    * sensor *tmp13 :needsFourUnits.0:unit @speed
    39 label *label13
    40 label *label15
    41 set :areUnitsAvailable.0:needed 2
 
    96 set :areUnitsAvailable.1:firstUnit @unit
    97 jump *label332 equal :areUnitsAvailable.1:firstUnit null
    98 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
    99 label *label323
   100 label *label324
   101 set :areUnitsAvailable.1:needed 2
 
   160 set :areUnitsAvailable.1:firstUnit @unit
   161 jump *label356 equal :areUnitsAvailable.1:firstUnit null
   162 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   163 label *label347
   164 label *label348
   165 set :areUnitsAvailable.1:needed 2
 
   224 set :areUnitsAvailable.1:firstUnit @unit
   225 jump *label380 equal :areUnitsAvailable.1:firstUnit null
   226 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   227 label *label371
   228 label *label372
   229 set :areUnitsAvailable.1:needed 2
 
   288 set :areUnitsAvailable.1:firstUnit @unit
   289 jump *label404 equal :areUnitsAvailable.1:firstUnit null
   290 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   291 label *label395
   292 label *label396
   293 set :areUnitsAvailable.1:needed 2
 
   487 op sub *tmp141 .DOME_Y .CORE_Y
   488 op len *tmp142 *tmp140 *tmp141
   489 op mul *tmp143 2 *tmp142
-    * sensor *tmp144 .UNIT_S1 @speed
   490 op div :needsFourUnits.2:travel_time *tmp143 .SPEED
   491 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   492 label *label100

Modifications by Final phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
    35 ubind UNIT_TYPE
    36 set :areUnitsAvailable.0:firstUnit @unit
    37 jump *label11 equal :areUnitsAvailable.0:firstUnit null
-    * set :needsFourUnits.0:unit @unit
    38 label *label13
    39 label *label15
    40 set :areUnitsAvailable.0:needed 2
 
    94 ubind @flare
    95 set :areUnitsAvailable.1:firstUnit @unit
    96 jump *label332 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
    97 label *label323
    98 label *label324
    99 set :areUnitsAvailable.1:needed 2
 
   157 ubind @poly
   158 set :areUnitsAvailable.1:firstUnit @unit
   159 jump *label356 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
   160 label *label347
   161 label *label348
   162 set :areUnitsAvailable.1:needed 2
 
   220 ubind @mega
   221 set :areUnitsAvailable.1:firstUnit @unit
   222 jump *label380 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
   223 label *label371
   224 label *label372
   225 set :areUnitsAvailable.1:needed 2
 
   283 ubind @mono
   284 set :areUnitsAvailable.1:firstUnit @unit
   285 jump *label404 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
   286 label *label395
   287 label *label396
   288 set :areUnitsAvailable.1:needed 2

Modifications by Final phase, Single Step Elimination, iteration 1 (-2 instructions):
 
  1285 label *label308
  1286 label *label301
  1287 label *label302
-    * jump *label313 always
  1288 label *label313
  1289 label *label314
  1290 set *tmp501 false
 
  1300 sensor *tmp211 switch1 @enabled
  1301 jump *label321 notEqual *tmp211 false
  1302 label *label135
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-83 instructions):
 
    16 sensor *tmp1 switch1 @enabled
    17 jump *label5 notEqual *tmp1 false
    18 label *label320
-    * print "[coral]Activate switch to begin supplying overdrive dome..."
-    * print "\n"
+   19 print "[coral]Activate switch to begin supplying overdrive dome...\n"
    20 printflush message1
    21 label *label4
    22 sensor *tmp1 switch1 @enabled
 
    24 label *label5
    25 label *label7
    26 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   27 print "[gold]Looking for suitable unit type:[]\n"
    28 remark "chooseUnitType: "
    29 remark UNIT_TYPE
    30 set :areUnitsAvailable.0:needed 0
 
    61 label *label11
    62 label *label12
    63 print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.0:occupied
-    * print ","
-    * print " free: "
+   64 print ": occupied: {0}, free: "
+   65 format :areUnitsAvailable.0:occupied
    66 print :areUnitsAvailable.0:free
    67 jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
    68 print ", needed: "
 
    81 label *label28
    82 label *label322
    83 jump *label341 equal @flare UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @flare
+   84 remark "chooseUnitType: flare"
    85 set :areUnitsAvailable.1:needed 0
    86 set :areUnitsAvailable.1:occupied 0
    87 set :areUnitsAvailable.1:free 0
 
   115 label *label331
   116 label *label332
   117 label *label333
-    * print @flare
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  118 print "flare: occupied: {0}, free: "
+  119 format :areUnitsAvailable.1:occupied
   120 print :areUnitsAvailable.1:free
   121 jump *label334 lessThanEq :areUnitsAvailable.1:needed 0
   122 print ", needed: "
 
   139 label *label343
   140 label *label346
   141 jump *label365 equal @poly UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @poly
+  142 remark "chooseUnitType: poly"
   143 set :areUnitsAvailable.1:needed 0
   144 set :areUnitsAvailable.1:occupied 0
   145 set :areUnitsAvailable.1:free 0
 
   173 label *label355
   174 label *label356
   175 label *label357
-    * print @poly
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  176 print "poly: occupied: {0}, free: "
+  177 format :areUnitsAvailable.1:occupied
   178 print :areUnitsAvailable.1:free
   179 jump *label358 lessThanEq :areUnitsAvailable.1:needed 0
   180 print ", needed: "
 
   197 label *label367
   198 label *label370
   199 jump *label389 equal @mega UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @mega
+  200 remark "chooseUnitType: mega"
   201 set :areUnitsAvailable.1:needed 0
   202 set :areUnitsAvailable.1:occupied 0
   203 set :areUnitsAvailable.1:free 0
 
   231 label *label379
   232 label *label380
   233 label *label381
-    * print @mega
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  234 print "mega: occupied: {0}, free: "
+  235 format :areUnitsAvailable.1:occupied
   236 print :areUnitsAvailable.1:free
   237 jump *label382 lessThanEq :areUnitsAvailable.1:needed 0
   238 print ", needed: "
 
   255 label *label391
   256 label *label394
   257 jump *label413 equal @mono UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @mono
+  258 remark "chooseUnitType: mono"
   259 set :areUnitsAvailable.1:needed 0
   260 set :areUnitsAvailable.1:occupied 0
   261 set :areUnitsAvailable.1:free 0
 
   289 label *label403
   290 label *label404
   291 label *label405
-    * print @mono
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  292 print "mono: occupied: {0}, free: "
+  293 format :areUnitsAvailable.1:occupied
   294 print :areUnitsAvailable.1:free
   295 jump *label406 lessThanEq :areUnitsAvailable.1:needed 0
   296 print ", needed: "
 
   581 jump __start__ equal *tmp211 false
   582 label *label321
   583 set :start @time
-    * print " === [gold]Supplying Overdrive Dome[] === "
-    * print "\n"
-    * print "\n"
-    * print "Unit type: [green]"
-    * print *tmp3
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "\n[green]Silicon[] status:\n"
+  584 print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
+  585 format *tmp3
   586 sensor :printDomeStatus.0:level .DOME @silicon
   587 jump *label137 lessThanEq :printDomeStatus.0:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.0:level
-    * print "["
-    * print "]"
-    * print "\n"
+  588 print "  dome:  [green]{0}[]\n"
+  589 format :printDomeStatus.0:level
   590 jump *label138 always
   591 label *label137
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.0:level
-    * print "["
-    * print "]"
-    * print "\n"
+  592 print "  dome:  [coral]{0}[]\n"
+  593 format :printDomeStatus.0:level
   594 label *label138
   595 label *label136
   596 jump *label141 equal .UNIT_S1 null
 
   712 label *label167
   713 ucontrol flag :processUnit.0:state
   714 sensor *tmp279 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp279
-    * print "["
-    * print "]"
+  715 print "  {0}: [gold]{0}[]"
+  716 format .GROUP1
+  717 format *tmp279
   718 jump *label174 lessThan :processUnit.0:distance 0
   719 print :processUnit.0:msg
   720 print :processUnit.0:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  721 print "[] sec\n"
   722 jump *label175 always
   723 label *label174
   724 print :processUnit.0:msg
 
   847 label *label206
   848 ucontrol flag :processUnit.1:state
   849 sensor *tmp346 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp346
-    * print "["
-    * print "]"
+  850 print "  {0}: [gold]{0}[]"
+  851 format .GROUP2
+  852 format *tmp346
   853 jump *label213 lessThan :processUnit.1:distance 0
   854 print :processUnit.1:msg
   855 print :processUnit.1:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  856 print "[] sec\n"
   857 jump *label214 always
   858 label *label213
   859 print :processUnit.1:msg
 
   874 print "\n[green]Phase fabric[] status:\n"
   875 sensor :printDomeStatus.1:level .DOME @phase-fabric
   876 jump *label218 lessThanEq :printDomeStatus.1:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  877 print "  dome:  [green]{0}[]\n"
+  878 format :printDomeStatus.1:level
   879 jump *label219 always
   880 label *label218
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  881 print "  dome:  [coral]{0}[]\n"
+  882 format :printDomeStatus.1:level
   883 label *label219
   884 label *label217
   885 jump *label222 equal .UNIT_P1 null
 
  1001 label *label248
  1002 ucontrol flag :processUnit.2:state
  1003 sensor *tmp420 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp420
-    * print "["
-    * print "]"
+ 1004 print "  {0}: [gold]{0}[]"
+ 1005 format .GROUP1
+ 1006 format *tmp420
  1007 jump *label255 lessThan :processUnit.2:distance 0
  1008 print :processUnit.2:msg
  1009 print :processUnit.2:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1010 print "[] sec\n"
  1011 jump *label256 always
  1012 label *label255
  1013 print :processUnit.2:msg
 
  1136 label *label287
  1137 ucontrol flag :processUnit.3:state
  1138 sensor *tmp487 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp487
-    * print "["
-    * print "]"
+ 1139 print "  {0}: [gold]{0}[]"
+ 1140 format .GROUP2
+ 1141 format *tmp487
  1142 jump *label294 lessThan :processUnit.3:distance 0
  1143 print :processUnit.3:msg
  1144 print :processUnit.3:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1145 print "[] sec\n"
  1146 jump *label295 always
  1147 label *label294
  1148 print :processUnit.3:msg
 
  1162 label *label258
  1163 op sub *tmp495 @time :start
  1164 op floor *tmp496 *tmp495
-    * print "\n"
-    * print "[lightgray]Loop time: "
-    * print *tmp496
-    * print " "
-    * print "ms"
+ 1165 print "\n[lightgray]Loop time: {0} ms"
+ 1166 format *tmp496
  1167 printflush message1
  1168 op notEqual *tmp497 *tmp3 UNIT_TYPE
  1169 op greaterThan *tmp498 :unitCheck @time

Final code before resolving virtual instructions:

label __start__
remark "This is the preferred unit type to use for bringing in supplies."
remark "If no units of this type exist, we'll try using other types."
set UNIT_TYPE @flare
remark "Do not modify anything below this line."
set .DOME dome1
jump *label2 notEqual dome1 null
label *label319
print "[gold]Waiting for an overdrive dome to be connected..."
printflush message1
set .DOME dome1
jump *label319 equal dome1 null
label *label2
sensor *tmp1 switch1 @enabled
jump *label5 notEqual *tmp1 false
label *label320
print "[coral]Activate switch to begin supplying overdrive dome...\n"
printflush message1
sensor *tmp1 switch1 @enabled
jump *label320 equal *tmp1 false
label *label5
label *label7
printflush null
print "[gold]Looking for suitable unit type:[]\n"
remark "chooseUnitType: "
remark UNIT_TYPE
set :areUnitsAvailable.0:needed 0
set :areUnitsAvailable.0:occupied 0
set :areUnitsAvailable.0:free 0
ubind UNIT_TYPE
set :areUnitsAvailable.0:firstUnit @unit
jump *label11 equal :areUnitsAvailable.0:firstUnit null
set :areUnitsAvailable.0:needed 2
label *label16
sensor *tmp17 @unit @controlled
op equal *tmp18 *tmp17 0
sensor *tmp19 @unit @controller
op equal *tmp20 *tmp19 @this
op or *tmp21 *tmp18 *tmp20
jump *label19 equal *tmp21 false
op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
jump *label20 lessThan :areUnitsAvailable.0:free 2
set *tmp4 true
jump *label10 always
label *label19
op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
label *label20
ubind UNIT_TYPE
op notEqual *tmp25 @unit :areUnitsAvailable.0:firstUnit
sensor *tmp26 :areUnitsAvailable.0:firstUnit @dead
op equal *tmp27 *tmp26 0
op land *tmp28 *tmp25 *tmp27
jump *label16 notEqual *tmp28 false
label *label11
print UNIT_TYPE
print ": occupied: {0}, free: "
format :areUnitsAvailable.0:occupied
print :areUnitsAvailable.0:free
jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
print ", needed: "
print :areUnitsAvailable.0:needed
label *label25
print "\n"
set *tmp4 false
label *label10
jump *label27 equal *tmp4 false
set *tmp3 UNIT_TYPE
jump *label6 always
label *label27
jump *label341 equal @flare UNIT_TYPE
remark "chooseUnitType: flare"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @flare
set :areUnitsAvailable.1:firstUnit @unit
jump *label332 equal :areUnitsAvailable.1:firstUnit null
set :areUnitsAvailable.1:needed 2
label *label325
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label328 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label329 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label338 always
label *label328
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label329
ubind @flare
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label325 notEqual *tmp60 false
label *label332
print "flare: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label334 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label334
print "\n"
set *tmp36 false
label *label338
jump *label339 equal *tmp36 false
printflush null
set *tmp3 @flare
jump *label6 always
label *label339
label *label341
jump *label365 equal @poly UNIT_TYPE
remark "chooseUnitType: poly"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @poly
set :areUnitsAvailable.1:firstUnit @unit
jump *label356 equal :areUnitsAvailable.1:firstUnit null
set :areUnitsAvailable.1:needed 2
label *label349
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label352 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label353 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label362 always
label *label352
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label353
ubind @poly
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label349 notEqual *tmp60 false
label *label356
print "poly: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label358 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label358
print "\n"
set *tmp36 false
label *label362
jump *label363 equal *tmp36 false
printflush null
set *tmp3 @poly
jump *label6 always
label *label363
label *label365
jump *label389 equal @mega UNIT_TYPE
remark "chooseUnitType: mega"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @mega
set :areUnitsAvailable.1:firstUnit @unit
jump *label380 equal :areUnitsAvailable.1:firstUnit null
set :areUnitsAvailable.1:needed 2
label *label373
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label376 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label377 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label386 always
label *label376
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label377
ubind @mega
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label373 notEqual *tmp60 false
label *label380
print "mega: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label382 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label382
print "\n"
set *tmp36 false
label *label386
jump *label387 equal *tmp36 false
printflush null
set *tmp3 @mega
jump *label6 always
label *label387
label *label389
jump *label413 equal @mono UNIT_TYPE
remark "chooseUnitType: mono"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @mono
set :areUnitsAvailable.1:firstUnit @unit
jump *label404 equal :areUnitsAvailable.1:firstUnit null
set :areUnitsAvailable.1:needed 2
label *label397
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label400 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label401 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label410 always
label *label400
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label401
ubind @mono
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label397 notEqual *tmp60 false
label *label404
print "mono: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label406 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label406
print "\n"
set *tmp36 false
label *label410
jump *label411 equal *tmp36 false
printflush null
set *tmp3 @mono
jump *label6 always
label *label411
label *label413
printflush message1
jump *label7 always
label *label6
print "[gold]Binding units..."
printflush message1
set .UNIT_P2 null
set .UNIT_S2 null
set .UNIT_P1 null
set .UNIT_S1 null
set :rebindUnits.0:count 0
ubind *tmp3
set :rebindUnits.0:firstUnit @unit
jump *label58 notEqual :rebindUnits.0:firstUnit null
end
label *label58
label *label60
sensor *tmp69 @unit @controller
jump *label63 notEqual *tmp69 @this
op add :rebindUnits.0:count :rebindUnits.0:count 1
ucontrol flag 1
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 .UNIT_P1
set .UNIT_P1 @unit
jump *label62 notEqual .UNIT_S2 null
label *label63
ubind *tmp3
op notEqual *tmp75 @unit :rebindUnits.0:firstUnit
sensor *tmp76 :rebindUnits.0:firstUnit @dead
op equal *tmp77 *tmp76 0
op land *tmp78 *tmp75 *tmp77
jump *label60 notEqual *tmp78 false
label *label62
jump *label69 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp83 @unit @dead
op strictEqual *tmp84 *tmp83 0
sensor *tmp85 @unit @controller
op equal *tmp86 *tmp85 @this
op land *tmp87 *tmp84 *tmp86
jump *label68 notEqual *tmp87 false
label *label69
ubind *tmp3
set :rebindUnit.0:firstUnit @unit
jump __start__ equal :rebindUnit.0:firstUnit null
label *label75
sensor *tmp92 @unit @controlled
jump *label68 equal *tmp92 0
ubind *tmp3
op notEqual *tmp95 @unit :rebindUnit.0:firstUnit
sensor *tmp96 :rebindUnit.0:firstUnit @dead
op equal *tmp97 *tmp96 0
op land *tmp98 *tmp95 *tmp97
jump *label75 notEqual *tmp98 false
end
label *label68
ucontrol flag 1
set *tmp79 @unit
set .UNIT_S1 *tmp79
jump *label82 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp103 @unit @dead
op strictEqual *tmp104 *tmp103 0
sensor *tmp105 @unit @controller
op equal *tmp106 *tmp105 @this
op land *tmp107 *tmp104 *tmp106
jump *label81 notEqual *tmp107 false
label *label82
ubind *tmp3
set :rebindUnit.1:firstUnit @unit
jump __start__ equal :rebindUnit.1:firstUnit null
label *label88
sensor *tmp112 @unit @controlled
jump *label81 equal *tmp112 0
ubind *tmp3
op notEqual *tmp115 @unit :rebindUnit.1:firstUnit
sensor *tmp116 :rebindUnit.1:firstUnit @dead
op equal *tmp117 *tmp116 0
op land *tmp118 *tmp115 *tmp117
jump *label88 notEqual *tmp118 false
end
label *label81
ucontrol flag 1
set *tmp99 @unit
set .UNIT_P1 *tmp99
sensor *tmp119 *tmp79 @firstItem
op equal *tmp120 *tmp119 @phase-fabric
sensor *tmp121 *tmp99 @firstItem
op equal *tmp122 *tmp121 @silicon
op or *tmp123 *tmp120 *tmp122
jump *label93 equal *tmp123 false
set .UNIT_S1 *tmp99
set .UNIT_P1 *tmp79
label *label93
sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
sensor .SPEED .UNIT_S1 @speed
op div .SPEED_TENTHS .SPEED 10
op strictEqual *tmp128 .SPEED null
jump *label95 equal *tmp128 false
stop
label *label95
print "[gold]Locating core..."
printflush message1
label *label97
ulocate building core false @copper 0 0 0 .CORE
jump *label97 equal .CORE null
sensor .CORE_X .CORE @x
sensor .CORE_Y .CORE @y
sensor .DOME_X .DOME @x
sensor .DOME_Y .DOME @y
op sub *tmp140 .DOME_X .CORE_X
op sub *tmp141 .DOME_Y .CORE_Y
op len *tmp142 *tmp140 *tmp141
op mul *tmp143 2 *tmp142
op div :needsFourUnits.2:travel_time *tmp143 .SPEED
op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
jump *label101 equal *tmp139 false
jump *label105 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp152 @unit @dead
op strictEqual *tmp153 *tmp152 0
sensor *tmp154 @unit @controller
op equal *tmp155 *tmp154 @this
op land *tmp156 *tmp153 *tmp155
jump *label104 notEqual *tmp156 false
label *label105
ubind *tmp3
set :rebindUnit.2:firstUnit @unit
jump __start__ equal :rebindUnit.2:firstUnit null
label *label111
sensor *tmp161 @unit @controlled
jump *label104 equal *tmp161 0
ubind *tmp3
op notEqual *tmp164 @unit :rebindUnit.2:firstUnit
sensor *tmp165 :rebindUnit.2:firstUnit @dead
op equal *tmp166 *tmp165 0
op land *tmp167 *tmp164 *tmp166
jump *label111 notEqual *tmp167 false
end
label *label104
ucontrol flag 1
set *tmp148 @unit
set .UNIT_S2 *tmp148
jump *label118 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp172 @unit @dead
op strictEqual *tmp173 *tmp172 0
sensor *tmp174 @unit @controller
op equal *tmp175 *tmp174 @this
op land *tmp176 *tmp173 *tmp175
jump *label117 notEqual *tmp176 false
label *label118
ubind *tmp3
set :rebindUnit.3:firstUnit @unit
jump __start__ equal :rebindUnit.3:firstUnit null
label *label124
sensor *tmp181 @unit @controlled
jump *label117 equal *tmp181 0
ubind *tmp3
op notEqual *tmp184 @unit :rebindUnit.3:firstUnit
sensor *tmp185 :rebindUnit.3:firstUnit @dead
op equal *tmp186 *tmp185 0
op land *tmp187 *tmp184 *tmp186
jump *label124 notEqual *tmp187 false
end
label *label117
ucontrol flag 1
set *tmp168 @unit
set .UNIT_P2 *tmp168
sensor *tmp188 .UNIT_S1 @firstItem
op equal *tmp189 *tmp188 @phase-fabric
sensor *tmp190 *tmp168 @firstItem
op notEqual *tmp191 *tmp190 @phase-fabric
op land *tmp192 *tmp189 *tmp191
jump *label129 equal *tmp192 false
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 *tmp168
label *label129
sensor *tmp194 *tmp148 @firstItem
op equal *tmp195 *tmp194 @phase-fabric
sensor *tmp196 .UNIT_P2 @firstItem
op equal *tmp197 *tmp196 @silicon
op or *tmp198 *tmp195 *tmp197
jump *label131 equal *tmp198 false
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 *tmp148
label *label131
set .GROUP1 "unit  1"
set .GROUP2 "unit 2"
jump *label102 always
label *label101
ubind .UNIT_S2
ucontrol unbind
set .UNIT_S2 null
ubind .UNIT_P2
ucontrol unbind
set .UNIT_P2 null
set .GROUP1 "unit"
set .GROUP2 ""
label *label102
op equal *tmp200 *tmp139 false
sensor *tmp201 .UNIT_S1 @totalItems
sensor *tmp202 .UNIT_S2 @totalItems
op lessThan *tmp203 *tmp201 *tmp202
op or .SUPPLY_S_FIRST *tmp200 *tmp203
sensor *tmp206 .UNIT_P1 @totalItems
sensor *tmp207 .UNIT_P2 @totalItems
op lessThan *tmp208 *tmp206 *tmp207
op or .SUPPLY_P_FIRST *tmp200 *tmp208
op add :unitCheck @time 5000
sensor *tmp211 switch1 @enabled
jump __start__ equal *tmp211 false
label *label321
set :start @time
print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
format *tmp3
sensor :printDomeStatus.0:level .DOME @silicon
jump *label137 lessThanEq :printDomeStatus.0:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.0:level
jump *label138 always
label *label137
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.0:level
label *label138
jump *label141 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp221 @unit @dead
op strictEqual *tmp222 *tmp221 0
sensor *tmp223 @unit @controller
op equal *tmp224 *tmp223 @this
op land *tmp225 *tmp222 *tmp224
jump *label140 notEqual *tmp225 false
label *label141
ubind *tmp3
set :rebindUnit.4:firstUnit @unit
jump __start__ equal :rebindUnit.4:firstUnit null
label *label147
sensor *tmp230 @unit @controlled
jump *label140 equal *tmp230 0
ubind *tmp3
op notEqual *tmp233 @unit :rebindUnit.4:firstUnit
sensor *tmp234 :rebindUnit.4:firstUnit @dead
op equal *tmp235 *tmp234 0
op land *tmp236 *tmp233 *tmp235
jump *label147 notEqual *tmp236 false
end
label *label140
set :processUnit.0:msg ""
sensor :processUnit.0:state @unit @flag
set :processUnit.0:distance -1
op lessThan *tmp238 :processUnit.0:state 2
op greaterThan *tmp239 :processUnit.0:state 3
op or *tmp240 *tmp238 *tmp239
jump *label152 equal *tmp240 false
sensor *tmp242 @unit @firstItem
jump *label154 notEqual *tmp242 @silicon
set :processUnit.0:state 3
jump *label155 always
label *label154
sensor *tmp245 @unit @totalItems
jump *label156 notEqual *tmp245 0
set :processUnit.0:state 2
jump *label157 always
label *label156
set :processUnit.0:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp248
jump *label158 equal *tmp248 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label158
label *label157
label *label155
label *label152
jump *label160 notEqual :processUnit.0:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp252
jump *label162 equal *tmp252 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp254 @unit @totalItems
jump *label164 lessThan *tmp254 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.0:state 3
jump *label163 always
label *label164
set :processUnit.0:msg ", loading\n"
jump *label163 always
label *label162
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.0:msg ", fetching in [gold]"
sensor *tmp257 @unit @x
op sub *tmp258 .CORE_X *tmp257
sensor *tmp259 @unit @y
op sub *tmp260 .CORE_Y *tmp259
op len *tmp261 *tmp258 *tmp260
op idiv *tmp262 *tmp261 .SPEED_TENTHS
op div :processUnit.0:distance *tmp262 10
label *label163
label *label160
jump *label166 notEqual :processUnit.0:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp266
jump *label168 equal *tmp266 false
jump *label170 equal .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.0:msg ", supplying\n"
jump *label171 always
label *label170
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.0:msg ", waiting\n"
label *label171
sensor *tmp269 @unit @totalItems
jump *label169 greaterThan *tmp269 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.0:state 2
jump *label169 always
label *label168
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.0:msg ", returning in [gold]"
sensor *tmp272 @unit @x
op sub *tmp273 .DOME_X *tmp272
sensor *tmp274 @unit @y
op sub *tmp275 .DOME_Y *tmp274
op len *tmp276 *tmp273 *tmp275
op idiv *tmp277 *tmp276 .SPEED_TENTHS
op div :processUnit.0:distance *tmp277 10
label *label169
label *label166
ucontrol flag :processUnit.0:state
sensor *tmp279 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp279
jump *label174 lessThan :processUnit.0:distance 0
print :processUnit.0:msg
print :processUnit.0:distance
print "[] sec\n"
jump *label175 always
label *label174
print :processUnit.0:msg
label *label175
set *tmp217 @unit
set .UNIT_S1 *tmp217
jump *label176 equal *tmp139 false
op equal *tmp283 .SUPPLY_S_FIRST false
jump *label180 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp288 @unit @dead
op strictEqual *tmp289 *tmp288 0
sensor *tmp290 @unit @controller
op equal *tmp291 *tmp290 @this
op land *tmp292 *tmp289 *tmp291
jump *label179 notEqual *tmp292 false
label *label180
ubind *tmp3
set :rebindUnit.5:firstUnit @unit
jump __start__ equal :rebindUnit.5:firstUnit null
label *label186
sensor *tmp297 @unit @controlled
jump *label179 equal *tmp297 0
ubind *tmp3
op notEqual *tmp300 @unit :rebindUnit.5:firstUnit
sensor *tmp301 :rebindUnit.5:firstUnit @dead
op equal *tmp302 *tmp301 0
op land *tmp303 *tmp300 *tmp302
jump *label186 notEqual *tmp303 false
end
label *label179
set :processUnit.1:msg ""
sensor :processUnit.1:state @unit @flag
set :processUnit.1:distance -1
op lessThan *tmp305 :processUnit.1:state 2
op greaterThan *tmp306 :processUnit.1:state 3
op or *tmp307 *tmp305 *tmp306
jump *label191 equal *tmp307 false
sensor *tmp309 @unit @firstItem
jump *label193 notEqual *tmp309 @silicon
set :processUnit.1:state 3
jump *label194 always
label *label193
sensor *tmp312 @unit @totalItems
jump *label195 notEqual *tmp312 0
set :processUnit.1:state 2
jump *label196 always
label *label195
set :processUnit.1:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp315
jump *label197 equal *tmp315 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label197
label *label196
label *label194
label *label191
jump *label199 notEqual :processUnit.1:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp319
jump *label201 equal *tmp319 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp321 @unit @totalItems
jump *label203 lessThan *tmp321 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:state 3
jump *label202 always
label *label203
set :processUnit.1:msg ", loading\n"
jump *label202 always
label *label201
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:msg ", fetching in [gold]"
sensor *tmp324 @unit @x
op sub *tmp325 .CORE_X *tmp324
sensor *tmp326 @unit @y
op sub *tmp327 .CORE_Y *tmp326
op len *tmp328 *tmp325 *tmp327
op idiv *tmp329 *tmp328 .SPEED_TENTHS
op div :processUnit.1:distance *tmp329 10
label *label202
label *label199
jump *label205 notEqual :processUnit.1:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp333
jump *label207 equal *tmp333 false
jump *label209 equal *tmp283 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.1:msg ", supplying\n"
jump *label210 always
label *label209
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:msg ", waiting\n"
label *label210
sensor *tmp336 @unit @totalItems
jump *label208 greaterThan *tmp336 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:state 2
jump *label208 always
label *label207
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:msg ", returning in [gold]"
sensor *tmp339 @unit @x
op sub *tmp340 .DOME_X *tmp339
sensor *tmp341 @unit @y
op sub *tmp342 .DOME_Y *tmp341
op len *tmp343 *tmp340 *tmp342
op idiv *tmp344 *tmp343 .SPEED_TENTHS
op div :processUnit.1:distance *tmp344 10
label *label208
label *label205
ucontrol flag :processUnit.1:state
sensor *tmp346 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp346
jump *label213 lessThan :processUnit.1:distance 0
print :processUnit.1:msg
print :processUnit.1:distance
print "[] sec\n"
jump *label214 always
label *label213
print :processUnit.1:msg
label *label214
set *tmp284 @unit
set .UNIT_S2 *tmp284
jump *label215 equal .SUPPLY_S_FIRST false
sensor *tmp350 *tmp217 @totalItems
op greaterThan .SUPPLY_S_FIRST *tmp350 0
jump *label216 always
label *label215
sensor *tmp352 *tmp284 @totalItems
op equal .SUPPLY_S_FIRST *tmp352 0
label *label216
label *label176
print "\n[green]Phase fabric[] status:\n"
sensor :printDomeStatus.1:level .DOME @phase-fabric
jump *label218 lessThanEq :printDomeStatus.1:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.1:level
jump *label219 always
label *label218
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.1:level
label *label219
jump *label222 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp362 @unit @dead
op strictEqual *tmp363 *tmp362 0
sensor *tmp364 @unit @controller
op equal *tmp365 *tmp364 @this
op land *tmp366 *tmp363 *tmp365
jump *label221 notEqual *tmp366 false
label *label222
ubind *tmp3
set :rebindUnit.6:firstUnit @unit
jump __start__ equal :rebindUnit.6:firstUnit null
label *label228
sensor *tmp371 @unit @controlled
jump *label221 equal *tmp371 0
ubind *tmp3
op notEqual *tmp374 @unit :rebindUnit.6:firstUnit
sensor *tmp375 :rebindUnit.6:firstUnit @dead
op equal *tmp376 *tmp375 0
op land *tmp377 *tmp374 *tmp376
jump *label228 notEqual *tmp377 false
end
label *label221
set :processUnit.2:msg ""
sensor :processUnit.2:state @unit @flag
set :processUnit.2:distance -1
op lessThan *tmp379 :processUnit.2:state 2
op greaterThan *tmp380 :processUnit.2:state 3
op or *tmp381 *tmp379 *tmp380
jump *label233 equal *tmp381 false
sensor *tmp383 @unit @firstItem
jump *label235 notEqual *tmp383 @phase-fabric
set :processUnit.2:state 3
jump *label236 always
label *label235
sensor *tmp386 @unit @totalItems
jump *label237 notEqual *tmp386 0
set :processUnit.2:state 2
jump *label238 always
label *label237
set :processUnit.2:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp389
jump *label239 equal *tmp389 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label239
label *label238
label *label236
label *label233
jump *label241 notEqual :processUnit.2:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp393
jump *label243 equal *tmp393 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp395 @unit @totalItems
jump *label245 lessThan *tmp395 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:state 3
jump *label244 always
label *label245
set :processUnit.2:msg ", loading\n"
jump *label244 always
label *label243
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:msg ", fetching in [gold]"
sensor *tmp398 @unit @x
op sub *tmp399 .CORE_X *tmp398
sensor *tmp400 @unit @y
op sub *tmp401 .CORE_Y *tmp400
op len *tmp402 *tmp399 *tmp401
op idiv *tmp403 *tmp402 .SPEED_TENTHS
op div :processUnit.2:distance *tmp403 10
label *label244
label *label241
jump *label247 notEqual :processUnit.2:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp407
jump *label249 equal *tmp407 false
jump *label251 equal .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.2:msg ", supplying\n"
jump *label252 always
label *label251
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:msg ", waiting\n"
label *label252
sensor *tmp410 @unit @totalItems
jump *label250 greaterThan *tmp410 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:state 2
jump *label250 always
label *label249
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:msg ", returning in [gold]"
sensor *tmp413 @unit @x
op sub *tmp414 .DOME_X *tmp413
sensor *tmp415 @unit @y
op sub *tmp416 .DOME_Y *tmp415
op len *tmp417 *tmp414 *tmp416
op idiv *tmp418 *tmp417 .SPEED_TENTHS
op div :processUnit.2:distance *tmp418 10
label *label250
label *label247
ucontrol flag :processUnit.2:state
sensor *tmp420 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp420
jump *label255 lessThan :processUnit.2:distance 0
print :processUnit.2:msg
print :processUnit.2:distance
print "[] sec\n"
jump *label256 always
label *label255
print :processUnit.2:msg
label *label256
set *tmp358 @unit
set .UNIT_P1 *tmp358
jump *label257 equal *tmp139 false
op equal *tmp424 .SUPPLY_P_FIRST false
jump *label261 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp429 @unit @dead
op strictEqual *tmp430 *tmp429 0
sensor *tmp431 @unit @controller
op equal *tmp432 *tmp431 @this
op land *tmp433 *tmp430 *tmp432
jump *label260 notEqual *tmp433 false
label *label261
ubind *tmp3
set :rebindUnit.7:firstUnit @unit
jump __start__ equal :rebindUnit.7:firstUnit null
label *label267
sensor *tmp438 @unit @controlled
jump *label260 equal *tmp438 0
ubind *tmp3
op notEqual *tmp441 @unit :rebindUnit.7:firstUnit
sensor *tmp442 :rebindUnit.7:firstUnit @dead
op equal *tmp443 *tmp442 0
op land *tmp444 *tmp441 *tmp443
jump *label267 notEqual *tmp444 false
end
label *label260
set :processUnit.3:msg ""
sensor :processUnit.3:state @unit @flag
set :processUnit.3:distance -1
op lessThan *tmp446 :processUnit.3:state 2
op greaterThan *tmp447 :processUnit.3:state 3
op or *tmp448 *tmp446 *tmp447
jump *label272 equal *tmp448 false
sensor *tmp450 @unit @firstItem
jump *label274 notEqual *tmp450 @phase-fabric
set :processUnit.3:state 3
jump *label275 always
label *label274
sensor *tmp453 @unit @totalItems
jump *label276 notEqual *tmp453 0
set :processUnit.3:state 2
jump *label277 always
label *label276
set :processUnit.3:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp456
jump *label278 equal *tmp456 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label278
label *label277
label *label275
label *label272
jump *label280 notEqual :processUnit.3:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp460
jump *label282 equal *tmp460 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp462 @unit @totalItems
jump *label284 lessThan *tmp462 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:state 3
jump *label283 always
label *label284
set :processUnit.3:msg ", loading\n"
jump *label283 always
label *label282
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:msg ", fetching in [gold]"
sensor *tmp465 @unit @x
op sub *tmp466 .CORE_X *tmp465
sensor *tmp467 @unit @y
op sub *tmp468 .CORE_Y *tmp467
op len *tmp469 *tmp466 *tmp468
op idiv *tmp470 *tmp469 .SPEED_TENTHS
op div :processUnit.3:distance *tmp470 10
label *label283
label *label280
jump *label286 notEqual :processUnit.3:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp474
jump *label288 equal *tmp474 false
jump *label290 equal *tmp424 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.3:msg ", supplying\n"
jump *label291 always
label *label290
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:msg ", waiting\n"
label *label291
sensor *tmp477 @unit @totalItems
jump *label289 greaterThan *tmp477 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:state 2
jump *label289 always
label *label288
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:msg ", returning in [gold]"
sensor *tmp480 @unit @x
op sub *tmp481 .DOME_X *tmp480
sensor *tmp482 @unit @y
op sub *tmp483 .DOME_Y *tmp482
op len *tmp484 *tmp481 *tmp483
op idiv *tmp485 *tmp484 .SPEED_TENTHS
op div :processUnit.3:distance *tmp485 10
label *label289
label *label286
ucontrol flag :processUnit.3:state
sensor *tmp487 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp487
jump *label294 lessThan :processUnit.3:distance 0
print :processUnit.3:msg
print :processUnit.3:distance
print "[] sec\n"
jump *label295 always
label *label294
print :processUnit.3:msg
label *label295
set *tmp425 @unit
set .UNIT_P2 *tmp425
jump *label296 equal .SUPPLY_P_FIRST false
sensor *tmp491 *tmp358 @totalItems
op greaterThan .SUPPLY_P_FIRST *tmp491 0
jump *label297 always
label *label296
sensor *tmp493 *tmp425 @totalItems
op equal .SUPPLY_P_FIRST *tmp493 0
label *label297
label *label257
op sub *tmp495 @time :start
op floor *tmp496 *tmp495
print "\n[lightgray]Loop time: {0} ms"
format *tmp496
printflush message1
op notEqual *tmp497 *tmp3 UNIT_TYPE
op greaterThan *tmp498 :unitCheck @time
op land *tmp499 *tmp497 *tmp498
jump *label298 equal *tmp499 false
set :areUnitsAvailable.2:occupied 0
set :areUnitsAvailable.2:free 0
ubind UNIT_TYPE
set :areUnitsAvailable.2:firstUnit @unit
jump *label313 equal :areUnitsAvailable.2:firstUnit null
set *tmp513 2
set :needsFourUnits.3:unit @unit
sensor *tmp510 :needsFourUnits.3:unit @speed
op div :needsFourUnits.3:travel_time *tmp143 *tmp510
jump *label305 lessThan :needsFourUnits.3:travel_time 47
set *tmp513 4
label *label305
label *label306
sensor *tmp514 @unit @controlled
op equal *tmp515 *tmp514 0
sensor *tmp516 @unit @controller
op equal *tmp517 *tmp516 @this
op or *tmp518 *tmp515 *tmp517
jump *label309 equal *tmp518 false
op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
jump *label310 lessThan :areUnitsAvailable.2:free *tmp513
set *tmp501 true
jump *label300 always
label *label309
op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
label *label310
ubind UNIT_TYPE
op notEqual *tmp522 @unit :areUnitsAvailable.2:firstUnit
sensor *tmp523 :areUnitsAvailable.2:firstUnit @dead
op equal *tmp524 *tmp523 0
op land *tmp525 *tmp522 *tmp524
jump *label306 notEqual *tmp525 false
label *label313
set *tmp501 false
label *label300
jump *label317 equal *tmp501 false
end
label *label317
op add :unitCheck @time 5000
label *label298
sensor *tmp211 switch1 @enabled
jump *label321 notEqual *tmp211 false
