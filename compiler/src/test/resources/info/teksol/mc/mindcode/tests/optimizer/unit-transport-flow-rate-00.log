   133 instructions before optimizations.
    28 instructions eliminated by Temp Variables Elimination (7 iterations).
     4 instructions eliminated by Dead Code Elimination (4 iterations).
     9 instructions eliminated by Condition Optimization (6 iterations).
     5 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Expression Optimization (2 passes, 3 iterations).
    11 instructions eliminated by Data Flow Optimization (3 passes, 10 iterations).
     3 instructions added by Loop Rotation (3 iterations).
       3 loop conditions were partially rotated.
     1 instructions eliminated by Jump Straightening (6 iterations).
     3 instructions updated by Jump Threading.
    11 instructions eliminated by Print Merging.
    66 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 924):
    Partial loop rotation at line 17:1                           size    +2, benefit       25.0, efficiency     12.500
  * Partial loop rotation at line 38:1                           size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)

Pass 1: speed optimization selection (cost limit 923):
  * Partial loop rotation at line 17:1                           size    +2, benefit       25.0, efficiency     12.500 (+2 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-4 instructions):
 
    71 print "Wait reset\n"
    72 op add *tmp22 :start .DELAY
    73 set :wait *tmp22
-    * set *tmp21 :wait
    74 jump *label13 always
    75 label *label12
-    * set *tmp21 null
    76 label *label13
    77 set *tmp23 .IND_SHIPPED
    78 read *tmp24 .BANK *tmp23
 
    86 op add .MILLIS .MILLIS .DELAY
    87 op mul *tmp29 .MULTIPLIER .MILLIS
    88 set .SIGN_MILLIS *tmp29
-    * set *tmp28 .SIGN_MILLIS
    89 jump *label15 always
    90 label *label14
    91 set *tmp30 :index
    92 read *tmp31 .BANK *tmp30
    93 set :last_total *tmp31
-    * set *tmp28 :last_total
    94 label *label15
    95 set *tmp32 :index
    96 write :total .BANK *tmp32

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-27 instructions):
 
     4 set .IND_SESSION_KEY 509
     5 set .IND_TIME 508
     6 set .IND_FLOW_RATE 507
-    * op mul *tmp0 .DELAY .SAMPLES
-    * set .TOTAL_MILLIS *tmp0
+    7 op mul .TOTAL_MILLIS .DELAY .SAMPLES
     8 set .SIGN_MILLIS null
     9 set .SORTER sorter1
    10 set .VAULT vault1
 
    29 label *label1
    30 jump *label0 always
    31 label *label2
-    * set *tmp4 .IND_SHIPPED
-    * read *tmp5 .BANK *tmp4
-    * set :shipped *tmp5
-    * set *tmp6 .IND_MULTIPLIER
-    * read *tmp7 .BANK *tmp6
-    * set .MULTIPLIER *tmp7
-    * set *tmp8 .IND_SESSION_KEY
-    * read *tmp9 .BANK *tmp8
-    * set .SESSION_KEY *tmp9
-    * sensor *tmp10 .SORTER @config
-    * set :item *tmp10
+   32 read :shipped .BANK .IND_SHIPPED
+   33 read .MULTIPLIER .BANK .IND_MULTIPLIER
+   34 read .SESSION_KEY .BANK .IND_SESSION_KEY
+   35 sensor :item .SORTER @config
    36 set :last_total :shipped
    37 set :index 0
    38 set .MILLIS 0
 
    48 jump *label8 equal *tmp14 false
    49 jump *label10 always
    50 label *label10
-    * set *tmp15 .IND_SESSION_KEY
-    * read *tmp16 .BANK *tmp15
+   51 read *tmp16 .BANK .IND_SESSION_KEY
    52 op strictEqual *tmp17 .SESSION_KEY *tmp16
    53 jump *label8 equal *tmp17 false
    54 jump *label9 always
    55 label *label9
-    * set *tmp18 @time
-    * set :start *tmp18
-    * op add *tmp19 :wait .DELAY
-    * set :wait *tmp19
+   56 set :start @time
+   57 op add :wait :wait .DELAY
    58 op greaterThan *tmp20 :start :wait
    59 jump *label12 equal *tmp20 false
    60 print "Wait reset\n"
-    * op add *tmp22 :start .DELAY
-    * set :wait *tmp22
+   61 op add :wait :start .DELAY
    62 jump *label13 always
    63 label *label12
    64 label *label13
-    * set *tmp23 .IND_SHIPPED
-    * read *tmp24 .BANK *tmp23
-    * set :shipped *tmp24
-    * sensor *tmp25 .SORTER @config
-    * set :item *tmp25
-    * op add *tmp26 :level :shipped
-    * set :total *tmp26
+   65 read :shipped .BANK .IND_SHIPPED
+   66 sensor :item .SORTER @config
+   67 op add :total :level :shipped
    68 op lessThan *tmp27 .MILLIS .TOTAL_MILLIS
    69 jump *label14 equal *tmp27 false
    70 op add .MILLIS .MILLIS .DELAY
-    * op mul *tmp29 .MULTIPLIER .MILLIS
-    * set .SIGN_MILLIS *tmp29
+   71 op mul .SIGN_MILLIS .MULTIPLIER .MILLIS
    72 jump *label15 always
    73 label *label14
-    * set *tmp30 :index
-    * read *tmp31 .BANK *tmp30
-    * set :last_total *tmp31
+   74 read :last_total .BANK :index
    75 label *label15
-    * set *tmp32 :index
-    * write :total .BANK *tmp32
+   76 write :total .BANK :index
    77 op sub *tmp34 :total :last_total
-    * op div *tmp35 *tmp34 .SIGN_MILLIS
-    * set :flow_rate *tmp35
-    * set *tmp36 .IND_FLOW_RATE
-    * write :flow_rate .BANK *tmp36
+   78 op div :flow_rate *tmp34 .SIGN_MILLIS
+   79 write :flow_rate .BANK .IND_FLOW_RATE
    80 set *tmp38 .IND_TIME
-    * set *tmp40 @time
-    * write *tmp40 .BANK *tmp38
+   81 write @time .BANK *tmp38
    82 op add *tmp41 :index 1
-    * op mod *tmp42 *tmp41 .SAMPLES
-    * set :index *tmp42
+   83 op mod :index *tmp41 .SAMPLES
    84 op mul *tmp43 60000 :flow_rate
-    * op floor *tmp44 *tmp43
-    * set :flow_rate_str *tmp44
-    * op div *tmp45 .MILLIS 1000
-    * set :seconds *tmp45
-    * op sub *tmp46 @time :start
-    * set :elapsed *tmp46
+   85 op floor :flow_rate_str *tmp43
+   86 op div :seconds .MILLIS 1000
+   87 op sub :elapsed @time :start
    88 print "Measured interval: "
    89 print :seconds
    90 print " sec"

Modifications by Initial phase, Temp Variables Elimination, iteration 2 (-1 instructions):
 
    77 op sub *tmp34 :total :last_total
    78 op div :flow_rate *tmp34 .SIGN_MILLIS
    79 write :flow_rate .BANK .IND_FLOW_RATE
-    * set *tmp38 .IND_TIME
-    * write @time .BANK *tmp38
+   80 write @time .BANK .IND_TIME
    81 op add *tmp41 :index 1
    82 op mod :index *tmp41 .SAMPLES
    83 op mul *tmp43 60000 :flow_rate

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-1 instructions):
 
    18 jump *label4 always
    19 label *label4
    20 op equal *tmp3 .BANK null
-    * jump *label3 notEqual *tmp3 false
-    * jump *label2 always
+   21 jump *label2 equal *tmp3 false
    22 label *label3
    23 print "Missing sorter, vault or memory bank."
    24 printflush message1

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-9 instructions):
 
    10 set .VAULT vault1
    11 set .BANK bank1
    12 label *label0
-    * op equal *tmp1 .SORTER null
-    * jump *label3 notEqual *tmp1 false
+   13 jump *label3 equal .SORTER null
    14 label *label5
-    * op equal *tmp2 .VAULT null
-    * jump *label3 notEqual *tmp2 false
+   15 jump *label3 equal .VAULT null
    16 jump *label4 always
    17 label *label4
-    * op equal *tmp3 .BANK null
-    * jump *label2 equal *tmp3 false
+   18 jump *label2 notEqual .BANK null
    19 label *label3
    20 print "Missing sorter, vault or memory bank."
    21 printflush message1
 
    36 set :wait 0
    37 label *label6
    38 sensor *tmp11 .SORTER @dead
-    * op strictEqual *tmp12 *tmp11 0
-    * jump *label8 equal *tmp12 false
+   39 jump *label8 strictNotEqual *tmp11 0
    40 label *label11
    41 sensor *tmp13 .VAULT @dead
-    * op strictEqual *tmp14 *tmp13 0
-    * jump *label8 equal *tmp14 false
+   42 jump *label8 strictNotEqual *tmp13 0
    43 jump *label10 always
    44 label *label10
    45 read *tmp16 .BANK .IND_SESSION_KEY
-    * op strictEqual *tmp17 .SESSION_KEY *tmp16
-    * jump *label8 equal *tmp17 false
+   46 jump *label8 strictNotEqual .SESSION_KEY *tmp16
    47 jump *label9 always
    48 label *label9
    49 set :start @time
    50 op add :wait :wait .DELAY
-    * op greaterThan *tmp20 :start :wait
-    * jump *label12 equal *tmp20 false
+   51 jump *label12 lessThanEq :start :wait
    52 print "Wait reset\n"
    53 op add :wait :start .DELAY
    54 jump *label13 always
 
    57 read :shipped .BANK .IND_SHIPPED
    58 sensor :item .SORTER @config
    59 op add :total :level :shipped
-    * op lessThan *tmp27 .MILLIS .TOTAL_MILLIS
-    * jump *label14 equal *tmp27 false
+   60 jump *label14 greaterThanEq .MILLIS .TOTAL_MILLIS
    61 op add .MILLIS .MILLIS .DELAY
    62 op mul .SIGN_MILLIS .MULTIPLIER .MILLIS
    63 jump *label15 always
 
    98 printflush message1
    99 set :loops 0
   100 label *label16
-    * op lessThan *tmp47 @time :wait
-    * jump *label18 equal *tmp47 false
+  101 jump *label18 greaterThanEq @time :wait
   102 op add :loops :loops 1
   103 label *label17
   104 jump *label16 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-4 instructions):
 
    13 jump *label3 equal .SORTER null
    14 label *label5
    15 jump *label3 equal .VAULT null
-    * jump *label4 always
    16 label *label4
    17 jump *label2 notEqual .BANK null
    18 label *label3
 
    39 label *label11
    40 sensor *tmp13 .VAULT @dead
    41 jump *label8 strictNotEqual *tmp13 0
-    * jump *label10 always
    42 label *label10
    43 read *tmp16 .BANK .IND_SESSION_KEY
    44 jump *label8 strictNotEqual .SESSION_KEY *tmp16
-    * jump *label9 always
    45 label *label9
    46 set :start @time
    47 op add :wait :wait .DELAY
    48 jump *label12 lessThanEq :start :wait
    49 print "Wait reset\n"
    50 op add :wait :start .DELAY
-    * jump *label13 always
    51 label *label12
    52 label *label13
    53 read :shipped .BANK .IND_SHIPPED

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    67 write @time .BANK .IND_TIME
    68 op add *tmp41 :index 1
    69 op mod :index *tmp41 .SAMPLES
-    * op mul *tmp43 60000 :flow_rate
-    * op floor :flow_rate_str *tmp43
+   70 op idiv :flow_rate_str :flow_rate 0.000016666666666666667
    71 op div :seconds .MILLIS 1000
    72 op sub :elapsed @time :start
    73 print "Measured interval: "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
     4 set .IND_SESSION_KEY 509
     5 set .IND_TIME 508
     6 set .IND_FLOW_RATE 507
-    * op mul .TOTAL_MILLIS .DELAY .SAMPLES
+    7 op mul .TOTAL_MILLIS 1000 10
     8 set .SIGN_MILLIS null
     9 set .SORTER sorter1
    10 set .VAULT vault1
 
    24 label *label1
    25 jump *label0 always
    26 label *label2
-    * read :shipped .BANK .IND_SHIPPED
-    * read .MULTIPLIER .BANK .IND_MULTIPLIER
-    * read .SESSION_KEY .BANK .IND_SESSION_KEY
-    * sensor :item .SORTER @config
+   27 read :shipped .BANK 511
+   28 read .MULTIPLIER .BANK 510
+   29 read .SESSION_KEY .BANK 509
    30 set :last_total :shipped
    31 set :index 0
    32 set .MILLIS 0
 
    39 sensor *tmp13 .VAULT @dead
    40 jump *label8 strictNotEqual *tmp13 0
    41 label *label10
-    * read *tmp16 .BANK .IND_SESSION_KEY
+   42 read *tmp16 .BANK 509
    43 jump *label8 strictNotEqual .SESSION_KEY *tmp16
    44 label *label9
    45 set :start @time
-    * op add :wait :wait .DELAY
+   46 op add :wait :wait 1000
    47 jump *label12 lessThanEq :start :wait
    48 print "Wait reset\n"
-    * op add :wait :start .DELAY
+   49 op add :wait :start 1000
    50 label *label12
    51 label *label13
-    * read :shipped .BANK .IND_SHIPPED
+   52 read :shipped .BANK 511
    53 sensor :item .SORTER @config
-    * op add :total :level :shipped
-    * jump *label14 greaterThanEq .MILLIS .TOTAL_MILLIS
-    * op add .MILLIS .MILLIS .DELAY
+   54 op add :total 0 :shipped
+   55 jump *label14 greaterThanEq .MILLIS 10000
+   56 op add .MILLIS .MILLIS 1000
    57 op mul .SIGN_MILLIS .MULTIPLIER .MILLIS
    58 jump *label15 always
    59 label *label14
 
    62 write :total .BANK :index
    63 op sub *tmp34 :total :last_total
    64 op div :flow_rate *tmp34 .SIGN_MILLIS
-    * write :flow_rate .BANK .IND_FLOW_RATE
-    * write @time .BANK .IND_TIME
+   65 write :flow_rate .BANK 507
+   66 write @time .BANK 508
    67 op add *tmp41 :index 1
-    * op mod :index *tmp41 .SAMPLES
+   68 op mod :index *tmp41 10
    69 op idiv :flow_rate_str :flow_rate 0.000016666666666666667
    70 op div :seconds .MILLIS 1000
    71 op sub :elapsed @time :start
 
    77 print "\nItems shipped: "
    78 print :shipped
    79 print "\nContainer level: "
-    * print :level
+   80 print 0
    81 print "\nFlow rate: "
    82 print :flow_rate_str
    83 print "\nTotal: "

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-9 instructions):
-    * set .DELAY 1000
-    * set .SAMPLES 10
-    * set .IND_SHIPPED 511
-    * set .IND_MULTIPLIER 510
-    * set .IND_SESSION_KEY 509
-    * set .IND_TIME 508
-    * set .IND_FLOW_RATE 507
-    * op mul .TOTAL_MILLIS 1000 10
     0 set .SIGN_MILLIS null
     1 set .SORTER sorter1
     2 set .VAULT vault1
 
    22 set :last_total :shipped
    23 set :index 0
    24 set .MILLIS 0
-    * set :level 0
    25 set :wait 0
    26 label *label6
    27 sensor *tmp11 .SORTER @dead

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     3 set .BANK bank1
     4 label *label0
     5 jump *label3 equal .SORTER null
-    * label *label5
     6 jump *label3 equal .VAULT null
-    * label *label4
     7 jump *label2 notEqual .BANK null
     8 label *label3
     9 print "Missing sorter, vault or memory bank."
 
    24 label *label6
    25 sensor *tmp11 .SORTER @dead
    26 jump *label8 strictNotEqual *tmp11 0
-    * label *label11
    27 sensor *tmp13 .VAULT @dead
    28 jump *label8 strictNotEqual *tmp13 0
-    * label *label10
    29 read *tmp16 .BANK 509
    30 jump *label8 strictNotEqual .SESSION_KEY *tmp16
-    * label *label9
    31 set :start @time
    32 op add :wait :wait 1000
    33 jump *label12 lessThanEq :start :wait
 
    79 set :loops 0
    80 label *label16
    81 jump *label18 greaterThanEq @time :wait
+   82 label *label19
    83 op add :loops :loops 1
    84 label *label17
-    * jump *label16 always
+   85 jump *label19 lessThan @time :wait
    86 label *label18
    87 label *label7
    88 jump *label6 always

Modifications by Partial loop rotation at line 38:1 (+1 instructions):
 
    24 label *label6
    25 sensor *tmp11 .SORTER @dead
    26 jump *label8 strictNotEqual *tmp11 0
+   27 label *label20
    28 sensor *tmp13 .VAULT @dead
    29 jump *label8 strictNotEqual *tmp13 0
    30 read *tmp16 .BANK 509
 
    86 jump *label19 lessThan @time :wait
    87 label *label18
    88 label *label7
-    * jump *label6 always
+   89 sensor *tmp11 .SORTER @dead
+   90 jump *label20 strictEqual *tmp11 0
    91 label *label8
    92 end

Modifications by Partial loop rotation at line 17:1 (+2 instructions):
 
     5 jump *label3 equal .SORTER null
     6 jump *label3 equal .VAULT null
     7 jump *label2 notEqual .BANK null
+    8 label *label22
     9 label *label3
    10 print "Missing sorter, vault or memory bank."
    11 printflush message1
 
    13 set .VAULT vault1
    14 set .BANK bank1
    15 label *label1
-    * jump *label0 always
+   16 jump *label3 equal .SORTER null
+   17 jump *label3 equal .VAULT null
+   18 jump *label22 equal .BANK null
    19 label *label2
    20 read :shipped .BANK 511
    21 read .MULTIPLIER .BANK 510

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set .VAULT vault1
     3 set .BANK bank1
     4 label *label0
-    * jump *label3 equal .SORTER null
-    * jump *label3 equal .VAULT null
-    * jump *label2 notEqual .BANK null
+    5 jump *label3 equal sorter1 null
+    6 jump *label3 equal vault1 null
+    7 jump *label2 notEqual bank1 null
     8 label *label22
     9 label *label3
    10 print "Missing sorter, vault or memory bank."

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    41 label *label13
    42 read :shipped .BANK 511
    43 sensor :item .SORTER @config
-    * op add :total 0 :shipped
+   44 set :total :shipped
    45 jump *label14 greaterThanEq .MILLIS 10000
    46 op add .MILLIS .MILLIS 1000
    47 op mul .SIGN_MILLIS .MULTIPLIER .MILLIS

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    49 label *label14
    50 read :last_total .BANK :index
    51 label *label15
-    * write :total .BANK :index
-    * op sub *tmp34 :total :last_total
+   52 write :shipped .BANK :index
+   53 op sub *tmp34 :shipped :last_total
    54 op div :flow_rate *tmp34 .SIGN_MILLIS
    55 write :flow_rate .BANK 507
    56 write @time .BANK 508
 
    71 print "\nFlow rate: "
    72 print :flow_rate_str
    73 print "\nTotal: "
-    * print :total
+   74 print :shipped
    75 print "\nLast total: "
    76 print :last_total
    77 print "\nIndex: "

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
    41 label *label13
    42 read :shipped .BANK 511
    43 sensor :item .SORTER @config
-    * set :total :shipped
    44 jump *label14 greaterThanEq .MILLIS 10000
    45 op add .MILLIS .MILLIS 1000
    46 op mul .SIGN_MILLIS .MULTIPLIER .MILLIS

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 set .SIGN_MILLIS null
     2 set .SORTER sorter1
     3 set .VAULT vault1
 
    24 set .MILLIS 0
    25 set :wait 0
    26 sensor *tmp11 .SORTER @dead
-    * jump *label8 strictNotEqual *tmp11 0
+   27 jump __start__ strictNotEqual *tmp11 0
    28 label *label20
    29 sensor *tmp13 .VAULT @dead
-    * jump *label8 strictNotEqual *tmp13 0
+   30 jump __start__ strictNotEqual *tmp13 0
    31 read *tmp16 .BANK 509
-    * jump *label8 strictNotEqual .SESSION_KEY *tmp16
+   32 jump __start__ strictNotEqual .SESSION_KEY *tmp16
    33 set :start @time
    34 op add :wait :wait 1000
    35 jump *label12 lessThanEq :start :wait

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
    84 label *label18
    85 sensor *tmp11 .SORTER @dead
    86 jump *label20 strictEqual *tmp11 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-11 instructions):
 
    55 op idiv :flow_rate_str :flow_rate 0.000016666666666666667
    56 op div :seconds .MILLIS 1000
    57 op sub :elapsed @time :start
-    * print "Measured interval: "
-    * print :seconds
-    * print " sec"
-    * print "\nItem: "
-    * print :item
-    * print "\nItems shipped: "
-    * print :shipped
-    * print "\nContainer level: "
-    * print 0
-    * print "\nFlow rate: "
-    * print :flow_rate_str
-    * print "\nTotal: "
-    * print :shipped
-    * print "\nLast total: "
-    * print :last_total
-    * print "\nIndex: "
-    * print :index
-    * print "\nElapsed: "
-    * print :elapsed
-    * print " ms"
+   58 print "Measured interval: {0} sec\nItem: {0}\nItems shipped: {0}\nContainer level: 0\nFlow rate: {0}\nTotal: {0}\nLast total: {0}\nIndex: {0}\nElapsed: {0} ms"
+   59 format :seconds
+   60 format :item
+   61 format :shipped
+   62 format :flow_rate_str
+   63 format :shipped
+   64 format :last_total
+   65 format :index
+   66 format :elapsed
    67 printflush message1
    68 set :loops 0
    69 jump *label18 greaterThanEq @time :wait

Final code before resolving virtual instructions:

label __start__
set .SIGN_MILLIS null
set .SORTER sorter1
set .VAULT vault1
set .BANK bank1
jump *label3 equal sorter1 null
jump *label3 equal vault1 null
jump *label2 notEqual bank1 null
label *label22
label *label3
print "Missing sorter, vault or memory bank."
printflush message1
set .SORTER sorter1
set .VAULT vault1
set .BANK bank1
jump *label3 equal .SORTER null
jump *label3 equal .VAULT null
jump *label22 equal .BANK null
label *label2
read :shipped .BANK 511
read .MULTIPLIER .BANK 510
read .SESSION_KEY .BANK 509
set :last_total :shipped
set :index 0
set .MILLIS 0
set :wait 0
sensor *tmp11 .SORTER @dead
jump __start__ strictNotEqual *tmp11 0
label *label20
sensor *tmp13 .VAULT @dead
jump __start__ strictNotEqual *tmp13 0
read *tmp16 .BANK 509
jump __start__ strictNotEqual .SESSION_KEY *tmp16
set :start @time
op add :wait :wait 1000
jump *label12 lessThanEq :start :wait
print "Wait reset\n"
op add :wait :start 1000
label *label12
read :shipped .BANK 511
sensor :item .SORTER @config
jump *label14 greaterThanEq .MILLIS 10000
op add .MILLIS .MILLIS 1000
op mul .SIGN_MILLIS .MULTIPLIER .MILLIS
jump *label15 always
label *label14
read :last_total .BANK :index
label *label15
write :shipped .BANK :index
op sub *tmp34 :shipped :last_total
op div :flow_rate *tmp34 .SIGN_MILLIS
write :flow_rate .BANK 507
write @time .BANK 508
op add *tmp41 :index 1
op mod :index *tmp41 10
op idiv :flow_rate_str :flow_rate 0.000016666666666666667
op div :seconds .MILLIS 1000
op sub :elapsed @time :start
print "Measured interval: {0} sec\nItem: {0}\nItems shipped: {0}\nContainer level: 0\nFlow rate: {0}\nTotal: {0}\nLast total: {0}\nIndex: {0}\nElapsed: {0} ms"
format :seconds
format :item
format :shipped
format :flow_rate_str
format :shipped
format :last_total
format :index
format :elapsed
printflush message1
set :loops 0
jump *label18 greaterThanEq @time :wait
label *label19
op add :loops :loops 1
jump *label19 lessThan @time :wait
label *label18
sensor *tmp11 .SORTER @dead
jump *label20 strictEqual *tmp11 0
