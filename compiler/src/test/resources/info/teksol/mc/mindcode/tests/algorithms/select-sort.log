    45 instructions before optimizations.
     8 instructions eliminated by Temp Variables Elimination (2 iterations).
     2 instructions eliminated by Dead Code Elimination (4 iterations).
     1 instructions eliminated by Jump Optimization (5 iterations).
     2 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     3 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     3 instructions modified by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
    29 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    20 jump *label6 equal *tmp7 false
    21 set :min :curr
    22 set :min_index :j
-    * set *tmp8 :min_index
    23 jump *label7 always
    24 label *label6
-    * set *tmp8 null
    25 label *label7
    26 label *label4
    27 op add :j :j 1

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-8 instructions):
     0 set SIZE 128
     1 set ARRAY bank2
     2 set FINAL bank3
-    * op sub *tmp0 SIZE 1
-    * set *tmp1 *tmp0
+    3 op sub *tmp1 SIZE 1
     4 set :i 0
     5 label *label0
     6 jump *label2 greaterThanEq :i *tmp1
-    * set *tmp2 :i
-    * read *tmp3 ARRAY *tmp2
-    * set :min *tmp3
+    7 read :min ARRAY :i
     8 set :min_index :i
-    * op add *tmp4 :i 1
-    * set :j *tmp4
+    9 op add :j :i 1
    10 label *label3
    11 jump *label5 greaterThanEq :j SIZE
-    * set *tmp5 :j
-    * read *tmp6 ARRAY *tmp5
-    * set :curr *tmp6
+   12 read :curr ARRAY :j
    13 op lessThan *tmp7 :curr :min
    14 jump *label6 equal *tmp7 false
    15 set :min :curr
 
    22 jump *label3 always
    23 label *label5
    24 set *tmp9 :min_index
-    * set *tmp11 :i
-    * read *tmp12 ARRAY *tmp11
+   25 read *tmp12 ARRAY :i
    26 write *tmp12 ARRAY *tmp9
-    * set *tmp13 :i
-    * write :min ARRAY *tmp13
+   27 write :min ARRAY :i
    28 label *label1
    29 op add :i :i 1
    30 jump *label0 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-1 instructions):
 
    10 label *label3
    11 jump *label5 greaterThanEq :j SIZE
    12 read :curr ARRAY :j
-    * op lessThan *tmp7 :curr :min
-    * jump *label6 equal *tmp7 false
+   13 jump *label6 greaterThanEq :curr :min
    14 set :min :curr
    15 set :min_index :j
    16 jump *label7 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-1 instructions):
 
    13 jump *label6 greaterThanEq :curr :min
    14 set :min :curr
    15 set :min_index :j
-    * jump *label7 always
    16 label *label6
    17 label *label7
    18 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    21 label *label5
    22 set *tmp9 :min_index
    23 read *tmp12 ARRAY :i
-    * write *tmp12 ARRAY *tmp9
+   24 write *tmp12 ARRAY :min_index
    25 write :min ARRAY :i
    26 label *label1
    27 op add :i :i 1
 
    32 jump *label10 greaterThanEq :i SIZE
    33 set *tmp15 :i
    34 set *tmp17 :i
-    * read *tmp16 FINAL *tmp15
-    * read *tmp18 ARRAY *tmp17
+   35 read *tmp16 FINAL :i
+   36 read *tmp18 ARRAY :i
    37 assertequals *tmp16 *tmp18 "unexpected value"
    38 label *label9
    39 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    19 op add :j :j 1
    20 jump *label3 always
    21 label *label5
-    * set *tmp9 :min_index
    22 read *tmp12 ARRAY :i
    23 write *tmp12 ARRAY :min_index
    24 write :min ARRAY :i
 
    29 set :i 0
    30 label *label8
    31 jump *label10 greaterThanEq :i SIZE
-    * set *tmp15 :i
-    * set *tmp17 :i
    32 read *tmp16 FINAL :i
    33 read *tmp18 ARRAY :i
    34 assertequals *tmp16 *tmp18 "unexpected value"

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     4 set :i 0
     5 label *label0
     6 jump *label2 greaterThanEq :i *tmp1
+    7 label *label11
     8 read :min ARRAY :i
     9 set :min_index :i
    10 op add :j :i 1
    11 label *label3
    12 jump *label5 greaterThanEq :j SIZE
+   13 label *label12
    14 read :curr ARRAY :j
    15 jump *label6 greaterThanEq :curr :min
    16 set :min :curr
 
    19 label *label7
    20 label *label4
    21 op add :j :j 1
-    * jump *label3 always
+   22 jump *label12 lessThan :j SIZE
    23 label *label5
    24 read *tmp12 ARRAY :i
    25 write *tmp12 ARRAY :min_index
    26 write :min ARRAY :i
    27 label *label1
    28 op add :i :i 1
-    * jump *label0 always
+   29 jump *label11 lessThan :i *tmp1
    30 label *label2
    31 set :i 0
    32 label *label8
    33 jump *label10 greaterThanEq :i SIZE
+   34 label *label13
    35 read *tmp16 FINAL :i
    36 read *tmp18 ARRAY :i
    37 assertequals *tmp16 *tmp18 "unexpected value"
    38 label *label9
    39 op add :i :i 1
-    * jump *label8 always
+   40 jump *label13 lessThan :i SIZE
    41 label *label10
    42 stop
    43 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
     3 op sub *tmp1 SIZE 1
     4 set :i 0
     5 label *label0
-    * jump *label2 greaterThanEq :i *tmp1
+    6 jump *label2 greaterThanEq 0 *tmp1
     7 label *label11
     8 read :min ARRAY :i
     9 set :min_index :i
 
    30 label *label2
    31 set :i 0
    32 label *label8
-    * jump *label10 greaterThanEq :i SIZE
+   33 jump *label10 greaterThanEq 0 SIZE
    34 label *label13
    35 read *tmp16 FINAL :i
    36 read *tmp18 ARRAY :i

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     2 set FINAL bank3
     3 op sub *tmp1 SIZE 1
     4 set :i 0
-    * label *label0
     5 jump *label2 greaterThanEq 0 *tmp1
     6 label *label11
     7 read :min ARRAY :i
     8 set :min_index :i
     9 op add :j :i 1
-    * label *label3
    10 jump *label5 greaterThanEq :j SIZE
    11 label *label12
    12 read :curr ARRAY :j
 
    14 set :min :curr
    15 set :min_index :j
    16 label *label6
-    * label *label7
-    * label *label4
    17 op add :j :j 1
    18 jump *label12 lessThan :j SIZE
    19 label *label5
    20 read *tmp12 ARRAY :i
    21 write *tmp12 ARRAY :min_index
    22 write :min ARRAY :i
-    * label *label1
    23 op add :i :i 1
    24 jump *label11 lessThan :i *tmp1
    25 label *label2
    26 set :i 0
-    * label *label8
    27 jump *label10 greaterThanEq 0 SIZE
    28 label *label13
    29 read *tmp16 FINAL :i
    30 read *tmp18 ARRAY :i
    31 assertequals *tmp16 *tmp18 "unexpected value"
-    * label *label9
    32 op add :i :i 1
    33 jump *label13 lessThan :i SIZE
    34 label *label10

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
    33 jump *label13 lessThan :i SIZE
    34 label *label10
    35 stop
-    * end

Final code before resolving virtual instructions:

set SIZE 128
set ARRAY bank2
set FINAL bank3
op sub *tmp1 SIZE 1
set :i 0
jump *label2 greaterThanEq 0 *tmp1
label *label11
read :min ARRAY :i
set :min_index :i
op add :j :i 1
jump *label5 greaterThanEq :j SIZE
label *label12
read :curr ARRAY :j
jump *label6 greaterThanEq :curr :min
set :min :curr
set :min_index :j
label *label6
op add :j :j 1
jump *label12 lessThan :j SIZE
label *label5
read *tmp12 ARRAY :i
write *tmp12 ARRAY :min_index
write :min ARRAY :i
op add :i :i 1
jump *label11 lessThan :i *tmp1
label *label2
set :i 0
jump *label10 greaterThanEq 0 SIZE
label *label13
read *tmp16 FINAL :i
read *tmp18 ARRAY :i
assertequals *tmp16 *tmp18 "unexpected value"
op add :i :i 1
jump *label13 lessThan :i SIZE
label *label10
stop
