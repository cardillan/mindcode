   262 instructions before optimizations.
    22 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Case Expression Optimization.
    27 instructions eliminated by Dead Code Elimination (7 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    12 instructions eliminated by Condition Optimization (2 passes, 5 iterations).
     7 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     2 instructions modified by Expression Optimization (3 iterations).
     9 instructions eliminated by Boolean Optimization (4 iterations).
       3 fully-evaluated conditions turned to a sequence of selects.
     7 instructions eliminated by Data Flow Optimization (3 passes, 11 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
   131 instructions added by Case Switching (5 iterations).
     1 case expressions converted to switched jumps by Case Switching.
     8 instructions eliminated by Jump Straightening (5 iterations).
     2 instructions updated by Jump Threading.
    35 instructions eliminated by Print Merging.
   265 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 827):
  * Replicate loop condition at line 72:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  o Convert case at line 26:9 (segments: 15)                     size    +0, benefit     2013.9, efficiency   Infinity
  o Convert case at line 26:9 (segments: 6)                      size    +1, benefit     2118.1, efficiency   2118.056
  o Convert case at line 26:9 (segments: 4, padded low)          size   +67, benefit     2395.8, efficiency     35.759
  o Convert case at line 26:9 (segments: 6, padded low)          size   +68, benefit     2500.0, efficiency     36.765
  o Convert case at line 26:9 (segments: 2, padded low)          size   +85, benefit     2847.2, efficiency     33.497
  o Convert case at line 26:9 (segments: 5, padded low)          size   +86, benefit     2881.9, efficiency     33.511
  o Convert case at line 26:9 (segments: 3, padded low)          size  +127, benefit     3333.3, efficiency     26.247
  o Convert case at line 26:9 (segments: 1, padded low)          size  +131, benefit     3472.2, efficiency     26.506

Pass 1: speed optimization selection (cost limit 826):
  o Convert case at line 26:9 (segments: 15)                     size    +0, benefit     2013.9, efficiency   Infinity
  o Convert case at line 26:9 (segments: 6)                      size    +1, benefit     2118.1, efficiency   2118.056
  o Convert case at line 26:9 (segments: 4, padded low)          size   +67, benefit     2395.8, efficiency     35.759
  o Convert case at line 26:9 (segments: 6, padded low)          size   +68, benefit     2500.0, efficiency     36.765
  o Convert case at line 26:9 (segments: 2, padded low)          size   +85, benefit     2847.2, efficiency     33.497
  o Convert case at line 26:9 (segments: 5, padded low)          size   +86, benefit     2881.9, efficiency     33.511
  o Convert case at line 26:9 (segments: 3, padded low)          size  +127, benefit     3333.3, efficiency     26.247
  * Convert case at line 26:9 (segments: 1, padded low)          size  +131, benefit     3472.2, efficiency     26.506 (+131 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    26 print :block
    27 print "\n"
    28 sensor *tmp5 :block @type
-    * set *tmp6 *tmp5
-    * jump *label8 equal *tmp6 @message
+   29 jump *label8 equal *tmp5 @message
    30 jump *label7 always
    31 label *label8
    32 set .MESSAGE :block
    33 set *tmp4 .MESSAGE
    34 jump *label6 always
    35 label *label7
-    * jump *label10 equal *tmp6 @switch
+   36 jump *label10 equal *tmp5 @switch
    37 jump *label9 always
    38 label *label10
    39 set .SWITCH :block
    40 set *tmp4 .SWITCH
    41 jump *label6 always
    42 label *label9
-    * jump *label12 equal *tmp6 @sorter
-    * jump *label12 equal *tmp6 @inverted-sorter
-    * jump *label12 equal *tmp6 @unloader
+   43 jump *label12 equal *tmp5 @sorter
+   44 jump *label12 equal *tmp5 @inverted-sorter
+   45 jump *label12 equal *tmp5 @unloader
    46 jump *label11 always
    47 label *label12
    48 set .SORTER :block
    49 set *tmp4 .SORTER
    50 jump *label6 always
    51 label *label11
-    * jump *label14 equal *tmp6 @vault
-    * jump *label14 equal *tmp6 @container
-    * jump *label14 equal *tmp6 @core-shard
-    * jump *label14 equal *tmp6 @core-foundation
-    * jump *label14 equal *tmp6 @core-nucleus
+   52 jump *label14 equal *tmp5 @vault
+   53 jump *label14 equal *tmp5 @container
+   54 jump *label14 equal *tmp5 @core-shard
+   55 jump *label14 equal *tmp5 @core-foundation
+   56 jump *label14 equal *tmp5 @core-nucleus
    57 jump *label13 always
    58 label *label14
    59 set .CONTAINER :block
 
    64 set *tmp4 .START
    65 jump *label6 always
    66 label *label13
-    * jump *label16 equal *tmp6 @liquid-tank
-    * jump *label16 equal *tmp6 @liquid-container
-    * jump *label16 equal *tmp6 @liquid-router
+   67 jump *label16 equal *tmp5 @liquid-tank
+   68 jump *label16 equal *tmp5 @liquid-container
+   69 jump *label16 equal *tmp5 @liquid-router
    70 jump *label15 always
    71 label *label16
    72 set .CONTAINER :block
 
    77 set *tmp4 .START
    78 jump *label6 always
    79 label *label15
-    * jump *label18 equal *tmp6 @battery
-    * jump *label18 equal *tmp6 @battery-large
+   80 jump *label18 equal *tmp5 @battery
+   81 jump *label18 equal *tmp5 @battery-large
    82 jump *label17 always
    83 label *label18
    84 set .CONTAINER :block
 
    89 set *tmp4 .START
    90 jump *label6 always
    91 label *label17
-    * jump *label20 equal *tmp6 @power-node
-    * jump *label20 equal *tmp6 @power-node-large
-    * jump *label20 equal *tmp6 @surge-tower
+   92 jump *label20 equal *tmp5 @power-node
+   93 jump *label20 equal *tmp5 @power-node-large
+   94 jump *label20 equal *tmp5 @surge-tower
    95 jump *label19 always
    96 label *label20
    97 set .CONTAINER :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-17 instructions):
 
    30 jump *label7 always
    31 label *label8
    32 set .MESSAGE :block
-    * set *tmp4 .MESSAGE
    33 jump *label6 always
    34 label *label7
    35 jump *label10 equal *tmp5 @switch
    36 jump *label9 always
    37 label *label10
    38 set .SWITCH :block
-    * set *tmp4 .SWITCH
    39 jump *label6 always
    40 label *label9
    41 jump *label12 equal *tmp5 @sorter
 
    44 jump *label11 always
    45 label *label12
    46 set .SORTER :block
-    * set *tmp4 .SORTER
    47 jump *label6 always
    48 label *label11
    49 jump *label14 equal *tmp5 @vault
 
    58 set .MAXIMUM @itemCapacity
    59 op add *tmp7 :n 1
    60 set .START *tmp7
-    * set *tmp4 .START
    61 jump *label6 always
    62 label *label13
    63 jump *label16 equal *tmp5 @liquid-tank
 
    70 set .MAXIMUM @liquidCapacity
    71 op add *tmp8 :n 1
    72 set .START *tmp8
-    * set *tmp4 .START
    73 jump *label6 always
    74 label *label15
    75 jump *label18 equal *tmp5 @battery
 
    81 set .MAXIMUM @powerCapacity
    82 op add *tmp9 :n 1
    83 set .START *tmp9
-    * set *tmp4 .START
    84 jump *label6 always
    85 label *label17
    86 jump *label20 equal *tmp5 @power-node
 
    93 set .MAXIMUM @powerNetCapacity
    94 op add *tmp10 :n 1
    95 set .START *tmp10
-    * set *tmp4 .START
    96 jump *label6 always
    97 label *label19
-    * set *tmp4 null
    98 label *label6
    99 label *label4
   100 jump *label3 always
 
   115 jump *label21 equal *tmp11 false
   116 print "No container."
   117 print "\n"
-    * set *tmp12 "No container."
   118 jump *label22 always
   119 label *label21
-    * set *tmp12 null
   120 label *label22
   121 printflush .MESSAGE
   122 label *label1
 
   146 label *label24
   147 set *tmp18 null
   148 label *label25
-    * set *tmp16 *tmp18
   149 label *label23
   150 set *tmp21 .SWITCH
   151 control enabled *tmp21 0
 
   167 set :item .SENSOR
   168 print "Measuring [gold]total[] in "
   169 print .CONTAINER
-    * set *tmp29 null
   170 jump *label32 always
   171 label *label31
   172 print "Measuring [gold]"
 
   174 print "["
   175 print "] in "
   176 print .CONTAINER
-    * set *tmp29 null
   177 label *label32
   178 sensor *tmp30 .CONTAINER .MAXIMUM
   179 set :max *tmp30
 
   206 label *label39
   207 set *tmp36 *tmp38
   208 label *label37
-    * set *tmp35 *tmp36
   209 jump *label36 always
   210 label *label35
   211 op greaterThanEq *tmp41 :pct PCT_HIGH
 
   237 label *label42
   238 set *tmp42 null
   239 label *label43
-    * set *tmp35 *tmp42
   240 label *label36
   241 print "\n"
   242 print "Level: [gold]"
 
   254 print PCT_LOW
   255 print "%"
   256 print "[]"
-    * set *tmp48 null
   257 jump *label50 always
   258 label *label49
   259 print "\n"
 
   266 print PCT_HIGH
   267 print "%"
   268 print "[]"
-    * set *tmp48 null
   269 label *label50
   270 print .ACTIVE_TEXT
   271 set :n .START

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
   141 set *tmp20 "\nCurrently inactive:[salmon]"
   142 label *label27
   143 set .ACTIVE_TEXT *tmp20
-    * set *tmp18 .ACTIVE_TEXT
   144 jump *label25 always
   145 label *label24
-    * set *tmp18 null
   146 label *label25
   147 label *label23
   148 set *tmp21 .SWITCH
 
   202 label *label38
   203 set *tmp38 null
   204 label *label39
-    * set *tmp36 *tmp38
   205 label *label37
   206 jump *label36 always
   207 label *label35
 
   229 label *label46
   230 set *tmp43 *tmp45
   231 label *label44
-    * set *tmp42 *tmp43
   232 jump *label43 always
   233 label *label42
-    * set *tmp42 null
   234 label *label43
   235 label *label36
   236 print "\n"

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-3 instructions):
 
   197 set *tmp40 "\nCurrently inactive:[salmon]"
   198 label *label41
   199 set .ACTIVE_TEXT *tmp40
-    * set *tmp38 .ACTIVE_TEXT
   200 jump *label39 always
   201 label *label38
-    * set *tmp38 null
   202 label *label39
   203 label *label37
   204 jump *label36 always
 
   225 label *label45
   226 set *tmp45 null
   227 label *label46
-    * set *tmp43 *tmp45
   228 label *label44
   229 jump *label43 always
   230 label *label42

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   220 set *tmp47 "\nCurrently inactive:[salmon]"
   221 label *label48
   222 set .ACTIVE_TEXT *tmp47
-    * set *tmp45 .ACTIVE_TEXT
   223 jump *label46 always
   224 label *label45
-    * set *tmp45 null
   225 label *label46
   226 label *label44
   227 jump *label43 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-19 instructions):
 
    13 label *label0
    14 print "Configuring regulator..."
    15 print "\n"
-    * set *tmp0 @links
-    * set :n *tmp0
+   16 set :n @links
    17 label *label3
    18 op greaterThan *tmp1 :n 0
    19 jump *label5 equal *tmp1 false
-    * op sub *tmp2 :n 1
-    * set :n *tmp2
-    * getlink *tmp3 :n
-    * set :block *tmp3
+   20 op sub :n :n 1
+   21 getlink :block :n
    22 print "Found: "
    23 print :block
    24 print "\n"
 
    53 set .CONTAINER :block
    54 set .SENSOR @totalItems
    55 set .MAXIMUM @itemCapacity
-    * op add *tmp7 :n 1
-    * set .START *tmp7
+   56 op add .START :n 1
    57 jump *label6 always
    58 label *label13
    59 jump *label16 equal *tmp5 @liquid-tank
 
    64 set .CONTAINER :block
    65 set .SENSOR @totalLiquids
    66 set .MAXIMUM @liquidCapacity
-    * op add *tmp8 :n 1
-    * set .START *tmp8
+   67 op add .START :n 1
    68 jump *label6 always
    69 label *label15
    70 jump *label18 equal *tmp5 @battery
 
    74 set .CONTAINER :block
    75 set .SENSOR @totalPower
    76 set .MAXIMUM @powerCapacity
-    * op add *tmp9 :n 1
-    * set .START *tmp9
+   77 op add .START :n 1
    78 jump *label6 always
    79 label *label17
    80 jump *label20 equal *tmp5 @power-node
 
    85 set .CONTAINER :block
    86 set .SENSOR @powerNetStored
    87 set .MAXIMUM @powerNetCapacity
-    * op add *tmp10 :n 1
-    * set .START *tmp10
+   88 op add .START :n 1
    89 jump *label6 always
    90 label *label19
    91 label *label6
 
   117 jump *label0 notEqual *tmp13 false
   118 label *label2
   119 sensor *tmp14 .SORTER @type
-    * op strictEqual *tmp15 *tmp14 @inverted-sorter
-    * set .INVERTED *tmp15
+  120 op strictEqual .INVERTED *tmp14 @inverted-sorter
   121 # "Function: inline def setState(in newState)"
   122 set :setState:newState true
   123 op notEqual *tmp17 .STATE :setState:newState
   124 jump *label24 equal *tmp17 false
   125 set .STATE :setState:newState
   126 op add .CYCLES .CYCLES 1
-    * op xor *tmp19 .INVERTED .STATE
-    * set .ON *tmp19
+  127 op xor .ON .INVERTED .STATE
   128 jump *label26 equal .ON false
   129 set *tmp20 "\nCurrently active:[green]"
   130 jump *label27 always
 
   136 label *label24
   137 label *label25
   138 label *label23
-    * set *tmp21 .SWITCH
-    * control enabled *tmp21 0
+  139 control enabled .SWITCH 0
   140 label *label28
   141 sensor *tmp23 .SWITCH @enabled
   142 op equal *tmp24 *tmp23 0
   143 jump *label30 equal *tmp24 false
-    * set *tmp25 @time
-    * set :start *tmp25
-    * sensor *tmp26 .SORTER @config
-    * set :item *tmp26
+  144 set :start @time
+  145 sensor :item .SORTER @config
   146 op equal *tmp27 :item null
   147 jump *label33 notEqual *tmp27 false
   148 label *label34
 
   161 print "] in "
   162 print .CONTAINER
   163 label *label32
-    * sensor *tmp30 .CONTAINER .MAXIMUM
-    * set :max *tmp30
-    * sensor *tmp31 .CONTAINER :item
-    * set :amount *tmp31
+  164 sensor :max .CONTAINER .MAXIMUM
+  165 sensor :amount .CONTAINER :item
   166 op mul *tmp32 100 :amount
-    * op idiv *tmp33 *tmp32 :max
-    * set :pct *tmp33
+  167 op idiv :pct *tmp32 :max
   168 op lessThanEq *tmp34 :pct PCT_LOW
   169 jump *label35 equal *tmp34 false
   170 # "Function: inline def setState(in newState)"
 
   173 jump *label38 equal *tmp37 false
   174 set .STATE :setState.1:newState
   175 op add .CYCLES .CYCLES 1
-    * op xor *tmp39 .INVERTED .STATE
-    * set .ON *tmp39
+  176 op xor .ON .INVERTED .STATE
   177 jump *label40 equal .ON false
   178 set *tmp40 "\nCurrently active:[green]"
   179 jump *label41 always
 
   195 jump *label45 equal *tmp44 false
   196 set .STATE :setState.2:newState
   197 op add .CYCLES .CYCLES 1
-    * op xor *tmp46 .INVERTED .STATE
-    * set .ON *tmp46
+  198 op xor .ON .INVERTED .STATE
   199 jump *label47 equal .ON false
   200 set *tmp47 "\nCurrently active:[green]"
   201 jump *label48 always
 
   245 label *label51
   246 op lessThan *tmp49 :n @links
   247 jump *label53 equal *tmp49 false
-    * getlink *tmp50 :n
-    * set :block *tmp50
-    * set *tmp51 :block
-    * control enabled *tmp51 .ON
+  248 getlink :block :n
+  249 control enabled :block .ON
   250 print "\n    "
   251 print :block
   252 op add :n :n 1

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-8 instructions):
 
    23 print :block
    24 print "\n"
    25 sensor *tmp5 :block @type
-    * jump *label8 equal *tmp5 @message
-    * jump *label7 always
+   26 jump *label7 notEqual *tmp5 @message
    27 label *label8
    28 set .MESSAGE :block
    29 jump *label6 always
    30 label *label7
-    * jump *label10 equal *tmp5 @switch
-    * jump *label9 always
+   31 jump *label9 notEqual *tmp5 @switch
    32 label *label10
    33 set .SWITCH :block
    34 jump *label6 always
    35 label *label9
    36 jump *label12 equal *tmp5 @sorter
    37 jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label12 equal *tmp5 @unloader
-    * jump *label11 always
+   38 jump *label11 notEqual *tmp5 @unloader
    39 label *label12
    40 set .SORTER :block
    41 jump *label6 always
 
    44 jump *label14 equal *tmp5 @container
    45 jump *label14 equal *tmp5 @core-shard
    46 jump *label14 equal *tmp5 @core-foundation
-    * jump *label14 equal *tmp5 @core-nucleus
-    * jump *label13 always
+   47 jump *label13 notEqual *tmp5 @core-nucleus
    48 label *label14
    49 set .CONTAINER :block
    50 set .SENSOR @totalItems
 
    54 label *label13
    55 jump *label16 equal *tmp5 @liquid-tank
    56 jump *label16 equal *tmp5 @liquid-container
-    * jump *label16 equal *tmp5 @liquid-router
-    * jump *label15 always
+   57 jump *label15 notEqual *tmp5 @liquid-router
    58 label *label16
    59 set .CONTAINER :block
    60 set .SENSOR @totalLiquids
 
    63 jump *label6 always
    64 label *label15
    65 jump *label18 equal *tmp5 @battery
-    * jump *label18 equal *tmp5 @battery-large
-    * jump *label17 always
+   66 jump *label17 notEqual *tmp5 @battery-large
    67 label *label18
    68 set .CONTAINER :block
    69 set .SENSOR @totalPower
 
    73 label *label17
    74 jump *label20 equal *tmp5 @power-node
    75 jump *label20 equal *tmp5 @power-node-large
-    * jump *label20 equal *tmp5 @surge-tower
-    * jump *label19 always
+   76 jump *label19 notEqual *tmp5 @surge-tower
    77 label *label20
    78 set .CONTAINER :block
    79 set .SENSOR @powerNetStored
 
   140 jump *label33 notEqual *tmp27 false
   141 label *label34
   142 op notEqual *tmp28 .SENSOR @totalItems
-    * jump *label33 notEqual *tmp28 false
-    * jump *label31 always
+  143 jump *label31 equal *tmp28 false
   144 label *label33
   145 set :item .SENSOR
   146 print "Measuring [gold]total[] in "

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-12 instructions):
 
    15 print "\n"
    16 set :n @links
    17 label *label3
-    * op greaterThan *tmp1 :n 0
-    * jump *label5 equal *tmp1 false
+   18 jump *label5 lessThanEq :n 0
    19 op sub :n :n 1
    20 getlink :block :n
    21 print "Found: "
 
    96 print "Container: "
    97 print .CONTAINER
    98 print "\n"
-    * op equal *tmp11 .CONTAINER null
-    * jump *label21 equal *tmp11 false
+   99 jump *label21 notEqual .CONTAINER null
   100 print "No container."
   101 print "\n"
   102 jump *label22 always
 
   104 label *label22
   105 printflush .MESSAGE
   106 label *label1
-    * op equal *tmp13 .CONTAINER null
-    * jump *label0 notEqual *tmp13 false
+  107 jump *label0 equal .CONTAINER null
   108 label *label2
   109 sensor *tmp14 .SORTER @type
   110 op strictEqual .INVERTED *tmp14 @inverted-sorter
   111 # "Function: inline def setState(in newState)"
   112 set :setState:newState true
-    * op notEqual *tmp17 .STATE :setState:newState
-    * jump *label24 equal *tmp17 false
+  113 jump *label24 equal .STATE :setState:newState
   114 set .STATE :setState:newState
   115 op add .CYCLES .CYCLES 1
   116 op xor .ON .INVERTED .STATE
 
   128 control enabled .SWITCH 0
   129 label *label28
   130 sensor *tmp23 .SWITCH @enabled
-    * op equal *tmp24 *tmp23 0
-    * jump *label30 equal *tmp24 false
+  131 jump *label30 notEqual *tmp23 0
   132 set :start @time
   133 sensor :item .SORTER @config
-    * op equal *tmp27 :item null
-    * jump *label33 notEqual *tmp27 false
+  134 jump *label33 equal :item null
   135 label *label34
-    * op notEqual *tmp28 .SENSOR @totalItems
-    * jump *label31 equal *tmp28 false
+  136 jump *label31 equal .SENSOR @totalItems
   137 label *label33
   138 set :item .SENSOR
   139 print "Measuring [gold]total[] in "
 
   150 sensor :amount .CONTAINER :item
   151 op mul *tmp32 100 :amount
   152 op idiv :pct *tmp32 :max
-    * op lessThanEq *tmp34 :pct PCT_LOW
-    * jump *label35 equal *tmp34 false
+  153 jump *label35 greaterThan :pct PCT_LOW
   154 # "Function: inline def setState(in newState)"
   155 set :setState.1:newState true
-    * op notEqual *tmp37 .STATE :setState.1:newState
-    * jump *label38 equal *tmp37 false
+  156 jump *label38 equal .STATE :setState.1:newState
   157 set .STATE :setState.1:newState
   158 op add .CYCLES .CYCLES 1
   159 op xor .ON .INVERTED .STATE
 
   170 label *label37
   171 jump *label36 always
   172 label *label35
-    * op greaterThanEq *tmp41 :pct PCT_HIGH
-    * jump *label42 equal *tmp41 false
+  173 jump *label42 lessThan :pct PCT_HIGH
   174 # "Function: inline def setState(in newState)"
   175 set :setState.2:newState false
-    * op notEqual *tmp44 .STATE :setState.2:newState
-    * jump *label45 equal *tmp44 false
+  176 jump *label45 equal .STATE :setState.2:newState
   177 set .STATE :setState.2:newState
   178 op add .CYCLES .CYCLES 1
   179 op xor .ON .INVERTED .STATE
 
   224 print .ACTIVE_TEXT
   225 set :n .START
   226 label *label51
-    * op lessThan *tmp49 :n @links
-    * jump *label53 equal *tmp49 false
+  227 jump *label53 greaterThanEq :n @links
   228 getlink :block :n
   229 control enabled :block .ON
   230 print "\n    "

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-6 instructions):
 
    78 set .SENSOR @powerNetStored
    79 set .MAXIMUM @powerNetCapacity
    80 op add .START :n 1
-    * jump *label6 always
    81 label *label19
    82 label *label6
    83 label *label4
 
    98 jump *label21 notEqual .CONTAINER null
    99 print "No container."
   100 print "\n"
-    * jump *label22 always
   101 label *label21
   102 label *label22
   103 printflush .MESSAGE
 
   119 set *tmp20 "\nCurrently inactive:[salmon]"
   120 label *label27
   121 set .ACTIVE_TEXT *tmp20
-    * jump *label25 always
   122 label *label24
   123 label *label25
   124 label *label23
 
   161 set *tmp40 "\nCurrently inactive:[salmon]"
   162 label *label41
   163 set .ACTIVE_TEXT *tmp40
-    * jump *label39 always
   164 label *label38
   165 label *label39
   166 label *label37
 
   180 set *tmp47 "\nCurrently inactive:[salmon]"
   181 label *label48
   182 set .ACTIVE_TEXT *tmp47
-    * jump *label46 always
   183 label *label45
   184 label *label46
   185 label *label44
-    * jump *label43 always
   186 label *label42
   187 label *label43
   188 label *label36

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set .CONTAINER null
     3 set .SORTER null
     4 set .SWITCH null
-    * set .STATE .SWITCH
-    * set .START .STATE
-    * set .SENSOR .START
-    * set .ON .SENSOR
-    * set .MESSAGE .ON
-    * set .MAXIMUM .MESSAGE
-    * set .ACTIVE_TEXT .MAXIMUM
+    5 set .STATE null
+    6 set .START .SWITCH
+    7 set .SENSOR .STATE
+    8 set .ON .START
+    9 set .MESSAGE .SENSOR
+   10 set .MAXIMUM .ON
+   11 set .ACTIVE_TEXT .MESSAGE
    12 set .CYCLES 0
    13 label *label0
    14 print "Configuring regulator..."
 
   108 op strictEqual .INVERTED *tmp14 @inverted-sorter
   109 # "Function: inline def setState(in newState)"
   110 set :setState:newState true
-    * jump *label24 equal .STATE :setState:newState
-    * set .STATE :setState:newState
-    * op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  111 jump *label24 equal .STATE true
+  112 set .STATE true
+  113 op add .CYCLES 0 1
+  114 op xor .ON .INVERTED :setState:newState
   115 jump *label26 equal .ON false
   116 set *tmp20 "\nCurrently active:[green]"
   117 jump *label27 always
 
   150 jump *label35 greaterThan :pct PCT_LOW
   151 # "Function: inline def setState(in newState)"
   152 set :setState.1:newState true
-    * jump *label38 equal .STATE :setState.1:newState
-    * set .STATE :setState.1:newState
+  153 jump *label38 equal .STATE true
+  154 set .STATE true
   155 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  156 op xor .ON .INVERTED :setState.1:newState
   157 jump *label40 equal .ON false
   158 set *tmp40 "\nCurrently active:[green]"
   159 jump *label41 always
 
   169 jump *label42 lessThan :pct PCT_HIGH
   170 # "Function: inline def setState(in newState)"
   171 set :setState.2:newState false
-    * jump *label45 equal .STATE :setState.2:newState
-    * set .STATE :setState.2:newState
+  172 jump *label45 equal .STATE false
+  173 set .STATE false
   174 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  175 op xor .ON .INVERTED :setState.2:newState
   176 jump *label47 equal .ON false
   177 set *tmp47 "\nCurrently active:[green]"
   178 jump *label48 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
     3 set .SORTER null
     4 set .SWITCH null
     5 set .STATE null
-    * set .START .SWITCH
-    * set .SENSOR .STATE
-    * set .ON .START
-    * set .MESSAGE .SENSOR
-    * set .MAXIMUM .ON
-    * set .ACTIVE_TEXT .MESSAGE
-    * set .CYCLES 0
+    6 set .START null
+    7 set .SENSOR null
+    8 set .ON .SWITCH
+    9 set .MESSAGE .STATE
+   10 set .MAXIMUM .START
+   11 set .ACTIVE_TEXT .SENSOR
    12 label *label0
    13 print "Configuring regulator..."
    14 print "\n"
 
   107 op strictEqual .INVERTED *tmp14 @inverted-sorter
   108 # "Function: inline def setState(in newState)"
   109 set :setState:newState true
-    * jump *label24 equal .STATE true
+  110 jump *label24 equal null true
   111 set .STATE true
   112 op add .CYCLES 0 1
-    * op xor .ON .INVERTED :setState:newState
+  113 op xor .ON .INVERTED true
   114 jump *label26 equal .ON false
   115 set *tmp20 "\nCurrently active:[green]"
   116 jump *label27 always
 
   152 jump *label38 equal .STATE true
   153 set .STATE true
   154 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.1:newState
+  155 op xor .ON .INVERTED true
   156 jump *label40 equal .ON false
   157 set *tmp40 "\nCurrently active:[green]"
   158 jump *label41 always
 
   171 jump *label45 equal .STATE false
   172 set .STATE false
   173 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.2:newState
+  174 op xor .ON .INVERTED false
   175 jump *label47 equal .ON false
   176 set *tmp47 "\nCurrently active:[green]"
   177 jump *label48 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
     5 set .STATE null
     6 set .START null
     7 set .SENSOR null
-    * set .ON .SWITCH
-    * set .MESSAGE .STATE
-    * set .MAXIMUM .START
-    * set .ACTIVE_TEXT .SENSOR
+    8 set .ON null
+    9 set .MESSAGE null
+   10 set .MAXIMUM null
+   11 set .ACTIVE_TEXT null
    12 label *label0
    13 print "Configuring regulator..."
    14 print "\n"
 
   106 sensor *tmp14 .SORTER @type
   107 op strictEqual .INVERTED *tmp14 @inverted-sorter
   108 # "Function: inline def setState(in newState)"
-    * set :setState:newState true
   109 jump *label24 equal null true
   110 set .STATE true
   111 op add .CYCLES 0 1
 
   147 op idiv :pct *tmp32 :max
   148 jump *label35 greaterThan :pct PCT_LOW
   149 # "Function: inline def setState(in newState)"
-    * set :setState.1:newState true
   150 jump *label38 equal .STATE true
   151 set .STATE true
   152 op add .CYCLES .CYCLES 1
 
   165 label *label35
   166 jump *label42 lessThan :pct PCT_HIGH
   167 # "Function: inline def setState(in newState)"
-    * set :setState.2:newState false
   168 jump *label45 equal .STATE false
   169 set .STATE false
   170 op add .CYCLES .CYCLES 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-3 instructions):
 
     2 set .CONTAINER null
     3 set .SORTER null
     4 set .SWITCH null
-    * set .STATE null
     5 set .START null
     6 set .SENSOR null
-    * set .ON null
     7 set .MESSAGE null
     8 set .MAXIMUM null
-    * set .ACTIVE_TEXT null
     9 label *label0
    10 print "Configuring regulator..."
    11 print "\n"

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    12 set :n @links
    13 label *label3
    14 jump *label5 lessThanEq :n 0
+   15 label *label54
    16 op sub :n :n 1
    17 getlink :block :n
    18 print "Found: "
 
    78 label *label19
    79 label *label6
    80 label *label4
-    * jump *label3 always
+   81 jump *label54 greaterThan :n 0
    82 label *label5
    83 print "Message: "
    84 print .MESSAGE
 
   213 set :n .START
   214 label *label51
   215 jump *label53 greaterThanEq :n @links
+  216 label *label55
   217 getlink :block :n
   218 control enabled :block .ON
   219 print "\n    "
   220 print :block
   221 op add :n :n 1
   222 label *label52
-    * jump *label51 always
+  223 jump *label55 lessThan :n @links
   224 label *label53
   225 print "[]"
   226 print "\n"

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-9 instructions):
 
   108 set .STATE true
   109 op add .CYCLES 0 1
   110 op xor .ON .INVERTED true
-    * jump *label26 equal .ON false
-    * set *tmp20 "\nCurrently active:[green]"
-    * jump *label27 always
-    * label *label26
-    * set *tmp20 "\nCurrently inactive:[salmon]"
-    * label *label27
+  111 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   112 set .ACTIVE_TEXT *tmp20
   113 label *label24
   114 label *label25
 
   144 set .STATE true
   145 op add .CYCLES .CYCLES 1
   146 op xor .ON .INVERTED true
-    * jump *label40 equal .ON false
-    * set *tmp40 "\nCurrently active:[green]"
-    * jump *label41 always
-    * label *label40
-    * set *tmp40 "\nCurrently inactive:[salmon]"
-    * label *label41
+  147 select *tmp40 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   148 set .ACTIVE_TEXT *tmp40
   149 label *label38
   150 label *label39
 
   157 set .STATE false
   158 op add .CYCLES .CYCLES 1
   159 op xor .ON .INVERTED false
-    * jump *label47 equal .ON false
-    * set *tmp47 "\nCurrently active:[green]"
-    * jump *label48 always
-    * label *label47
-    * set *tmp47 "\nCurrently inactive:[salmon]"
-    * label *label48
+  160 select *tmp47 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   161 set .ACTIVE_TEXT *tmp47
   162 label *label45
   163 label *label46

Modifications by Replicate loop condition at line 72:1 (+1 instructions):
 
   117 label *label28
   118 sensor *tmp23 .SWITCH @enabled
   119 jump *label30 notEqual *tmp23 0
+  120 label *label56
   121 set :start @time
   122 sensor :item .SORTER @config
   123 jump *label33 equal :item null
 
   221 print "ms"
   222 printflush .MESSAGE
   223 label *label29
-    * jump *label28 always
+  224 sensor *tmp23 .SWITCH @enabled
+  225 jump *label56 equal *tmp23 0
   226 label *label30
   227 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   198 print .ACTIVE_TEXT
   199 set :n .START
   200 label *label51
-    * jump *label53 greaterThanEq :n @links
+  201 jump *label53 greaterThanEq .START @links
   202 label *label55
   203 getlink :block :n
   204 control enabled :block .ON

Modifications by Convert case at line 26:9 (segments: 1, padded low) (+131 instructions):
 
    19 print :block
    20 print "\n"
    21 sensor *tmp5 :block @type
-    * jump *label7 notEqual *tmp5 @message
+   22 sensor *tmp55 *tmp5 @id
+   23 jump *label57 greaterThanEq *tmp55 147
+   24 multijump *label59 *tmp55 0 (m:*label58)
+   25 multilabel *label59 (m:*label58)
+   26 jump *label57 always
+   27 multilabel *label60 (m:*label58)
+   28 jump *label57 always
+   29 multilabel *label61 (m:*label58)
+   30 jump *label57 always
+   31 multilabel *label62 (m:*label58)
+   32 jump *label57 always
+   33 multilabel *label63 (m:*label58)
+   34 jump *label57 always
+   35 multilabel *label64 (m:*label58)
+   36 jump *label57 always
+   37 multilabel *label65 (m:*label58)
+   38 jump *label57 always
+   39 multilabel *label66 (m:*label58)
+   40 jump *label57 always
+   41 multilabel *label67 (m:*label58)
+   42 jump *label57 always
+   43 multilabel *label68 (m:*label58)
+   44 jump *label57 always
+   45 multilabel *label69 (m:*label58)
+   46 jump *label57 always
+   47 multilabel *label70 (m:*label58)
+   48 jump *label57 always
+   49 multilabel *label71 (m:*label58)
+   50 jump *label57 always
+   51 multilabel *label72 (m:*label58)
+   52 jump *label57 always
+   53 multilabel *label73 (m:*label58)
+   54 jump *label57 always
+   55 multilabel *label74 (m:*label58)
+   56 jump *label57 always
+   57 multilabel *label75 (m:*label58)
+   58 jump *label57 always
+   59 multilabel *label76 (m:*label58)
+   60 jump *label57 always
+   61 multilabel *label77 (m:*label58)
+   62 jump *label57 always
+   63 multilabel *label78 (m:*label58)
+   64 jump *label57 always
+   65 multilabel *label79 (m:*label58)
+   66 jump *label57 always
+   67 multilabel *label80 (m:*label58)
+   68 jump *label57 always
+   69 multilabel *label81 (m:*label58)
+   70 jump *label57 always
+   71 multilabel *label82 (m:*label58)
+   72 jump *label57 always
+   73 multilabel *label83 (m:*label58)
+   74 jump *label57 always
+   75 multilabel *label84 (m:*label58)
+   76 jump *label57 always
+   77 multilabel *label85 (m:*label58)
+   78 jump *label57 always
+   79 multilabel *label86 (m:*label58)
+   80 jump *label57 always
+   81 multilabel *label87 (m:*label58)
+   82 jump *label57 always
+   83 multilabel *label88 (m:*label58)
+   84 jump *label57 always
+   85 multilabel *label89 (m:*label58)
+   86 jump *label57 always
+   87 multilabel *label90 (m:*label58)
+   88 jump *label57 always
+   89 multilabel *label91 (m:*label58)
+   90 jump *label57 always
+   91 multilabel *label92 (m:*label58)
+   92 jump *label57 always
+   93 multilabel *label93 (m:*label58)
+   94 jump *label57 always
+   95 multilabel *label94 (m:*label58)
+   96 jump *label57 always
+   97 multilabel *label95 (m:*label58)
+   98 jump *label57 always
+   99 multilabel *label96 (m:*label58)
+  100 jump *label57 always
+  101 multilabel *label97 (m:*label58)
+  102 jump *label57 always
+  103 multilabel *label98 (m:*label58)
+  104 jump *label57 always
+  105 multilabel *label99 (m:*label58)
+  106 jump *label57 always
+  107 multilabel *label100 (m:*label58)
+  108 jump *label57 always
+  109 multilabel *label101 (m:*label58)
+  110 jump *label57 always
+  111 multilabel *label102 (m:*label58)
+  112 jump *label57 always
+  113 multilabel *label103 (m:*label58)
+  114 jump *label57 always
+  115 multilabel *label104 (m:*label58)
+  116 jump *label57 always
+  117 multilabel *label105 (m:*label58)
+  118 jump *label57 always
+  119 multilabel *label106 (m:*label58)
+  120 jump *label57 always
+  121 multilabel *label107 (m:*label58)
+  122 jump *label12 always
+  123 multilabel *label108 (m:*label58)
+  124 jump *label12 always
+  125 multilabel *label109 (m:*label58)
+  126 jump *label57 always
+  127 multilabel *label110 (m:*label58)
+  128 jump *label57 always
+  129 multilabel *label111 (m:*label58)
+  130 jump *label57 always
+  131 multilabel *label112 (m:*label58)
+  132 jump *label57 always
+  133 multilabel *label113 (m:*label58)
+  134 jump *label57 always
+  135 multilabel *label114 (m:*label58)
+  136 jump *label57 always
+  137 multilabel *label115 (m:*label58)
+  138 jump *label57 always
+  139 multilabel *label116 (m:*label58)
+  140 jump *label57 always
+  141 multilabel *label117 (m:*label58)
+  142 jump *label57 always
+  143 multilabel *label118 (m:*label58)
+  144 jump *label57 always
+  145 multilabel *label119 (m:*label58)
+  146 jump *label57 always
+  147 multilabel *label120 (m:*label58)
+  148 jump *label57 always
+  149 multilabel *label121 (m:*label58)
+  150 jump *label57 always
+  151 multilabel *label122 (m:*label58)
+  152 jump *label16 always
+  153 multilabel *label123 (m:*label58)
+  154 jump *label16 always
+  155 multilabel *label124 (m:*label58)
+  156 jump *label57 always
+  157 multilabel *label125 (m:*label58)
+  158 jump *label57 always
+  159 multilabel *label126 (m:*label58)
+  160 jump *label57 always
+  161 multilabel *label127 (m:*label58)
+  162 jump *label20 always
+  163 multilabel *label128 (m:*label58)
+  164 jump *label20 always
+  165 multilabel *label129 (m:*label58)
+  166 jump *label20 always
+  167 multilabel *label130 (m:*label58)
+  168 jump *label57 always
+  169 multilabel *label131 (m:*label58)
+  170 jump *label18 always
+  171 multilabel *label132 (m:*label58)
+  172 jump *label18 always
+  173 multilabel *label133 (m:*label58)
+  174 jump *label57 always
+  175 multilabel *label134 (m:*label58)
+  176 jump *label57 always
+  177 multilabel *label135 (m:*label58)
+  178 jump *label57 always
+  179 multilabel *label136 (m:*label58)
+  180 jump *label57 always
+  181 multilabel *label137 (m:*label58)
+  182 jump *label57 always
+  183 multilabel *label138 (m:*label58)
+  184 jump *label57 always
+  185 multilabel *label139 (m:*label58)
+  186 jump *label57 always
+  187 multilabel *label140 (m:*label58)
+  188 jump *label57 always
+  189 multilabel *label141 (m:*label58)
+  190 jump *label57 always
+  191 multilabel *label142 (m:*label58)
+  192 jump *label57 always
+  193 multilabel *label143 (m:*label58)
+  194 jump *label57 always
+  195 multilabel *label144 (m:*label58)
+  196 jump *label57 always
+  197 multilabel *label145 (m:*label58)
+  198 jump *label57 always
+  199 multilabel *label146 (m:*label58)
+  200 jump *label57 always
+  201 multilabel *label147 (m:*label58)
+  202 jump *label57 always
+  203 multilabel *label148 (m:*label58)
+  204 jump *label57 always
+  205 multilabel *label149 (m:*label58)
+  206 jump *label14 always
+  207 multilabel *label150 (m:*label58)
+  208 jump *label14 always
+  209 multilabel *label151 (m:*label58)
+  210 jump *label14 always
+  211 multilabel *label152 (m:*label58)
+  212 jump *label14 always
+  213 multilabel *label153 (m:*label58)
+  214 jump *label14 always
+  215 multilabel *label154 (m:*label58)
+  216 jump *label12 always
+  217 multilabel *label155 (m:*label58)
+  218 jump *label57 always
+  219 multilabel *label156 (m:*label58)
+  220 jump *label57 always
+  221 multilabel *label157 (m:*label58)
+  222 jump *label57 always
+  223 multilabel *label158 (m:*label58)
+  224 jump *label57 always
+  225 multilabel *label159 (m:*label58)
+  226 jump *label57 always
+  227 multilabel *label160 (m:*label58)
+  228 jump *label57 always
+  229 multilabel *label161 (m:*label58)
+  230 jump *label57 always
+  231 multilabel *label162 (m:*label58)
+  232 jump *label57 always
+  233 multilabel *label163 (m:*label58)
+  234 jump *label57 always
+  235 multilabel *label164 (m:*label58)
+  236 jump *label57 always
+  237 multilabel *label165 (m:*label58)
+  238 jump *label57 always
+  239 multilabel *label166 (m:*label58)
+  240 jump *label57 always
+  241 multilabel *label167 (m:*label58)
+  242 jump *label57 always
+  243 multilabel *label168 (m:*label58)
+  244 jump *label57 always
+  245 multilabel *label169 (m:*label58)
+  246 jump *label57 always
+  247 multilabel *label170 (m:*label58)
+  248 jump *label57 always
+  249 multilabel *label171 (m:*label58)
+  250 jump *label57 always
+  251 multilabel *label172 (m:*label58)
+  252 jump *label57 always
+  253 multilabel *label173 (m:*label58)
+  254 jump *label57 always
+  255 multilabel *label174 (m:*label58)
+  256 jump *label57 always
+  257 multilabel *label175 (m:*label58)
+  258 jump *label57 always
+  259 multilabel *label176 (m:*label58)
+  260 jump *label57 always
+  261 multilabel *label177 (m:*label58)
+  262 jump *label57 always
+  263 multilabel *label178 (m:*label58)
+  264 jump *label57 always
+  265 multilabel *label179 (m:*label58)
+  266 jump *label57 always
+  267 multilabel *label180 (m:*label58)
+  268 jump *label57 always
+  269 multilabel *label181 (m:*label58)
+  270 jump *label57 always
+  271 multilabel *label182 (m:*label58)
+  272 jump *label57 always
+  273 multilabel *label183 (m:*label58)
+  274 jump *label57 always
+  275 multilabel *label184 (m:*label58)
+  276 jump *label57 always
+  277 multilabel *label185 (m:*label58)
+  278 jump *label57 always
+  279 multilabel *label186 (m:*label58)
+  280 jump *label57 always
+  281 multilabel *label187 (m:*label58)
+  282 jump *label57 always
+  283 multilabel *label188 (m:*label58)
+  284 jump *label57 always
+  285 multilabel *label189 (m:*label58)
+  286 jump *label57 always
+  287 multilabel *label190 (m:*label58)
+  288 jump *label57 always
+  289 multilabel *label191 (m:*label58)
+  290 jump *label57 always
+  291 multilabel *label192 (m:*label58)
+  292 jump *label57 always
+  293 multilabel *label193 (m:*label58)
+  294 jump *label57 always
+  295 multilabel *label194 (m:*label58)
+  296 jump *label57 always
+  297 multilabel *label195 (m:*label58)
+  298 jump *label57 always
+  299 multilabel *label196 (m:*label58)
+  300 jump *label8 always
+  301 multilabel *label197 (m:*label58)
+  302 jump *label10 always
+  303 multilabel *label198 (m:*label58)
+  304 jump *label57 always
+  305 multilabel *label199 (m:*label58)
+  306 jump *label57 always
+  307 multilabel *label200 (m:*label58)
+  308 jump *label57 always
+  309 multilabel *label201 (m:*label58)
+  310 jump *label57 always
+  311 multilabel *label202 (m:*label58)
+  312 jump *label57 always
+  313 multilabel *label203 (m:*label58)
+  314 jump *label57 always
+  315 multilabel *label204 (m:*label58)
+  316 jump *label57 always
+  317 multilabel *label205 (m:*label58)
+  318 label *label16
+  319 set .CONTAINER :block
+  320 set .SENSOR @totalLiquids
+  321 set .MAXIMUM @liquidCapacity
+  322 op add .START :n 1
+  323 jump *label6 always
   324 label *label8
   325 set .MESSAGE :block
   326 jump *label6 always
   327 label *label7
-    * jump *label9 notEqual *tmp5 @switch
   328 label *label10
   329 set .SWITCH :block
   330 jump *label6 always
   331 label *label9
-    * jump *label12 equal *tmp5 @sorter
-    * jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label11 notEqual *tmp5 @unloader
   332 label *label12
   333 set .SORTER :block
   334 jump *label6 always
   335 label *label11
-    * jump *label14 equal *tmp5 @vault
-    * jump *label14 equal *tmp5 @container
-    * jump *label14 equal *tmp5 @core-shard
-    * jump *label14 equal *tmp5 @core-foundation
-    * jump *label13 notEqual *tmp5 @core-nucleus
   336 label *label14
   337 set .CONTAINER :block
   338 set .SENSOR @totalItems
 
   340 op add .START :n 1
   341 jump *label6 always
   342 label *label13
-    * jump *label16 equal *tmp5 @liquid-tank
-    * jump *label16 equal *tmp5 @liquid-container
-    * jump *label15 notEqual *tmp5 @liquid-router
-    * label *label16
-    * set .CONTAINER :block
-    * set .SENSOR @totalLiquids
-    * set .MAXIMUM @liquidCapacity
-    * op add .START :n 1
-    * jump *label6 always
   343 label *label15
-    * jump *label18 equal *tmp5 @battery
-    * jump *label17 notEqual *tmp5 @battery-large
   344 label *label18
   345 set .CONTAINER :block
   346 set .SENSOR @totalPower
 
   348 op add .START :n 1
   349 jump *label6 always
   350 label *label17
-    * jump *label20 equal *tmp5 @power-node
-    * jump *label20 equal *tmp5 @power-node-large
-    * jump *label19 notEqual *tmp5 @surge-tower
   351 label *label20
   352 set .CONTAINER :block
   353 set .SENSOR @powerNetStored
   354 set .MAXIMUM @powerNetCapacity
   355 op add .START :n 1
   356 label *label19
+  357 label *label57
   358 label *label6
   359 label *label4
   360 jump *label54 greaterThan :n 0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   383 sensor *tmp14 .SORTER @type
   384 op strictEqual .INVERTED *tmp14 @inverted-sorter
   385 # "Function: inline def setState(in newState)"
-    * jump *label24 equal null true
   386 set .STATE true
   387 op add .CYCLES 0 1
   388 op xor .ON .INVERTED true

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   384 op strictEqual .INVERTED *tmp14 @inverted-sorter
   385 # "Function: inline def setState(in newState)"
   386 set .STATE true
-    * op add .CYCLES 0 1
+  387 set .CYCLES 1
   388 op xor .ON .INVERTED true
   389 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   390 set .ACTIVE_TEXT *tmp20
 
   435 jump *label45 equal .STATE false
   436 set .STATE false
   437 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED false
+  438 set .ON .INVERTED
   439 select *tmp47 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   440 set .ACTIVE_TEXT *tmp47
   441 label *label45

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   436 set .STATE false
   437 op add .CYCLES .CYCLES 1
   438 set .ON .INVERTED
-    * select *tmp47 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
+  439 select *tmp47 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   440 set .ACTIVE_TEXT *tmp47
   441 label *label45
   442 label *label46

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-3 instructions):
 
   386 set .STATE true
   387 set .CYCLES 1
   388 op xor .ON .INVERTED true
-    * select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * set .ACTIVE_TEXT *tmp20
+  389 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   390 label *label24
   391 label *label25
   392 label *label23
 
   422 set .STATE true
   423 op add .CYCLES .CYCLES 1
   424 op xor .ON .INVERTED true
-    * select *tmp40 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * set .ACTIVE_TEXT *tmp40
+  425 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   426 label *label38
   427 label *label39
   428 label *label37
 
   434 set .STATE false
   435 op add .CYCLES .CYCLES 1
   436 set .ON .INVERTED
-    * select *tmp47 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * set .ACTIVE_TEXT *tmp47
+  437 select .ACTIVE_TEXT notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   438 label *label45
   439 label *label46
   440 label *label44

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    10 print "Configuring regulator..."
    11 print "\n"
    12 set :n @links
-    * label *label3
    13 jump *label5 lessThanEq :n 0
    14 label *label54
    15 op sub :n :n 1
 
   323 label *label8
   324 set .MESSAGE :block
   325 jump *label6 always
-    * label *label7
   326 label *label10
   327 set .SWITCH :block
   328 jump *label6 always
-    * label *label9
   329 label *label12
   330 set .SORTER :block
   331 jump *label6 always
-    * label *label11
   332 label *label14
   333 set .CONTAINER :block
   334 set .SENSOR @totalItems
   335 set .MAXIMUM @itemCapacity
   336 op add .START :n 1
   337 jump *label6 always
-    * label *label13
-    * label *label15
   338 label *label18
   339 set .CONTAINER :block
   340 set .SENSOR @totalPower
   341 set .MAXIMUM @powerCapacity
   342 op add .START :n 1
   343 jump *label6 always
-    * label *label17
   344 label *label20
   345 set .CONTAINER :block
   346 set .SENSOR @powerNetStored
   347 set .MAXIMUM @powerNetCapacity
   348 op add .START :n 1
-    * label *label19
   349 label *label57
   350 label *label6
-    * label *label4
   351 jump *label54 greaterThan :n 0
   352 label *label5
   353 print "Message: "
 
   366 print "No container."
   367 print "\n"
   368 label *label21
-    * label *label22
   369 printflush .MESSAGE
-    * label *label1
   370 jump *label0 equal .CONTAINER null
-    * label *label2
   371 sensor *tmp14 .SORTER @type
   372 op strictEqual .INVERTED *tmp14 @inverted-sorter
   373 # "Function: inline def setState(in newState)"
 
   375 set .CYCLES 1
   376 op xor .ON .INVERTED true
   377 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label24
-    * label *label25
-    * label *label23
   378 control enabled .SWITCH 0
-    * label *label28
   379 sensor *tmp23 .SWITCH @enabled
   380 jump *label30 notEqual *tmp23 0
   381 label *label56
   382 set :start @time
   383 sensor :item .SORTER @config
   384 jump *label33 equal :item null
-    * label *label34
   385 jump *label31 equal .SENSOR @totalItems
   386 label *label33
   387 set :item .SENSOR
 
   407 op xor .ON .INVERTED true
   408 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   409 label *label38
-    * label *label39
-    * label *label37
   410 jump *label36 always
   411 label *label35
   412 jump *label42 lessThan :pct PCT_HIGH
 
   417 set .ON .INVERTED
   418 select .ACTIVE_TEXT notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   419 label *label45
-    * label *label46
-    * label *label44
   420 label *label42
-    * label *label43
   421 label *label36
   422 print "\n"
   423 print "Level: [gold]"
 
   450 label *label50
   451 print .ACTIVE_TEXT
   452 set :n .START
-    * label *label51
   453 jump *label53 greaterThanEq .START @links
   454 label *label55
   455 getlink :block :n
 
   457 print "\n    "
   458 print :block
   459 op add :n :n 1
-    * label *label52
   460 jump *label55 lessThan :n @links
   461 label *label53
   462 print "[]"
 
   471 print " "
   472 print "ms"
   473 printflush .MESSAGE
-    * label *label29
   474 sensor *tmp23 .SWITCH @enabled
   475 jump *label56 equal *tmp23 0
   476 label *label30

Modifications by Jumps phase, Condition Optimization, pass 4, iteration 1:
 
   415 set .STATE false
   416 op add .CYCLES .CYCLES 1
   417 set .ON .INVERTED
-    * select .ACTIVE_TEXT notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
+  418 select .ACTIVE_TEXT strictEqual *tmp14 @inverted-sorter "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   419 label *label45
   420 label *label42
   421 label *label36

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 set PCT_LOW 60
     2 set PCT_HIGH 80
     3 set .CONTAINER null
 
   378 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   379 control enabled .SWITCH 0
   380 sensor *tmp23 .SWITCH @enabled
-    * jump *label30 notEqual *tmp23 0
+  381 jump __start__ notEqual *tmp23 0
   382 label *label56
   383 set :start @time
   384 sensor :item .SORTER @config
 
   402 op idiv :pct *tmp32 :max
   403 jump *label35 greaterThan :pct PCT_LOW
   404 # "Function: inline def setState(in newState)"
-    * jump *label38 equal .STATE true
+  405 jump *label36 equal .STATE true
   406 set .STATE true
   407 op add .CYCLES .CYCLES 1
   408 op xor .ON .INVERTED true

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1:
 
   407 op add .CYCLES .CYCLES 1
   408 op xor .ON .INVERTED true
   409 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label38
   410 jump *label36 always
   411 label *label35
   412 jump *label42 lessThan :pct PCT_HIGH
 
   473 printflush .MESSAGE
   474 sensor *tmp23 .SWITCH @enabled
   475 jump *label56 equal *tmp23 0
-    * label *label30
   476 end

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   473 printflush .MESSAGE
   474 sensor *tmp23 .SWITCH @enabled
   475 jump *label56 equal *tmp23 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-35 instructions):
 
     8 set .MESSAGE null
     9 set .MAXIMUM null
    10 label *label0
-    * print "Configuring regulator..."
-    * print "\n"
+   11 print "Configuring regulator...\n"
    12 set :n @links
    13 jump *label5 lessThanEq :n 0
    14 label *label54
    15 op sub :n :n 1
    16 getlink :block :n
-    * print "Found: "
-    * print :block
-    * print "\n"
+   17 print "Found: {0}\n"
+   18 format :block
    19 sensor *tmp5 :block @type
    20 sensor *tmp55 *tmp5 @id
    21 jump *label57 greaterThanEq *tmp55 147
 
   349 label *label6
   350 jump *label54 greaterThan :n 0
   351 label *label5
-    * print "Message: "
-    * print .MESSAGE
-    * print "\n"
-    * print "Switch: "
-    * print .SWITCH
-    * print "\n"
-    * print "Sorter: "
-    * print .SORTER
-    * print "\n"
-    * print "Container: "
-    * print .CONTAINER
-    * print "\n"
+  352 print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
+  353 format .MESSAGE
+  354 format .SWITCH
+  355 format .SORTER
+  356 format .CONTAINER
   357 jump *label21 notEqual .CONTAINER null
-    * print "No container."
-    * print "\n"
+  358 print "No container.\n"
   359 label *label21
   360 printflush .MESSAGE
   361 jump *label0 equal .CONTAINER null
 
   380 print .CONTAINER
   381 jump *label32 always
   382 label *label31
-    * print "Measuring [gold]"
-    * print :item
-    * print "["
-    * print "] in "
+  383 print "Measuring [gold]{0}[] in "
+  384 format :item
   385 print .CONTAINER
   386 label *label32
   387 sensor :max .CONTAINER .MAXIMUM
 
   407 label *label45
   408 label *label42
   409 label *label36
-    * print "\n"
-    * print "Level: [gold]"
-    * print :pct
-    * print "%"
-    * print "[]"
+  410 print "\nLevel: [gold]{0}%[]"
+  411 format :pct
   412 jump *label49 equal .INVERTED false
-    * print "\n"
-    * print "Activate above [green]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate below [salmon]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
+  413 print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
+  414 format PCT_HIGH
+  415 format PCT_LOW
   416 jump *label50 always
   417 label *label49
-    * print "\n"
-    * print "Activate below [green]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate above [salmon]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
+  418 print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
+  419 format PCT_LOW
+  420 format PCT_HIGH
   421 label *label50
   422 print .ACTIVE_TEXT
   423 set :n .START
 
   430 op add :n :n 1
   431 jump *label55 lessThan :n @links
   432 label *label53
-    * print "[]"
-    * print "\n"
-    * print "# of cycles: "
-    * print .CYCLES
+  433 print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
+  434 format .CYCLES
   435 op sub *tmp53 @time :start
   436 op floor *tmp54 *tmp53
-    * print "\n"
-    * print "[lightgray]Loop: "
-    * print *tmp54
-    * print " "
-    * print "ms"
+  437 format *tmp54
   438 printflush .MESSAGE
   439 sensor *tmp23 .SWITCH @enabled
   440 jump *label56 equal *tmp23 0

Final code before resolving virtual instructions:

label __start__
set PCT_LOW 60
set PCT_HIGH 80
set .CONTAINER null
set .SORTER null
set .SWITCH null
set .START null
set .SENSOR null
set .MESSAGE null
set .MAXIMUM null
label *label0
print "Configuring regulator...\n"
set :n @links
jump *label5 lessThanEq :n 0
label *label54
op sub :n :n 1
getlink :block :n
print "Found: {0}\n"
format :block
sensor *tmp5 :block @type
sensor *tmp55 *tmp5 @id
jump *label57 greaterThanEq *tmp55 147
multijump *label59 *tmp55 0
multilabel *label59
jump *label57 always
multilabel *label60
jump *label57 always
multilabel *label61
jump *label57 always
multilabel *label62
jump *label57 always
multilabel *label63
jump *label57 always
multilabel *label64
jump *label57 always
multilabel *label65
jump *label57 always
multilabel *label66
jump *label57 always
multilabel *label67
jump *label57 always
multilabel *label68
jump *label57 always
multilabel *label69
jump *label57 always
multilabel *label70
jump *label57 always
multilabel *label71
jump *label57 always
multilabel *label72
jump *label57 always
multilabel *label73
jump *label57 always
multilabel *label74
jump *label57 always
multilabel *label75
jump *label57 always
multilabel *label76
jump *label57 always
multilabel *label77
jump *label57 always
multilabel *label78
jump *label57 always
multilabel *label79
jump *label57 always
multilabel *label80
jump *label57 always
multilabel *label81
jump *label57 always
multilabel *label82
jump *label57 always
multilabel *label83
jump *label57 always
multilabel *label84
jump *label57 always
multilabel *label85
jump *label57 always
multilabel *label86
jump *label57 always
multilabel *label87
jump *label57 always
multilabel *label88
jump *label57 always
multilabel *label89
jump *label57 always
multilabel *label90
jump *label57 always
multilabel *label91
jump *label57 always
multilabel *label92
jump *label57 always
multilabel *label93
jump *label57 always
multilabel *label94
jump *label57 always
multilabel *label95
jump *label57 always
multilabel *label96
jump *label57 always
multilabel *label97
jump *label57 always
multilabel *label98
jump *label57 always
multilabel *label99
jump *label57 always
multilabel *label100
jump *label57 always
multilabel *label101
jump *label57 always
multilabel *label102
jump *label57 always
multilabel *label103
jump *label57 always
multilabel *label104
jump *label57 always
multilabel *label105
jump *label57 always
multilabel *label106
jump *label57 always
multilabel *label107
jump *label12 always
multilabel *label108
jump *label12 always
multilabel *label109
jump *label57 always
multilabel *label110
jump *label57 always
multilabel *label111
jump *label57 always
multilabel *label112
jump *label57 always
multilabel *label113
jump *label57 always
multilabel *label114
jump *label57 always
multilabel *label115
jump *label57 always
multilabel *label116
jump *label57 always
multilabel *label117
jump *label57 always
multilabel *label118
jump *label57 always
multilabel *label119
jump *label57 always
multilabel *label120
jump *label57 always
multilabel *label121
jump *label57 always
multilabel *label122
jump *label16 always
multilabel *label123
jump *label16 always
multilabel *label124
jump *label57 always
multilabel *label125
jump *label57 always
multilabel *label126
jump *label57 always
multilabel *label127
jump *label20 always
multilabel *label128
jump *label20 always
multilabel *label129
jump *label20 always
multilabel *label130
jump *label57 always
multilabel *label131
jump *label18 always
multilabel *label132
jump *label18 always
multilabel *label133
jump *label57 always
multilabel *label134
jump *label57 always
multilabel *label135
jump *label57 always
multilabel *label136
jump *label57 always
multilabel *label137
jump *label57 always
multilabel *label138
jump *label57 always
multilabel *label139
jump *label57 always
multilabel *label140
jump *label57 always
multilabel *label141
jump *label57 always
multilabel *label142
jump *label57 always
multilabel *label143
jump *label57 always
multilabel *label144
jump *label57 always
multilabel *label145
jump *label57 always
multilabel *label146
jump *label57 always
multilabel *label147
jump *label57 always
multilabel *label148
jump *label57 always
multilabel *label149
jump *label14 always
multilabel *label150
jump *label14 always
multilabel *label151
jump *label14 always
multilabel *label152
jump *label14 always
multilabel *label153
jump *label14 always
multilabel *label154
jump *label12 always
multilabel *label155
jump *label57 always
multilabel *label156
jump *label57 always
multilabel *label157
jump *label57 always
multilabel *label158
jump *label57 always
multilabel *label159
jump *label57 always
multilabel *label160
jump *label57 always
multilabel *label161
jump *label57 always
multilabel *label162
jump *label57 always
multilabel *label163
jump *label57 always
multilabel *label164
jump *label57 always
multilabel *label165
jump *label57 always
multilabel *label166
jump *label57 always
multilabel *label167
jump *label57 always
multilabel *label168
jump *label57 always
multilabel *label169
jump *label57 always
multilabel *label170
jump *label57 always
multilabel *label171
jump *label57 always
multilabel *label172
jump *label57 always
multilabel *label173
jump *label57 always
multilabel *label174
jump *label57 always
multilabel *label175
jump *label57 always
multilabel *label176
jump *label57 always
multilabel *label177
jump *label57 always
multilabel *label178
jump *label57 always
multilabel *label179
jump *label57 always
multilabel *label180
jump *label57 always
multilabel *label181
jump *label57 always
multilabel *label182
jump *label57 always
multilabel *label183
jump *label57 always
multilabel *label184
jump *label57 always
multilabel *label185
jump *label57 always
multilabel *label186
jump *label57 always
multilabel *label187
jump *label57 always
multilabel *label188
jump *label57 always
multilabel *label189
jump *label57 always
multilabel *label190
jump *label57 always
multilabel *label191
jump *label57 always
multilabel *label192
jump *label57 always
multilabel *label193
jump *label57 always
multilabel *label194
jump *label57 always
multilabel *label195
jump *label57 always
multilabel *label196
jump *label8 always
multilabel *label197
jump *label10 always
multilabel *label198
jump *label57 always
multilabel *label199
jump *label57 always
multilabel *label200
jump *label57 always
multilabel *label201
jump *label57 always
multilabel *label202
jump *label57 always
multilabel *label203
jump *label57 always
multilabel *label204
jump *label57 always
multilabel *label205
label *label16
set .CONTAINER :block
set .SENSOR @totalLiquids
set .MAXIMUM @liquidCapacity
op add .START :n 1
jump *label6 always
label *label8
set .MESSAGE :block
jump *label6 always
label *label10
set .SWITCH :block
jump *label6 always
label *label12
set .SORTER :block
jump *label6 always
label *label14
set .CONTAINER :block
set .SENSOR @totalItems
set .MAXIMUM @itemCapacity
op add .START :n 1
jump *label6 always
label *label18
set .CONTAINER :block
set .SENSOR @totalPower
set .MAXIMUM @powerCapacity
op add .START :n 1
jump *label6 always
label *label20
set .CONTAINER :block
set .SENSOR @powerNetStored
set .MAXIMUM @powerNetCapacity
op add .START :n 1
label *label57
label *label6
jump *label54 greaterThan :n 0
label *label5
print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
format .MESSAGE
format .SWITCH
format .SORTER
format .CONTAINER
jump *label21 notEqual .CONTAINER null
print "No container.\n"
label *label21
printflush .MESSAGE
jump *label0 equal .CONTAINER null
sensor *tmp14 .SORTER @type
op strictEqual .INVERTED *tmp14 @inverted-sorter
# "Function: inline def setState(in newState)"
set .STATE true
set .CYCLES 1
op xor .ON .INVERTED true
select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
control enabled .SWITCH 0
sensor *tmp23 .SWITCH @enabled
jump __start__ notEqual *tmp23 0
label *label56
set :start @time
sensor :item .SORTER @config
jump *label33 equal :item null
jump *label31 equal .SENSOR @totalItems
label *label33
set :item .SENSOR
print "Measuring [gold]total[] in "
print .CONTAINER
jump *label32 always
label *label31
print "Measuring [gold]{0}[] in "
format :item
print .CONTAINER
label *label32
sensor :max .CONTAINER .MAXIMUM
sensor :amount .CONTAINER :item
op mul *tmp32 100 :amount
op idiv :pct *tmp32 :max
jump *label35 greaterThan :pct PCT_LOW
# "Function: inline def setState(in newState)"
jump *label36 equal .STATE true
set .STATE true
op add .CYCLES .CYCLES 1
op xor .ON .INVERTED true
select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
jump *label36 always
label *label35
jump *label42 lessThan :pct PCT_HIGH
# "Function: inline def setState(in newState)"
jump *label45 equal .STATE false
set .STATE false
op add .CYCLES .CYCLES 1
set .ON .INVERTED
select .ACTIVE_TEXT strictEqual *tmp14 @inverted-sorter "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
label *label45
label *label42
label *label36
print "\nLevel: [gold]{0}%[]"
format :pct
jump *label49 equal .INVERTED false
print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
format PCT_HIGH
format PCT_LOW
jump *label50 always
label *label49
print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
format PCT_LOW
format PCT_HIGH
label *label50
print .ACTIVE_TEXT
set :n .START
jump *label53 greaterThanEq .START @links
label *label55
getlink :block :n
control enabled :block .ON
print "\n    "
print :block
op add :n :n 1
jump *label55 lessThan :n @links
label *label53
print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
format .CYCLES
op sub *tmp53 @time :start
op floor *tmp54 *tmp53
format *tmp54
printflush .MESSAGE
sensor *tmp23 .SWITCH @enabled
jump *label56 equal *tmp23 0
