   261 instructions before optimizations.
    19 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
    27 instructions eliminated by Dead Code Elimination (7 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    10 instructions eliminated by Jump Optimization (5 iterations).
    10 instructions eliminated by Single Step Elimination (3 passes, 8 iterations).
     1 instructions modified by Expression Optimization (3 iterations).
     3 instructions eliminated by If Expression Optimization (3 iterations).
     7 instructions eliminated by Data Flow Optimization (3 passes, 11 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
    86 instructions added by Case Switching (5 iterations).
     1 case expressions converted to switched jumps Case Switching.
     7 instructions eliminated by Jump Straightening (5 iterations).
     3 instructions updated by JumpThreading.
    35 instructions eliminated by Print Merging.
   228 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 819):
    Replicate loop condition at line 72:1                        cost     1, benefit       25.0, efficiency     25.000
  * Convert case at line 25:9 (segments: 1)                      cost    86, benefit     2187.5, efficiency     25.436 (+86 instructions)

Pass 1: speed optimization selection (cost limit 733):
  * Replicate loop condition at line 72:1                        cost     1, benefit       25.0, efficiency     25.000 (+1 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    25 print :block
    26 print "\n"
    27 sensor *tmp5 :block @type
-    * set *tmp6 *tmp5
-    * jump *label8 equal *tmp6 @message
+   28 jump *label8 equal *tmp5 @message
    29 jump *label7 always
    30 label *label8
    31 set .MESSAGE :block
    32 set *tmp4 .MESSAGE
    33 jump *label6 always
    34 label *label7
-    * jump *label10 equal *tmp6 @switch
+   35 jump *label10 equal *tmp5 @switch
    36 jump *label9 always
    37 label *label10
    38 set .SWITCH :block
    39 set *tmp4 .SWITCH
    40 jump *label6 always
    41 label *label9
-    * jump *label12 equal *tmp6 @sorter
-    * jump *label12 equal *tmp6 @inverted-sorter
-    * jump *label12 equal *tmp6 @unloader
+   42 jump *label12 equal *tmp5 @sorter
+   43 jump *label12 equal *tmp5 @inverted-sorter
+   44 jump *label12 equal *tmp5 @unloader
    45 jump *label11 always
    46 label *label12
    47 set .SORTER :block
    48 set *tmp4 .SORTER
    49 jump *label6 always
    50 label *label11
-    * jump *label14 equal *tmp6 @vault
-    * jump *label14 equal *tmp6 @container
-    * jump *label14 equal *tmp6 @core-shard
-    * jump *label14 equal *tmp6 @core-foundation
-    * jump *label14 equal *tmp6 @core-nucleus
+   51 jump *label14 equal *tmp5 @vault
+   52 jump *label14 equal *tmp5 @container
+   53 jump *label14 equal *tmp5 @core-shard
+   54 jump *label14 equal *tmp5 @core-foundation
+   55 jump *label14 equal *tmp5 @core-nucleus
    56 jump *label13 always
    57 label *label14
    58 set .CONTAINER :block
 
    63 set *tmp4 .START
    64 jump *label6 always
    65 label *label13
-    * jump *label16 equal *tmp6 @liquid-tank
-    * jump *label16 equal *tmp6 @liquid-container
-    * jump *label16 equal *tmp6 @liquid-router
+   66 jump *label16 equal *tmp5 @liquid-tank
+   67 jump *label16 equal *tmp5 @liquid-container
+   68 jump *label16 equal *tmp5 @liquid-router
    69 jump *label15 always
    70 label *label16
    71 set .CONTAINER :block
 
    76 set *tmp4 .START
    77 jump *label6 always
    78 label *label15
-    * jump *label18 equal *tmp6 @battery
-    * jump *label18 equal *tmp6 @battery-large
+   79 jump *label18 equal *tmp5 @battery
+   80 jump *label18 equal *tmp5 @battery-large
    81 jump *label17 always
    82 label *label18
    83 set .CONTAINER :block
 
    88 set *tmp4 .START
    89 jump *label6 always
    90 label *label17
-    * jump *label20 equal *tmp6 @power-node
-    * jump *label20 equal *tmp6 @power-node-large
-    * jump *label20 equal *tmp6 @surge-tower
+   91 jump *label20 equal *tmp5 @power-node
+   92 jump *label20 equal *tmp5 @power-node-large
+   93 jump *label20 equal *tmp5 @surge-tower
    94 jump *label19 always
    95 label *label20
    96 set .CONTAINER :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-17 instructions):
 
    29 jump *label7 always
    30 label *label8
    31 set .MESSAGE :block
-    * set *tmp4 .MESSAGE
    32 jump *label6 always
    33 label *label7
    34 jump *label10 equal *tmp5 @switch
    35 jump *label9 always
    36 label *label10
    37 set .SWITCH :block
-    * set *tmp4 .SWITCH
    38 jump *label6 always
    39 label *label9
    40 jump *label12 equal *tmp5 @sorter
 
    43 jump *label11 always
    44 label *label12
    45 set .SORTER :block
-    * set *tmp4 .SORTER
    46 jump *label6 always
    47 label *label11
    48 jump *label14 equal *tmp5 @vault
 
    57 set .MAXIMUM @itemCapacity
    58 op add *tmp7 :n 1
    59 set .START *tmp7
-    * set *tmp4 .START
    60 jump *label6 always
    61 label *label13
    62 jump *label16 equal *tmp5 @liquid-tank
 
    69 set .MAXIMUM @liquidCapacity
    70 op add *tmp8 :n 1
    71 set .START *tmp8
-    * set *tmp4 .START
    72 jump *label6 always
    73 label *label15
    74 jump *label18 equal *tmp5 @battery
 
    80 set .MAXIMUM @powerCapacity
    81 op add *tmp9 :n 1
    82 set .START *tmp9
-    * set *tmp4 .START
    83 jump *label6 always
    84 label *label17
    85 jump *label20 equal *tmp5 @power-node
 
    92 set .MAXIMUM @powerNetCapacity
    93 op add *tmp10 :n 1
    94 set .START *tmp10
-    * set *tmp4 .START
    95 jump *label6 always
    96 label *label19
-    * set *tmp4 null
    97 label *label6
    98 label *label4
    99 jump *label3 always
 
   114 jump *label21 equal *tmp11 false
   115 print "No container."
   116 print "\n"
-    * set *tmp12 "No container."
   117 jump *label22 always
   118 label *label21
-    * set *tmp12 null
   119 label *label22
   120 printflush .MESSAGE
   121 label *label1
 
   145 label *label24
   146 set *tmp18 null
   147 label *label25
-    * set *tmp16 *tmp18
   148 label *label23
   149 set .CYCLES 0
   150 set *tmp21 .SWITCH
 
   164 set :item .SENSOR
   165 print "Measuring [gold]total[] in "
   166 print .CONTAINER
-    * set *tmp30 null
   167 jump *label32 always
   168 label *label31
   169 print "Measuring [gold]"
 
   171 print "["
   172 print "] in "
   173 print .CONTAINER
-    * set *tmp30 null
   174 label *label32
   175 sensor *tmp31 .CONTAINER .MAXIMUM
   176 set :max *tmp31
 
   203 label *label37
   204 set *tmp37 *tmp39
   205 label *label35
-    * set *tmp36 *tmp37
   206 jump *label34 always
   207 label *label33
   208 op greaterThanEq *tmp42 :pct PCT_HIGH
 
   234 label *label40
   235 set *tmp43 null
   236 label *label41
-    * set *tmp36 *tmp43
   237 label *label34
   238 print "\n"
   239 print "Level: [gold]"
 
   251 print PCT_LOW
   252 print "%"
   253 print "[]"
-    * set *tmp49 null
   254 jump *label48 always
   255 label *label47
   256 print "\n"
 
   263 print PCT_HIGH
   264 print "%"
   265 print "[]"
-    * set *tmp49 null
   266 label *label48
   267 print .ACTIVE_TEXT
   268 set :n .START

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
   140 set *tmp20 "\nCurrently inactive:[salmon]"
   141 label *label27
   142 set .ACTIVE_TEXT *tmp20
-    * set *tmp18 .ACTIVE_TEXT
   143 jump *label25 always
   144 label *label24
-    * set *tmp18 null
   145 label *label25
   146 label *label23
   147 set .CYCLES 0
 
   199 label *label36
   200 set *tmp39 null
   201 label *label37
-    * set *tmp37 *tmp39
   202 label *label35
   203 jump *label34 always
   204 label *label33
 
   226 label *label44
   227 set *tmp44 *tmp46
   228 label *label42
-    * set *tmp43 *tmp44
   229 jump *label41 always
   230 label *label40
-    * set *tmp43 null
   231 label *label41
   232 label *label34
   233 print "\n"

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-3 instructions):
 
   194 set *tmp41 "\nCurrently inactive:[salmon]"
   195 label *label39
   196 set .ACTIVE_TEXT *tmp41
-    * set *tmp39 .ACTIVE_TEXT
   197 jump *label37 always
   198 label *label36
-    * set *tmp39 null
   199 label *label37
   200 label *label35
   201 jump *label34 always
 
   222 label *label43
   223 set *tmp46 null
   224 label *label44
-    * set *tmp44 *tmp46
   225 label *label42
   226 jump *label41 always
   227 label *label40

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   217 set *tmp48 "\nCurrently inactive:[salmon]"
   218 label *label46
   219 set .ACTIVE_TEXT *tmp48
-    * set *tmp46 .ACTIVE_TEXT
   220 jump *label44 always
   221 label *label43
-    * set *tmp46 null
   222 label *label44
   223 label *label42
   224 jump *label41 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-19 instructions):
 
    12 label *label0
    13 print "Configuring regulator..."
    14 print "\n"
-    * set *tmp0 @links
-    * set :n *tmp0
+   15 set :n @links
    16 label *label3
    17 op greaterThan *tmp1 :n 0
    18 jump *label5 equal *tmp1 false
-    * op sub *tmp2 :n 1
-    * set :n *tmp2
-    * getlink *tmp3 :n
-    * set :block *tmp3
+   19 op sub :n :n 1
+   20 getlink :block :n
    21 print "Found: "
    22 print :block
    23 print "\n"
 
    52 set .CONTAINER :block
    53 set .SENSOR @totalItems
    54 set .MAXIMUM @itemCapacity
-    * op add *tmp7 :n 1
-    * set .START *tmp7
+   55 op add .START :n 1
    56 jump *label6 always
    57 label *label13
    58 jump *label16 equal *tmp5 @liquid-tank
 
    63 set .CONTAINER :block
    64 set .SENSOR @totalLiquids
    65 set .MAXIMUM @liquidCapacity
-    * op add *tmp8 :n 1
-    * set .START *tmp8
+   66 op add .START :n 1
    67 jump *label6 always
    68 label *label15
    69 jump *label18 equal *tmp5 @battery
 
    73 set .CONTAINER :block
    74 set .SENSOR @totalPower
    75 set .MAXIMUM @powerCapacity
-    * op add *tmp9 :n 1
-    * set .START *tmp9
+   76 op add .START :n 1
    77 jump *label6 always
    78 label *label17
    79 jump *label20 equal *tmp5 @power-node
 
    84 set .CONTAINER :block
    85 set .SENSOR @powerNetStored
    86 set .MAXIMUM @powerNetCapacity
-    * op add *tmp10 :n 1
-    * set .START *tmp10
+   87 op add .START :n 1
    88 jump *label6 always
    89 label *label19
    90 label *label6
 
   116 jump *label0 notEqual *tmp13 false
   117 label *label2
   118 sensor *tmp14 .SORTER @type
-    * op strictEqual *tmp15 *tmp14 @inverted-sorter
-    * set .INVERTED *tmp15
+  119 op strictEqual .INVERTED *tmp14 @inverted-sorter
   120 # "Function: inline def setState(in newState)"
   121 set :setState:newState true
   122 op notEqual *tmp17 .STATE :setState:newState
   123 jump *label24 equal *tmp17 false
   124 set .STATE :setState:newState
   125 op add .CYCLES .CYCLES 1
-    * op xor *tmp19 .INVERTED .STATE
-    * set .ON *tmp19
+  126 op xor .ON .INVERTED .STATE
   127 jump *label26 equal .ON false
   128 set *tmp20 "\nCurrently active:[green]"
   129 jump *label27 always
 
   136 label *label25
   137 label *label23
   138 set .CYCLES 0
-    * set *tmp21 .SWITCH
-    * control enabled *tmp21 0
+  139 control enabled .SWITCH 0
   140 label *label28
   141 sensor *tmp23 .SWITCH @enabled
   142 op equal *tmp24 *tmp23 0
   143 jump *label30 equal *tmp24 false
-    * set *tmp25 @time
-    * set :start *tmp25
-    * sensor *tmp26 .SORTER @config
-    * set :item *tmp26
+  144 set :start @time
+  145 sensor :item .SORTER @config
   146 op equal *tmp27 :item null
   147 op notEqual *tmp28 .SENSOR @totalItems
   148 op or *tmp29 *tmp27 *tmp28
 
   158 print "] in "
   159 print .CONTAINER
   160 label *label32
-    * sensor *tmp31 .CONTAINER .MAXIMUM
-    * set :max *tmp31
-    * sensor *tmp32 .CONTAINER :item
-    * set :amount *tmp32
+  161 sensor :max .CONTAINER .MAXIMUM
+  162 sensor :amount .CONTAINER :item
   163 op mul *tmp33 100 :amount
-    * op idiv *tmp34 *tmp33 :max
-    * set :pct *tmp34
+  164 op idiv :pct *tmp33 :max
   165 op lessThanEq *tmp35 :pct PCT_LOW
   166 jump *label33 equal *tmp35 false
   167 # "Function: inline def setState(in newState)"
 
   170 jump *label36 equal *tmp38 false
   171 set .STATE :setState.1:newState
   172 op add .CYCLES .CYCLES 1
-    * op xor *tmp40 .INVERTED .STATE
-    * set .ON *tmp40
+  173 op xor .ON .INVERTED .STATE
   174 jump *label38 equal .ON false
   175 set *tmp41 "\nCurrently active:[green]"
   176 jump *label39 always
 
   192 jump *label43 equal *tmp45 false
   193 set .STATE :setState.2:newState
   194 op add .CYCLES .CYCLES 1
-    * op xor *tmp47 .INVERTED .STATE
-    * set .ON *tmp47
+  195 op xor .ON .INVERTED .STATE
   196 jump *label45 equal .ON false
   197 set *tmp48 "\nCurrently active:[green]"
   198 jump *label46 always
 
   242 label *label49
   243 op lessThan *tmp50 :n @links
   244 jump *label51 equal *tmp50 false
-    * getlink *tmp51 :n
-    * set :block *tmp51
-    * set *tmp52 :block
-    * control enabled *tmp52 .ON
+  245 getlink :block :n
+  246 control enabled :block .ON
   247 print "\n    "
   248 print :block
   249 op add :n :n 1

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    22 print :block
    23 print "\n"
    24 sensor *tmp5 :block @type
-    * jump *label8 equal *tmp5 @message
-    * jump *label7 always
+   25 jump *label7 notEqual *tmp5 @message
    26 label *label8
    27 set .MESSAGE :block
    28 jump *label6 always
    29 label *label7
-    * jump *label10 equal *tmp5 @switch
-    * jump *label9 always
+   30 jump *label9 notEqual *tmp5 @switch
    31 label *label10
    32 set .SWITCH :block
    33 jump *label6 always
    34 label *label9
    35 jump *label12 equal *tmp5 @sorter
    36 jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label12 equal *tmp5 @unloader
-    * jump *label11 always
+   37 jump *label11 notEqual *tmp5 @unloader
    38 label *label12
    39 set .SORTER :block
    40 jump *label6 always
 
    43 jump *label14 equal *tmp5 @container
    44 jump *label14 equal *tmp5 @core-shard
    45 jump *label14 equal *tmp5 @core-foundation
-    * jump *label14 equal *tmp5 @core-nucleus
-    * jump *label13 always
+   46 jump *label13 notEqual *tmp5 @core-nucleus
    47 label *label14
    48 set .CONTAINER :block
    49 set .SENSOR @totalItems
 
    53 label *label13
    54 jump *label16 equal *tmp5 @liquid-tank
    55 jump *label16 equal *tmp5 @liquid-container
-    * jump *label16 equal *tmp5 @liquid-router
-    * jump *label15 always
+   56 jump *label15 notEqual *tmp5 @liquid-router
    57 label *label16
    58 set .CONTAINER :block
    59 set .SENSOR @totalLiquids
 
    62 jump *label6 always
    63 label *label15
    64 jump *label18 equal *tmp5 @battery
-    * jump *label18 equal *tmp5 @battery-large
-    * jump *label17 always
+   65 jump *label17 notEqual *tmp5 @battery-large
    66 label *label18
    67 set .CONTAINER :block
    68 set .SENSOR @totalPower
 
    72 label *label17
    73 jump *label20 equal *tmp5 @power-node
    74 jump *label20 equal *tmp5 @power-node-large
-    * jump *label20 equal *tmp5 @surge-tower
-    * jump *label19 always
+   75 jump *label19 notEqual *tmp5 @surge-tower
    76 label *label20
    77 set .CONTAINER :block
    78 set .SENSOR @powerNetStored

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-10 instructions):
 
    14 print "\n"
    15 set :n @links
    16 label *label3
-    * op greaterThan *tmp1 :n 0
-    * jump *label5 equal *tmp1 false
+   17 jump *label5 lessThanEq :n 0
    18 op sub :n :n 1
    19 getlink :block :n
    20 print "Found: "
 
    95 print "Container: "
    96 print .CONTAINER
    97 print "\n"
-    * op equal *tmp11 .CONTAINER null
-    * jump *label21 equal *tmp11 false
+   98 jump *label21 notEqual .CONTAINER null
    99 print "No container."
   100 print "\n"
   101 jump *label22 always
 
   103 label *label22
   104 printflush .MESSAGE
   105 label *label1
-    * op equal *tmp13 .CONTAINER null
-    * jump *label0 notEqual *tmp13 false
+  106 jump *label0 equal .CONTAINER null
   107 label *label2
   108 sensor *tmp14 .SORTER @type
   109 op strictEqual .INVERTED *tmp14 @inverted-sorter
   110 # "Function: inline def setState(in newState)"
   111 set :setState:newState true
-    * op notEqual *tmp17 .STATE :setState:newState
-    * jump *label24 equal *tmp17 false
+  112 jump *label24 equal .STATE :setState:newState
   113 set .STATE :setState:newState
   114 op add .CYCLES .CYCLES 1
   115 op xor .ON .INVERTED .STATE
 
   128 control enabled .SWITCH 0
   129 label *label28
   130 sensor *tmp23 .SWITCH @enabled
-    * op equal *tmp24 *tmp23 0
-    * jump *label30 equal *tmp24 false
+  131 jump *label30 notEqual *tmp23 0
   132 set :start @time
   133 sensor :item .SORTER @config
   134 op equal *tmp27 :item null
 
   150 sensor :amount .CONTAINER :item
   151 op mul *tmp33 100 :amount
   152 op idiv :pct *tmp33 :max
-    * op lessThanEq *tmp35 :pct PCT_LOW
-    * jump *label33 equal *tmp35 false
+  153 jump *label33 greaterThan :pct PCT_LOW
   154 # "Function: inline def setState(in newState)"
   155 set :setState.1:newState true
-    * op notEqual *tmp38 .STATE :setState.1:newState
-    * jump *label36 equal *tmp38 false
+  156 jump *label36 equal .STATE :setState.1:newState
   157 set .STATE :setState.1:newState
   158 op add .CYCLES .CYCLES 1
   159 op xor .ON .INVERTED .STATE
 
   170 label *label35
   171 jump *label34 always
   172 label *label33
-    * op greaterThanEq *tmp42 :pct PCT_HIGH
-    * jump *label40 equal *tmp42 false
+  173 jump *label40 lessThan :pct PCT_HIGH
   174 # "Function: inline def setState(in newState)"
   175 set :setState.2:newState false
-    * op notEqual *tmp45 .STATE :setState.2:newState
-    * jump *label43 equal *tmp45 false
+  176 jump *label43 equal .STATE :setState.2:newState
   177 set .STATE :setState.2:newState
   178 op add .CYCLES .CYCLES 1
   179 op xor .ON .INVERTED .STATE
 
   224 print .ACTIVE_TEXT
   225 set :n .START
   226 label *label49
-    * op lessThan *tmp50 :n @links
-    * jump *label51 equal *tmp50 false
+  227 jump *label51 greaterThanEq :n @links
   228 getlink :block :n
   229 control enabled :block .ON
   230 print "\n    "

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-6 instructions):
 
    77 set .SENSOR @powerNetStored
    78 set .MAXIMUM @powerNetCapacity
    79 op add .START :n 1
-    * jump *label6 always
    80 label *label19
    81 label *label6
    82 label *label4
 
    97 jump *label21 notEqual .CONTAINER null
    98 print "No container."
    99 print "\n"
-    * jump *label22 always
   100 label *label21
   101 label *label22
   102 printflush .MESSAGE
 
   118 set *tmp20 "\nCurrently inactive:[salmon]"
   119 label *label27
   120 set .ACTIVE_TEXT *tmp20
-    * jump *label25 always
   121 label *label24
   122 label *label25
   123 label *label23
 
   161 set *tmp41 "\nCurrently inactive:[salmon]"
   162 label *label39
   163 set .ACTIVE_TEXT *tmp41
-    * jump *label37 always
   164 label *label36
   165 label *label37
   166 label *label35
 
   180 set *tmp48 "\nCurrently inactive:[salmon]"
   181 label *label46
   182 set .ACTIVE_TEXT *tmp48
-    * jump *label44 always
   183 label *label43
   184 label *label44
   185 label *label42
-    * jump *label41 always
   186 label *label40
   187 label *label41
   188 label *label34

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-1 instructions):
 
     2 set .CONTAINER null
     3 set .SORTER null
     4 set .SWITCH null
-    * set .STATE .SWITCH
-    * set .START .STATE
-    * set .SENSOR .START
-    * set .ON .SENSOR
-    * set .MESSAGE .ON
-    * set .MAXIMUM .MESSAGE
-    * set .ACTIVE_TEXT .MAXIMUM
+    5 set .STATE null
+    6 set .START .SWITCH
+    7 set .SENSOR .STATE
+    8 set .ON .START
+    9 set .MESSAGE .SENSOR
+   10 set .MAXIMUM .ON
+   11 set .ACTIVE_TEXT .MESSAGE
    12 label *label0
    13 print "Configuring regulator..."
    14 print "\n"
 
   107 op strictEqual .INVERTED *tmp14 @inverted-sorter
   108 # "Function: inline def setState(in newState)"
   109 set :setState:newState true
-    * jump *label24 equal .STATE :setState:newState
-    * set .STATE :setState:newState
-    * op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  110 jump *label24 equal .STATE true
+  111 set .STATE true
+  112 op xor .ON .INVERTED :setState:newState
   113 jump *label26 equal .ON false
   114 set *tmp20 "\nCurrently active:[green]"
   115 jump *label27 always
 
   149 jump *label33 greaterThan :pct PCT_LOW
   150 # "Function: inline def setState(in newState)"
   151 set :setState.1:newState true
-    * jump *label36 equal .STATE :setState.1:newState
-    * set .STATE :setState.1:newState
+  152 jump *label36 equal .STATE true
+  153 set .STATE true
   154 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  155 op xor .ON .INVERTED :setState.1:newState
   156 jump *label38 equal .ON false
   157 set *tmp41 "\nCurrently active:[green]"
   158 jump *label39 always
 
   168 jump *label40 lessThan :pct PCT_HIGH
   169 # "Function: inline def setState(in newState)"
   170 set :setState.2:newState false
-    * jump *label43 equal .STATE :setState.2:newState
-    * set .STATE :setState.2:newState
+  171 jump *label43 equal .STATE false
+  172 set .STATE false
   173 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  174 op xor .ON .INVERTED :setState.2:newState
   175 jump *label45 equal .ON false
   176 set *tmp48 "\nCurrently active:[green]"
   177 jump *label46 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2:
 
     3 set .SORTER null
     4 set .SWITCH null
     5 set .STATE null
-    * set .START .SWITCH
-    * set .SENSOR .STATE
-    * set .ON .START
-    * set .MESSAGE .SENSOR
-    * set .MAXIMUM .ON
-    * set .ACTIVE_TEXT .MESSAGE
+    6 set .START null
+    7 set .SENSOR null
+    8 set .ON .SWITCH
+    9 set .MESSAGE .STATE
+   10 set .MAXIMUM .START
+   11 set .ACTIVE_TEXT .SENSOR
    12 label *label0
    13 print "Configuring regulator..."
    14 print "\n"
 
   107 op strictEqual .INVERTED *tmp14 @inverted-sorter
   108 # "Function: inline def setState(in newState)"
   109 set :setState:newState true
-    * jump *label24 equal .STATE true
+  110 jump *label24 equal null true
   111 set .STATE true
-    * op xor .ON .INVERTED :setState:newState
+  112 op xor .ON .INVERTED true
   113 jump *label26 equal .ON false
   114 set *tmp20 "\nCurrently active:[green]"
   115 jump *label27 always
 
   152 jump *label36 equal .STATE true
   153 set .STATE true
   154 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.1:newState
+  155 op xor .ON .INVERTED true
   156 jump *label38 equal .ON false
   157 set *tmp41 "\nCurrently active:[green]"
   158 jump *label39 always
 
   171 jump *label43 equal .STATE false
   172 set .STATE false
   173 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.2:newState
+  174 op xor .ON .INVERTED false
   175 jump *label45 equal .ON false
   176 set *tmp48 "\nCurrently active:[green]"
   177 jump *label46 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
     5 set .STATE null
     6 set .START null
     7 set .SENSOR null
-    * set .ON .SWITCH
-    * set .MESSAGE .STATE
-    * set .MAXIMUM .START
-    * set .ACTIVE_TEXT .SENSOR
+    8 set .ON null
+    9 set .MESSAGE null
+   10 set .MAXIMUM null
+   11 set .ACTIVE_TEXT null
    12 label *label0
    13 print "Configuring regulator..."
    14 print "\n"
 
   106 sensor *tmp14 .SORTER @type
   107 op strictEqual .INVERTED *tmp14 @inverted-sorter
   108 # "Function: inline def setState(in newState)"
-    * set :setState:newState true
   109 jump *label24 equal null true
   110 set .STATE true
   111 op xor .ON .INVERTED true
 
   147 op idiv :pct *tmp33 :max
   148 jump *label33 greaterThan :pct PCT_LOW
   149 # "Function: inline def setState(in newState)"
-    * set :setState.1:newState true
   150 jump *label36 equal .STATE true
   151 set .STATE true
   152 op add .CYCLES .CYCLES 1
 
   165 label *label33
   166 jump *label40 lessThan :pct PCT_HIGH
   167 # "Function: inline def setState(in newState)"
-    * set :setState.2:newState false
   168 jump *label43 equal .STATE false
   169 set .STATE false
   170 op add .CYCLES .CYCLES 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-3 instructions):
 
     2 set .CONTAINER null
     3 set .SORTER null
     4 set .SWITCH null
-    * set .STATE null
     5 set .START null
     6 set .SENSOR null
-    * set .ON null
     7 set .MESSAGE null
     8 set .MAXIMUM null
-    * set .ACTIVE_TEXT null
     9 label *label0
    10 print "Configuring regulator..."
    11 print "\n"

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    12 set :n @links
    13 label *label3
    14 jump *label5 lessThanEq :n 0
+   15 label *label52
    16 op sub :n :n 1
    17 getlink :block :n
    18 print "Found: "
 
    78 label *label19
    79 label *label6
    80 label *label4
-    * jump *label3 always
+   81 jump *label52 greaterThan :n 0
    82 label *label5
    83 print "Message: "
    84 print .MESSAGE
 
   213 set :n .START
   214 label *label49
   215 jump *label51 greaterThanEq :n @links
+  216 label *label53
   217 getlink :block :n
   218 control enabled :block .ON
   219 print "\n    "
   220 print :block
   221 op add :n :n 1
   222 label *label50
-    * jump *label49 always
+  223 jump *label53 lessThan :n @links
   224 label *label51
   225 print "[]"
   226 print "\n"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
   107 jump *label24 equal null true
   108 set .STATE true
   109 op xor .ON .INVERTED true
-    * jump *label26 equal .ON false
-    * set *tmp20 "\nCurrently active:[green]"
+  110 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
+  111 jump *label27 equal .ON false
+  112 set .ACTIVE_TEXT "\nCurrently active:[green]"
   113 jump *label27 always
-    * label *label26
-    * set *tmp20 "\nCurrently inactive:[salmon]"
   114 label *label27
-    * set .ACTIVE_TEXT *tmp20
   115 label *label24
   116 label *label25
   117 label *label23
 
   147 set .STATE true
   148 op add .CYCLES .CYCLES 1
   149 op xor .ON .INVERTED true
-    * jump *label38 equal .ON false
-    * set *tmp41 "\nCurrently active:[green]"
+  150 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
+  151 jump *label39 equal .ON false
+  152 set .ACTIVE_TEXT "\nCurrently active:[green]"
   153 jump *label39 always
-    * label *label38
-    * set *tmp41 "\nCurrently inactive:[salmon]"
   154 label *label39
-    * set .ACTIVE_TEXT *tmp41
   155 label *label36
   156 label *label37
   157 label *label35
 
   163 set .STATE false
   164 op add .CYCLES .CYCLES 1
   165 op xor .ON .INVERTED false
-    * jump *label45 equal .ON false
-    * set *tmp48 "\nCurrently active:[green]"
+  166 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
+  167 jump *label46 equal .ON false
+  168 set .ACTIVE_TEXT "\nCurrently active:[green]"
   169 jump *label46 always
-    * label *label45
-    * set *tmp48 "\nCurrently inactive:[salmon]"
   170 label *label46
-    * set .ACTIVE_TEXT *tmp48
   171 label *label43
   172 label *label44
   173 label *label42

Modifications by Convert case at line 25:9 (segments: 1) (+86 instructions):
 
    19 print :block
    20 print "\n"
    21 sensor *tmp5 :block @type
-    * jump *label7 notEqual *tmp5 @message
+   22 sensor *tmp56 *tmp5 @id
+   23 jump *label54 lessThan *tmp56 48
+   24 jump *label54 greaterThan *tmp56 146
+   25 multijump *label55 *tmp56 48 (m:*label154)
+   26 multilabel *label55 (m:*label154)
+   27 jump *label12 always
+   28 multilabel *label56 (m:*label154)
+   29 jump *label12 always
+   30 multilabel *label57 (m:*label154)
+   31 jump *label54 always
+   32 multilabel *label58 (m:*label154)
+   33 jump *label54 always
+   34 multilabel *label59 (m:*label154)
+   35 jump *label54 always
+   36 multilabel *label60 (m:*label154)
+   37 jump *label54 always
+   38 multilabel *label61 (m:*label154)
+   39 jump *label54 always
+   40 multilabel *label62 (m:*label154)
+   41 jump *label54 always
+   42 multilabel *label63 (m:*label154)
+   43 jump *label54 always
+   44 multilabel *label64 (m:*label154)
+   45 jump *label54 always
+   46 multilabel *label65 (m:*label154)
+   47 jump *label54 always
+   48 multilabel *label66 (m:*label154)
+   49 jump *label54 always
+   50 multilabel *label67 (m:*label154)
+   51 jump *label54 always
+   52 multilabel *label68 (m:*label154)
+   53 jump *label54 always
+   54 multilabel *label69 (m:*label154)
+   55 jump *label54 always
+   56 multilabel *label70 (m:*label154)
+   57 jump *label16 always
+   58 multilabel *label71 (m:*label154)
+   59 jump *label16 always
+   60 multilabel *label72 (m:*label154)
+   61 jump *label54 always
+   62 multilabel *label73 (m:*label154)
+   63 jump *label54 always
+   64 multilabel *label74 (m:*label154)
+   65 jump *label54 always
+   66 multilabel *label75 (m:*label154)
+   67 jump *label20 always
+   68 multilabel *label76 (m:*label154)
+   69 jump *label20 always
+   70 multilabel *label77 (m:*label154)
+   71 jump *label20 always
+   72 multilabel *label78 (m:*label154)
+   73 jump *label54 always
+   74 multilabel *label79 (m:*label154)
+   75 jump *label18 always
+   76 multilabel *label80 (m:*label154)
+   77 jump *label18 always
+   78 multilabel *label81 (m:*label154)
+   79 jump *label54 always
+   80 multilabel *label82 (m:*label154)
+   81 jump *label54 always
+   82 multilabel *label83 (m:*label154)
+   83 jump *label54 always
+   84 multilabel *label84 (m:*label154)
+   85 jump *label54 always
+   86 multilabel *label85 (m:*label154)
+   87 jump *label54 always
+   88 multilabel *label86 (m:*label154)
+   89 jump *label54 always
+   90 multilabel *label87 (m:*label154)
+   91 jump *label54 always
+   92 multilabel *label88 (m:*label154)
+   93 jump *label54 always
+   94 multilabel *label89 (m:*label154)
+   95 jump *label54 always
+   96 multilabel *label90 (m:*label154)
+   97 jump *label54 always
+   98 multilabel *label91 (m:*label154)
+   99 jump *label54 always
+  100 multilabel *label92 (m:*label154)
+  101 jump *label54 always
+  102 multilabel *label93 (m:*label154)
+  103 jump *label54 always
+  104 multilabel *label94 (m:*label154)
+  105 jump *label54 always
+  106 multilabel *label95 (m:*label154)
+  107 jump *label54 always
+  108 multilabel *label96 (m:*label154)
+  109 jump *label54 always
+  110 multilabel *label97 (m:*label154)
+  111 jump *label14 always
+  112 multilabel *label98 (m:*label154)
+  113 jump *label14 always
+  114 multilabel *label99 (m:*label154)
+  115 jump *label14 always
+  116 multilabel *label100 (m:*label154)
+  117 jump *label14 always
+  118 multilabel *label101 (m:*label154)
+  119 jump *label14 always
+  120 multilabel *label102 (m:*label154)
+  121 jump *label12 always
+  122 multilabel *label103 (m:*label154)
+  123 jump *label54 always
+  124 multilabel *label104 (m:*label154)
+  125 jump *label54 always
+  126 multilabel *label105 (m:*label154)
+  127 jump *label54 always
+  128 multilabel *label106 (m:*label154)
+  129 jump *label54 always
+  130 multilabel *label107 (m:*label154)
+  131 jump *label54 always
+  132 multilabel *label108 (m:*label154)
+  133 jump *label54 always
+  134 multilabel *label109 (m:*label154)
+  135 jump *label54 always
+  136 multilabel *label110 (m:*label154)
+  137 jump *label54 always
+  138 multilabel *label111 (m:*label154)
+  139 jump *label54 always
+  140 multilabel *label112 (m:*label154)
+  141 jump *label54 always
+  142 multilabel *label113 (m:*label154)
+  143 jump *label54 always
+  144 multilabel *label114 (m:*label154)
+  145 jump *label54 always
+  146 multilabel *label115 (m:*label154)
+  147 jump *label54 always
+  148 multilabel *label116 (m:*label154)
+  149 jump *label54 always
+  150 multilabel *label117 (m:*label154)
+  151 jump *label54 always
+  152 multilabel *label118 (m:*label154)
+  153 jump *label54 always
+  154 multilabel *label119 (m:*label154)
+  155 jump *label54 always
+  156 multilabel *label120 (m:*label154)
+  157 jump *label54 always
+  158 multilabel *label121 (m:*label154)
+  159 jump *label54 always
+  160 multilabel *label122 (m:*label154)
+  161 jump *label54 always
+  162 multilabel *label123 (m:*label154)
+  163 jump *label54 always
+  164 multilabel *label124 (m:*label154)
+  165 jump *label54 always
+  166 multilabel *label125 (m:*label154)
+  167 jump *label54 always
+  168 multilabel *label126 (m:*label154)
+  169 jump *label54 always
+  170 multilabel *label127 (m:*label154)
+  171 jump *label54 always
+  172 multilabel *label128 (m:*label154)
+  173 jump *label54 always
+  174 multilabel *label129 (m:*label154)
+  175 jump *label54 always
+  176 multilabel *label130 (m:*label154)
+  177 jump *label54 always
+  178 multilabel *label131 (m:*label154)
+  179 jump *label54 always
+  180 multilabel *label132 (m:*label154)
+  181 jump *label54 always
+  182 multilabel *label133 (m:*label154)
+  183 jump *label54 always
+  184 multilabel *label134 (m:*label154)
+  185 jump *label54 always
+  186 multilabel *label135 (m:*label154)
+  187 jump *label54 always
+  188 multilabel *label136 (m:*label154)
+  189 jump *label54 always
+  190 multilabel *label137 (m:*label154)
+  191 jump *label54 always
+  192 multilabel *label138 (m:*label154)
+  193 jump *label54 always
+  194 multilabel *label139 (m:*label154)
+  195 jump *label54 always
+  196 multilabel *label140 (m:*label154)
+  197 jump *label54 always
+  198 multilabel *label141 (m:*label154)
+  199 jump *label54 always
+  200 multilabel *label142 (m:*label154)
+  201 jump *label54 always
+  202 multilabel *label143 (m:*label154)
+  203 jump *label54 always
+  204 multilabel *label144 (m:*label154)
+  205 jump *label8 always
+  206 multilabel *label145 (m:*label154)
+  207 jump *label10 always
+  208 multilabel *label146 (m:*label154)
+  209 jump *label54 always
+  210 multilabel *label147 (m:*label154)
+  211 jump *label54 always
+  212 multilabel *label148 (m:*label154)
+  213 jump *label54 always
+  214 multilabel *label149 (m:*label154)
+  215 jump *label54 always
+  216 multilabel *label150 (m:*label154)
+  217 jump *label54 always
+  218 multilabel *label151 (m:*label154)
+  219 jump *label54 always
+  220 multilabel *label152 (m:*label154)
+  221 jump *label54 always
+  222 multilabel *label153 (m:*label154)
+  223 jump *label16 always
   224 label *label8
   225 set .MESSAGE :block
   226 jump *label6 always
   227 label *label7
-    * jump *label9 notEqual *tmp5 @switch
   228 label *label10
   229 set .SWITCH :block
   230 jump *label6 always
   231 label *label9
-    * jump *label12 equal *tmp5 @sorter
-    * jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label11 notEqual *tmp5 @unloader
   232 label *label12
   233 set .SORTER :block
   234 jump *label6 always
   235 label *label11
-    * jump *label14 equal *tmp5 @vault
-    * jump *label14 equal *tmp5 @container
-    * jump *label14 equal *tmp5 @core-shard
-    * jump *label14 equal *tmp5 @core-foundation
-    * jump *label13 notEqual *tmp5 @core-nucleus
   236 label *label14
   237 set .CONTAINER :block
   238 set .SENSOR @totalItems
 
   240 op add .START :n 1
   241 jump *label6 always
   242 label *label13
-    * jump *label16 equal *tmp5 @liquid-tank
-    * jump *label16 equal *tmp5 @liquid-container
-    * jump *label15 notEqual *tmp5 @liquid-router
   243 label *label16
   244 set .CONTAINER :block
   245 set .SENSOR @totalLiquids
 
   247 op add .START :n 1
   248 jump *label6 always
   249 label *label15
-    * jump *label18 equal *tmp5 @battery
-    * jump *label17 notEqual *tmp5 @battery-large
   250 label *label18
   251 set .CONTAINER :block
   252 set .SENSOR @totalPower
 
   254 op add .START :n 1
   255 jump *label6 always
   256 label *label17
-    * jump *label20 equal *tmp5 @power-node
-    * jump *label20 equal *tmp5 @power-node-large
-    * jump *label19 notEqual *tmp5 @surge-tower
   257 label *label20
   258 set .CONTAINER :block
   259 set .SENSOR @powerNetStored
   260 set .MAXIMUM @powerNetCapacity
   261 op add .START :n 1
   262 label *label19
+  263 label *label54
   264 label *label6
   265 label *label4
   266 jump *label52 greaterThan :n 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   391 print .ACTIVE_TEXT
   392 set :n .START
   393 label *label49
-    * jump *label51 greaterThanEq :n @links
+  394 jump *label51 greaterThanEq .START @links
   395 label *label53
   396 getlink :block :n
   397 control enabled :block .ON

Modifications by Replicate loop condition at line 72:1 (+1 instructions):
 
   305 label *label28
   306 sensor *tmp23 .SWITCH @enabled
   307 jump *label30 notEqual *tmp23 0
+  308 label *label155
   309 set :start @time
   310 sensor :item .SORTER @config
   311 op equal *tmp27 :item null
 
   415 print "ms"
   416 printflush .MESSAGE
   417 label *label29
-    * jump *label28 always
+  418 sensor *tmp23 .SWITCH @enabled
+  419 jump *label155 equal *tmp23 0
   420 label *label30
   421 end

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   289 sensor *tmp14 .SORTER @type
   290 op strictEqual .INVERTED *tmp14 @inverted-sorter
   291 # "Function: inline def setState(in newState)"
-    * jump *label24 equal null true
   292 set .STATE true
   293 op xor .ON .INVERTED true
   294 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
   294 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
   295 jump *label27 equal .ON false
   296 set .ACTIVE_TEXT "\nCurrently active:[green]"
-    * jump *label27 always
   297 label *label27
   298 label *label24
   299 label *label25
 
   334 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
   335 jump *label39 equal .ON false
   336 set .ACTIVE_TEXT "\nCurrently active:[green]"
-    * jump *label39 always
   337 label *label39
   338 label *label36
   339 label *label37
 
   349 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
   350 jump *label46 equal .ON false
   351 set .ACTIVE_TEXT "\nCurrently active:[green]"
-    * jump *label46 always
   352 label *label46
   353 label *label43
   354 label *label44

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   345 jump *label43 equal .STATE false
   346 set .STATE false
   347 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED false
+  348 set .ON .INVERTED
   349 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
   350 jump *label46 equal .ON false
   351 set .ACTIVE_TEXT "\nCurrently active:[green]"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   347 op add .CYCLES .CYCLES 1
   348 set .ON .INVERTED
   349 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
-    * jump *label46 equal .ON false
+  350 jump *label46 equal .INVERTED false
   351 set .ACTIVE_TEXT "\nCurrently active:[green]"
   352 label *label46
   353 label *label43

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    10 print "Configuring regulator..."
    11 print "\n"
    12 set :n @links
-    * label *label3
    13 jump *label5 lessThanEq :n 0
    14 label *label52
    15 op sub :n :n 1
 
   223 label *label8
   224 set .MESSAGE :block
   225 jump *label6 always
-    * label *label7
   226 label *label10
   227 set .SWITCH :block
   228 jump *label6 always
-    * label *label9
   229 label *label12
   230 set .SORTER :block
   231 jump *label6 always
-    * label *label11
   232 label *label14
   233 set .CONTAINER :block
   234 set .SENSOR @totalItems
   235 set .MAXIMUM @itemCapacity
   236 op add .START :n 1
   237 jump *label6 always
-    * label *label13
   238 label *label16
   239 set .CONTAINER :block
   240 set .SENSOR @totalLiquids
   241 set .MAXIMUM @liquidCapacity
   242 op add .START :n 1
   243 jump *label6 always
-    * label *label15
   244 label *label18
   245 set .CONTAINER :block
   246 set .SENSOR @totalPower
   247 set .MAXIMUM @powerCapacity
   248 op add .START :n 1
   249 jump *label6 always
-    * label *label17
   250 label *label20
   251 set .CONTAINER :block
   252 set .SENSOR @powerNetStored
   253 set .MAXIMUM @powerNetCapacity
   254 op add .START :n 1
-    * label *label19
   255 label *label54
   256 label *label6
-    * label *label4
   257 jump *label52 greaterThan :n 0
   258 label *label5
   259 print "Message: "
 
   272 print "No container."
   273 print "\n"
   274 label *label21
-    * label *label22
   275 printflush .MESSAGE
-    * label *label1
   276 jump *label0 equal .CONTAINER null
-    * label *label2
   277 sensor *tmp14 .SORTER @type
   278 op strictEqual .INVERTED *tmp14 @inverted-sorter
   279 # "Function: inline def setState(in newState)"
 
   283 jump *label27 equal .ON false
   284 set .ACTIVE_TEXT "\nCurrently active:[green]"
   285 label *label27
-    * label *label24
-    * label *label25
-    * label *label23
   286 set .CYCLES 0
   287 control enabled .SWITCH 0
-    * label *label28
   288 sensor *tmp23 .SWITCH @enabled
   289 jump *label30 notEqual *tmp23 0
   290 label *label155
 
   320 set .ACTIVE_TEXT "\nCurrently active:[green]"
   321 label *label39
   322 label *label36
-    * label *label37
-    * label *label35
   323 jump *label34 always
   324 label *label33
   325 jump *label40 lessThan :pct PCT_HIGH
 
   333 set .ACTIVE_TEXT "\nCurrently active:[green]"
   334 label *label46
   335 label *label43
-    * label *label44
-    * label *label42
   336 label *label40
-    * label *label41
   337 label *label34
   338 print "\n"
   339 print "Level: [gold]"
 
   366 label *label48
   367 print .ACTIVE_TEXT
   368 set :n .START
-    * label *label49
   369 jump *label51 greaterThanEq .START @links
   370 label *label53
   371 getlink :block :n
 
   373 print "\n    "
   374 print :block
   375 op add :n :n 1
-    * label *label50
   376 jump *label53 lessThan :n @links
   377 label *label51
   378 print "[]"
 
   387 print " "
   388 print "ms"
   389 printflush .MESSAGE
-    * label *label29
   390 sensor *tmp23 .SWITCH @enabled
   391 jump *label155 equal *tmp23 0
   392 label *label30

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 set PCT_LOW 60
     2 set PCT_HIGH 80
     3 set .CONTAINER null
 
   287 set .CYCLES 0
   288 control enabled .SWITCH 0
   289 sensor *tmp23 .SWITCH @enabled
-    * jump *label30 notEqual *tmp23 0
+  290 jump __start__ notEqual *tmp23 0
   291 label *label155
   292 set :start @time
   293 sensor :item .SORTER @config
 
   312 op idiv :pct *tmp33 :max
   313 jump *label33 greaterThan :pct PCT_LOW
   314 # "Function: inline def setState(in newState)"
-    * jump *label36 equal .STATE true
+  315 jump *label34 equal .STATE true
   316 set .STATE true
   317 op add .CYCLES .CYCLES 1
   318 op xor .ON .INVERTED true
   319 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
-    * jump *label39 equal .ON false
+  320 jump *label34 equal .ON false
   321 set .ACTIVE_TEXT "\nCurrently active:[green]"
   322 label *label39
   323 label *label36

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1:
 
   319 set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
   320 jump *label34 equal .ON false
   321 set .ACTIVE_TEXT "\nCurrently active:[green]"
-    * label *label39
-    * label *label36
   322 jump *label34 always
   323 label *label33
   324 jump *label40 lessThan :pct PCT_HIGH
 
   388 printflush .MESSAGE
   389 sensor *tmp23 .SWITCH @enabled
   390 jump *label155 equal *tmp23 0
-    * label *label30
   391 end

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   388 printflush .MESSAGE
   389 sensor *tmp23 .SWITCH @enabled
   390 jump *label155 equal *tmp23 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-35 instructions):
 
     8 set .MESSAGE null
     9 set .MAXIMUM null
    10 label *label0
-    * print "Configuring regulator..."
-    * print "\n"
+   11 print "Configuring regulator...\n"
    12 set :n @links
    13 jump *label5 lessThanEq :n 0
    14 label *label52
    15 op sub :n :n 1
    16 getlink :block :n
-    * print "Found: "
-    * print :block
-    * print "\n"
+   17 print "Found: {0}\n"
+   18 format :block
    19 sensor *tmp5 :block @type
    20 sensor *tmp56 *tmp5 @id
    21 jump *label54 lessThan *tmp56 48
 
   255 label *label6
   256 jump *label52 greaterThan :n 0
   257 label *label5
-    * print "Message: "
-    * print .MESSAGE
-    * print "\n"
-    * print "Switch: "
-    * print .SWITCH
-    * print "\n"
-    * print "Sorter: "
-    * print .SORTER
-    * print "\n"
-    * print "Container: "
-    * print .CONTAINER
-    * print "\n"
+  258 print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
+  259 format .MESSAGE
+  260 format .SWITCH
+  261 format .SORTER
+  262 format .CONTAINER
   263 jump *label21 notEqual .CONTAINER null
-    * print "No container."
-    * print "\n"
+  264 print "No container.\n"
   265 label *label21
   266 printflush .MESSAGE
   267 jump *label0 equal .CONTAINER null
 
   290 print .CONTAINER
   291 jump *label32 always
   292 label *label31
-    * print "Measuring [gold]"
-    * print :item
-    * print "["
-    * print "] in "
+  293 print "Measuring [gold]{0}[] in "
+  294 format :item
   295 print .CONTAINER
   296 label *label32
   297 sensor :max .CONTAINER .MAXIMUM
 
   322 label *label43
   323 label *label40
   324 label *label34
-    * print "\n"
-    * print "Level: [gold]"
-    * print :pct
-    * print "%"
-    * print "[]"
+  325 print "\nLevel: [gold]{0}%[]"
+  326 format :pct
   327 jump *label47 equal .INVERTED false
-    * print "\n"
-    * print "Activate above [green]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate below [salmon]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
+  328 print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
+  329 format PCT_HIGH
+  330 format PCT_LOW
   331 jump *label48 always
   332 label *label47
-    * print "\n"
-    * print "Activate below [green]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate above [salmon]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
+  333 print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
+  334 format PCT_LOW
+  335 format PCT_HIGH
   336 label *label48
   337 print .ACTIVE_TEXT
   338 set :n .START
 
   345 op add :n :n 1
   346 jump *label53 lessThan :n @links
   347 label *label51
-    * print "[]"
-    * print "\n"
-    * print "# of cycles: "
-    * print .CYCLES
+  348 print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
+  349 format .CYCLES
   350 op sub *tmp54 @time :start
   351 op floor *tmp55 *tmp54
-    * print "\n"
-    * print "[lightgray]Loop: "
-    * print *tmp55
-    * print " "
-    * print "ms"
+  352 format *tmp55
   353 printflush .MESSAGE
   354 sensor *tmp23 .SWITCH @enabled
   355 jump *label155 equal *tmp23 0

Final code before resolving virtual instructions:

label __start__
set PCT_LOW 60
set PCT_HIGH 80
set .CONTAINER null
set .SORTER null
set .SWITCH null
set .START null
set .SENSOR null
set .MESSAGE null
set .MAXIMUM null
label *label0
print "Configuring regulator...\n"
set :n @links
jump *label5 lessThanEq :n 0
label *label52
op sub :n :n 1
getlink :block :n
print "Found: {0}\n"
format :block
sensor *tmp5 :block @type
sensor *tmp56 *tmp5 @id
jump *label54 lessThan *tmp56 48
jump *label54 greaterThan *tmp56 146
multijump *label55 *tmp56 48
multilabel *label55
jump *label12 always
multilabel *label56
jump *label12 always
multilabel *label57
jump *label54 always
multilabel *label58
jump *label54 always
multilabel *label59
jump *label54 always
multilabel *label60
jump *label54 always
multilabel *label61
jump *label54 always
multilabel *label62
jump *label54 always
multilabel *label63
jump *label54 always
multilabel *label64
jump *label54 always
multilabel *label65
jump *label54 always
multilabel *label66
jump *label54 always
multilabel *label67
jump *label54 always
multilabel *label68
jump *label54 always
multilabel *label69
jump *label54 always
multilabel *label70
jump *label16 always
multilabel *label71
jump *label16 always
multilabel *label72
jump *label54 always
multilabel *label73
jump *label54 always
multilabel *label74
jump *label54 always
multilabel *label75
jump *label20 always
multilabel *label76
jump *label20 always
multilabel *label77
jump *label20 always
multilabel *label78
jump *label54 always
multilabel *label79
jump *label18 always
multilabel *label80
jump *label18 always
multilabel *label81
jump *label54 always
multilabel *label82
jump *label54 always
multilabel *label83
jump *label54 always
multilabel *label84
jump *label54 always
multilabel *label85
jump *label54 always
multilabel *label86
jump *label54 always
multilabel *label87
jump *label54 always
multilabel *label88
jump *label54 always
multilabel *label89
jump *label54 always
multilabel *label90
jump *label54 always
multilabel *label91
jump *label54 always
multilabel *label92
jump *label54 always
multilabel *label93
jump *label54 always
multilabel *label94
jump *label54 always
multilabel *label95
jump *label54 always
multilabel *label96
jump *label54 always
multilabel *label97
jump *label14 always
multilabel *label98
jump *label14 always
multilabel *label99
jump *label14 always
multilabel *label100
jump *label14 always
multilabel *label101
jump *label14 always
multilabel *label102
jump *label12 always
multilabel *label103
jump *label54 always
multilabel *label104
jump *label54 always
multilabel *label105
jump *label54 always
multilabel *label106
jump *label54 always
multilabel *label107
jump *label54 always
multilabel *label108
jump *label54 always
multilabel *label109
jump *label54 always
multilabel *label110
jump *label54 always
multilabel *label111
jump *label54 always
multilabel *label112
jump *label54 always
multilabel *label113
jump *label54 always
multilabel *label114
jump *label54 always
multilabel *label115
jump *label54 always
multilabel *label116
jump *label54 always
multilabel *label117
jump *label54 always
multilabel *label118
jump *label54 always
multilabel *label119
jump *label54 always
multilabel *label120
jump *label54 always
multilabel *label121
jump *label54 always
multilabel *label122
jump *label54 always
multilabel *label123
jump *label54 always
multilabel *label124
jump *label54 always
multilabel *label125
jump *label54 always
multilabel *label126
jump *label54 always
multilabel *label127
jump *label54 always
multilabel *label128
jump *label54 always
multilabel *label129
jump *label54 always
multilabel *label130
jump *label54 always
multilabel *label131
jump *label54 always
multilabel *label132
jump *label54 always
multilabel *label133
jump *label54 always
multilabel *label134
jump *label54 always
multilabel *label135
jump *label54 always
multilabel *label136
jump *label54 always
multilabel *label137
jump *label54 always
multilabel *label138
jump *label54 always
multilabel *label139
jump *label54 always
multilabel *label140
jump *label54 always
multilabel *label141
jump *label54 always
multilabel *label142
jump *label54 always
multilabel *label143
jump *label54 always
multilabel *label144
jump *label8 always
multilabel *label145
jump *label10 always
multilabel *label146
jump *label54 always
multilabel *label147
jump *label54 always
multilabel *label148
jump *label54 always
multilabel *label149
jump *label54 always
multilabel *label150
jump *label54 always
multilabel *label151
jump *label54 always
multilabel *label152
jump *label54 always
multilabel *label153
jump *label16 always
label *label8
set .MESSAGE :block
jump *label6 always
label *label10
set .SWITCH :block
jump *label6 always
label *label12
set .SORTER :block
jump *label6 always
label *label14
set .CONTAINER :block
set .SENSOR @totalItems
set .MAXIMUM @itemCapacity
op add .START :n 1
jump *label6 always
label *label16
set .CONTAINER :block
set .SENSOR @totalLiquids
set .MAXIMUM @liquidCapacity
op add .START :n 1
jump *label6 always
label *label18
set .CONTAINER :block
set .SENSOR @totalPower
set .MAXIMUM @powerCapacity
op add .START :n 1
jump *label6 always
label *label20
set .CONTAINER :block
set .SENSOR @powerNetStored
set .MAXIMUM @powerNetCapacity
op add .START :n 1
label *label54
label *label6
jump *label52 greaterThan :n 0
label *label5
print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
format .MESSAGE
format .SWITCH
format .SORTER
format .CONTAINER
jump *label21 notEqual .CONTAINER null
print "No container.\n"
label *label21
printflush .MESSAGE
jump *label0 equal .CONTAINER null
sensor *tmp14 .SORTER @type
op strictEqual .INVERTED *tmp14 @inverted-sorter
# "Function: inline def setState(in newState)"
set .STATE true
op xor .ON .INVERTED true
set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
jump *label27 equal .ON false
set .ACTIVE_TEXT "\nCurrently active:[green]"
label *label27
set .CYCLES 0
control enabled .SWITCH 0
sensor *tmp23 .SWITCH @enabled
jump __start__ notEqual *tmp23 0
label *label155
set :start @time
sensor :item .SORTER @config
op equal *tmp27 :item null
op notEqual *tmp28 .SENSOR @totalItems
op or *tmp29 *tmp27 *tmp28
jump *label31 equal *tmp29 false
set :item .SENSOR
print "Measuring [gold]total[] in "
print .CONTAINER
jump *label32 always
label *label31
print "Measuring [gold]{0}[] in "
format :item
print .CONTAINER
label *label32
sensor :max .CONTAINER .MAXIMUM
sensor :amount .CONTAINER :item
op mul *tmp33 100 :amount
op idiv :pct *tmp33 :max
jump *label33 greaterThan :pct PCT_LOW
# "Function: inline def setState(in newState)"
jump *label34 equal .STATE true
set .STATE true
op add .CYCLES .CYCLES 1
op xor .ON .INVERTED true
set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
jump *label34 equal .ON false
set .ACTIVE_TEXT "\nCurrently active:[green]"
jump *label34 always
label *label33
jump *label40 lessThan :pct PCT_HIGH
# "Function: inline def setState(in newState)"
jump *label43 equal .STATE false
set .STATE false
op add .CYCLES .CYCLES 1
set .ON .INVERTED
set .ACTIVE_TEXT "\nCurrently inactive:[salmon]"
jump *label46 equal .INVERTED false
set .ACTIVE_TEXT "\nCurrently active:[green]"
label *label46
label *label43
label *label40
label *label34
print "\nLevel: [gold]{0}%[]"
format :pct
jump *label47 equal .INVERTED false
print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
format PCT_HIGH
format PCT_LOW
jump *label48 always
label *label47
print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
format PCT_LOW
format PCT_HIGH
label *label48
print .ACTIVE_TEXT
set :n .START
jump *label51 greaterThanEq .START @links
label *label53
getlink :block :n
control enabled :block .ON
print "\n    "
print :block
op add :n :n 1
jump *label53 lessThan :n @links
label *label51
print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
format .CYCLES
op sub *tmp54 @time :start
op floor *tmp55 *tmp54
format *tmp55
printflush .MESSAGE
sensor *tmp23 .SWITCH @enabled
jump *label155 equal *tmp23 0
