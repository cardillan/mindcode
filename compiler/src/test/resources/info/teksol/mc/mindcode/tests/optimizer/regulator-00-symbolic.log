   261 instructions before optimizations.
    19 instructions eliminated by Temp Variables Elimination (2 iterations).
     1 instructions eliminated by Case Expression Optimization.
    27 instructions eliminated by Dead Code Elimination (7 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    10 instructions eliminated by Jump Optimization (5 iterations).
     7 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     2 instructions modified by Expression Optimization (3 iterations).
     9 instructions eliminated by If Expression Optimization (3 iterations).
     3 instructions eliminated by Data Flow Optimization (3 passes, 10 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
   131 instructions added by Case Switching (5 iterations).
     1 case expressions converted to switched jumps Case Switching.
     7 instructions eliminated by Jump Straightening (5 iterations).
     2 instructions updated by Jump Threading.
    35 instructions eliminated by Print Merging.
   274 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 821):
  * Replicate loop condition at line 72:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  o Convert case at line 26:9 (segments: 15)                     size    +0, benefit     2013.9, efficiency   Infinity
  o Convert case at line 26:9 (segments: 6)                      size    +1, benefit     2118.1, efficiency   2118.056
  o Convert case at line 26:9 (segments: 4, padded low)          size   +67, benefit     2395.8, efficiency     35.759
  o Convert case at line 26:9 (segments: 6, padded low)          size   +68, benefit     2500.0, efficiency     36.765
  o Convert case at line 26:9 (segments: 2, padded low)          size   +85, benefit     2847.2, efficiency     33.497
  o Convert case at line 26:9 (segments: 5, padded low)          size   +86, benefit     2881.9, efficiency     33.511
  o Convert case at line 26:9 (segments: 3, padded low)          size  +127, benefit     3333.3, efficiency     26.247
  o Convert case at line 26:9 (segments: 1, padded low)          size  +131, benefit     3472.2, efficiency     26.506

Pass 1: speed optimization selection (cost limit 820):
  o Convert case at line 26:9 (segments: 15)                     size    +0, benefit     2013.9, efficiency   Infinity
  o Convert case at line 26:9 (segments: 6)                      size    +1, benefit     2118.1, efficiency   2118.056
  o Convert case at line 26:9 (segments: 4, padded low)          size   +67, benefit     2395.8, efficiency     35.759
  o Convert case at line 26:9 (segments: 6, padded low)          size   +68, benefit     2500.0, efficiency     36.765
  o Convert case at line 26:9 (segments: 2, padded low)          size   +85, benefit     2847.2, efficiency     33.497
  o Convert case at line 26:9 (segments: 5, padded low)          size   +86, benefit     2881.9, efficiency     33.511
  o Convert case at line 26:9 (segments: 3, padded low)          size  +127, benefit     3333.3, efficiency     26.247
  * Convert case at line 26:9 (segments: 1, padded low)          size  +131, benefit     3472.2, efficiency     26.506 (+131 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    26 print :block
    27 print "\n"
    28 sensor *tmp5 :block @type
-    * set *tmp6 *tmp5
-    * jump *label8 equal *tmp6 @message
+   29 jump *label8 equal *tmp5 @message
    30 jump *label7 always
    31 label *label8
    32 set .MESSAGE :block
    33 set *tmp4 .MESSAGE
    34 jump *label6 always
    35 label *label7
-    * jump *label10 equal *tmp6 @switch
+   36 jump *label10 equal *tmp5 @switch
    37 jump *label9 always
    38 label *label10
    39 set .SWITCH :block
    40 set *tmp4 .SWITCH
    41 jump *label6 always
    42 label *label9
-    * jump *label12 equal *tmp6 @sorter
-    * jump *label12 equal *tmp6 @inverted-sorter
-    * jump *label12 equal *tmp6 @unloader
+   43 jump *label12 equal *tmp5 @sorter
+   44 jump *label12 equal *tmp5 @inverted-sorter
+   45 jump *label12 equal *tmp5 @unloader
    46 jump *label11 always
    47 label *label12
    48 set .SORTER :block
    49 set *tmp4 .SORTER
    50 jump *label6 always
    51 label *label11
-    * jump *label14 equal *tmp6 @vault
-    * jump *label14 equal *tmp6 @container
-    * jump *label14 equal *tmp6 @core-shard
-    * jump *label14 equal *tmp6 @core-foundation
-    * jump *label14 equal *tmp6 @core-nucleus
+   52 jump *label14 equal *tmp5 @vault
+   53 jump *label14 equal *tmp5 @container
+   54 jump *label14 equal *tmp5 @core-shard
+   55 jump *label14 equal *tmp5 @core-foundation
+   56 jump *label14 equal *tmp5 @core-nucleus
    57 jump *label13 always
    58 label *label14
    59 set .CONTAINER :block
 
    64 set *tmp4 .START
    65 jump *label6 always
    66 label *label13
-    * jump *label16 equal *tmp6 @liquid-tank
-    * jump *label16 equal *tmp6 @liquid-container
-    * jump *label16 equal *tmp6 @liquid-router
+   67 jump *label16 equal *tmp5 @liquid-tank
+   68 jump *label16 equal *tmp5 @liquid-container
+   69 jump *label16 equal *tmp5 @liquid-router
    70 jump *label15 always
    71 label *label16
    72 set .CONTAINER :block
 
    77 set *tmp4 .START
    78 jump *label6 always
    79 label *label15
-    * jump *label18 equal *tmp6 @battery
-    * jump *label18 equal *tmp6 @battery-large
+   80 jump *label18 equal *tmp5 @battery
+   81 jump *label18 equal *tmp5 @battery-large
    82 jump *label17 always
    83 label *label18
    84 set .CONTAINER :block
 
    89 set *tmp4 .START
    90 jump *label6 always
    91 label *label17
-    * jump *label20 equal *tmp6 @power-node
-    * jump *label20 equal *tmp6 @power-node-large
-    * jump *label20 equal *tmp6 @surge-tower
+   92 jump *label20 equal *tmp5 @power-node
+   93 jump *label20 equal *tmp5 @power-node-large
+   94 jump *label20 equal *tmp5 @surge-tower
    95 jump *label19 always
    96 label *label20
    97 set .CONTAINER :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-17 instructions):
 
    30 jump *label7 always
    31 label *label8
    32 set .MESSAGE :block
-    * set *tmp4 .MESSAGE
    33 jump *label6 always
    34 label *label7
    35 jump *label10 equal *tmp5 @switch
    36 jump *label9 always
    37 label *label10
    38 set .SWITCH :block
-    * set *tmp4 .SWITCH
    39 jump *label6 always
    40 label *label9
    41 jump *label12 equal *tmp5 @sorter
 
    44 jump *label11 always
    45 label *label12
    46 set .SORTER :block
-    * set *tmp4 .SORTER
    47 jump *label6 always
    48 label *label11
    49 jump *label14 equal *tmp5 @vault
 
    58 set .MAXIMUM @itemCapacity
    59 op add *tmp7 :n 1
    60 set .START *tmp7
-    * set *tmp4 .START
    61 jump *label6 always
    62 label *label13
    63 jump *label16 equal *tmp5 @liquid-tank
 
    70 set .MAXIMUM @liquidCapacity
    71 op add *tmp8 :n 1
    72 set .START *tmp8
-    * set *tmp4 .START
    73 jump *label6 always
    74 label *label15
    75 jump *label18 equal *tmp5 @battery
 
    81 set .MAXIMUM @powerCapacity
    82 op add *tmp9 :n 1
    83 set .START *tmp9
-    * set *tmp4 .START
    84 jump *label6 always
    85 label *label17
    86 jump *label20 equal *tmp5 @power-node
 
    93 set .MAXIMUM @powerNetCapacity
    94 op add *tmp10 :n 1
    95 set .START *tmp10
-    * set *tmp4 .START
    96 jump *label6 always
    97 label *label19
-    * set *tmp4 null
    98 label *label6
    99 label *label4
   100 jump *label3 always
 
   115 jump *label21 equal *tmp11 false
   116 print "No container."
   117 print "\n"
-    * set *tmp12 "No container."
   118 jump *label22 always
   119 label *label21
-    * set *tmp12 null
   120 label *label22
   121 printflush .MESSAGE
   122 label *label1
 
   146 label *label24
   147 set *tmp18 null
   148 label *label25
-    * set *tmp16 *tmp18
   149 label *label23
   150 set *tmp21 .SWITCH
   151 control enabled *tmp21 0
 
   164 set :item .SENSOR
   165 print "Measuring [gold]total[] in "
   166 print .CONTAINER
-    * set *tmp30 null
   167 jump *label32 always
   168 label *label31
   169 print "Measuring [gold]"
 
   171 print "["
   172 print "] in "
   173 print .CONTAINER
-    * set *tmp30 null
   174 label *label32
   175 sensor *tmp31 .CONTAINER .MAXIMUM
   176 set :max *tmp31
 
   203 label *label37
   204 set *tmp37 *tmp39
   205 label *label35
-    * set *tmp36 *tmp37
   206 jump *label34 always
   207 label *label33
   208 op greaterThanEq *tmp42 :pct PCT_HIGH
 
   234 label *label40
   235 set *tmp43 null
   236 label *label41
-    * set *tmp36 *tmp43
   237 label *label34
   238 print "\n"
   239 print "Level: [gold]"
 
   251 print PCT_LOW
   252 print "%"
   253 print "[]"
-    * set *tmp49 null
   254 jump *label48 always
   255 label *label47
   256 print "\n"
 
   263 print PCT_HIGH
   264 print "%"
   265 print "[]"
-    * set *tmp49 null
   266 label *label48
   267 print .ACTIVE_TEXT
   268 set :n .START

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
   141 set *tmp20 "\nCurrently inactive:[salmon]"
   142 label *label27
   143 set .ACTIVE_TEXT *tmp20
-    * set *tmp18 .ACTIVE_TEXT
   144 jump *label25 always
   145 label *label24
-    * set *tmp18 null
   146 label *label25
   147 label *label23
   148 set *tmp21 .SWITCH
 
   199 label *label36
   200 set *tmp39 null
   201 label *label37
-    * set *tmp37 *tmp39
   202 label *label35
   203 jump *label34 always
   204 label *label33
 
   226 label *label44
   227 set *tmp44 *tmp46
   228 label *label42
-    * set *tmp43 *tmp44
   229 jump *label41 always
   230 label *label40
-    * set *tmp43 null
   231 label *label41
   232 label *label34
   233 print "\n"

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-3 instructions):
 
   194 set *tmp41 "\nCurrently inactive:[salmon]"
   195 label *label39
   196 set .ACTIVE_TEXT *tmp41
-    * set *tmp39 .ACTIVE_TEXT
   197 jump *label37 always
   198 label *label36
-    * set *tmp39 null
   199 label *label37
   200 label *label35
   201 jump *label34 always
 
   222 label *label43
   223 set *tmp46 null
   224 label *label44
-    * set *tmp44 *tmp46
   225 label *label42
   226 jump *label41 always
   227 label *label40

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   217 set *tmp48 "\nCurrently inactive:[salmon]"
   218 label *label46
   219 set .ACTIVE_TEXT *tmp48
-    * set *tmp46 .ACTIVE_TEXT
   220 jump *label44 always
   221 label *label43
-    * set *tmp46 null
   222 label *label44
   223 label *label42
   224 jump *label41 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-19 instructions):
 
    13 label *label0
    14 print "Configuring regulator..."
    15 print "\n"
-    * set *tmp0 @links
-    * set :n *tmp0
+   16 set :n @links
    17 label *label3
    18 op greaterThan *tmp1 :n 0
    19 jump *label5 equal *tmp1 false
-    * op sub *tmp2 :n 1
-    * set :n *tmp2
-    * getlink *tmp3 :n
-    * set :block *tmp3
+   20 op sub :n :n 1
+   21 getlink :block :n
    22 print "Found: "
    23 print :block
    24 print "\n"
 
    53 set .CONTAINER :block
    54 set .SENSOR @totalItems
    55 set .MAXIMUM @itemCapacity
-    * op add *tmp7 :n 1
-    * set .START *tmp7
+   56 op add .START :n 1
    57 jump *label6 always
    58 label *label13
    59 jump *label16 equal *tmp5 @liquid-tank
 
    64 set .CONTAINER :block
    65 set .SENSOR @totalLiquids
    66 set .MAXIMUM @liquidCapacity
-    * op add *tmp8 :n 1
-    * set .START *tmp8
+   67 op add .START :n 1
    68 jump *label6 always
    69 label *label15
    70 jump *label18 equal *tmp5 @battery
 
    74 set .CONTAINER :block
    75 set .SENSOR @totalPower
    76 set .MAXIMUM @powerCapacity
-    * op add *tmp9 :n 1
-    * set .START *tmp9
+   77 op add .START :n 1
    78 jump *label6 always
    79 label *label17
    80 jump *label20 equal *tmp5 @power-node
 
    85 set .CONTAINER :block
    86 set .SENSOR @powerNetStored
    87 set .MAXIMUM @powerNetCapacity
-    * op add *tmp10 :n 1
-    * set .START *tmp10
+   88 op add .START :n 1
    89 jump *label6 always
    90 label *label19
    91 label *label6
 
   117 jump *label0 notEqual *tmp13 false
   118 label *label2
   119 sensor *tmp14 .SORTER @type
-    * op strictEqual *tmp15 *tmp14 @inverted-sorter
-    * set .INVERTED *tmp15
+  120 op strictEqual .INVERTED *tmp14 @inverted-sorter
   121 # "Function: inline def setState(in newState)"
   122 set :setState:newState true
   123 op notEqual *tmp17 .STATE :setState:newState
   124 jump *label24 equal *tmp17 false
   125 set .STATE :setState:newState
   126 op add .CYCLES .CYCLES 1
-    * op xor *tmp19 .INVERTED .STATE
-    * set .ON *tmp19
+  127 op xor .ON .INVERTED .STATE
   128 jump *label26 equal .ON false
   129 set *tmp20 "\nCurrently active:[green]"
   130 jump *label27 always
 
   136 label *label24
   137 label *label25
   138 label *label23
-    * set *tmp21 .SWITCH
-    * control enabled *tmp21 0
+  139 control enabled .SWITCH 0
   140 label *label28
   141 sensor *tmp23 .SWITCH @enabled
   142 op equal *tmp24 *tmp23 0
   143 jump *label30 equal *tmp24 false
-    * set *tmp25 @time
-    * set :start *tmp25
-    * sensor *tmp26 .SORTER @config
-    * set :item *tmp26
+  144 set :start @time
+  145 sensor :item .SORTER @config
   146 op equal *tmp27 :item null
   147 op notEqual *tmp28 .SENSOR @totalItems
   148 op or *tmp29 *tmp27 *tmp28
 
   158 print "] in "
   159 print .CONTAINER
   160 label *label32
-    * sensor *tmp31 .CONTAINER .MAXIMUM
-    * set :max *tmp31
-    * sensor *tmp32 .CONTAINER :item
-    * set :amount *tmp32
+  161 sensor :max .CONTAINER .MAXIMUM
+  162 sensor :amount .CONTAINER :item
   163 op mul *tmp33 100 :amount
-    * op idiv *tmp34 *tmp33 :max
-    * set :pct *tmp34
+  164 op idiv :pct *tmp33 :max
   165 op lessThanEq *tmp35 :pct PCT_LOW
   166 jump *label33 equal *tmp35 false
   167 # "Function: inline def setState(in newState)"
 
   170 jump *label36 equal *tmp38 false
   171 set .STATE :setState.1:newState
   172 op add .CYCLES .CYCLES 1
-    * op xor *tmp40 .INVERTED .STATE
-    * set .ON *tmp40
+  173 op xor .ON .INVERTED .STATE
   174 jump *label38 equal .ON false
   175 set *tmp41 "\nCurrently active:[green]"
   176 jump *label39 always
 
   192 jump *label43 equal *tmp45 false
   193 set .STATE :setState.2:newState
   194 op add .CYCLES .CYCLES 1
-    * op xor *tmp47 .INVERTED .STATE
-    * set .ON *tmp47
+  195 op xor .ON .INVERTED .STATE
   196 jump *label45 equal .ON false
   197 set *tmp48 "\nCurrently active:[green]"
   198 jump *label46 always
 
   242 label *label49
   243 op lessThan *tmp50 :n @links
   244 jump *label51 equal *tmp50 false
-    * getlink *tmp51 :n
-    * set :block *tmp51
-    * set *tmp52 :block
-    * control enabled *tmp52 .ON
+  245 getlink :block :n
+  246 control enabled :block .ON
   247 print "\n    "
   248 print :block
   249 op add :n :n 1

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    23 print :block
    24 print "\n"
    25 sensor *tmp5 :block @type
-    * jump *label8 equal *tmp5 @message
-    * jump *label7 always
+   26 jump *label7 notEqual *tmp5 @message
    27 label *label8
    28 set .MESSAGE :block
    29 jump *label6 always
    30 label *label7
-    * jump *label10 equal *tmp5 @switch
-    * jump *label9 always
+   31 jump *label9 notEqual *tmp5 @switch
    32 label *label10
    33 set .SWITCH :block
    34 jump *label6 always
    35 label *label9
    36 jump *label12 equal *tmp5 @sorter
    37 jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label12 equal *tmp5 @unloader
-    * jump *label11 always
+   38 jump *label11 notEqual *tmp5 @unloader
    39 label *label12
    40 set .SORTER :block
    41 jump *label6 always
 
    44 jump *label14 equal *tmp5 @container
    45 jump *label14 equal *tmp5 @core-shard
    46 jump *label14 equal *tmp5 @core-foundation
-    * jump *label14 equal *tmp5 @core-nucleus
-    * jump *label13 always
+   47 jump *label13 notEqual *tmp5 @core-nucleus
    48 label *label14
    49 set .CONTAINER :block
    50 set .SENSOR @totalItems
 
    54 label *label13
    55 jump *label16 equal *tmp5 @liquid-tank
    56 jump *label16 equal *tmp5 @liquid-container
-    * jump *label16 equal *tmp5 @liquid-router
-    * jump *label15 always
+   57 jump *label15 notEqual *tmp5 @liquid-router
    58 label *label16
    59 set .CONTAINER :block
    60 set .SENSOR @totalLiquids
 
    63 jump *label6 always
    64 label *label15
    65 jump *label18 equal *tmp5 @battery
-    * jump *label18 equal *tmp5 @battery-large
-    * jump *label17 always
+   66 jump *label17 notEqual *tmp5 @battery-large
    67 label *label18
    68 set .CONTAINER :block
    69 set .SENSOR @totalPower
 
    73 label *label17
    74 jump *label20 equal *tmp5 @power-node
    75 jump *label20 equal *tmp5 @power-node-large
-    * jump *label20 equal *tmp5 @surge-tower
-    * jump *label19 always
+   76 jump *label19 notEqual *tmp5 @surge-tower
    77 label *label20
    78 set .CONTAINER :block
    79 set .SENSOR @powerNetStored

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-10 instructions):
 
    15 print "\n"
    16 set :n @links
    17 label *label3
-    * op greaterThan *tmp1 :n 0
-    * jump *label5 equal *tmp1 false
+   18 jump *label5 lessThanEq :n 0
    19 op sub :n :n 1
    20 getlink :block :n
    21 print "Found: "
 
    96 print "Container: "
    97 print .CONTAINER
    98 print "\n"
-    * op equal *tmp11 .CONTAINER null
-    * jump *label21 equal *tmp11 false
+   99 jump *label21 notEqual .CONTAINER null
   100 print "No container."
   101 print "\n"
   102 jump *label22 always
 
   104 label *label22
   105 printflush .MESSAGE
   106 label *label1
-    * op equal *tmp13 .CONTAINER null
-    * jump *label0 notEqual *tmp13 false
+  107 jump *label0 equal .CONTAINER null
   108 label *label2
   109 sensor *tmp14 .SORTER @type
   110 op strictEqual .INVERTED *tmp14 @inverted-sorter
   111 # "Function: inline def setState(in newState)"
   112 set :setState:newState true
-    * op notEqual *tmp17 .STATE :setState:newState
-    * jump *label24 equal *tmp17 false
+  113 jump *label24 equal .STATE :setState:newState
   114 set .STATE :setState:newState
   115 op add .CYCLES .CYCLES 1
   116 op xor .ON .INVERTED .STATE
 
   128 control enabled .SWITCH 0
   129 label *label28
   130 sensor *tmp23 .SWITCH @enabled
-    * op equal *tmp24 *tmp23 0
-    * jump *label30 equal *tmp24 false
+  131 jump *label30 notEqual *tmp23 0
   132 set :start @time
   133 sensor :item .SORTER @config
   134 op equal *tmp27 :item null
 
   150 sensor :amount .CONTAINER :item
   151 op mul *tmp33 100 :amount
   152 op idiv :pct *tmp33 :max
-    * op lessThanEq *tmp35 :pct PCT_LOW
-    * jump *label33 equal *tmp35 false
+  153 jump *label33 greaterThan :pct PCT_LOW
   154 # "Function: inline def setState(in newState)"
   155 set :setState.1:newState true
-    * op notEqual *tmp38 .STATE :setState.1:newState
-    * jump *label36 equal *tmp38 false
+  156 jump *label36 equal .STATE :setState.1:newState
   157 set .STATE :setState.1:newState
   158 op add .CYCLES .CYCLES 1
   159 op xor .ON .INVERTED .STATE
 
   170 label *label35
   171 jump *label34 always
   172 label *label33
-    * op greaterThanEq *tmp42 :pct PCT_HIGH
-    * jump *label40 equal *tmp42 false
+  173 jump *label40 lessThan :pct PCT_HIGH
   174 # "Function: inline def setState(in newState)"
   175 set :setState.2:newState false
-    * op notEqual *tmp45 .STATE :setState.2:newState
-    * jump *label43 equal *tmp45 false
+  176 jump *label43 equal .STATE :setState.2:newState
   177 set .STATE :setState.2:newState
   178 op add .CYCLES .CYCLES 1
   179 op xor .ON .INVERTED .STATE
 
   224 print .ACTIVE_TEXT
   225 set :n .START
   226 label *label49
-    * op lessThan *tmp50 :n @links
-    * jump *label51 equal *tmp50 false
+  227 jump *label51 greaterThanEq :n @links
   228 getlink :block :n
   229 control enabled :block .ON
   230 print "\n    "

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-6 instructions):
 
    78 set .SENSOR @powerNetStored
    79 set .MAXIMUM @powerNetCapacity
    80 op add .START :n 1
-    * jump *label6 always
    81 label *label19
    82 label *label6
    83 label *label4
 
    98 jump *label21 notEqual .CONTAINER null
    99 print "No container."
   100 print "\n"
-    * jump *label22 always
   101 label *label21
   102 label *label22
   103 printflush .MESSAGE
 
   119 set *tmp20 "\nCurrently inactive:[salmon]"
   120 label *label27
   121 set .ACTIVE_TEXT *tmp20
-    * jump *label25 always
   122 label *label24
   123 label *label25
   124 label *label23
 
   161 set *tmp41 "\nCurrently inactive:[salmon]"
   162 label *label39
   163 set .ACTIVE_TEXT *tmp41
-    * jump *label37 always
   164 label *label36
   165 label *label37
   166 label *label35
 
   180 set *tmp48 "\nCurrently inactive:[salmon]"
   181 label *label46
   182 set .ACTIVE_TEXT *tmp48
-    * jump *label44 always
   183 label *label43
   184 label *label44
   185 label *label42
-    * jump *label41 always
   186 label *label40
   187 label *label41
   188 label *label34

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set .CONTAINER null
     3 set .SORTER null
     4 set .SWITCH null
-    * set .STATE .SWITCH
-    * set .START .STATE
-    * set .SENSOR .START
-    * set .ON .SENSOR
-    * set .MESSAGE .ON
-    * set .MAXIMUM .MESSAGE
-    * set .ACTIVE_TEXT .MAXIMUM
+    5 set .STATE null
+    6 set .START .SWITCH
+    7 set .SENSOR .STATE
+    8 set .ON .START
+    9 set .MESSAGE .SENSOR
+   10 set .MAXIMUM .ON
+   11 set .ACTIVE_TEXT .MESSAGE
    12 set .CYCLES 0
    13 label *label0
    14 print "Configuring regulator..."
 
   108 op strictEqual .INVERTED *tmp14 @inverted-sorter
   109 # "Function: inline def setState(in newState)"
   110 set :setState:newState true
-    * jump *label24 equal .STATE :setState:newState
-    * set .STATE :setState:newState
-    * op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  111 jump *label24 equal .STATE true
+  112 set .STATE true
+  113 op add .CYCLES 0 1
+  114 op xor .ON .INVERTED :setState:newState
   115 jump *label26 equal .ON false
   116 set *tmp20 "\nCurrently active:[green]"
   117 jump *label27 always
 
   150 jump *label33 greaterThan :pct PCT_LOW
   151 # "Function: inline def setState(in newState)"
   152 set :setState.1:newState true
-    * jump *label36 equal .STATE :setState.1:newState
-    * set .STATE :setState.1:newState
+  153 jump *label36 equal .STATE true
+  154 set .STATE true
   155 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  156 op xor .ON .INVERTED :setState.1:newState
   157 jump *label38 equal .ON false
   158 set *tmp41 "\nCurrently active:[green]"
   159 jump *label39 always
 
   169 jump *label40 lessThan :pct PCT_HIGH
   170 # "Function: inline def setState(in newState)"
   171 set :setState.2:newState false
-    * jump *label43 equal .STATE :setState.2:newState
-    * set .STATE :setState.2:newState
+  172 jump *label43 equal .STATE false
+  173 set .STATE false
   174 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  175 op xor .ON .INVERTED :setState.2:newState
   176 jump *label45 equal .ON false
   177 set *tmp48 "\nCurrently active:[green]"
   178 jump *label46 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2:
 
     3 set .SORTER null
     4 set .SWITCH null
     5 set .STATE null
-    * set .START .SWITCH
-    * set .SENSOR .STATE
-    * set .ON .START
-    * set .MESSAGE .SENSOR
-    * set .MAXIMUM .ON
-    * set .ACTIVE_TEXT .MESSAGE
+    6 set .START null
+    7 set .SENSOR null
+    8 set .ON .SWITCH
+    9 set .MESSAGE .STATE
+   10 set .MAXIMUM .START
+   11 set .ACTIVE_TEXT .SENSOR
    12 set .CYCLES 0
    13 label *label0
    14 print "Configuring regulator..."
 
   108 op strictEqual .INVERTED *tmp14 @inverted-sorter
   109 # "Function: inline def setState(in newState)"
   110 set :setState:newState true
-    * jump *label24 equal .STATE true
+  111 jump *label24 equal null true
   112 set .STATE true
   113 op add .CYCLES 0 1
-    * op xor .ON .INVERTED :setState:newState
+  114 op xor .ON .INVERTED true
   115 jump *label26 equal .ON false
   116 set *tmp20 "\nCurrently active:[green]"
   117 jump *label27 always
 
   153 jump *label36 equal .STATE true
   154 set .STATE true
   155 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.1:newState
+  156 op xor .ON .INVERTED true
   157 jump *label38 equal .ON false
   158 set *tmp41 "\nCurrently active:[green]"
   159 jump *label39 always
 
   172 jump *label43 equal .STATE false
   173 set .STATE false
   174 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.2:newState
+  175 op xor .ON .INVERTED false
   176 jump *label45 equal .ON false
   177 set *tmp48 "\nCurrently active:[green]"
   178 jump *label46 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
     5 set .STATE null
     6 set .START null
     7 set .SENSOR null
-    * set .ON .SWITCH
-    * set .MESSAGE .STATE
-    * set .MAXIMUM .START
-    * set .ACTIVE_TEXT .SENSOR
+    8 set .ON null
+    9 set .MESSAGE null
+   10 set .MAXIMUM null
+   11 set .ACTIVE_TEXT null
    12 set .CYCLES 0
    13 label *label0
    14 print "Configuring regulator..."
 
   107 sensor *tmp14 .SORTER @type
   108 op strictEqual .INVERTED *tmp14 @inverted-sorter
   109 # "Function: inline def setState(in newState)"
-    * set :setState:newState true
   110 jump *label24 equal null true
   111 set .STATE true
   112 op add .CYCLES 0 1
 
   148 op idiv :pct *tmp33 :max
   149 jump *label33 greaterThan :pct PCT_LOW
   150 # "Function: inline def setState(in newState)"
-    * set :setState.1:newState true
   151 jump *label36 equal .STATE true
   152 set .STATE true
   153 op add .CYCLES .CYCLES 1
 
   166 label *label33
   167 jump *label40 lessThan :pct PCT_HIGH
   168 # "Function: inline def setState(in newState)"
-    * set :setState.2:newState false
   169 jump *label43 equal .STATE false
   170 set .STATE false
   171 op add .CYCLES .CYCLES 1

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    16 set :n @links
    17 label *label3
    18 jump *label5 lessThanEq :n 0
+   19 label *label52
    20 op sub :n :n 1
    21 getlink :block :n
    22 print "Found: "
 
    82 label *label19
    83 label *label6
    84 label *label4
-    * jump *label3 always
+   85 jump *label52 greaterThan :n 0
    86 label *label5
    87 print "Message: "
    88 print .MESSAGE
 
   217 set :n .START
   218 label *label49
   219 jump *label51 greaterThanEq :n @links
+  220 label *label53
   221 getlink :block :n
   222 control enabled :block .ON
   223 print "\n    "
   224 print :block
   225 op add :n :n 1
   226 label *label50
-    * jump *label49 always
+  227 jump *label53 lessThan :n @links
   228 label *label51
   229 print "[]"
   230 print "\n"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-9 instructions):
 
   112 set .STATE true
   113 op add .CYCLES 0 1
   114 op xor .ON .INVERTED true
-    * jump *label26 equal .ON false
-    * set *tmp20 "\nCurrently active:[green]"
-    * jump *label27 always
+  115 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   116 label *label26
-    * set *tmp20 "\nCurrently inactive:[salmon]"
   117 label *label27
   118 set .ACTIVE_TEXT *tmp20
   119 label *label24
 
   150 set .STATE true
   151 op add .CYCLES .CYCLES 1
   152 op xor .ON .INVERTED true
-    * jump *label38 equal .ON false
-    * set *tmp41 "\nCurrently active:[green]"
-    * jump *label39 always
+  153 select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   154 label *label38
-    * set *tmp41 "\nCurrently inactive:[salmon]"
   155 label *label39
   156 set .ACTIVE_TEXT *tmp41
   157 label *label36
 
   165 set .STATE false
   166 op add .CYCLES .CYCLES 1
   167 op xor .ON .INVERTED false
-    * jump *label45 equal .ON false
-    * set *tmp48 "\nCurrently active:[green]"
-    * jump *label46 always
+  168 select *tmp48 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   169 label *label45
-    * set *tmp48 "\nCurrently inactive:[salmon]"
   170 label *label46
   171 set .ACTIVE_TEXT *tmp48
   172 label *label43

Modifications by Replicate loop condition at line 72:1 (+1 instructions):
 
   123 label *label28
   124 sensor *tmp23 .SWITCH @enabled
   125 jump *label30 notEqual *tmp23 0
+  126 label *label54
   127 set :start @time
   128 sensor :item .SORTER @config
   129 op equal *tmp27 :item null
 
   231 print "ms"
   232 printflush .MESSAGE
   233 label *label29
-    * jump *label28 always
+  234 sensor *tmp23 .SWITCH @enabled
+  235 jump *label54 equal *tmp23 0
   236 label *label30
   237 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   208 print .ACTIVE_TEXT
   209 set :n .START
   210 label *label49
-    * jump *label51 greaterThanEq :n @links
+  211 jump *label51 greaterThanEq .START @links
   212 label *label53
   213 getlink :block :n
   214 control enabled :block .ON

Modifications by Convert case at line 26:9 (segments: 1, padded low) (+131 instructions):
 
    23 print :block
    24 print "\n"
    25 sensor *tmp5 :block @type
-    * jump *label7 notEqual *tmp5 @message
+   26 sensor *tmp56 *tmp5 @id
+   27 jump *label55 greaterThanEq *tmp56 147
+   28 multijump *label57 *tmp56 0 (m:*label56)
+   29 multilabel *label57 (m:*label56)
+   30 jump *label55 always
+   31 multilabel *label58 (m:*label56)
+   32 jump *label55 always
+   33 multilabel *label59 (m:*label56)
+   34 jump *label55 always
+   35 multilabel *label60 (m:*label56)
+   36 jump *label55 always
+   37 multilabel *label61 (m:*label56)
+   38 jump *label55 always
+   39 multilabel *label62 (m:*label56)
+   40 jump *label55 always
+   41 multilabel *label63 (m:*label56)
+   42 jump *label55 always
+   43 multilabel *label64 (m:*label56)
+   44 jump *label55 always
+   45 multilabel *label65 (m:*label56)
+   46 jump *label55 always
+   47 multilabel *label66 (m:*label56)
+   48 jump *label55 always
+   49 multilabel *label67 (m:*label56)
+   50 jump *label55 always
+   51 multilabel *label68 (m:*label56)
+   52 jump *label55 always
+   53 multilabel *label69 (m:*label56)
+   54 jump *label55 always
+   55 multilabel *label70 (m:*label56)
+   56 jump *label55 always
+   57 multilabel *label71 (m:*label56)
+   58 jump *label55 always
+   59 multilabel *label72 (m:*label56)
+   60 jump *label55 always
+   61 multilabel *label73 (m:*label56)
+   62 jump *label55 always
+   63 multilabel *label74 (m:*label56)
+   64 jump *label55 always
+   65 multilabel *label75 (m:*label56)
+   66 jump *label55 always
+   67 multilabel *label76 (m:*label56)
+   68 jump *label55 always
+   69 multilabel *label77 (m:*label56)
+   70 jump *label55 always
+   71 multilabel *label78 (m:*label56)
+   72 jump *label55 always
+   73 multilabel *label79 (m:*label56)
+   74 jump *label55 always
+   75 multilabel *label80 (m:*label56)
+   76 jump *label55 always
+   77 multilabel *label81 (m:*label56)
+   78 jump *label55 always
+   79 multilabel *label82 (m:*label56)
+   80 jump *label55 always
+   81 multilabel *label83 (m:*label56)
+   82 jump *label55 always
+   83 multilabel *label84 (m:*label56)
+   84 jump *label55 always
+   85 multilabel *label85 (m:*label56)
+   86 jump *label55 always
+   87 multilabel *label86 (m:*label56)
+   88 jump *label55 always
+   89 multilabel *label87 (m:*label56)
+   90 jump *label55 always
+   91 multilabel *label88 (m:*label56)
+   92 jump *label55 always
+   93 multilabel *label89 (m:*label56)
+   94 jump *label55 always
+   95 multilabel *label90 (m:*label56)
+   96 jump *label55 always
+   97 multilabel *label91 (m:*label56)
+   98 jump *label55 always
+   99 multilabel *label92 (m:*label56)
+  100 jump *label55 always
+  101 multilabel *label93 (m:*label56)
+  102 jump *label55 always
+  103 multilabel *label94 (m:*label56)
+  104 jump *label55 always
+  105 multilabel *label95 (m:*label56)
+  106 jump *label55 always
+  107 multilabel *label96 (m:*label56)
+  108 jump *label55 always
+  109 multilabel *label97 (m:*label56)
+  110 jump *label55 always
+  111 multilabel *label98 (m:*label56)
+  112 jump *label55 always
+  113 multilabel *label99 (m:*label56)
+  114 jump *label55 always
+  115 multilabel *label100 (m:*label56)
+  116 jump *label55 always
+  117 multilabel *label101 (m:*label56)
+  118 jump *label55 always
+  119 multilabel *label102 (m:*label56)
+  120 jump *label55 always
+  121 multilabel *label103 (m:*label56)
+  122 jump *label55 always
+  123 multilabel *label104 (m:*label56)
+  124 jump *label55 always
+  125 multilabel *label105 (m:*label56)
+  126 jump *label12 always
+  127 multilabel *label106 (m:*label56)
+  128 jump *label12 always
+  129 multilabel *label107 (m:*label56)
+  130 jump *label55 always
+  131 multilabel *label108 (m:*label56)
+  132 jump *label55 always
+  133 multilabel *label109 (m:*label56)
+  134 jump *label55 always
+  135 multilabel *label110 (m:*label56)
+  136 jump *label55 always
+  137 multilabel *label111 (m:*label56)
+  138 jump *label55 always
+  139 multilabel *label112 (m:*label56)
+  140 jump *label55 always
+  141 multilabel *label113 (m:*label56)
+  142 jump *label55 always
+  143 multilabel *label114 (m:*label56)
+  144 jump *label55 always
+  145 multilabel *label115 (m:*label56)
+  146 jump *label55 always
+  147 multilabel *label116 (m:*label56)
+  148 jump *label55 always
+  149 multilabel *label117 (m:*label56)
+  150 jump *label55 always
+  151 multilabel *label118 (m:*label56)
+  152 jump *label55 always
+  153 multilabel *label119 (m:*label56)
+  154 jump *label55 always
+  155 multilabel *label120 (m:*label56)
+  156 jump *label16 always
+  157 multilabel *label121 (m:*label56)
+  158 jump *label16 always
+  159 multilabel *label122 (m:*label56)
+  160 jump *label55 always
+  161 multilabel *label123 (m:*label56)
+  162 jump *label55 always
+  163 multilabel *label124 (m:*label56)
+  164 jump *label55 always
+  165 multilabel *label125 (m:*label56)
+  166 jump *label20 always
+  167 multilabel *label126 (m:*label56)
+  168 jump *label20 always
+  169 multilabel *label127 (m:*label56)
+  170 jump *label20 always
+  171 multilabel *label128 (m:*label56)
+  172 jump *label55 always
+  173 multilabel *label129 (m:*label56)
+  174 jump *label18 always
+  175 multilabel *label130 (m:*label56)
+  176 jump *label18 always
+  177 multilabel *label131 (m:*label56)
+  178 jump *label55 always
+  179 multilabel *label132 (m:*label56)
+  180 jump *label55 always
+  181 multilabel *label133 (m:*label56)
+  182 jump *label55 always
+  183 multilabel *label134 (m:*label56)
+  184 jump *label55 always
+  185 multilabel *label135 (m:*label56)
+  186 jump *label55 always
+  187 multilabel *label136 (m:*label56)
+  188 jump *label55 always
+  189 multilabel *label137 (m:*label56)
+  190 jump *label55 always
+  191 multilabel *label138 (m:*label56)
+  192 jump *label55 always
+  193 multilabel *label139 (m:*label56)
+  194 jump *label55 always
+  195 multilabel *label140 (m:*label56)
+  196 jump *label55 always
+  197 multilabel *label141 (m:*label56)
+  198 jump *label55 always
+  199 multilabel *label142 (m:*label56)
+  200 jump *label55 always
+  201 multilabel *label143 (m:*label56)
+  202 jump *label55 always
+  203 multilabel *label144 (m:*label56)
+  204 jump *label55 always
+  205 multilabel *label145 (m:*label56)
+  206 jump *label55 always
+  207 multilabel *label146 (m:*label56)
+  208 jump *label55 always
+  209 multilabel *label147 (m:*label56)
+  210 jump *label14 always
+  211 multilabel *label148 (m:*label56)
+  212 jump *label14 always
+  213 multilabel *label149 (m:*label56)
+  214 jump *label14 always
+  215 multilabel *label150 (m:*label56)
+  216 jump *label14 always
+  217 multilabel *label151 (m:*label56)
+  218 jump *label14 always
+  219 multilabel *label152 (m:*label56)
+  220 jump *label12 always
+  221 multilabel *label153 (m:*label56)
+  222 jump *label55 always
+  223 multilabel *label154 (m:*label56)
+  224 jump *label55 always
+  225 multilabel *label155 (m:*label56)
+  226 jump *label55 always
+  227 multilabel *label156 (m:*label56)
+  228 jump *label55 always
+  229 multilabel *label157 (m:*label56)
+  230 jump *label55 always
+  231 multilabel *label158 (m:*label56)
+  232 jump *label55 always
+  233 multilabel *label159 (m:*label56)
+  234 jump *label55 always
+  235 multilabel *label160 (m:*label56)
+  236 jump *label55 always
+  237 multilabel *label161 (m:*label56)
+  238 jump *label55 always
+  239 multilabel *label162 (m:*label56)
+  240 jump *label55 always
+  241 multilabel *label163 (m:*label56)
+  242 jump *label55 always
+  243 multilabel *label164 (m:*label56)
+  244 jump *label55 always
+  245 multilabel *label165 (m:*label56)
+  246 jump *label55 always
+  247 multilabel *label166 (m:*label56)
+  248 jump *label55 always
+  249 multilabel *label167 (m:*label56)
+  250 jump *label55 always
+  251 multilabel *label168 (m:*label56)
+  252 jump *label55 always
+  253 multilabel *label169 (m:*label56)
+  254 jump *label55 always
+  255 multilabel *label170 (m:*label56)
+  256 jump *label55 always
+  257 multilabel *label171 (m:*label56)
+  258 jump *label55 always
+  259 multilabel *label172 (m:*label56)
+  260 jump *label55 always
+  261 multilabel *label173 (m:*label56)
+  262 jump *label55 always
+  263 multilabel *label174 (m:*label56)
+  264 jump *label55 always
+  265 multilabel *label175 (m:*label56)
+  266 jump *label55 always
+  267 multilabel *label176 (m:*label56)
+  268 jump *label55 always
+  269 multilabel *label177 (m:*label56)
+  270 jump *label55 always
+  271 multilabel *label178 (m:*label56)
+  272 jump *label55 always
+  273 multilabel *label179 (m:*label56)
+  274 jump *label55 always
+  275 multilabel *label180 (m:*label56)
+  276 jump *label55 always
+  277 multilabel *label181 (m:*label56)
+  278 jump *label55 always
+  279 multilabel *label182 (m:*label56)
+  280 jump *label55 always
+  281 multilabel *label183 (m:*label56)
+  282 jump *label55 always
+  283 multilabel *label184 (m:*label56)
+  284 jump *label55 always
+  285 multilabel *label185 (m:*label56)
+  286 jump *label55 always
+  287 multilabel *label186 (m:*label56)
+  288 jump *label55 always
+  289 multilabel *label187 (m:*label56)
+  290 jump *label55 always
+  291 multilabel *label188 (m:*label56)
+  292 jump *label55 always
+  293 multilabel *label189 (m:*label56)
+  294 jump *label55 always
+  295 multilabel *label190 (m:*label56)
+  296 jump *label55 always
+  297 multilabel *label191 (m:*label56)
+  298 jump *label55 always
+  299 multilabel *label192 (m:*label56)
+  300 jump *label55 always
+  301 multilabel *label193 (m:*label56)
+  302 jump *label55 always
+  303 multilabel *label194 (m:*label56)
+  304 jump *label8 always
+  305 multilabel *label195 (m:*label56)
+  306 jump *label10 always
+  307 multilabel *label196 (m:*label56)
+  308 jump *label55 always
+  309 multilabel *label197 (m:*label56)
+  310 jump *label55 always
+  311 multilabel *label198 (m:*label56)
+  312 jump *label55 always
+  313 multilabel *label199 (m:*label56)
+  314 jump *label55 always
+  315 multilabel *label200 (m:*label56)
+  316 jump *label55 always
+  317 multilabel *label201 (m:*label56)
+  318 jump *label55 always
+  319 multilabel *label202 (m:*label56)
+  320 jump *label55 always
+  321 multilabel *label203 (m:*label56)
+  322 label *label16
+  323 set .CONTAINER :block
+  324 set .SENSOR @totalLiquids
+  325 set .MAXIMUM @liquidCapacity
+  326 op add .START :n 1
+  327 jump *label6 always
   328 label *label8
   329 set .MESSAGE :block
   330 jump *label6 always
   331 label *label7
-    * jump *label9 notEqual *tmp5 @switch
   332 label *label10
   333 set .SWITCH :block
   334 jump *label6 always
   335 label *label9
-    * jump *label12 equal *tmp5 @sorter
-    * jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label11 notEqual *tmp5 @unloader
   336 label *label12
   337 set .SORTER :block
   338 jump *label6 always
   339 label *label11
-    * jump *label14 equal *tmp5 @vault
-    * jump *label14 equal *tmp5 @container
-    * jump *label14 equal *tmp5 @core-shard
-    * jump *label14 equal *tmp5 @core-foundation
-    * jump *label13 notEqual *tmp5 @core-nucleus
   340 label *label14
   341 set .CONTAINER :block
   342 set .SENSOR @totalItems
 
   344 op add .START :n 1
   345 jump *label6 always
   346 label *label13
-    * jump *label16 equal *tmp5 @liquid-tank
-    * jump *label16 equal *tmp5 @liquid-container
-    * jump *label15 notEqual *tmp5 @liquid-router
-    * label *label16
-    * set .CONTAINER :block
-    * set .SENSOR @totalLiquids
-    * set .MAXIMUM @liquidCapacity
-    * op add .START :n 1
-    * jump *label6 always
   347 label *label15
-    * jump *label18 equal *tmp5 @battery
-    * jump *label17 notEqual *tmp5 @battery-large
   348 label *label18
   349 set .CONTAINER :block
   350 set .SENSOR @totalPower
 
   352 op add .START :n 1
   353 jump *label6 always
   354 label *label17
-    * jump *label20 equal *tmp5 @power-node
-    * jump *label20 equal *tmp5 @power-node-large
-    * jump *label19 notEqual *tmp5 @surge-tower
   355 label *label20
   356 set .CONTAINER :block
   357 set .SENSOR @powerNetStored
   358 set .MAXIMUM @powerNetCapacity
   359 op add .START :n 1
   360 label *label19
+  361 label *label55
   362 label *label6
   363 label *label4
   364 jump *label52 greaterThan :n 0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   387 sensor *tmp14 .SORTER @type
   388 op strictEqual .INVERTED *tmp14 @inverted-sorter
   389 # "Function: inline def setState(in newState)"
-    * jump *label24 equal null true
   390 set .STATE true
   391 op add .CYCLES 0 1
   392 op xor .ON .INVERTED true

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   388 op strictEqual .INVERTED *tmp14 @inverted-sorter
   389 # "Function: inline def setState(in newState)"
   390 set .STATE true
-    * op add .CYCLES 0 1
+  391 set .CYCLES 1
   392 op xor .ON .INVERTED true
   393 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   394 label *label26
 
   443 jump *label43 equal .STATE false
   444 set .STATE false
   445 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED false
+  446 set .ON .INVERTED
   447 select *tmp48 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   448 label *label45
   449 label *label46

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   444 set .STATE false
   445 op add .CYCLES .CYCLES 1
   446 set .ON .INVERTED
-    * select *tmp48 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
+  447 select *tmp48 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   448 label *label45
   449 label *label46
   450 set .ACTIVE_TEXT *tmp48

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    14 print "Configuring regulator..."
    15 print "\n"
    16 set :n @links
-    * label *label3
    17 jump *label5 lessThanEq :n 0
    18 label *label52
    19 op sub :n :n 1
 
   327 label *label8
   328 set .MESSAGE :block
   329 jump *label6 always
-    * label *label7
   330 label *label10
   331 set .SWITCH :block
   332 jump *label6 always
-    * label *label9
   333 label *label12
   334 set .SORTER :block
   335 jump *label6 always
-    * label *label11
   336 label *label14
   337 set .CONTAINER :block
   338 set .SENSOR @totalItems
   339 set .MAXIMUM @itemCapacity
   340 op add .START :n 1
   341 jump *label6 always
-    * label *label13
-    * label *label15
   342 label *label18
   343 set .CONTAINER :block
   344 set .SENSOR @totalPower
   345 set .MAXIMUM @powerCapacity
   346 op add .START :n 1
   347 jump *label6 always
-    * label *label17
   348 label *label20
   349 set .CONTAINER :block
   350 set .SENSOR @powerNetStored
   351 set .MAXIMUM @powerNetCapacity
   352 op add .START :n 1
-    * label *label19
   353 label *label55
   354 label *label6
-    * label *label4
   355 jump *label52 greaterThan :n 0
   356 label *label5
   357 print "Message: "
 
   370 print "No container."
   371 print "\n"
   372 label *label21
-    * label *label22
   373 printflush .MESSAGE
-    * label *label1
   374 jump *label0 equal .CONTAINER null
-    * label *label2
   375 sensor *tmp14 .SORTER @type
   376 op strictEqual .INVERTED *tmp14 @inverted-sorter
   377 # "Function: inline def setState(in newState)"
 
   379 set .CYCLES 1
   380 op xor .ON .INVERTED true
   381 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label26
-    * label *label27
   382 set .ACTIVE_TEXT *tmp20
-    * label *label24
-    * label *label25
-    * label *label23
   383 control enabled .SWITCH 0
-    * label *label28
   384 sensor *tmp23 .SWITCH @enabled
   385 jump *label30 notEqual *tmp23 0
   386 label *label54
 
   412 op add .CYCLES .CYCLES 1
   413 op xor .ON .INVERTED true
   414 select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label38
-    * label *label39
   415 set .ACTIVE_TEXT *tmp41
   416 label *label36
-    * label *label37
-    * label *label35
   417 jump *label34 always
   418 label *label33
   419 jump *label40 lessThan :pct PCT_HIGH
 
   423 op add .CYCLES .CYCLES 1
   424 set .ON .INVERTED
   425 select *tmp48 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label45
-    * label *label46
   426 set .ACTIVE_TEXT *tmp48
   427 label *label43
-    * label *label44
-    * label *label42
   428 label *label40
-    * label *label41
   429 label *label34
   430 print "\n"
   431 print "Level: [gold]"
 
   458 label *label48
   459 print .ACTIVE_TEXT
   460 set :n .START
-    * label *label49
   461 jump *label51 greaterThanEq .START @links
   462 label *label53
   463 getlink :block :n
 
   465 print "\n    "
   466 print :block
   467 op add :n :n 1
-    * label *label50
   468 jump *label53 lessThan :n @links
   469 label *label51
   470 print "[]"
 
   479 print " "
   480 print "ms"
   481 printflush .MESSAGE
-    * label *label29
   482 sensor *tmp23 .SWITCH @enabled
   483 jump *label54 equal *tmp23 0
   484 label *label30

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 set PCT_LOW 60
     2 set PCT_HIGH 80
     3 set .CONTAINER null
 
   383 set .ACTIVE_TEXT *tmp20
   384 control enabled .SWITCH 0
   385 sensor *tmp23 .SWITCH @enabled
-    * jump *label30 notEqual *tmp23 0
+  386 jump __start__ notEqual *tmp23 0
   387 label *label54
   388 set :start @time
   389 sensor :item .SORTER @config
 
   408 op idiv :pct *tmp33 :max
   409 jump *label33 greaterThan :pct PCT_LOW
   410 # "Function: inline def setState(in newState)"
-    * jump *label36 equal .STATE true
+  411 jump *label34 equal .STATE true
   412 set .STATE true
   413 op add .CYCLES .CYCLES 1
   414 op xor .ON .INVERTED true

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1:
 
   414 op xor .ON .INVERTED true
   415 select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   416 set .ACTIVE_TEXT *tmp41
-    * label *label36
   417 jump *label34 always
   418 label *label33
   419 jump *label40 lessThan :pct PCT_HIGH
 
   481 printflush .MESSAGE
   482 sensor *tmp23 .SWITCH @enabled
   483 jump *label54 equal *tmp23 0
-    * label *label30
   484 end

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   481 printflush .MESSAGE
   482 sensor *tmp23 .SWITCH @enabled
   483 jump *label54 equal *tmp23 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-35 instructions):
 
    12 set .ACTIVE_TEXT null
    13 set .CYCLES 0
    14 label *label0
-    * print "Configuring regulator..."
-    * print "\n"
+   15 print "Configuring regulator...\n"
    16 set :n @links
    17 jump *label5 lessThanEq :n 0
    18 label *label52
    19 op sub :n :n 1
    20 getlink :block :n
-    * print "Found: "
-    * print :block
-    * print "\n"
+   21 print "Found: {0}\n"
+   22 format :block
    23 sensor *tmp5 :block @type
    24 sensor *tmp56 *tmp5 @id
    25 jump *label55 greaterThanEq *tmp56 147
 
   353 label *label6
   354 jump *label52 greaterThan :n 0
   355 label *label5
-    * print "Message: "
-    * print .MESSAGE
-    * print "\n"
-    * print "Switch: "
-    * print .SWITCH
-    * print "\n"
-    * print "Sorter: "
-    * print .SORTER
-    * print "\n"
-    * print "Container: "
-    * print .CONTAINER
-    * print "\n"
+  356 print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
+  357 format .MESSAGE
+  358 format .SWITCH
+  359 format .SORTER
+  360 format .CONTAINER
   361 jump *label21 notEqual .CONTAINER null
-    * print "No container."
-    * print "\n"
+  362 print "No container.\n"
   363 label *label21
   364 printflush .MESSAGE
   365 jump *label0 equal .CONTAINER null
 
   386 print .CONTAINER
   387 jump *label32 always
   388 label *label31
-    * print "Measuring [gold]"
-    * print :item
-    * print "["
-    * print "] in "
+  389 print "Measuring [gold]{0}[] in "
+  390 format :item
   391 print .CONTAINER
   392 label *label32
   393 sensor :max .CONTAINER .MAXIMUM
 
   415 label *label43
   416 label *label40
   417 label *label34
-    * print "\n"
-    * print "Level: [gold]"
-    * print :pct
-    * print "%"
-    * print "[]"
+  418 print "\nLevel: [gold]{0}%[]"
+  419 format :pct
   420 jump *label47 equal .INVERTED false
-    * print "\n"
-    * print "Activate above [green]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate below [salmon]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
+  421 print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
+  422 format PCT_HIGH
+  423 format PCT_LOW
   424 jump *label48 always
   425 label *label47
-    * print "\n"
-    * print "Activate below [green]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate above [salmon]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
+  426 print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
+  427 format PCT_LOW
+  428 format PCT_HIGH
   429 label *label48
   430 print .ACTIVE_TEXT
   431 set :n .START
 
   438 op add :n :n 1
   439 jump *label53 lessThan :n @links
   440 label *label51
-    * print "[]"
-    * print "\n"
-    * print "# of cycles: "
-    * print .CYCLES
+  441 print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
+  442 format .CYCLES
   443 op sub *tmp54 @time :start
   444 op floor *tmp55 *tmp54
-    * print "\n"
-    * print "[lightgray]Loop: "
-    * print *tmp55
-    * print " "
-    * print "ms"
+  445 format *tmp55
   446 printflush .MESSAGE
   447 sensor *tmp23 .SWITCH @enabled
   448 jump *label54 equal *tmp23 0

Final code before resolving virtual instructions:

label __start__
set PCT_LOW 60
set PCT_HIGH 80
set .CONTAINER null
set .SORTER null
set .SWITCH null
set .STATE null
set .START null
set .SENSOR null
set .ON null
set .MESSAGE null
set .MAXIMUM null
set .ACTIVE_TEXT null
set .CYCLES 0
label *label0
print "Configuring regulator...\n"
set :n @links
jump *label5 lessThanEq :n 0
label *label52
op sub :n :n 1
getlink :block :n
print "Found: {0}\n"
format :block
sensor *tmp5 :block @type
sensor *tmp56 *tmp5 @id
jump *label55 greaterThanEq *tmp56 147
multijump *label57 *tmp56 0
multilabel *label57
jump *label55 always
multilabel *label58
jump *label55 always
multilabel *label59
jump *label55 always
multilabel *label60
jump *label55 always
multilabel *label61
jump *label55 always
multilabel *label62
jump *label55 always
multilabel *label63
jump *label55 always
multilabel *label64
jump *label55 always
multilabel *label65
jump *label55 always
multilabel *label66
jump *label55 always
multilabel *label67
jump *label55 always
multilabel *label68
jump *label55 always
multilabel *label69
jump *label55 always
multilabel *label70
jump *label55 always
multilabel *label71
jump *label55 always
multilabel *label72
jump *label55 always
multilabel *label73
jump *label55 always
multilabel *label74
jump *label55 always
multilabel *label75
jump *label55 always
multilabel *label76
jump *label55 always
multilabel *label77
jump *label55 always
multilabel *label78
jump *label55 always
multilabel *label79
jump *label55 always
multilabel *label80
jump *label55 always
multilabel *label81
jump *label55 always
multilabel *label82
jump *label55 always
multilabel *label83
jump *label55 always
multilabel *label84
jump *label55 always
multilabel *label85
jump *label55 always
multilabel *label86
jump *label55 always
multilabel *label87
jump *label55 always
multilabel *label88
jump *label55 always
multilabel *label89
jump *label55 always
multilabel *label90
jump *label55 always
multilabel *label91
jump *label55 always
multilabel *label92
jump *label55 always
multilabel *label93
jump *label55 always
multilabel *label94
jump *label55 always
multilabel *label95
jump *label55 always
multilabel *label96
jump *label55 always
multilabel *label97
jump *label55 always
multilabel *label98
jump *label55 always
multilabel *label99
jump *label55 always
multilabel *label100
jump *label55 always
multilabel *label101
jump *label55 always
multilabel *label102
jump *label55 always
multilabel *label103
jump *label55 always
multilabel *label104
jump *label55 always
multilabel *label105
jump *label12 always
multilabel *label106
jump *label12 always
multilabel *label107
jump *label55 always
multilabel *label108
jump *label55 always
multilabel *label109
jump *label55 always
multilabel *label110
jump *label55 always
multilabel *label111
jump *label55 always
multilabel *label112
jump *label55 always
multilabel *label113
jump *label55 always
multilabel *label114
jump *label55 always
multilabel *label115
jump *label55 always
multilabel *label116
jump *label55 always
multilabel *label117
jump *label55 always
multilabel *label118
jump *label55 always
multilabel *label119
jump *label55 always
multilabel *label120
jump *label16 always
multilabel *label121
jump *label16 always
multilabel *label122
jump *label55 always
multilabel *label123
jump *label55 always
multilabel *label124
jump *label55 always
multilabel *label125
jump *label20 always
multilabel *label126
jump *label20 always
multilabel *label127
jump *label20 always
multilabel *label128
jump *label55 always
multilabel *label129
jump *label18 always
multilabel *label130
jump *label18 always
multilabel *label131
jump *label55 always
multilabel *label132
jump *label55 always
multilabel *label133
jump *label55 always
multilabel *label134
jump *label55 always
multilabel *label135
jump *label55 always
multilabel *label136
jump *label55 always
multilabel *label137
jump *label55 always
multilabel *label138
jump *label55 always
multilabel *label139
jump *label55 always
multilabel *label140
jump *label55 always
multilabel *label141
jump *label55 always
multilabel *label142
jump *label55 always
multilabel *label143
jump *label55 always
multilabel *label144
jump *label55 always
multilabel *label145
jump *label55 always
multilabel *label146
jump *label55 always
multilabel *label147
jump *label14 always
multilabel *label148
jump *label14 always
multilabel *label149
jump *label14 always
multilabel *label150
jump *label14 always
multilabel *label151
jump *label14 always
multilabel *label152
jump *label12 always
multilabel *label153
jump *label55 always
multilabel *label154
jump *label55 always
multilabel *label155
jump *label55 always
multilabel *label156
jump *label55 always
multilabel *label157
jump *label55 always
multilabel *label158
jump *label55 always
multilabel *label159
jump *label55 always
multilabel *label160
jump *label55 always
multilabel *label161
jump *label55 always
multilabel *label162
jump *label55 always
multilabel *label163
jump *label55 always
multilabel *label164
jump *label55 always
multilabel *label165
jump *label55 always
multilabel *label166
jump *label55 always
multilabel *label167
jump *label55 always
multilabel *label168
jump *label55 always
multilabel *label169
jump *label55 always
multilabel *label170
jump *label55 always
multilabel *label171
jump *label55 always
multilabel *label172
jump *label55 always
multilabel *label173
jump *label55 always
multilabel *label174
jump *label55 always
multilabel *label175
jump *label55 always
multilabel *label176
jump *label55 always
multilabel *label177
jump *label55 always
multilabel *label178
jump *label55 always
multilabel *label179
jump *label55 always
multilabel *label180
jump *label55 always
multilabel *label181
jump *label55 always
multilabel *label182
jump *label55 always
multilabel *label183
jump *label55 always
multilabel *label184
jump *label55 always
multilabel *label185
jump *label55 always
multilabel *label186
jump *label55 always
multilabel *label187
jump *label55 always
multilabel *label188
jump *label55 always
multilabel *label189
jump *label55 always
multilabel *label190
jump *label55 always
multilabel *label191
jump *label55 always
multilabel *label192
jump *label55 always
multilabel *label193
jump *label55 always
multilabel *label194
jump *label8 always
multilabel *label195
jump *label10 always
multilabel *label196
jump *label55 always
multilabel *label197
jump *label55 always
multilabel *label198
jump *label55 always
multilabel *label199
jump *label55 always
multilabel *label200
jump *label55 always
multilabel *label201
jump *label55 always
multilabel *label202
jump *label55 always
multilabel *label203
label *label16
set .CONTAINER :block
set .SENSOR @totalLiquids
set .MAXIMUM @liquidCapacity
op add .START :n 1
jump *label6 always
label *label8
set .MESSAGE :block
jump *label6 always
label *label10
set .SWITCH :block
jump *label6 always
label *label12
set .SORTER :block
jump *label6 always
label *label14
set .CONTAINER :block
set .SENSOR @totalItems
set .MAXIMUM @itemCapacity
op add .START :n 1
jump *label6 always
label *label18
set .CONTAINER :block
set .SENSOR @totalPower
set .MAXIMUM @powerCapacity
op add .START :n 1
jump *label6 always
label *label20
set .CONTAINER :block
set .SENSOR @powerNetStored
set .MAXIMUM @powerNetCapacity
op add .START :n 1
label *label55
label *label6
jump *label52 greaterThan :n 0
label *label5
print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
format .MESSAGE
format .SWITCH
format .SORTER
format .CONTAINER
jump *label21 notEqual .CONTAINER null
print "No container.\n"
label *label21
printflush .MESSAGE
jump *label0 equal .CONTAINER null
sensor *tmp14 .SORTER @type
op strictEqual .INVERTED *tmp14 @inverted-sorter
# "Function: inline def setState(in newState)"
set .STATE true
set .CYCLES 1
op xor .ON .INVERTED true
select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
set .ACTIVE_TEXT *tmp20
control enabled .SWITCH 0
sensor *tmp23 .SWITCH @enabled
jump __start__ notEqual *tmp23 0
label *label54
set :start @time
sensor :item .SORTER @config
op equal *tmp27 :item null
op notEqual *tmp28 .SENSOR @totalItems
op or *tmp29 *tmp27 *tmp28
jump *label31 equal *tmp29 false
set :item .SENSOR
print "Measuring [gold]total[] in "
print .CONTAINER
jump *label32 always
label *label31
print "Measuring [gold]{0}[] in "
format :item
print .CONTAINER
label *label32
sensor :max .CONTAINER .MAXIMUM
sensor :amount .CONTAINER :item
op mul *tmp33 100 :amount
op idiv :pct *tmp33 :max
jump *label33 greaterThan :pct PCT_LOW
# "Function: inline def setState(in newState)"
jump *label34 equal .STATE true
set .STATE true
op add .CYCLES .CYCLES 1
op xor .ON .INVERTED true
select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
set .ACTIVE_TEXT *tmp41
jump *label34 always
label *label33
jump *label40 lessThan :pct PCT_HIGH
# "Function: inline def setState(in newState)"
jump *label43 equal .STATE false
set .STATE false
op add .CYCLES .CYCLES 1
set .ON .INVERTED
select *tmp48 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
set .ACTIVE_TEXT *tmp48
label *label43
label *label40
label *label34
print "\nLevel: [gold]{0}%[]"
format :pct
jump *label47 equal .INVERTED false
print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
format PCT_HIGH
format PCT_LOW
jump *label48 always
label *label47
print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
format PCT_LOW
format PCT_HIGH
label *label48
print .ACTIVE_TEXT
set :n .START
jump *label51 greaterThanEq .START @links
label *label53
getlink :block :n
control enabled :block .ON
print "\n    "
print :block
op add :n :n 1
jump *label53 lessThan :n @links
label *label51
print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
format .CYCLES
op sub *tmp54 @time :start
op floor *tmp55 *tmp54
format *tmp55
printflush .MESSAGE
sensor *tmp23 .SWITCH @enabled
jump *label54 equal *tmp23 0
