    23 instructions before optimizations.
     1 instructions eliminated by Temp Variables Elimination (2 iterations).
     5 instructions eliminated by Dead Code Elimination (2 passes, 5 iterations).
     2 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     1 instructions eliminated by Data Flow Optimization (6 iterations).
    14 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-3 instructions):
 
    13 set :test:res *tmp3
    14 jump *label1 equal :test:res false
    15 print "yes"
-    * set *tmp4 "yes"
    16 jump *label2 always
    17 label *label1
-    * set *tmp4 null
    18 label *label2
    19 print :test:res
-    * set *tmp2 :test:res
    20 label *label0
    21 assertprints "yes1" "assignments in conditions"
    22 stop

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-1 instructions):
 
     9 assertequals 4 *tmp1 "(B += 1) + B"
    10 assertflush
    11 # "Function: def test()"
-    * op lessThan *tmp3 a b
-    * set :test:res *tmp3
+   12 op lessThan :test:res a b
    13 jump *label1 equal :test:res false
    14 print "yes"
    15 jump *label2 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-1 instructions):
 
    12 op lessThan :test:res a b
    13 jump *label1 equal :test:res false
    14 print "yes"
-    * jump *label2 always
    15 label *label1
    16 label *label2
    17 print :test:res

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set a 1
     1 set b 2
     2 set .A a
-    * set .B .A
-    * op add .A .A 1
+    3 set .B a
+    4 op add .A a 1
     5 op add *tmp0 .A .A
     6 assertequals 4 *tmp0 "A + (A += 1)"
     7 op add .B .B 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2:
 
     4 op add .A a 1
     5 op add *tmp0 .A .A
     6 assertequals 4 *tmp0 "A + (A += 1)"
-    * op add .B .B 1
+    7 op add .B a 1
     8 op add *tmp1 .B .B
     9 assertequals 4 *tmp1 "(B += 1) + B"
    10 assertflush

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3:
 
     5 op add *tmp0 .A .A
     6 assertequals 4 *tmp0 "A + (A += 1)"
     7 op add .B a 1
-    * op add *tmp1 .B .B
-    * assertequals 4 *tmp1 "(B += 1) + B"
+    8 op add *tmp1 .A .A
+    9 assertequals 4 *tmp0 "(B += 1) + B"
    10 assertflush
    11 # "Function: def test()"
    12 op lessThan :test:res a b

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-1 instructions):
 
     5 op add *tmp0 .A .A
     6 assertequals 4 *tmp0 "A + (A += 1)"
     7 op add .B a 1
-    * op add *tmp1 .A .A
     8 assertequals 4 *tmp0 "(B += 1) + B"
     9 assertflush
    10 # "Function: def test()"

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
    12 jump *label1 equal :test:res false
    13 print "yes"
    14 label *label1
-    * label *label2
    15 print :test:res
-    * label *label0
    16 assertprints "yes1" "assignments in conditions"
    17 stop
    18 end

Modifications by Jumps phase, Dead Code Elimination, pass 3, iteration 1 (-2 instructions):
     0 set a 1
     1 set b 2
     2 set .A a
-    * set .B a
     3 op add .A a 1
     4 op add *tmp0 .A .A
     5 assertequals 4 *tmp0 "A + (A += 1)"
-    * op add .B a 1
     6 assertequals 4 *tmp0 "(B += 1) + B"
     7 assertflush
     8 # "Function: def test()"

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
    13 print :test:res
    14 assertprints "yes1" "assignments in conditions"
    15 stop
-    * end

Final code before resolving virtual instructions:

set a 1
set b 2
set .A a
op add .A a 1
op add *tmp0 .A .A
assertequals 4 *tmp0 "A + (A += 1)"
assertequals 4 *tmp0 "(B += 1) + B"
assertflush
# "Function: def test()"
op lessThan :test:res a b
jump *label1 equal :test:res false
print "yes"
label *label1
print :test:res
assertprints "yes1" "assignments in conditions"
stop
