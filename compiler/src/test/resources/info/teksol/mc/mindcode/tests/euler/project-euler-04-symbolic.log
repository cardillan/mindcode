    36 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (6 iterations).
     4 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Condition Optimization (6 iterations).
     3 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Boolean Optimization (6 iterations).
       1 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     1 instructions eliminated by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
    21 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 978):
  ! Unroll loop at line 4:1                                      size +1332, benefit     4500.0, efficiency      3.378

Pass 2: speed optimization selection (cost limit 978):
  ! Unroll loop at line 4:1                                      size +1332, benefit     4500.0, efficiency      3.378

Pass 3: speed optimization selection (cost limit 978):
  ! Unroll loop at line 4:1                                      size +1332, benefit     4500.0, efficiency      3.378

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    32 label *label8
    33 set *tmp9 null
    34 label *label9
-    * set *tmp2 *tmp9
    35 jump *label7 always
    36 label *label6
-    * set *tmp2 null
    37 label *label7
    38 label *label4
    39 op add :j :j 1

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
    27 op equal *tmp8 :num *tmp3
    28 jump *label8 equal *tmp8 false
    29 set :max :num
-    * set *tmp9 :max
    30 jump *label9 always
    31 label *label8
-    * set *tmp9 null
    32 label *label9
    33 jump *label7 always
    34 label *label6

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
     4 set :j :i
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
-    * op mul *tmp0 :i :j
-    * set :num *tmp0
+    7 op mul :num :i :j
     8 op greaterThan *tmp1 :num :max
     9 jump *label6 equal *tmp1 false
    10 # "Function: def revert(in num)"
 
    15 jump *label13 equal *tmp4 false
    16 op mul *tmp5 10 :revert:res
    17 op mod *tmp6 :revert:num 10
-    * op add *tmp7 *tmp5 *tmp6
-    * set :revert:res *tmp7
+   18 op add :revert:res *tmp5 *tmp6
    19 op idiv :revert:num :revert:num 10
    20 label *label12
    21 jump *label11 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-3 instructions):
 
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
     7 op mul :num :i :j
-    * op greaterThan *tmp1 :num :max
-    * jump *label6 equal *tmp1 false
+    8 jump *label6 lessThanEq :num :max
     9 # "Function: def revert(in num)"
    10 set :revert:num :num
    11 set :revert:res 0
    12 label *label11
-    * op greaterThan *tmp4 :revert:num 0
-    * jump *label13 equal *tmp4 false
+   13 jump *label13 lessThanEq :revert:num 0
    14 op mul *tmp5 10 :revert:res
    15 op mod *tmp6 :revert:num 10
    16 op add :revert:res *tmp5 *tmp6
 
    20 label *label13
    21 set *tmp3 :revert:res
    22 label *label10
-    * op equal *tmp8 :num *tmp3
-    * jump *label8 equal *tmp8 false
+   23 jump *label8 notEqual :num *tmp3
    24 set :max :num
    25 jump *label9 always
    26 label *label8

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    22 label *label10
    23 jump *label8 notEqual :num *tmp3
    24 set :max :num
-    * jump *label9 always
    25 label *label8
    26 label *label9
-    * jump *label7 always
    27 label *label6
    28 label *label7
    29 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    20 label *label13
    21 set *tmp3 :revert:res
    22 label *label10
-    * jump *label8 notEqual :num *tmp3
+   23 jump *label8 notEqual :num :revert:res
    24 set :max :num
    25 label *label8
    26 label *label9

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    18 label *label12
    19 jump *label11 always
    20 label *label13
-    * set *tmp3 :revert:res
    21 label *label10
    22 jump *label8 notEqual :num :revert:res
    23 set :max :num

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
     0 set :max 0
     1 set :i 10
     2 label *label0
-    * jump *label2 greaterThanEq :i 100
+    3 label *label14
     4 set :j :i
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
+    7 label *label15
     8 op mul :num :i :j
     9 jump *label6 lessThanEq :num :max
    10 # "Function: def revert(in num)"
 
    12 set :revert:res 0
    13 label *label11
    14 jump *label13 lessThanEq :revert:num 0
+   15 label *label16
    16 op mul *tmp5 10 :revert:res
    17 op mod *tmp6 :revert:num 10
    18 op add :revert:res *tmp5 *tmp6
    19 op idiv :revert:num :revert:num 10
    20 label *label12
-    * jump *label11 always
+   21 jump *label16 greaterThan :revert:num 0
    22 label *label13
    23 label *label10
    24 jump *label8 notEqual :num :revert:res
 
    29 label *label7
    30 label *label4
    31 op add :j :j 1
-    * jump *label3 always
+   32 jump *label15 lessThan :j 100
    33 label *label5
    34 label *label1
    35 op add :i :i 1
-    * jump *label0 always
+   36 jump *label14 lessThan :i 100
    37 label *label2
    38 assertequals 9009 :max "Project Euler 4"
    39 stop

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
     7 label *label15
     8 op mul :num :i :j
     9 jump *label6 lessThanEq :num :max
-    * # "Function: def revert(in num)"
-    * set :revert:num :num
-    * set :revert:res 0
-    * label *label11
-    * jump *label13 lessThanEq :revert:num 0
-    * label *label16
-    * op mul *tmp5 10 :revert:res
-    * op mod *tmp6 :revert:num 10
-    * op add :revert:res *tmp5 *tmp6
-    * op idiv :revert:num :revert:num 10
-    * label *label12
-    * jump *label16 greaterThan :revert:num 0
-    * label *label13
-    * label *label10
-    * jump *label8 notEqual :num :revert:res
-    * set :max :num
-    * label *label8
-    * label *label9
+   10 # "Function: def revert(in num)"
+   11 set :revert:num :num
+   12 set :revert:res 0
+   13 label *label17
+   14 jump *label20 lessThanEq :revert:num 0
+   15 label *label18
+   16 op mul *tmp5 10 :revert:res
+   17 op mod *tmp6 :revert:num 10
+   18 op add :revert:res *tmp5 *tmp6
+   19 op idiv :revert:num :revert:num 10
+   20 label *label19
+   21 jump *label18 greaterThan :revert:num 0
+   22 label *label20
+   23 label *label21
+   24 select :max equal :num :revert:res :num :max
    25 label *label6
    26 label *label7
    27 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
     3 label *label14
     4 set :j :i
     5 label *label3
-    * jump *label5 greaterThanEq :j 100
+    6 jump *label5 greaterThanEq :i 100
     7 label *label15
     8 op mul :num :i :j
     9 jump *label6 lessThanEq :num :max
 
    11 set :revert:num :num
    12 set :revert:res 0
    13 label *label17
-    * jump *label20 lessThanEq :revert:num 0
+   14 jump *label20 lessThanEq :num 0
    15 label *label18
    16 op mul *tmp5 10 :revert:res
    17 op mod *tmp6 :revert:num 10

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
    25 jump *label14 lessThan :i 100
    26 assertequals 9009 :max "Project Euler 4"
    27 stop
-    * end

Final code before resolving virtual instructions:

set :max 0
set :i 10
label *label14
set :j :i
jump *label5 greaterThanEq :i 100
label *label15
op mul :num :i :j
jump *label6 lessThanEq :num :max
# "Function: def revert(in num)"
set :revert:num :num
set :revert:res 0
jump *label20 lessThanEq :num 0
label *label18
op mul *tmp5 10 :revert:res
op mod *tmp6 :revert:num 10
op add :revert:res *tmp5 *tmp6
op idiv :revert:num :revert:num 10
jump *label18 greaterThan :revert:num 0
label *label20
select :max equal :num :revert:res :num :max
label *label6
op add :j :j 1
jump *label15 lessThan :j 100
label *label5
op add :i :i 1
jump *label14 lessThan :i 100
assertequals 9009 :max "Project Euler 4"
stop
