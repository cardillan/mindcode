    36 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (2 iterations).
     4 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Jump Optimization (5 iterations).
     3 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     1 instructions eliminated by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
    22 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 977):
  ! Unroll loop at line 4:1                                      size +1421, benefit     4500.0, efficiency      3.167

Pass 2: speed optimization selection (cost limit 977):
  ! Unroll loop at line 4:1                                      size +1421, benefit     4500.0, efficiency      3.167

Pass 3: speed optimization selection (cost limit 977):
  ! Unroll loop at line 4:1                                      size +1421, benefit     4500.0, efficiency      3.167

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    32 label *label12
    33 set *tmp9 null
    34 label *label13
-    * set *tmp2 *tmp9
    35 jump *label7 always
    36 label *label6
-    * set *tmp2 null
    37 label *label7
    38 label *label4
    39 op add :j :j 1

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
    27 op equal *tmp8 :num *tmp3
    28 jump *label12 equal *tmp8 false
    29 set :max :num
-    * set *tmp9 :max
    30 jump *label13 always
    31 label *label12
-    * set *tmp9 null
    32 label *label13
    33 jump *label7 always
    34 label *label6

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
     4 set :j :i
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
-    * op mul *tmp0 :i :j
-    * set :num *tmp0
+    7 op mul :num :i :j
     8 op greaterThan *tmp1 :num :max
     9 jump *label6 equal *tmp1 false
    10 # "Function: def revert(in num)"
 
    15 jump *label11 equal *tmp4 false
    16 op mul *tmp5 10 :revert:res
    17 op mod *tmp6 :revert:num 10
-    * op add *tmp7 *tmp5 *tmp6
-    * set :revert:res *tmp7
+   18 op add :revert:res *tmp5 *tmp6
    19 op idiv :revert:num :revert:num 10
    20 label *label10
    21 jump *label9 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-3 instructions):
 
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
     7 op mul :num :i :j
-    * op greaterThan *tmp1 :num :max
-    * jump *label6 equal *tmp1 false
+    8 jump *label6 lessThanEq :num :max
     9 # "Function: def revert(in num)"
    10 set :revert:num :num
    11 set :revert:res 0
    12 label *label9
-    * op greaterThan *tmp4 :revert:num 0
-    * jump *label11 equal *tmp4 false
+   13 jump *label11 lessThanEq :revert:num 0
    14 op mul *tmp5 10 :revert:res
    15 op mod *tmp6 :revert:num 10
    16 op add :revert:res *tmp5 *tmp6
 
    20 label *label11
    21 set *tmp3 :revert:res
    22 label *label8
-    * op equal *tmp8 :num *tmp3
-    * jump *label12 equal *tmp8 false
+   23 jump *label12 notEqual :num *tmp3
    24 set :max :num
    25 jump *label13 always
    26 label *label12

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    22 label *label8
    23 jump *label12 notEqual :num *tmp3
    24 set :max :num
-    * jump *label13 always
    25 label *label12
    26 label *label13
-    * jump *label7 always
    27 label *label6
    28 label *label7
    29 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    20 label *label11
    21 set *tmp3 :revert:res
    22 label *label8
-    * jump *label12 notEqual :num *tmp3
+   23 jump *label12 notEqual :num :revert:res
    24 set :max :num
    25 label *label12
    26 label *label13

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    18 label *label10
    19 jump *label9 always
    20 label *label11
-    * set *tmp3 :revert:res
    21 label *label8
    22 jump *label12 notEqual :num :revert:res
    23 set :max :num

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
     0 set :max 0
     1 set :i 10
     2 label *label0
-    * jump *label2 greaterThanEq :i 100
+    3 label *label14
     4 set :j :i
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
+    7 label *label15
     8 op mul :num :i :j
     9 jump *label6 lessThanEq :num :max
    10 # "Function: def revert(in num)"
 
    12 set :revert:res 0
    13 label *label9
    14 jump *label11 lessThanEq :revert:num 0
+   15 label *label16
    16 op mul *tmp5 10 :revert:res
    17 op mod *tmp6 :revert:num 10
    18 op add :revert:res *tmp5 *tmp6
    19 op idiv :revert:num :revert:num 10
    20 label *label10
-    * jump *label9 always
+   21 jump *label16 greaterThan :revert:num 0
    22 label *label11
    23 label *label8
    24 jump *label12 notEqual :num :revert:res
 
    29 label *label7
    30 label *label4
    31 op add :j :j 1
-    * jump *label3 always
+   32 jump *label15 lessThan :j 100
    33 label *label5
    34 label *label1
    35 op add :i :i 1
-    * jump *label0 always
+   36 jump *label14 lessThan :i 100
    37 label *label2
    38 assertequals 9009 :max "Project Euler 4"
    39 stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
     3 label *label14
     4 set :j :i
     5 label *label3
-    * jump *label5 greaterThanEq :j 100
+    6 jump *label5 greaterThanEq :i 100
     7 label *label15
     8 op mul :num :i :j
     9 jump *label6 lessThanEq :num :max
 
    11 set :revert:num :num
    12 set :revert:res 0
    13 label *label9
-    * jump *label11 lessThanEq :revert:num 0
+   14 jump *label11 lessThanEq :num 0
    15 label *label16
    16 op mul *tmp5 10 :revert:res
    17 op mod *tmp6 :revert:num 10

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
     0 set :max 0
     1 set :i 10
-    * label *label0
     2 label *label14
     3 set :j :i
-    * label *label3
     4 jump *label5 greaterThanEq :i 100
     5 label *label15
     6 op mul :num :i :j
 
     8 # "Function: def revert(in num)"
     9 set :revert:num :num
    10 set :revert:res 0
-    * label *label9
    11 jump *label11 lessThanEq :num 0
    12 label *label16
    13 op mul *tmp5 10 :revert:res
    14 op mod *tmp6 :revert:num 10
    15 op add :revert:res *tmp5 *tmp6
    16 op idiv :revert:num :revert:num 10
-    * label *label10
    17 jump *label16 greaterThan :revert:num 0
    18 label *label11
-    * label *label8
    19 jump *label12 notEqual :num :revert:res
    20 set :max :num
    21 label *label12
-    * label *label13
    22 label *label6
-    * label *label7
-    * label *label4
    23 op add :j :j 1
    24 jump *label15 lessThan :j 100
    25 label *label5
-    * label *label1
    26 op add :i :i 1
    27 jump *label14 lessThan :i 100
-    * label *label2
    28 assertequals 9009 :max "Project Euler 4"
    29 stop
    30 end

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
    27 jump *label14 lessThan :i 100
    28 assertequals 9009 :max "Project Euler 4"
    29 stop
-    * end

Final code before resolving virtual instructions:

set :max 0
set :i 10
label *label14
set :j :i
jump *label5 greaterThanEq :i 100
label *label15
op mul :num :i :j
jump *label6 lessThanEq :num :max
# "Function: def revert(in num)"
set :revert:num :num
set :revert:res 0
jump *label11 lessThanEq :num 0
label *label16
op mul *tmp5 10 :revert:res
op mod *tmp6 :revert:num 10
op add :revert:res *tmp5 *tmp6
op idiv :revert:num :revert:num 10
jump *label16 greaterThan :revert:num 0
label *label11
jump *label12 notEqual :num :revert:res
set :max :num
label *label12
label *label6
op add :j :j 1
jump *label15 lessThan :j 100
label *label5
op add :i :i 1
jump *label14 lessThan :i 100
assertequals 9009 :max "Project Euler 4"
stop
