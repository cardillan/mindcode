   140 instructions before optimizations.
     1 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Single Step Elimination (4 iterations).
     2 instructions modified by Expression Optimization (2 iterations).
    78 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
    11 instructions added by Function Inlining (3 iterations).
     6 function calls inlined by Function Inlining.
    71 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 897):
  * Inline function 'assertEqualsRound' defined at line 3:1      cost    19, benefit       27.0, efficiency        1.4 (-31 instructions)
    Inline function call at line 71:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 72:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 73:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 75:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 76:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 77:1                            cost     4, benefit        4.5, efficiency        1.1

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-1 instructions):
 
   128 # "Function: inline def round(in x)"
   129 set :round.0:x *tmp4
   130 op add *tmp6 :round.0:x 0.5
-    * op floor *tmp7 *tmp6
-    * set *tmp5 *tmp7
+  131 op floor *tmp5 *tmp6
   132 label *label5
   133 op div *tmp8 *tmp5 100000000
   134 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
 
   111 op xor :a :a 2
   112 assertequals 1 :a "^="
   113 set :a 1
-    * op land :a :a 0
+  114 set :a false
   115 assertequals false :a "&&="
   116 set :a 1
   117 op land :a :a 2
   118 assertequals true :a "&&="
   119 set :a 0
-    * op or *tmp3 :a 2
+  120 set *tmp3 true
   121 op notEqual :a *tmp3 false
   122 assertequals true :a "||="
   123 stop

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
    31 assertequals -1 -1 "not 1"
    32 assertequals -65536 -65536 "not 2"
    33 set :a 0xabcdefabcdef
-    * op add *tmp0 :a 1
-    * op sub *tmp1 0 *tmp0
-    * op not *tmp2 :a
-    * assertequals *tmp1 *tmp2 "not 3"
+   34 op add *tmp0 0xabcdefabcdef 1
+   35 op sub *tmp1 0 188900977659376
+   36 op not *tmp2 0xabcdefabcdef
+   37 assertequals -188900977659376 -188900977659376 "not 3"
    38 assertequals 4 4 "max"
    39 assertequals 2 2 "min"
    40 assertequals 2 2 "abs"
 
    75 assertequals 0 false "boolean negation 2"
    76 assertequals 0 false "boolean negation 3"
    77 set :a 2
-    * op pow :a :a 4
-    * assertequals 16 :a "**="
+   78 op pow :a 2 4
+   79 assertequals 16 16 "**="
    80 set :a 2
-    * op mul :a :a 4
-    * assertequals 8 :a "*="
+   81 op mul :a 2 4
+   82 assertequals 8 8 "*="
    83 set :a 6
-    * op div :a :a 4
-    * assertequals 1.5 :a "/="
+   84 op div :a 6 4
+   85 assertequals 1.5 1.5 "/="
    86 set :a 6
-    * op idiv :a :a 4
-    * assertequals 1 :a "\="
+   87 op idiv :a 6 4
+   88 assertequals 1 1 "\="
    89 set :a 6
-    * op mod :a :a 4
-    * assertequals 2 :a "%="
+   90 op mod :a 6 4
+   91 assertequals 2 2 "%="
    92 set :a 4
-    * op add :a :a 2
-    * assertequals 6 :a "+="
+   93 op add :a 4 2
+   94 assertequals 6 6 "+="
    95 set :a 4
-    * op sub :a :a 2
-    * assertequals 2 :a "-="
+   96 op sub :a 4 2
+   97 assertequals 2 2 "-="
    98 set :a 1
-    * op shl :a :a 2
-    * assertequals 4 :a "<<="
+   99 op shl :a 1 2
+  100 assertequals 4 4 "<<="
   101 set :a 9
-    * op shr :a :a 2
-    * assertequals 2 :a ">>="
+  102 op shr :a 9 2
+  103 assertequals 2 2 ">>="
   104 set :a 1
-    * op or :a :a 2
-    * assertequals 3 :a "|="
+  105 op or :a 1 2
+  106 assertequals 3 3 "|="
   107 set :a 3
-    * op and :a :a 2
-    * assertequals 2 :a "&="
+  108 op and :a 3 2
+  109 assertequals 2 2 "&="
   110 set :a 3
-    * op xor :a :a 2
-    * assertequals 1 :a "^="
-    * set :a 1
+  111 op xor :a 3 2
+  112 assertequals 1 1 "^="
   113 set :a false
-    * assertequals false :a "&&="
+  114 assertequals false false "&&="
   115 set :a 1
-    * op land :a :a 2
-    * assertequals true :a "&&="
-    * set :a 0
+  116 op land :a 1 2
+  117 assertequals true true "&&="
   118 set *tmp3 true
-    * op notEqual :a *tmp3 false
-    * assertequals true :a "||="
+  119 op notEqual :a true false
+  120 assertequals true true "||="
   121 stop
   122 end
   123 label *label3
 
   125 op mul *tmp4 :assertEqualsRound.0:actual 100000000
   126 # "Function: inline def round(in x)"
   127 set :round.0:x *tmp4
-    * op add *tmp6 :round.0:x 0.5
+  128 op add *tmp6 *tmp4 0.5
   129 op floor *tmp5 *tmp6
   130 label *label5
   131 op div *tmp8 *tmp5 100000000

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-34 instructions):
 
    30 assertequals 1 1 "xor"
    31 assertequals -1 -1 "not 1"
    32 assertequals -65536 -65536 "not 2"
-    * set :a 0xabcdefabcdef
-    * op add *tmp0 0xabcdefabcdef 1
-    * op sub *tmp1 0 188900977659376
-    * op not *tmp2 0xabcdefabcdef
    33 assertequals -188900977659376 -188900977659376 "not 3"
    34 assertequals 4 4 "max"
    35 assertequals 2 2 "min"
 
    70 assertequals 1 true "boolean negation 1"
    71 assertequals 0 false "boolean negation 2"
    72 assertequals 0 false "boolean negation 3"
-    * set :a 2
-    * op pow :a 2 4
    73 assertequals 16 16 "**="
-    * set :a 2
-    * op mul :a 2 4
    74 assertequals 8 8 "*="
-    * set :a 6
-    * op div :a 6 4
    75 assertequals 1.5 1.5 "/="
-    * set :a 6
-    * op idiv :a 6 4
    76 assertequals 1 1 "\="
-    * set :a 6
-    * op mod :a 6 4
    77 assertequals 2 2 "%="
-    * set :a 4
-    * op add :a 4 2
    78 assertequals 6 6 "+="
-    * set :a 4
-    * op sub :a 4 2
    79 assertequals 2 2 "-="
-    * set :a 1
-    * op shl :a 1 2
    80 assertequals 4 4 "<<="
-    * set :a 9
-    * op shr :a 9 2
    81 assertequals 2 2 ">>="
-    * set :a 1
-    * op or :a 1 2
    82 assertequals 3 3 "|="
-    * set :a 3
-    * op and :a 3 2
    83 assertequals 2 2 "&="
-    * set :a 3
-    * op xor :a 3 2
    84 assertequals 1 1 "^="
-    * set :a false
    85 assertequals false false "&&="
-    * set :a 1
-    * op land :a 1 2
    86 assertequals true true "&&="
-    * set *tmp3 true
-    * op notEqual :a true false
    87 assertequals true true "||="
    88 stop
    89 end
 
    91 # "Function: void assertEqualsRound(in expected, in actual, in title)"
    92 op mul *tmp4 :assertEqualsRound.0:actual 100000000
    93 # "Function: inline def round(in x)"
-    * set :round.0:x *tmp4
    94 op add *tmp6 *tmp4 0.5
    95 op floor *tmp5 *tmp6
    96 label *label5

Modifications by Inline function 'assertEqualsRound' defined at line 3:1 (+11 instructions):
 
    45 set :assertEqualsRound.0:expected 1
    46 set :assertEqualsRound.0:actual 1
    47 set :assertEqualsRound.0:title "sin"
-    * call *label3 :assertEqualsRound.0*retaddr :assertEqualsRound.0*retval
+   48 label *label6
+   49 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+   50 op mul *tmp4 :assertEqualsRound.0:actual 100000000
+   51 # "Function: inline def round(in x)"
+   52 op add *tmp6 *tmp4 0.5
+   53 op floor *tmp5 *tmp6
+   54 label *label7
+   55 op div *tmp8 *tmp5 100000000
+   56 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   57 label *label8
    58 set :assertEqualsRound.0:expected -1
    59 set :assertEqualsRound.0:actual -1
    60 set :assertEqualsRound.0:title "cos"
-    * call *label3 :assertEqualsRound.0*retaddr :assertEqualsRound.0*retval
+   61 label *label9
+   62 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+   63 op mul *tmp4 :assertEqualsRound.0:actual 100000000
+   64 # "Function: inline def round(in x)"
+   65 op add *tmp6 *tmp4 0.5
+   66 op floor *tmp5 *tmp6
+   67 label *label10
+   68 op div *tmp8 *tmp5 100000000
+   69 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   70 label *label11
    71 set :assertEqualsRound.0:expected 1
    72 set :assertEqualsRound.0:actual 0.9999999999999999
    73 set :assertEqualsRound.0:title "tan"
-    * call *label3 :assertEqualsRound.0*retaddr :assertEqualsRound.0*retval
+   74 label *label12
+   75 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+   76 op mul *tmp4 :assertEqualsRound.0:actual 100000000
+   77 # "Function: inline def round(in x)"
+   78 op add *tmp6 *tmp4 0.5
+   79 op floor *tmp5 *tmp6
+   80 label *label13
+   81 op div *tmp8 *tmp5 100000000
+   82 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   83 label *label14
    84 set :assertEqualsRound.0:expected 90
    85 set :assertEqualsRound.0:actual 90
    86 set :assertEqualsRound.0:title "asin"
-    * call *label3 :assertEqualsRound.0*retaddr :assertEqualsRound.0*retval
+   87 label *label15
+   88 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+   89 op mul *tmp4 :assertEqualsRound.0:actual 100000000
+   90 # "Function: inline def round(in x)"
+   91 op add *tmp6 *tmp4 0.5
+   92 op floor *tmp5 *tmp6
+   93 label *label16
+   94 op div *tmp8 *tmp5 100000000
+   95 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   96 label *label17
    97 set :assertEqualsRound.0:expected 0
    98 set :assertEqualsRound.0:actual 0
    99 set :assertEqualsRound.0:title "acos"
-    * call *label3 :assertEqualsRound.0*retaddr :assertEqualsRound.0*retval
+  100 label *label18
+  101 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+  102 op mul *tmp4 :assertEqualsRound.0:actual 100000000
+  103 # "Function: inline def round(in x)"
+  104 op add *tmp6 *tmp4 0.5
+  105 op floor *tmp5 *tmp6
+  106 label *label19
+  107 op div *tmp8 *tmp5 100000000
+  108 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+  109 label *label20
   110 set :assertEqualsRound.0:expected 45
   111 set :assertEqualsRound.0:actual 45
   112 set :assertEqualsRound.0:title "atan"
-    * call *label3 :assertEqualsRound.0*retaddr :assertEqualsRound.0*retval
+  113 label *label21
+  114 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+  115 op mul *tmp4 :assertEqualsRound.0:actual 100000000
+  116 # "Function: inline def round(in x)"
+  117 op add *tmp6 *tmp4 0.5
+  118 op floor *tmp5 *tmp6
+  119 label *label22
+  120 op div *tmp8 *tmp5 100000000
+  121 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+  122 label *label23
   123 assertequals -8 -8 "unary minus"
   124 assertequals 1 true "boolean negation 1"
   125 assertequals 0 false "boolean negation 2"
 
   141 assertequals true true "||="
   142 stop
   143 end
-    * label *label3
-    * # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 :assertEqualsRound.0:actual 100000000
-    * # "Function: inline def round(in x)"
-    * op add *tmp6 *tmp4 0.5
-    * op floor *tmp5 *tmp6
-    * label *label5
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
-    * label *label4
-    * return :assertEqualsRound.0*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    47 set :assertEqualsRound.0:title "sin"
    48 label *label6
    49 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 :assertEqualsRound.0:actual 100000000
+   50 op mul *tmp4 1 100000000
    51 # "Function: inline def round(in x)"
-    * op add *tmp6 *tmp4 0.5
-    * op floor *tmp5 *tmp6
+   52 op add *tmp6 100000000 0.5
+   53 op floor *tmp5 100000000.5
    54 label *label7
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   55 op div *tmp8 100000000 100000000
+   56 assertequals 1 1 "sin"
    57 label *label8
    58 set :assertEqualsRound.0:expected -1
    59 set :assertEqualsRound.0:actual -1
    60 set :assertEqualsRound.0:title "cos"
    61 label *label9
    62 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 :assertEqualsRound.0:actual 100000000
+   63 op mul *tmp4 -1 100000000
    64 # "Function: inline def round(in x)"
-    * op add *tmp6 *tmp4 0.5
-    * op floor *tmp5 *tmp6
+   65 op add *tmp6 -100000000 0.5
+   66 op floor *tmp5 -99999999.5
    67 label *label10
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   68 op div *tmp8 -100000000 100000000
+   69 assertequals -1 -1 "cos"
    70 label *label11
    71 set :assertEqualsRound.0:expected 1
    72 set :assertEqualsRound.0:actual 0.9999999999999999
    73 set :assertEqualsRound.0:title "tan"
    74 label *label12
    75 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 :assertEqualsRound.0:actual 100000000
+   76 op mul *tmp4 0.9999999999999999 100000000
    77 # "Function: inline def round(in x)"
-    * op add *tmp6 *tmp4 0.5
-    * op floor *tmp5 *tmp6
+   78 op add *tmp6 99999999.99999999 0.5
+   79 op floor *tmp5 100000000.49999999
    80 label *label13
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   81 op div *tmp8 100000000 100000000
+   82 assertequals 1 1 "tan"
    83 label *label14
    84 set :assertEqualsRound.0:expected 90
    85 set :assertEqualsRound.0:actual 90
    86 set :assertEqualsRound.0:title "asin"
    87 label *label15
    88 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 :assertEqualsRound.0:actual 100000000
+   89 op mul *tmp4 90 100000000
    90 # "Function: inline def round(in x)"
-    * op add *tmp6 *tmp4 0.5
-    * op floor *tmp5 *tmp6
+   91 op add *tmp6 9000000000 0.5
+   92 op floor *tmp5 9000000000.5
    93 label *label16
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   94 op div *tmp8 9000000000 100000000
+   95 assertequals 90 90 "asin"
    96 label *label17
    97 set :assertEqualsRound.0:expected 0
    98 set :assertEqualsRound.0:actual 0
    99 set :assertEqualsRound.0:title "acos"
   100 label *label18
   101 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 :assertEqualsRound.0:actual 100000000
+  102 op mul *tmp4 0 100000000
   103 # "Function: inline def round(in x)"
-    * op add *tmp6 *tmp4 0.5
-    * op floor *tmp5 *tmp6
+  104 op add *tmp6 0 0.5
+  105 op floor *tmp5 0.5
   106 label *label19
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+  107 op div *tmp8 0 100000000
+  108 assertequals 0 0 "acos"
   109 label *label20
   110 set :assertEqualsRound.0:expected 45
   111 set :assertEqualsRound.0:actual 45
   112 set :assertEqualsRound.0:title "atan"
   113 label *label21
   114 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 :assertEqualsRound.0:actual 100000000
+  115 op mul *tmp4 45 100000000
   116 # "Function: inline def round(in x)"
-    * op add *tmp6 *tmp4 0.5
-    * op floor *tmp5 *tmp6
+  117 op add *tmp6 4500000000 0.5
+  118 op floor *tmp5 4500000000.5
   119 label *label22
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+  120 op div *tmp8 4500000000 100000000
+  121 assertequals 45 45 "atan"
   122 label *label23
   123 assertequals -8 -8 "unary minus"
   124 assertequals 1 true "boolean negation 1"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-42 instructions):
 
    42 assertequals 45 45 "angle"
    43 assertequals 90 90 "angleDiff"
    44 assertequals 5 5 "len"
-    * set :assertEqualsRound.0:expected 1
-    * set :assertEqualsRound.0:actual 1
-    * set :assertEqualsRound.0:title "sin"
    45 label *label6
    46 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 1 100000000
    47 # "Function: inline def round(in x)"
-    * op add *tmp6 100000000 0.5
-    * op floor *tmp5 100000000.5
    48 label *label7
-    * op div *tmp8 100000000 100000000
    49 assertequals 1 1 "sin"
    50 label *label8
-    * set :assertEqualsRound.0:expected -1
-    * set :assertEqualsRound.0:actual -1
-    * set :assertEqualsRound.0:title "cos"
    51 label *label9
    52 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 -1 100000000
    53 # "Function: inline def round(in x)"
-    * op add *tmp6 -100000000 0.5
-    * op floor *tmp5 -99999999.5
    54 label *label10
-    * op div *tmp8 -100000000 100000000
    55 assertequals -1 -1 "cos"
    56 label *label11
-    * set :assertEqualsRound.0:expected 1
-    * set :assertEqualsRound.0:actual 0.9999999999999999
-    * set :assertEqualsRound.0:title "tan"
    57 label *label12
    58 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 0.9999999999999999 100000000
    59 # "Function: inline def round(in x)"
-    * op add *tmp6 99999999.99999999 0.5
-    * op floor *tmp5 100000000.49999999
    60 label *label13
-    * op div *tmp8 100000000 100000000
    61 assertequals 1 1 "tan"
    62 label *label14
-    * set :assertEqualsRound.0:expected 90
-    * set :assertEqualsRound.0:actual 90
-    * set :assertEqualsRound.0:title "asin"
    63 label *label15
    64 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 90 100000000
    65 # "Function: inline def round(in x)"
-    * op add *tmp6 9000000000 0.5
-    * op floor *tmp5 9000000000.5
    66 label *label16
-    * op div *tmp8 9000000000 100000000
    67 assertequals 90 90 "asin"
    68 label *label17
-    * set :assertEqualsRound.0:expected 0
-    * set :assertEqualsRound.0:actual 0
-    * set :assertEqualsRound.0:title "acos"
    69 label *label18
    70 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 0 100000000
    71 # "Function: inline def round(in x)"
-    * op add *tmp6 0 0.5
-    * op floor *tmp5 0.5
    72 label *label19
-    * op div *tmp8 0 100000000
    73 assertequals 0 0 "acos"
    74 label *label20
-    * set :assertEqualsRound.0:expected 45
-    * set :assertEqualsRound.0:actual 45
-    * set :assertEqualsRound.0:title "atan"
    75 label *label21
    76 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp4 45 100000000
    77 # "Function: inline def round(in x)"
-    * op add *tmp6 4500000000 0.5
-    * op floor *tmp5 4500000000.5
    78 label *label22
-    * op div *tmp8 4500000000 100000000
    79 assertequals 45 45 "atan"
    80 label *label23
    81 assertequals -8 -8 "unary minus"

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
    98 assertequals true true "&&="
    99 assertequals true true "||="
   100 stop
-    * end

Final code before resolving virtual instructions:

assertequals 5 5 "add"
assertequals 1 1 "sub"
assertequals 6 6 "mul"
assertequals 1.5 1.5 "div"
assertequals 0.00001 0.00001 "div exp"
assertequals 1 1 "idiv"
assertequals 2 2 "mod"
assertequals 16 16 "pow"
assertequals true true "equal 1"
assertequals false false "equal 2"
assertequals true true "equal null"
assertequals false false "notEqual 1"
assertequals true true "notEqual 2"
assertequals false false "notEqual null"
assertequals false false "land 1"
assertequals true true "land 2"
assertequals true true "lessThan 1"
assertequals false false "lessThan 2"
assertequals true true "lessThanEq 1"
assertequals false false "lessThanEq 2"
assertequals true true "greaterThan 1"
assertequals false false "greaterThan 2"
assertequals true true "greaterThanEq 1"
assertequals false false "greaterThanEq 2"
assertequals false false "strictEqual 1"
assertequals true true "strictEqual 2"
assertequals 4 4 "shl"
assertequals 2 2 "shr"
assertequals 3 3 "or"
assertequals 2 2 "and"
assertequals 1 1 "xor"
assertequals -1 -1 "not 1"
assertequals -65536 -65536 "not 2"
assertequals -188900977659376 -188900977659376 "not 3"
assertequals 4 4 "max"
assertequals 2 2 "min"
assertequals 2 2 "abs"
assertequals 1 1 "log"
assertequals 1 1 "log10"
assertequals 2 2 "floor"
assertequals 3 3 "ceil"
assertequals 4 4 "sqrt"
assertequals 45 45 "angle"
assertequals 90 90 "angleDiff"
assertequals 5 5 "len"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 1 1 "sin"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals -1 -1 "cos"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 1 1 "tan"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 90 90 "asin"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 0 0 "acos"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 45 45 "atan"
assertequals -8 -8 "unary minus"
assertequals 1 true "boolean negation 1"
assertequals 0 false "boolean negation 2"
assertequals 0 false "boolean negation 3"
assertequals 16 16 "**="
assertequals 8 8 "*="
assertequals 1.5 1.5 "/="
assertequals 1 1 "\="
assertequals 2 2 "%="
assertequals 6 6 "+="
assertequals 2 2 "-="
assertequals 4 4 "<<="
assertequals 2 2 ">>="
assertequals 3 3 "|="
assertequals 2 2 "&="
assertequals 1 1 "^="
assertequals false false "&&="
assertequals true true "&&="
assertequals true true "||="
stop
