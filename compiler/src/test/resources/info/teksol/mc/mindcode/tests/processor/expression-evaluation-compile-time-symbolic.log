   145 instructions before optimizations.
     1 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Single Step Elimination (5 iterations).
     3 instructions modified by Expression Optimization (2 iterations).
    79 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
    11 instructions added by Function Inlining (3 iterations).
     6 function calls inlined by Function Inlining.
    75 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 893):
  * Inline function 'assertEqualsRound' defined at line 3:1      size   +19, benefit       27.0, efficiency      1.421 (-31 instructions)
    Inline function call at line 74:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 75:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 76:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 78:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 79:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 80:1                            size    +4, benefit        4.5, efficiency      1.125

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-1 instructions):
 
   133 # "Function: inline def round(in x)"
   134 set :round:x *tmp5
   135 op add *tmp7 :round:x 0.5
-    * op floor *tmp8 *tmp7
-    * set *tmp6 *tmp8
+  136 op floor *tmp6 *tmp7
   137 label *label5
   138 op div *tmp9 *tmp6 100000000
   139 assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
 
   114 op xor :a :a 2
   115 assertequals 1 :a "^="
   116 set :a 1
-    * op land :a :a 0
+  117 set :a false
   118 assertequals false :a "&&="
   119 set :a 1
   120 op land :a :a 2
   121 assertequals true :a "&&="
   122 set :a 0
-    * op or *tmp3 :a 2
+  123 set *tmp3 true
   124 op notEqual :a *tmp3 false
   125 assertequals true :a "||="
-    * sensor *tmp4 @copper-wall @id
+  126 set *tmp4 17
   127 assertequals 17 *tmp4 "Logic ID"
   128 stop
   129 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
    31 assertequals -1 -1 "not 1"
    32 assertequals -65536 -65536 "not 2"
    33 set :a 0xabcdefabcdef
-    * op add *tmp0 :a 1
-    * op sub *tmp1 0 *tmp0
-    * op not *tmp2 :a
-    * assertequals *tmp1 *tmp2 "not 3"
+   34 op add *tmp0 0xabcdefabcdef 1
+   35 op sub *tmp1 0 188900977659376
+   36 op not *tmp2 0xabcdefabcdef
+   37 assertequals -188900977659376 -188900977659376 "not 3"
    38 assertequals 4 4 "max"
    39 assertequals 2 2 "min"
    40 assertequals 2 2 "abs"
 
    78 assertequals 0 false "boolean negation 2"
    79 assertequals 0 false "boolean negation 3"
    80 set :a 2
-    * op pow :a :a 4
-    * assertequals 16 :a "**="
+   81 op pow :a 2 4
+   82 assertequals 16 16 "**="
    83 set :a 2
-    * op mul :a :a 4
-    * assertequals 8 :a "*="
+   84 op mul :a 2 4
+   85 assertequals 8 8 "*="
    86 set :a 6
-    * op div :a :a 4
-    * assertequals 1.5 :a "/="
+   87 op div :a 6 4
+   88 assertequals 1.5 1.5 "/="
    89 set :a 6
-    * op idiv :a :a 4
-    * assertequals 1 :a "\="
+   90 op idiv :a 6 4
+   91 assertequals 1 1 "\="
    92 set :a 6
-    * op mod :a :a 4
-    * assertequals 2 :a "%="
+   93 op mod :a 6 4
+   94 assertequals 2 2 "%="
    95 set :a 4
-    * op add :a :a 2
-    * assertequals 6 :a "+="
+   96 op add :a 4 2
+   97 assertequals 6 6 "+="
    98 set :a 4
-    * op sub :a :a 2
-    * assertequals 2 :a "-="
+   99 op sub :a 4 2
+  100 assertequals 2 2 "-="
   101 set :a 1
-    * op shl :a :a 2
-    * assertequals 4 :a "<<="
+  102 op shl :a 1 2
+  103 assertequals 4 4 "<<="
   104 set :a 9
-    * op shr :a :a 2
-    * assertequals 2 :a ">>="
+  105 op shr :a 9 2
+  106 assertequals 2 2 ">>="
   107 set :a 1
-    * op or :a :a 2
-    * assertequals 3 :a "|="
+  108 op or :a 1 2
+  109 assertequals 3 3 "|="
   110 set :a 3
-    * op and :a :a 2
-    * assertequals 2 :a "&="
+  111 op and :a 3 2
+  112 assertequals 2 2 "&="
   113 set :a 3
-    * op xor :a :a 2
-    * assertequals 1 :a "^="
-    * set :a 1
+  114 op xor :a 3 2
+  115 assertequals 1 1 "^="
   116 set :a false
-    * assertequals false :a "&&="
+  117 assertequals false false "&&="
   118 set :a 1
-    * op land :a :a 2
-    * assertequals true :a "&&="
-    * set :a 0
+  119 op land :a 1 2
+  120 assertequals true true "&&="
   121 set *tmp3 true
-    * op notEqual :a *tmp3 false
-    * assertequals true :a "||="
+  122 op notEqual :a true false
+  123 assertequals true true "||="
   124 set *tmp4 17
-    * assertequals 17 *tmp4 "Logic ID"
+  125 assertequals 17 17 "Logic ID"
   126 stop
   127 end
   128 label *label3
 
   130 op mul *tmp5 :assertEqualsRound:actual 100000000
   131 # "Function: inline def round(in x)"
   132 set :round:x *tmp5
-    * op add *tmp7 :round:x 0.5
+  133 op add *tmp7 *tmp5 0.5
   134 op floor *tmp6 *tmp7
   135 label *label5
   136 op div *tmp9 *tmp6 100000000

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-35 instructions):
 
    30 assertequals 1 1 "xor"
    31 assertequals -1 -1 "not 1"
    32 assertequals -65536 -65536 "not 2"
-    * set :a 0xabcdefabcdef
-    * op add *tmp0 0xabcdefabcdef 1
-    * op sub *tmp1 0 188900977659376
-    * op not *tmp2 0xabcdefabcdef
    33 assertequals -188900977659376 -188900977659376 "not 3"
    34 assertequals 4 4 "max"
    35 assertequals 2 2 "min"
 
    73 assertequals 1 true "boolean negation 1"
    74 assertequals 0 false "boolean negation 2"
    75 assertequals 0 false "boolean negation 3"
-    * set :a 2
-    * op pow :a 2 4
    76 assertequals 16 16 "**="
-    * set :a 2
-    * op mul :a 2 4
    77 assertequals 8 8 "*="
-    * set :a 6
-    * op div :a 6 4
    78 assertequals 1.5 1.5 "/="
-    * set :a 6
-    * op idiv :a 6 4
    79 assertequals 1 1 "\="
-    * set :a 6
-    * op mod :a 6 4
    80 assertequals 2 2 "%="
-    * set :a 4
-    * op add :a 4 2
    81 assertequals 6 6 "+="
-    * set :a 4
-    * op sub :a 4 2
    82 assertequals 2 2 "-="
-    * set :a 1
-    * op shl :a 1 2
    83 assertequals 4 4 "<<="
-    * set :a 9
-    * op shr :a 9 2
    84 assertequals 2 2 ">>="
-    * set :a 1
-    * op or :a 1 2
    85 assertequals 3 3 "|="
-    * set :a 3
-    * op and :a 3 2
    86 assertequals 2 2 "&="
-    * set :a 3
-    * op xor :a 3 2
    87 assertequals 1 1 "^="
-    * set :a false
    88 assertequals false false "&&="
-    * set :a 1
-    * op land :a 1 2
    89 assertequals true true "&&="
-    * set *tmp3 true
-    * op notEqual :a true false
    90 assertequals true true "||="
-    * set *tmp4 17
    91 assertequals 17 17 "Logic ID"
    92 stop
    93 end
 
    95 # "Function: void assertEqualsRound(in expected, in actual, in title)"
    96 op mul *tmp5 :assertEqualsRound:actual 100000000
    97 # "Function: inline def round(in x)"
-    * set :round:x *tmp5
    98 op add *tmp7 *tmp5 0.5
    99 op floor *tmp6 *tmp7
   100 label *label5

Modifications by Inline function 'assertEqualsRound' defined at line 3:1 (+11 instructions):
 
    48 set :assertEqualsRound:expected 1
    49 set :assertEqualsRound:actual 1
    50 set :assertEqualsRound:title "sin"
-    * call *label3 :assertEqualsRound*retaddr :assertEqualsRound*retval
+   51 label *label6
+   52 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+   53 op mul *tmp5 :assertEqualsRound:actual 100000000
+   54 # "Function: inline def round(in x)"
+   55 op add *tmp7 *tmp5 0.5
+   56 op floor *tmp6 *tmp7
+   57 label *label7
+   58 op div *tmp9 *tmp6 100000000
+   59 assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+   60 label *label8
    61 set :assertEqualsRound:expected -1
    62 set :assertEqualsRound:actual -1
    63 set :assertEqualsRound:title "cos"
-    * call *label3 :assertEqualsRound*retaddr :assertEqualsRound*retval
+   64 label *label9
+   65 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+   66 op mul *tmp5 :assertEqualsRound:actual 100000000
+   67 # "Function: inline def round(in x)"
+   68 op add *tmp7 *tmp5 0.5
+   69 op floor *tmp6 *tmp7
+   70 label *label10
+   71 op div *tmp9 *tmp6 100000000
+   72 assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+   73 label *label11
    74 set :assertEqualsRound:expected 1
    75 set :assertEqualsRound:actual 0.9999999999999999
    76 set :assertEqualsRound:title "tan"
-    * call *label3 :assertEqualsRound*retaddr :assertEqualsRound*retval
+   77 label *label12
+   78 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+   79 op mul *tmp5 :assertEqualsRound:actual 100000000
+   80 # "Function: inline def round(in x)"
+   81 op add *tmp7 *tmp5 0.5
+   82 op floor *tmp6 *tmp7
+   83 label *label13
+   84 op div *tmp9 *tmp6 100000000
+   85 assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+   86 label *label14
    87 set :assertEqualsRound:expected 90
    88 set :assertEqualsRound:actual 90
    89 set :assertEqualsRound:title "asin"
-    * call *label3 :assertEqualsRound*retaddr :assertEqualsRound*retval
+   90 label *label15
+   91 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+   92 op mul *tmp5 :assertEqualsRound:actual 100000000
+   93 # "Function: inline def round(in x)"
+   94 op add *tmp7 *tmp5 0.5
+   95 op floor *tmp6 *tmp7
+   96 label *label16
+   97 op div *tmp9 *tmp6 100000000
+   98 assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+   99 label *label17
   100 set :assertEqualsRound:expected 0
   101 set :assertEqualsRound:actual 0
   102 set :assertEqualsRound:title "acos"
-    * call *label3 :assertEqualsRound*retaddr :assertEqualsRound*retval
+  103 label *label18
+  104 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+  105 op mul *tmp5 :assertEqualsRound:actual 100000000
+  106 # "Function: inline def round(in x)"
+  107 op add *tmp7 *tmp5 0.5
+  108 op floor *tmp6 *tmp7
+  109 label *label19
+  110 op div *tmp9 *tmp6 100000000
+  111 assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+  112 label *label20
   113 set :assertEqualsRound:expected 45
   114 set :assertEqualsRound:actual 45
   115 set :assertEqualsRound:title "atan"
-    * call *label3 :assertEqualsRound*retaddr :assertEqualsRound*retval
+  116 label *label21
+  117 # "Function: void assertEqualsRound(in expected, in actual, in title)"
+  118 op mul *tmp5 :assertEqualsRound:actual 100000000
+  119 # "Function: inline def round(in x)"
+  120 op add *tmp7 *tmp5 0.5
+  121 op floor *tmp6 *tmp7
+  122 label *label22
+  123 op div *tmp9 *tmp6 100000000
+  124 assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+  125 label *label23
   126 assertequals -8 -8 "unary minus"
   127 assertequals 1 true "boolean negation 1"
   128 assertequals 0 false "boolean negation 2"
 
   145 assertequals 17 17 "Logic ID"
   146 stop
   147 end
-    * label *label3
-    * # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 :assertEqualsRound:actual 100000000
-    * # "Function: inline def round(in x)"
-    * op add *tmp7 *tmp5 0.5
-    * op floor *tmp6 *tmp7
-    * label *label5
-    * op div *tmp9 *tmp6 100000000
-    * assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
-    * label *label4
-    * return :assertEqualsRound*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    50 set :assertEqualsRound:title "sin"
    51 label *label6
    52 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 :assertEqualsRound:actual 100000000
+   53 op mul *tmp5 1 100000000
    54 # "Function: inline def round(in x)"
-    * op add *tmp7 *tmp5 0.5
-    * op floor *tmp6 *tmp7
+   55 op add *tmp7 100000000 0.5
+   56 op floor *tmp6 100000000.5
    57 label *label7
-    * op div *tmp9 *tmp6 100000000
-    * assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+   58 op div *tmp9 100000000 100000000
+   59 assertequals 1 1 "sin"
    60 label *label8
    61 set :assertEqualsRound:expected -1
    62 set :assertEqualsRound:actual -1
    63 set :assertEqualsRound:title "cos"
    64 label *label9
    65 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 :assertEqualsRound:actual 100000000
+   66 op mul *tmp5 -1 100000000
    67 # "Function: inline def round(in x)"
-    * op add *tmp7 *tmp5 0.5
-    * op floor *tmp6 *tmp7
+   68 op add *tmp7 -100000000 0.5
+   69 op floor *tmp6 -99999999.5
    70 label *label10
-    * op div *tmp9 *tmp6 100000000
-    * assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+   71 op div *tmp9 -100000000 100000000
+   72 assertequals -1 -1 "cos"
    73 label *label11
    74 set :assertEqualsRound:expected 1
    75 set :assertEqualsRound:actual 0.9999999999999999
    76 set :assertEqualsRound:title "tan"
    77 label *label12
    78 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 :assertEqualsRound:actual 100000000
+   79 op mul *tmp5 0.9999999999999999 100000000
    80 # "Function: inline def round(in x)"
-    * op add *tmp7 *tmp5 0.5
-    * op floor *tmp6 *tmp7
+   81 op add *tmp7 99999999.99999999 0.5
+   82 op floor *tmp6 100000000.49999999
    83 label *label13
-    * op div *tmp9 *tmp6 100000000
-    * assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+   84 op div *tmp9 100000000 100000000
+   85 assertequals 1 1 "tan"
    86 label *label14
    87 set :assertEqualsRound:expected 90
    88 set :assertEqualsRound:actual 90
    89 set :assertEqualsRound:title "asin"
    90 label *label15
    91 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 :assertEqualsRound:actual 100000000
+   92 op mul *tmp5 90 100000000
    93 # "Function: inline def round(in x)"
-    * op add *tmp7 *tmp5 0.5
-    * op floor *tmp6 *tmp7
+   94 op add *tmp7 9000000000 0.5
+   95 op floor *tmp6 9000000000.5
    96 label *label16
-    * op div *tmp9 *tmp6 100000000
-    * assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+   97 op div *tmp9 9000000000 100000000
+   98 assertequals 90 90 "asin"
    99 label *label17
   100 set :assertEqualsRound:expected 0
   101 set :assertEqualsRound:actual 0
   102 set :assertEqualsRound:title "acos"
   103 label *label18
   104 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 :assertEqualsRound:actual 100000000
+  105 op mul *tmp5 0 100000000
   106 # "Function: inline def round(in x)"
-    * op add *tmp7 *tmp5 0.5
-    * op floor *tmp6 *tmp7
+  107 op add *tmp7 0 0.5
+  108 op floor *tmp6 0.5
   109 label *label19
-    * op div *tmp9 *tmp6 100000000
-    * assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+  110 op div *tmp9 0 100000000
+  111 assertequals 0 0 "acos"
   112 label *label20
   113 set :assertEqualsRound:expected 45
   114 set :assertEqualsRound:actual 45
   115 set :assertEqualsRound:title "atan"
   116 label *label21
   117 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 :assertEqualsRound:actual 100000000
+  118 op mul *tmp5 45 100000000
   119 # "Function: inline def round(in x)"
-    * op add *tmp7 *tmp5 0.5
-    * op floor *tmp6 *tmp7
+  120 op add *tmp7 4500000000 0.5
+  121 op floor *tmp6 4500000000.5
   122 label *label22
-    * op div *tmp9 *tmp6 100000000
-    * assertequals :assertEqualsRound:expected *tmp9 :assertEqualsRound:title
+  123 op div *tmp9 4500000000 100000000
+  124 assertequals 45 45 "atan"
   125 label *label23
   126 assertequals -8 -8 "unary minus"
   127 assertequals 1 true "boolean negation 1"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-42 instructions):
 
    45 assertequals 45 45 "angle"
    46 assertequals 90 90 "angleDiff"
    47 assertequals 5 5 "len"
-    * set :assertEqualsRound:expected 1
-    * set :assertEqualsRound:actual 1
-    * set :assertEqualsRound:title "sin"
    48 label *label6
    49 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 1 100000000
    50 # "Function: inline def round(in x)"
-    * op add *tmp7 100000000 0.5
-    * op floor *tmp6 100000000.5
    51 label *label7
-    * op div *tmp9 100000000 100000000
    52 assertequals 1 1 "sin"
    53 label *label8
-    * set :assertEqualsRound:expected -1
-    * set :assertEqualsRound:actual -1
-    * set :assertEqualsRound:title "cos"
    54 label *label9
    55 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 -1 100000000
    56 # "Function: inline def round(in x)"
-    * op add *tmp7 -100000000 0.5
-    * op floor *tmp6 -99999999.5
    57 label *label10
-    * op div *tmp9 -100000000 100000000
    58 assertequals -1 -1 "cos"
    59 label *label11
-    * set :assertEqualsRound:expected 1
-    * set :assertEqualsRound:actual 0.9999999999999999
-    * set :assertEqualsRound:title "tan"
    60 label *label12
    61 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 0.9999999999999999 100000000
    62 # "Function: inline def round(in x)"
-    * op add *tmp7 99999999.99999999 0.5
-    * op floor *tmp6 100000000.49999999
    63 label *label13
-    * op div *tmp9 100000000 100000000
    64 assertequals 1 1 "tan"
    65 label *label14
-    * set :assertEqualsRound:expected 90
-    * set :assertEqualsRound:actual 90
-    * set :assertEqualsRound:title "asin"
    66 label *label15
    67 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 90 100000000
    68 # "Function: inline def round(in x)"
-    * op add *tmp7 9000000000 0.5
-    * op floor *tmp6 9000000000.5
    69 label *label16
-    * op div *tmp9 9000000000 100000000
    70 assertequals 90 90 "asin"
    71 label *label17
-    * set :assertEqualsRound:expected 0
-    * set :assertEqualsRound:actual 0
-    * set :assertEqualsRound:title "acos"
    72 label *label18
    73 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 0 100000000
    74 # "Function: inline def round(in x)"
-    * op add *tmp7 0 0.5
-    * op floor *tmp6 0.5
    75 label *label19
-    * op div *tmp9 0 100000000
    76 assertequals 0 0 "acos"
    77 label *label20
-    * set :assertEqualsRound:expected 45
-    * set :assertEqualsRound:actual 45
-    * set :assertEqualsRound:title "atan"
    78 label *label21
    79 # "Function: void assertEqualsRound(in expected, in actual, in title)"
-    * op mul *tmp5 45 100000000
    80 # "Function: inline def round(in x)"
-    * op add *tmp7 4500000000 0.5
-    * op floor *tmp6 4500000000.5
    81 label *label22
-    * op div *tmp9 4500000000 100000000
    82 assertequals 45 45 "atan"
    83 label *label23
    84 assertequals -8 -8 "unary minus"

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
    45 assertequals 45 45 "angle"
    46 assertequals 90 90 "angleDiff"
    47 assertequals 5 5 "len"
-    * label *label6
    48 # "Function: void assertEqualsRound(in expected, in actual, in title)"
    49 # "Function: inline def round(in x)"
-    * label *label7
    50 assertequals 1 1 "sin"
-    * label *label8
-    * label *label9
    51 # "Function: void assertEqualsRound(in expected, in actual, in title)"
    52 # "Function: inline def round(in x)"
-    * label *label10
    53 assertequals -1 -1 "cos"
-    * label *label11
-    * label *label12
    54 # "Function: void assertEqualsRound(in expected, in actual, in title)"
    55 # "Function: inline def round(in x)"
-    * label *label13
    56 assertequals 1 1 "tan"
-    * label *label14
-    * label *label15
    57 # "Function: void assertEqualsRound(in expected, in actual, in title)"
    58 # "Function: inline def round(in x)"
-    * label *label16
    59 assertequals 90 90 "asin"
-    * label *label17
-    * label *label18
    60 # "Function: void assertEqualsRound(in expected, in actual, in title)"
    61 # "Function: inline def round(in x)"
-    * label *label19
    62 assertequals 0 0 "acos"
-    * label *label20
-    * label *label21
    63 # "Function: void assertEqualsRound(in expected, in actual, in title)"
    64 # "Function: inline def round(in x)"
-    * label *label22
    65 assertequals 45 45 "atan"
-    * label *label23
    66 assertequals -8 -8 "unary minus"
    67 assertequals 1 true "boolean negation 1"
    68 assertequals 0 false "boolean negation 2"

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
    84 assertequals true true "||="
    85 assertequals 17 17 "Logic ID"
    86 stop
-    * end

Final code before resolving virtual instructions:

assertequals 5 5 "add"
assertequals 1 1 "sub"
assertequals 6 6 "mul"
assertequals 1.5 1.5 "div"
assertequals 0.00001 0.00001 "div exp"
assertequals 1 1 "idiv"
assertequals 2 2 "mod"
assertequals 16 16 "pow"
assertequals true true "equal 1"
assertequals false false "equal 2"
assertequals true true "equal null"
assertequals false false "notEqual 1"
assertequals true true "notEqual 2"
assertequals false false "notEqual null"
assertequals false false "land 1"
assertequals true true "land 2"
assertequals true true "lessThan 1"
assertequals false false "lessThan 2"
assertequals true true "lessThanEq 1"
assertequals false false "lessThanEq 2"
assertequals true true "greaterThan 1"
assertequals false false "greaterThan 2"
assertequals true true "greaterThanEq 1"
assertequals false false "greaterThanEq 2"
assertequals false false "strictEqual 1"
assertequals true true "strictEqual 2"
assertequals 4 4 "shl"
assertequals 2 2 "shr"
assertequals 3 3 "or"
assertequals 2 2 "and"
assertequals 1 1 "xor"
assertequals -1 -1 "not 1"
assertequals -65536 -65536 "not 2"
assertequals -188900977659376 -188900977659376 "not 3"
assertequals 4 4 "max"
assertequals 2 2 "min"
assertequals 2 2 "abs"
assertequals -1 -1 "sign(-2)"
assertequals 1 1 "sign(2)"
assertequals 0 0 "sign(0)"
assertequals 1 1 "log"
assertequals 1 1 "log10"
assertequals 2 2 "floor"
assertequals 3 3 "ceil"
assertequals 4 4 "sqrt"
assertequals 45 45 "angle"
assertequals 90 90 "angleDiff"
assertequals 5 5 "len"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 1 1 "sin"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals -1 -1 "cos"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 1 1 "tan"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 90 90 "asin"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 0 0 "acos"
# "Function: void assertEqualsRound(in expected, in actual, in title)"
# "Function: inline def round(in x)"
assertequals 45 45 "atan"
assertequals -8 -8 "unary minus"
assertequals 1 true "boolean negation 1"
assertequals 0 false "boolean negation 2"
assertequals 0 false "boolean negation 3"
assertequals 16 16 "**="
assertequals 8 8 "*="
assertequals 1.5 1.5 "/="
assertequals 1 1 "\="
assertequals 2 2 "%="
assertequals 6 6 "+="
assertequals 2 2 "-="
assertequals 4 4 "<<="
assertequals 2 2 ">>="
assertequals 3 3 "|="
assertequals 2 2 "&="
assertequals 1 1 "^="
assertequals false false "&&="
assertequals true true "&&="
assertequals true true "||="
assertequals 17 17 "Logic ID"
stop
