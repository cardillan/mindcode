    45 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (6 iterations).
     2 instructions eliminated by Condition Optimization (6 iterations).
     2 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Expression Optimization (3 iterations).
     1 instructions eliminated by If Expression Optimization (3 iterations).
     7 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     2 loops improved by Loop Optimization.
    26 instructions after optimizations.

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
    12 set :testAndSwap:i :i
    13 set :testAndSwap:j *tmp1
    14 set :testAndSwap:sorted :sorted
-    * set *tmp3 :testAndSwap:i
-    * read *tmp4 ARRAY *tmp3
-    * set :testAndSwap:a *tmp4
-    * set *tmp5 :testAndSwap:j
-    * read *tmp6 ARRAY *tmp5
-    * set :testAndSwap:b *tmp6
+   15 read :testAndSwap:a ARRAY :testAndSwap:i
+   16 read :testAndSwap:b ARRAY :testAndSwap:j
    17 op greaterThan *tmp7 :testAndSwap:a :testAndSwap:b
    18 jump *label7 equal *tmp7 false
-    * set *tmp9 :testAndSwap:i
-    * write :testAndSwap:b ARRAY *tmp9
-    * set *tmp11 :testAndSwap:j
-    * write :testAndSwap:a ARRAY *tmp11
+   19 write :testAndSwap:b ARRAY :testAndSwap:i
+   20 write :testAndSwap:a ARRAY :testAndSwap:j
    21 set *tmp8 false
    22 jump *label8 always
    23 label *label7

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-2 instructions):
 
    14 set :testAndSwap:sorted :sorted
    15 read :testAndSwap:a ARRAY :testAndSwap:i
    16 read :testAndSwap:b ARRAY :testAndSwap:j
-    * op greaterThan *tmp7 :testAndSwap:a :testAndSwap:b
-    * jump *label7 equal *tmp7 false
+   17 jump *label7 lessThanEq :testAndSwap:a :testAndSwap:b
    18 write :testAndSwap:b ARRAY :testAndSwap:i
    19 write :testAndSwap:a ARRAY :testAndSwap:j
    20 set *tmp8 false
 
    30 jump *label3 always
    31 label *label5
    32 label *label1
-    * op equal *tmp13 :sorted false
-    * jump *label0 notEqual *tmp13 false
+   33 jump *label0 equal :sorted false
    34 label *label2
    35 set :i 0
    36 label *label9

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     7 set *tmp0 :n
     8 set :i 0
     9 label *label3
-    * jump *label5 greaterThanEq :i *tmp0
+   10 jump *label5 greaterThanEq :i :n
    11 op add *tmp1 :i 1
    12 set :testAndSwap:i :i
    13 set :testAndSwap:j *tmp1
    14 set :testAndSwap:sorted :sorted
-    * read :testAndSwap:a ARRAY :testAndSwap:i
-    * read :testAndSwap:b ARRAY :testAndSwap:j
+   15 read :testAndSwap:a ARRAY :i
+   16 read :testAndSwap:b ARRAY *tmp1
    17 jump *label7 lessThanEq :testAndSwap:a :testAndSwap:b
-    * write :testAndSwap:b ARRAY :testAndSwap:i
-    * write :testAndSwap:a ARRAY :testAndSwap:j
+   18 write :testAndSwap:b ARRAY :i
+   19 write :testAndSwap:a ARRAY *tmp1
    20 set *tmp8 false
    21 jump *label8 always
    22 label *label7
-    * set *tmp8 :testAndSwap:sorted
+   23 set *tmp8 :sorted
    24 label *label8
    25 set *tmp2 *tmp8
    26 label *label6
-    * set :sorted *tmp2
+   27 set :sorted *tmp8
    28 label *label4
    29 op add :i :i 1
    30 jump *label3 always
 
    37 jump *label11 greaterThanEq :i SIZE
    38 set *tmp14 :i
    39 set *tmp16 :i
-    * read *tmp15 FINAL *tmp14
-    * read *tmp17 ARRAY *tmp16
+   40 read *tmp15 FINAL :i
+   41 read *tmp17 ARRAY :i
    42 assertequals *tmp15 *tmp17 "unexpected value"
    43 label *label10
    44 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
     4 label *label0
     5 op sub :n :n 1
     6 set :sorted true
-    * set *tmp0 :n
     7 set :i 0
     8 label *label3
     9 jump *label5 greaterThanEq :i :n
    10 op add *tmp1 :i 1
-    * set :testAndSwap:i :i
-    * set :testAndSwap:j *tmp1
-    * set :testAndSwap:sorted :sorted
    11 read :testAndSwap:a ARRAY :i
    12 read :testAndSwap:b ARRAY *tmp1
    13 jump *label7 lessThanEq :testAndSwap:a :testAndSwap:b
 
    18 label *label7
    19 set *tmp8 :sorted
    20 label *label8
-    * set *tmp2 *tmp8
    21 label *label6
    22 set :sorted *tmp8
    23 label *label4
 
    30 set :i 0
    31 label *label9
    32 jump *label11 greaterThanEq :i SIZE
-    * set *tmp14 :i
-    * set *tmp16 :i
    33 read *tmp15 FINAL :i
    34 read *tmp17 ARRAY :i
    35 assertequals *tmp15 *tmp17 "unexpected value"

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     7 set :i 0
     8 label *label3
     9 jump *label5 greaterThanEq :i :n
+   10 label *label12
    11 op add *tmp1 :i 1
    12 read :testAndSwap:a ARRAY :i
    13 read :testAndSwap:b ARRAY *tmp1
 
    23 set :sorted *tmp8
    24 label *label4
    25 op add :i :i 1
-    * jump *label3 always
+   26 jump *label12 lessThan :i :n
    27 label *label5
    28 label *label1
    29 jump *label0 equal :sorted false
 
    31 set :i 0
    32 label *label9
    33 jump *label11 greaterThanEq :i SIZE
+   34 label *label13
    35 read *tmp15 FINAL :i
    36 read *tmp17 ARRAY :i
    37 assertequals *tmp15 *tmp17 "unexpected value"
    38 label *label10
    39 op add :i :i 1
-    * jump *label9 always
+   40 jump *label13 lessThan :i SIZE
    41 label *label11
    42 stop
    43 end

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
     9 jump *label5 greaterThanEq :i :n
    10 label *label12
    11 op add *tmp1 :i 1
+   12 set :sorted :sorted
    13 read :testAndSwap:a ARRAY :i
    14 read :testAndSwap:b ARRAY *tmp1
-    * jump *label7 lessThanEq :testAndSwap:a :testAndSwap:b
+   15 jump *label8 lessThanEq :testAndSwap:a :testAndSwap:b
    16 write :testAndSwap:b ARRAY :i
    17 write :testAndSwap:a ARRAY *tmp1
-    * set *tmp8 false
+   18 set :sorted false
    19 jump *label8 always
-    * label *label7
-    * set *tmp8 :sorted
    20 label *label8
    21 label *label6
-    * set :sorted *tmp8
    22 label *label4
    23 op add :i :i 1
    24 jump *label12 lessThan :i :n

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    16 write :testAndSwap:b ARRAY :i
    17 write :testAndSwap:a ARRAY *tmp1
    18 set :sorted false
-    * jump *label8 always
    19 label *label8
    20 label *label6
    21 label *label4

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-1 instructions):
 
     9 jump *label5 greaterThanEq :i :n
    10 label *label12
    11 op add *tmp1 :i 1
-    * set :sorted :sorted
    12 read :testAndSwap:a ARRAY :i
    13 read :testAndSwap:b ARRAY *tmp1
    14 jump *label8 lessThanEq :testAndSwap:a :testAndSwap:b

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
     6 set :sorted true
     7 set :i 0
     8 label *label3
-    * jump *label5 greaterThanEq :i :n
+    9 jump *label5 greaterThanEq 0 :n
    10 label *label12
    11 op add *tmp1 :i 1
    12 read :testAndSwap:a ARRAY :i
 
    26 label *label2
    27 set :i 0
    28 label *label9
-    * jump *label11 greaterThanEq :i SIZE
+   29 jump *label11 greaterThanEq 0 SIZE
    30 label *label13
    31 read *tmp15 FINAL :i
    32 read *tmp17 ARRAY :i

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
    29 jump *label13 lessThan :i SIZE
    30 label *label11
    31 stop
-    * end

Final code before resolving virtual instructions:

set SIZE 64
set ARRAY bank2
set FINAL bank3
set :n SIZE
label *label0
op sub :n :n 1
set :sorted true
set :i 0
jump *label5 greaterThanEq 0 :n
label *label12
op add *tmp1 :i 1
read :testAndSwap:a ARRAY :i
read :testAndSwap:b ARRAY *tmp1
jump *label8 lessThanEq :testAndSwap:a :testAndSwap:b
write :testAndSwap:b ARRAY :i
write :testAndSwap:a ARRAY *tmp1
set :sorted false
label *label8
op add :i :i 1
jump *label12 lessThan :i :n
label *label5
jump *label0 equal :sorted false
set :i 0
jump *label11 greaterThanEq 0 SIZE
label *label13
read *tmp15 FINAL :i
read *tmp17 ARRAY :i
assertequals *tmp15 *tmp17 "unexpected value"
op add :i :i 1
jump *label13 lessThan :i SIZE
label *label11
stop
