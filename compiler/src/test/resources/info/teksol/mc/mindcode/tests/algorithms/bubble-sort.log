    46 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination.
     2 instructions eliminated by Jump Optimization (5 iterations).
     2 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Expression Optimization (3 iterations).
     1 instructions eliminated by If Expression Optimization (3 iterations).
     7 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     2 instructions modified by Loop Optimization (3 iterations).
     2 loops improved by Loop Optimization.
    27 instructions after optimizations.

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
    14 set :testAndSwap.0:i :i
    15 set :testAndSwap.0:j *tmp1
    16 set :testAndSwap.0:sorted :sorted
-    * set *tmp3 :testAndSwap.0:i
-    * read *tmp4 ARRAY *tmp3
-    * set :testAndSwap.0:a *tmp4
-    * set *tmp5 :testAndSwap.0:j
-    * read *tmp6 ARRAY *tmp5
-    * set :testAndSwap.0:b *tmp6
+   17 read :testAndSwap.0:a ARRAY :testAndSwap.0:i
+   18 read :testAndSwap.0:b ARRAY :testAndSwap.0:j
    19 op greaterThan *tmp7 :testAndSwap.0:a :testAndSwap.0:b
    20 jump *label8 equal *tmp7 false
-    * set *tmp9 :testAndSwap.0:i
-    * write :testAndSwap.0:b ARRAY *tmp9
-    * set *tmp11 :testAndSwap.0:j
-    * write :testAndSwap.0:a ARRAY *tmp11
+   21 write :testAndSwap.0:b ARRAY :testAndSwap.0:i
+   22 write :testAndSwap.0:a ARRAY :testAndSwap.0:j
    23 set *tmp8 false
    24 jump *label9 always
    25 label *label8

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-2 instructions):
 
    16 set :testAndSwap.0:sorted :sorted
    17 read :testAndSwap.0:a ARRAY :testAndSwap.0:i
    18 read :testAndSwap.0:b ARRAY :testAndSwap.0:j
-    * op greaterThan *tmp7 :testAndSwap.0:a :testAndSwap.0:b
-    * jump *label8 equal *tmp7 false
+   19 jump *label8 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
    20 write :testAndSwap.0:b ARRAY :testAndSwap.0:i
    21 write :testAndSwap.0:a ARRAY :testAndSwap.0:j
    22 set *tmp8 false
 
    32 jump *label4 always
    33 label *label6
    34 label *label2
-    * op equal *tmp13 :sorted false
-    * jump *label1 notEqual *tmp13 false
+   35 jump *label1 equal :sorted false
    36 label *label3
    37 set :i 0
    38 label *label10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     9 set *tmp0 :n
    10 set :i 0
    11 label *label4
-    * jump *label6 greaterThanEq :i *tmp0
+   12 jump *label6 greaterThanEq :i :n
    13 op add *tmp1 :i 1
    14 set :testAndSwap.0:i :i
    15 set :testAndSwap.0:j *tmp1
    16 set :testAndSwap.0:sorted :sorted
-    * read :testAndSwap.0:a ARRAY :testAndSwap.0:i
-    * read :testAndSwap.0:b ARRAY :testAndSwap.0:j
+   17 read :testAndSwap.0:a ARRAY :i
+   18 read :testAndSwap.0:b ARRAY *tmp1
    19 jump *label8 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
-    * write :testAndSwap.0:b ARRAY :testAndSwap.0:i
-    * write :testAndSwap.0:a ARRAY :testAndSwap.0:j
+   20 write :testAndSwap.0:b ARRAY :i
+   21 write :testAndSwap.0:a ARRAY *tmp1
    22 set *tmp8 false
    23 jump *label9 always
    24 label *label8
-    * set *tmp8 :testAndSwap.0:sorted
+   25 set *tmp8 :sorted
    26 label *label9
    27 set *tmp2 *tmp8
    28 label *label7
-    * set :sorted *tmp2
+   29 set :sorted *tmp8
    30 label *label5
    31 op add :i :i 1
    32 jump *label4 always
 
    39 jump *label12 greaterThanEq :i SIZE
    40 set *tmp14 :i
    41 set *tmp16 :i
-    * read *tmp15 FINAL *tmp14
-    * read *tmp17 ARRAY *tmp16
+   42 read *tmp15 FINAL :i
+   43 read *tmp17 ARRAY :i
    44 assertequals *tmp15 *tmp17 "unexpected value"
    45 label *label11
    46 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
     6 label *label1
     7 op sub :n :n 1
     8 set :sorted true
-    * set *tmp0 :n
     9 set :i 0
    10 label *label4
    11 jump *label6 greaterThanEq :i :n
    12 op add *tmp1 :i 1
-    * set :testAndSwap.0:i :i
-    * set :testAndSwap.0:j *tmp1
-    * set :testAndSwap.0:sorted :sorted
    13 read :testAndSwap.0:a ARRAY :i
    14 read :testAndSwap.0:b ARRAY *tmp1
    15 jump *label8 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
 
    20 label *label8
    21 set *tmp8 :sorted
    22 label *label9
-    * set *tmp2 *tmp8
    23 label *label7
    24 set :sorted *tmp8
    25 label *label5
 
    32 set :i 0
    33 label *label10
    34 jump *label12 greaterThanEq :i SIZE
-    * set *tmp14 :i
-    * set *tmp16 :i
    35 read *tmp15 FINAL :i
    36 read *tmp17 ARRAY :i
    37 assertequals *tmp15 *tmp17 "unexpected value"

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     9 set :i 0
    10 label *label4
    11 jump *label6 greaterThanEq :i :n
+   12 label *label13
    13 op add *tmp1 :i 1
    14 read :testAndSwap.0:a ARRAY :i
    15 read :testAndSwap.0:b ARRAY *tmp1
 
    25 set :sorted *tmp8
    26 label *label5
    27 op add :i :i 1
-    * jump *label4 always
+   28 jump *label13 lessThan :i :n
    29 label *label6
    30 label *label2
    31 jump *label1 equal :sorted false
 
    33 set :i 0
    34 label *label10
    35 jump *label12 greaterThanEq :i SIZE
+   36 label *label14
    37 read *tmp15 FINAL :i
    38 read *tmp17 ARRAY :i
    39 assertequals *tmp15 *tmp17 "unexpected value"
    40 label *label11
    41 op add :i :i 1
-    * jump *label10 always
+   42 jump *label14 lessThan :i SIZE
    43 label *label12
    44 stop
    45 end

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    11 jump *label6 greaterThanEq :i :n
    12 label *label13
    13 op add *tmp1 :i 1
+   14 set :sorted :sorted
    15 read :testAndSwap.0:a ARRAY :i
    16 read :testAndSwap.0:b ARRAY *tmp1
-    * jump *label8 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
+   17 jump *label9 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
    18 write :testAndSwap.0:b ARRAY :i
    19 write :testAndSwap.0:a ARRAY *tmp1
-    * set *tmp8 false
+   20 set :sorted false
    21 jump *label9 always
-    * label *label8
-    * set *tmp8 :sorted
    22 label *label9
    23 label *label7
-    * set :sorted *tmp8
    24 label *label5
    25 op add :i :i 1
    26 jump *label13 lessThan :i :n

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    18 write :testAndSwap.0:b ARRAY :i
    19 write :testAndSwap.0:a ARRAY *tmp1
    20 set :sorted false
-    * jump *label9 always
    21 label *label9
    22 label *label7
    23 label *label5

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-1 instructions):
 
    11 jump *label6 greaterThanEq :i :n
    12 label *label13
    13 op add *tmp1 :i 1
-    * set :sorted :sorted
    14 read :testAndSwap.0:a ARRAY :i
    15 read :testAndSwap.0:b ARRAY *tmp1
    16 jump *label9 lessThanEq :testAndSwap.0:a :testAndSwap.0:b

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
     8 set :sorted true
     9 set :i 0
    10 label *label4
-    * jump *label6 greaterThanEq :i :n
+   11 jump *label6 greaterThanEq 0 :n
    12 label *label13
    13 op add *tmp1 :i 1
    14 read :testAndSwap.0:a ARRAY :i
 
    28 label *label3
    29 set :i 0
    30 label *label10
-    * jump *label12 greaterThanEq :i SIZE
+   31 jump *label12 greaterThanEq 0 SIZE
    32 label *label14
    33 read *tmp15 FINAL :i
    34 read *tmp17 ARRAY :i

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     7 op sub :n :n 1
     8 set :sorted true
     9 set :i 0
-    * label *label4
    10 jump *label6 greaterThanEq 0 :n
    11 label *label13
    12 op add *tmp1 :i 1
 
    17 write :testAndSwap.0:a ARRAY *tmp1
    18 set :sorted false
    19 label *label9
-    * label *label7
-    * label *label5
    20 op add :i :i 1
    21 jump *label13 lessThan :i :n
    22 label *label6
-    * label *label2
    23 jump *label1 equal :sorted false
-    * label *label3
    24 set :i 0
-    * label *label10
    25 jump *label12 greaterThanEq 0 SIZE
    26 label *label14
    27 read *tmp15 FINAL :i
    28 read *tmp17 ARRAY :i
    29 assertequals *tmp15 *tmp17 "unexpected value"
-    * label *label11
    30 op add :i :i 1
    31 jump *label14 lessThan :i SIZE
    32 label *label12

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
    31 jump *label14 lessThan :i SIZE
    32 label *label12
    33 stop
-    * end

Final code before resolving virtual instructions:

set SIZE 64
label *label0
jump *label0 equal bank1 null
set ARRAY bank2
set FINAL bank3
set :n SIZE
label *label1
op sub :n :n 1
set :sorted true
set :i 0
jump *label6 greaterThanEq 0 :n
label *label13
op add *tmp1 :i 1
read :testAndSwap.0:a ARRAY :i
read :testAndSwap.0:b ARRAY *tmp1
jump *label9 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
write :testAndSwap.0:b ARRAY :i
write :testAndSwap.0:a ARRAY *tmp1
set :sorted false
label *label9
op add :i :i 1
jump *label13 lessThan :i :n
label *label6
jump *label1 equal :sorted false
set :i 0
jump *label12 greaterThanEq 0 SIZE
label *label14
read *tmp15 FINAL :i
read *tmp17 ARRAY :i
assertequals *tmp15 *tmp17 "unexpected value"
op add :i :i 1
jump *label14 lessThan :i SIZE
label *label12
stop
