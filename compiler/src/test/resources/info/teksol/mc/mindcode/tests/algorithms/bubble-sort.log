    46 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
     2 instructions eliminated by Jump Optimization (4 iterations).
     2 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     1 instructions eliminated by Expression Optimization (3 iterations).
     1 instructions eliminated by If Expression Optimization (3 iterations).
    11 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     2 instructions modified by Loop Optimization (3 iterations).
     2 loops improved by Loop Optimization.
    27 instructions after optimizations.

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
    15 set :testAndSwap.0:j *tmp1
    16 set :testAndSwap.0:sorted :sorted
    17 set *tmp3 :testAndSwap.0:i
-    * read *tmp4 ARRAY *tmp3
-    * set :testAndSwap.0:a *tmp4
+   18 read :testAndSwap.0:a ARRAY *tmp3
    19 set *tmp5 :testAndSwap.0:j
-    * read *tmp6 ARRAY *tmp5
-    * set :testAndSwap.0:b *tmp6
+   20 read :testAndSwap.0:b ARRAY *tmp5
    21 op greaterThan *tmp7 :testAndSwap.0:a :testAndSwap.0:b
    22 jump *label8 equal *tmp7 false
    23 set *tmp9 :testAndSwap.0:i

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-2 instructions):
 
    18 read :testAndSwap.0:a ARRAY *tmp3
    19 set *tmp5 :testAndSwap.0:j
    20 read :testAndSwap.0:b ARRAY *tmp5
-    * op greaterThan *tmp7 :testAndSwap.0:a :testAndSwap.0:b
-    * jump *label8 equal *tmp7 false
+   21 jump *label8 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
    22 set *tmp9 :testAndSwap.0:i
    23 write :testAndSwap.0:b ARRAY *tmp9
    24 set *tmp11 :testAndSwap.0:j
 
    36 jump *label4 always
    37 label *label6
    38 label *label2
-    * op equal *tmp13 :sorted false
-    * jump *label1 notEqual *tmp13 false
+   39 jump *label1 equal :sorted false
    40 label *label3
    41 set :i 0
    42 label *label10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     9 set *tmp0 :n
    10 set :i 0
    11 label *label4
-    * jump *label6 greaterThanEq :i *tmp0
+   12 jump *label6 greaterThanEq :i :n
    13 op add *tmp1 :i 1
    14 set :testAndSwap.0:i :i
    15 set :testAndSwap.0:j *tmp1
    16 set :testAndSwap.0:sorted :sorted
-    * set *tmp3 :testAndSwap.0:i
-    * read :testAndSwap.0:a ARRAY *tmp3
-    * set *tmp5 :testAndSwap.0:j
-    * read :testAndSwap.0:b ARRAY *tmp5
+   17 set *tmp3 :i
+   18 read :testAndSwap.0:a ARRAY :testAndSwap.0:i
+   19 set *tmp5 *tmp1
+   20 read :testAndSwap.0:b ARRAY :testAndSwap.0:j
    21 jump *label8 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
-    * set *tmp9 :testAndSwap.0:i
-    * write :testAndSwap.0:b ARRAY *tmp9
-    * set *tmp11 :testAndSwap.0:j
-    * write :testAndSwap.0:a ARRAY *tmp11
+   22 set *tmp9 :i
+   23 write :testAndSwap.0:b ARRAY :testAndSwap.0:i
+   24 set *tmp11 *tmp1
+   25 write :testAndSwap.0:a ARRAY :testAndSwap.0:j
    26 set *tmp8 false
    27 jump *label9 always
    28 label *label8
-    * set *tmp8 :testAndSwap.0:sorted
+   29 set *tmp8 :sorted
    30 label *label9
    31 set *tmp2 *tmp8
    32 label *label7
-    * set :sorted *tmp2
+   33 set :sorted *tmp8
    34 label *label5
    35 op add :i :i 1
    36 jump *label4 always
 
    43 jump *label12 greaterThanEq :i SIZE
    44 set *tmp14 :i
    45 set *tmp16 :i
-    * read *tmp15 FINAL *tmp14
-    * read *tmp17 ARRAY *tmp16
+   46 read *tmp15 FINAL :i
+   47 read *tmp17 ARRAY :i
    48 assertequals *tmp15 *tmp17 "unexpected value"
    49 label *label11
    50 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-9 instructions):
 
     6 label *label1
     7 op sub :n :n 1
     8 set :sorted true
-    * set *tmp0 :n
     9 set :i 0
    10 label *label4
    11 jump *label6 greaterThanEq :i :n
    12 op add *tmp1 :i 1
    13 set :testAndSwap.0:i :i
    14 set :testAndSwap.0:j *tmp1
-    * set :testAndSwap.0:sorted :sorted
-    * set *tmp3 :i
-    * read :testAndSwap.0:a ARRAY :testAndSwap.0:i
-    * set *tmp5 *tmp1
-    * read :testAndSwap.0:b ARRAY :testAndSwap.0:j
+   15 read :testAndSwap.0:a ARRAY :i
+   16 read :testAndSwap.0:b ARRAY *tmp1
    17 jump *label8 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
-    * set *tmp9 :i
-    * write :testAndSwap.0:b ARRAY :testAndSwap.0:i
-    * set *tmp11 *tmp1
-    * write :testAndSwap.0:a ARRAY :testAndSwap.0:j
+   18 write :testAndSwap.0:b ARRAY :i
+   19 write :testAndSwap.0:a ARRAY *tmp1
    20 set *tmp8 false
    21 jump *label9 always
    22 label *label8
    23 set *tmp8 :sorted
    24 label *label9
-    * set *tmp2 *tmp8
    25 label *label7
    26 set :sorted *tmp8
    27 label *label5
 
    34 set :i 0
    35 label *label10
    36 jump *label12 greaterThanEq :i SIZE
-    * set *tmp14 :i
-    * set *tmp16 :i
    37 read *tmp15 FINAL :i
    38 read *tmp17 ARRAY :i
    39 assertequals *tmp15 *tmp17 "unexpected value"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-2 instructions):
 
    10 label *label4
    11 jump *label6 greaterThanEq :i :n
    12 op add *tmp1 :i 1
-    * set :testAndSwap.0:i :i
-    * set :testAndSwap.0:j *tmp1
    13 read :testAndSwap.0:a ARRAY :i
    14 read :testAndSwap.0:b ARRAY *tmp1
    15 jump *label8 lessThanEq :testAndSwap.0:a :testAndSwap.0:b

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     9 set :i 0
    10 label *label4
    11 jump *label6 greaterThanEq :i :n
+   12 label *label13
    13 op add *tmp1 :i 1
    14 read :testAndSwap.0:a ARRAY :i
    15 read :testAndSwap.0:b ARRAY *tmp1
 
    25 set :sorted *tmp8
    26 label *label5
    27 op add :i :i 1
-    * jump *label4 always
+   28 jump *label13 lessThan :i :n
    29 label *label6
    30 label *label2
    31 jump *label1 equal :sorted false
 
    33 set :i 0
    34 label *label10
    35 jump *label12 greaterThanEq :i SIZE
+   36 label *label14
    37 read *tmp15 FINAL :i
    38 read *tmp17 ARRAY :i
    39 assertequals *tmp15 *tmp17 "unexpected value"
    40 label *label11
    41 op add :i :i 1
-    * jump *label10 always
+   42 jump *label14 lessThan :i SIZE
    43 label *label12
    44 stop
    45 end

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    11 jump *label6 greaterThanEq :i :n
    12 label *label13
    13 op add *tmp1 :i 1
+   14 set :sorted :sorted
    15 read :testAndSwap.0:a ARRAY :i
    16 read :testAndSwap.0:b ARRAY *tmp1
-    * jump *label8 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
+   17 jump *label9 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
    18 write :testAndSwap.0:b ARRAY :i
    19 write :testAndSwap.0:a ARRAY *tmp1
-    * set *tmp8 false
+   20 set :sorted false
    21 jump *label9 always
-    * label *label8
-    * set *tmp8 :sorted
    22 label *label9
    23 label *label7
-    * set :sorted *tmp8
    24 label *label5
    25 op add :i :i 1
    26 jump *label13 lessThan :i :n

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-1 instructions):
 
    18 write :testAndSwap.0:b ARRAY :i
    19 write :testAndSwap.0:a ARRAY *tmp1
    20 set :sorted false
-    * jump *label9 always
    21 label *label9
    22 label *label7
    23 label *label5

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-1 instructions):
 
    11 jump *label6 greaterThanEq :i :n
    12 label *label13
    13 op add *tmp1 :i 1
-    * set :sorted :sorted
    14 read :testAndSwap.0:a ARRAY :i
    15 read :testAndSwap.0:b ARRAY *tmp1
    16 jump *label9 lessThanEq :testAndSwap.0:a :testAndSwap.0:b

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
     8 set :sorted true
     9 set :i 0
    10 label *label4
-    * jump *label6 greaterThanEq :i :n
+   11 jump *label6 greaterThanEq 0 :n
    12 label *label13
    13 op add *tmp1 :i 1
    14 read :testAndSwap.0:a ARRAY :i
 
    28 label *label3
    29 set :i 0
    30 label *label10
-    * jump *label12 greaterThanEq :i SIZE
+   31 jump *label12 greaterThanEq 0 SIZE
    32 label *label14
    33 read *tmp15 FINAL :i
    34 read *tmp17 ARRAY :i

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
    38 jump *label14 lessThan :i SIZE
    39 label *label12
    40 stop
-    * end

Final code before resolving virtual instructions:

set SIZE 64
label *label0
jump *label0 equal bank1 null
set ARRAY bank2
set FINAL bank3
set :n SIZE
label *label1
op sub :n :n 1
set :sorted true
set :i 0
jump *label6 greaterThanEq 0 :n
label *label13
op add *tmp1 :i 1
read :testAndSwap.0:a ARRAY :i
read :testAndSwap.0:b ARRAY *tmp1
jump *label9 lessThanEq :testAndSwap.0:a :testAndSwap.0:b
write :testAndSwap.0:b ARRAY :i
write :testAndSwap.0:a ARRAY *tmp1
set :sorted false
label *label9
op add :i :i 1
jump *label13 lessThan :i :n
label *label6
jump *label1 equal :sorted false
set :i 0
jump *label12 greaterThanEq 0 SIZE
label *label14
read *tmp15 FINAL :i
read *tmp17 ARRAY :i
assertequals *tmp15 *tmp17 "unexpected value"
op add :i :i 1
jump *label14 lessThan :i SIZE
label *label12
stop
