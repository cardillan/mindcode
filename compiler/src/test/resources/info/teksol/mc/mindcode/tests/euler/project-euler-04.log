    36 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
     4 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Jump Optimization (5 iterations).
     3 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     1 instructions eliminated by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
    22 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 977):
  ! Unroll loop at line 4:1                                      cost  1421, benefit     4500.0, efficiency      3.167

Pass 2: speed optimization selection (cost limit 977):
  ! Unroll loop at line 4:1                                      cost  1421, benefit     4500.0, efficiency      3.167

Pass 3: speed optimization selection (cost limit 977):
  ! Unroll loop at line 4:1                                      cost  1421, benefit     4500.0, efficiency      3.167

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    31 label *label12
    32 set *tmp9 null
    33 label *label13
-    * set *tmp2 *tmp9
    34 jump *label7 always
    35 label *label6
-    * set *tmp2 null
    36 label *label7
    37 label *label4
    38 op add :j :j 1

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
    26 op equal *tmp8 :num *tmp3
    27 jump *label12 equal *tmp8 false
    28 set :max :num
-    * set *tmp9 :max
    29 jump *label13 always
    30 label *label12
-    * set *tmp9 null
    31 label *label13
    32 jump *label7 always
    33 label *label6

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
     4 set :j :i
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
-    * op mul *tmp0 :i :j
-    * set :num *tmp0
+    7 op mul :num :i :j
     8 op greaterThan *tmp1 :num :max
     9 jump *label6 equal *tmp1 false
    10 set :revert:num :num
 
    14 jump *label11 equal *tmp4 false
    15 op mul *tmp5 10 :revert:res
    16 op mod *tmp6 :revert:num 10
-    * op add *tmp7 *tmp5 *tmp6
-    * set :revert:res *tmp7
+   17 op add :revert:res *tmp5 *tmp6
    18 op idiv :revert:num :revert:num 10
    19 label *label10
    20 jump *label9 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-3 instructions):
 
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
     7 op mul :num :i :j
-    * op greaterThan *tmp1 :num :max
-    * jump *label6 equal *tmp1 false
+    8 jump *label6 lessThanEq :num :max
     9 set :revert:num :num
    10 set :revert:res 0
    11 label *label9
-    * op greaterThan *tmp4 :revert:num 0
-    * jump *label11 equal *tmp4 false
+   12 jump *label11 lessThanEq :revert:num 0
    13 op mul *tmp5 10 :revert:res
    14 op mod *tmp6 :revert:num 10
    15 op add :revert:res *tmp5 *tmp6
 
    19 label *label11
    20 set *tmp3 :revert:res
    21 label *label8
-    * op equal *tmp8 :num *tmp3
-    * jump *label12 equal *tmp8 false
+   22 jump *label12 notEqual :num *tmp3
    23 set :max :num
    24 jump *label13 always
    25 label *label12

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    21 label *label8
    22 jump *label12 notEqual :num *tmp3
    23 set :max :num
-    * jump *label13 always
    24 label *label12
    25 label *label13
-    * jump *label7 always
    26 label *label6
    27 label *label7
    28 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    19 label *label11
    20 set *tmp3 :revert:res
    21 label *label8
-    * jump *label12 notEqual :num *tmp3
+   22 jump *label12 notEqual :num :revert:res
    23 set :max :num
    24 label *label12
    25 label *label13

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    17 label *label10
    18 jump *label9 always
    19 label *label11
-    * set *tmp3 :revert:res
    20 label *label8
    21 jump *label12 notEqual :num :revert:res
    22 set :max :num

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
     0 set :max 0
     1 set :i 10
     2 label *label0
-    * jump *label2 greaterThanEq :i 100
+    3 label *label14
     4 set :j :i
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
+    7 label *label15
     8 op mul :num :i :j
     9 jump *label6 lessThanEq :num :max
    10 set :revert:num :num
    11 set :revert:res 0
    12 label *label9
    13 jump *label11 lessThanEq :revert:num 0
+   14 label *label16
    15 op mul *tmp5 10 :revert:res
    16 op mod *tmp6 :revert:num 10
    17 op add :revert:res *tmp5 *tmp6
    18 op idiv :revert:num :revert:num 10
    19 label *label10
-    * jump *label9 always
+   20 jump *label16 greaterThan :revert:num 0
    21 label *label11
    22 label *label8
    23 jump *label12 notEqual :num :revert:res
 
    28 label *label7
    29 label *label4
    30 op add :j :j 1
-    * jump *label3 always
+   31 jump *label15 lessThan :j 100
    32 label *label5
    33 label *label1
    34 op add :i :i 1
-    * jump *label0 always
+   35 jump *label14 lessThan :i 100
    36 label *label2
    37 assertequals 9009 :max "Project Euler 4"
    38 stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
     3 label *label14
     4 set :j :i
     5 label *label3
-    * jump *label5 greaterThanEq :j 100
+    6 jump *label5 greaterThanEq :i 100
     7 label *label15
     8 op mul :num :i :j
     9 jump *label6 lessThanEq :num :max
    10 set :revert:num :num
    11 set :revert:res 0
    12 label *label9
-    * jump *label11 lessThanEq :revert:num 0
+   13 jump *label11 lessThanEq :num 0
    14 label *label16
    15 op mul *tmp5 10 :revert:res
    16 op mod *tmp6 :revert:num 10

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
     0 set :max 0
     1 set :i 10
-    * label *label0
     2 label *label14
     3 set :j :i
-    * label *label3
     4 jump *label5 greaterThanEq :i 100
     5 label *label15
     6 op mul :num :i :j
     7 jump *label6 lessThanEq :num :max
     8 set :revert:num :num
     9 set :revert:res 0
-    * label *label9
    10 jump *label11 lessThanEq :num 0
    11 label *label16
    12 op mul *tmp5 10 :revert:res
    13 op mod *tmp6 :revert:num 10
    14 op add :revert:res *tmp5 *tmp6
    15 op idiv :revert:num :revert:num 10
-    * label *label10
    16 jump *label16 greaterThan :revert:num 0
    17 label *label11
-    * label *label8
    18 jump *label12 notEqual :num :revert:res
    19 set :max :num
    20 label *label12
-    * label *label13
    21 label *label6
-    * label *label7
-    * label *label4
    22 op add :j :j 1
    23 jump *label15 lessThan :j 100
    24 label *label5
-    * label *label1
    25 op add :i :i 1
    26 jump *label14 lessThan :i 100
-    * label *label2
    27 assertequals 9009 :max "Project Euler 4"
    28 stop
    29 end

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
    26 jump *label14 lessThan :i 100
    27 assertequals 9009 :max "Project Euler 4"
    28 stop
-    * end

Final code before resolving virtual instructions:

set :max 0
set :i 10
label *label14
set :j :i
jump *label5 greaterThanEq :i 100
label *label15
op mul :num :i :j
jump *label6 lessThanEq :num :max
set :revert:num :num
set :revert:res 0
jump *label11 lessThanEq :num 0
label *label16
op mul *tmp5 10 :revert:res
op mod *tmp6 :revert:num 10
op add :revert:res *tmp5 *tmp6
op idiv :revert:num :revert:num 10
jump *label16 greaterThan :revert:num 0
label *label11
jump *label12 notEqual :num :revert:res
set :max :num
label *label12
label *label6
op add :j :j 1
jump *label15 lessThan :j 100
label *label5
op add :i :i 1
jump *label14 lessThan :i 100
assertequals 9009 :max "Project Euler 4"
stop
