    36 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (7 iterations).
     4 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Jump Normalization (6 iterations).
     3 instructions eliminated by Condition Optimization (7 iterations).
     3 instructions eliminated by Single Step Elimination (2 passes, 8 iterations).
     1 instructions eliminated by Boolean Optimization (7 iterations).
       1 fully-evaluated expressions optimized using selects.
     1 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
       3 loop conditions were partially rotated.
    21 instructions after optimizations.

Pass 3: speed optimization selection (cost limit 978):
  ! Unroll loop at line 4:1                                      size +1332, benefit     4500.0, efficiency      3.378

Pass 4: speed optimization selection (cost limit 978):
  ! Unroll loop at line 4:1                                      size +1332, benefit     4500.0, efficiency      3.378

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    31 label *label8
    32 set *tmp9 null
    33 label *label9
-    * set *tmp2 *tmp9
    34 jump *label7 always
    35 label *label6
-    * set *tmp2 null
    36 label *label7
    37 label *label4
    38 op add :j :j 1

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
    26 op equal *tmp8 :num *tmp3
    27 jump *label8 equal *tmp8 false
    28 set :max :num
-    * set *tmp9 :max
    29 jump *label9 always
    30 label *label8
-    * set *tmp9 null
    31 label *label9
    32 jump *label7 always
    33 label *label6

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
     4 set :j :i
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
-    * op mul *tmp0 :i :j
-    * set :num *tmp0
+    7 op mul :num :i :j
     8 op greaterThan *tmp1 :num :max
     9 jump *label6 equal *tmp1 false
    10 set :revert:num :num
 
    14 jump *label13 equal *tmp4 false
    15 op mul *tmp5 10 :revert:res
    16 op mod *tmp6 :revert:num 10
-    * op add *tmp7 *tmp5 *tmp6
-    * set :revert:res *tmp7
+   17 op add :revert:res *tmp5 *tmp6
    18 op idiv :revert:num :revert:num 10
    19 label *label12
    20 jump *label11 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-3 instructions):
 
     5 label *label3
     6 jump *label5 greaterThanEq :j 100
     7 op mul :num :i :j
-    * op greaterThan *tmp1 :num :max
-    * jump *label6 equal *tmp1 false
+    8 jump *label6 lessThanEq :num :max
     9 set :revert:num :num
    10 set :revert:res 0
    11 label *label11
-    * op greaterThan *tmp4 :revert:num 0
-    * jump *label13 equal *tmp4 false
+   12 jump *label13 lessThanEq :revert:num 0
    13 op mul *tmp5 10 :revert:res
    14 op mod *tmp6 :revert:num 10
    15 op add :revert:res *tmp5 *tmp6
 
    19 label *label13
    20 set *tmp3 :revert:res
    21 label *label10
-    * op equal *tmp8 :num *tmp3
-    * jump *label8 equal *tmp8 false
+   22 jump *label8 notEqual :num *tmp3
    23 set :max :num
    24 jump *label9 always
    25 label *label8

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    21 label *label10
    22 jump *label8 notEqual :num *tmp3
    23 set :max :num
-    * jump *label9 always
    24 label *label8
    25 label *label9
-    * jump *label7 always
    26 label *label6
    27 label *label7
    28 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    19 label *label13
    20 set *tmp3 :revert:res
    21 label *label10
-    * jump *label8 notEqual :num *tmp3
+   22 jump *label8 notEqual :num :revert:res
    23 set :max :num
    24 label *label8
    25 label *label9

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    17 label *label12
    18 jump *label11 always
    19 label *label13
-    * set *tmp3 :revert:res
    20 label *label10
    21 jump *label8 notEqual :num :revert:res
    22 set :max :num

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     1 set :i 10
     2 label *label0
     3 jump *label2 greaterThanEq :i 100
+    4 label *label14
     5 set :j :i
     6 label *label3
     7 jump *label5 greaterThanEq :j 100
+    8 label *label15
     9 op mul :num :i :j
    10 jump *label6 lessThanEq :num :max
    11 set :revert:num :num
    12 set :revert:res 0
    13 label *label11
    14 jump *label13 lessThanEq :revert:num 0
+   15 label *label16
    16 op mul *tmp5 10 :revert:res
    17 op mod *tmp6 :revert:num 10
    18 op add :revert:res *tmp5 *tmp6
    19 op idiv :revert:num :revert:num 10
    20 label *label12
-    * jump *label11 always
+   21 jump *label16 greaterThan :revert:num 0
    22 label *label13
    23 label *label10
    24 jump *label8 notEqual :num :revert:res
 
    29 label *label7
    30 label *label4
    31 op add :j :j 1
-    * jump *label3 always
+   32 jump *label15 lessThan :j 100
    33 label *label5
    34 label *label1
    35 op add :i :i 1
-    * jump *label0 always
+   36 jump *label14 lessThan :i 100
    37 label *label2
    38 assertequals 9009 :max "Project Euler 4"
    39 stop

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-1 instructions):
 
     8 label *label15
     9 op mul :num :i :j
    10 jump *label6 lessThanEq :num :max
-    * set :revert:num :num
-    * set :revert:res 0
-    * label *label11
-    * jump *label13 lessThanEq :revert:num 0
-    * label *label16
-    * op mul *tmp5 10 :revert:res
-    * op mod *tmp6 :revert:num 10
-    * op add :revert:res *tmp5 *tmp6
-    * op idiv :revert:num :revert:num 10
-    * label *label12
-    * jump *label16 greaterThan :revert:num 0
-    * label *label13
-    * label *label10
-    * jump *label8 notEqual :num :revert:res
-    * set :max :num
-    * label *label8
-    * label *label9
+   11 set :revert:num :num
+   12 set :revert:res 0
+   13 label *label17
+   14 jump *label20 lessThanEq :revert:num 0
+   15 label *label18
+   16 op mul *tmp5 10 :revert:res
+   17 op mod *tmp6 :revert:num 10
+   18 op add :revert:res *tmp5 *tmp6
+   19 op idiv :revert:num :revert:num 10
+   20 label *label19
+   21 jump *label18 greaterThan :revert:num 0
+   22 label *label20
+   23 label *label21
+   24 select :max equal :num :revert:res :num :max
    25 label *label6
    26 label *label7
    27 label *label4

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
     0 set :max 0
     1 set :i 10
     2 label *label0
-    * jump *label2 greaterThanEq :i 100
+    3 jump *label2 greaterThanEq 10 100
     4 label *label14
     5 set :j :i
     6 label *label3
-    * jump *label5 greaterThanEq :j 100
+    7 jump *label5 greaterThanEq :i 100
     8 label *label15
     9 op mul :num :i :j
    10 jump *label6 lessThanEq :num :max
    11 set :revert:num :num
    12 set :revert:res 0
    13 label *label17
-    * jump *label20 lessThanEq :revert:num 0
+   14 jump *label20 lessThanEq :num 0
    15 label *label18
    16 op mul *tmp5 10 :revert:res
    17 op mod *tmp6 :revert:num 10

Modifications by Iterated phase, Jump Normalization, pass 3, iteration 1 (-1 instructions):
     0 set :max 0
     1 set :i 10
     2 label *label0
-    * jump *label2 greaterThanEq 10 100
     3 label *label14
     4 set :j :i
     5 label *label3

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-1 instructions):
 
    24 jump *label14 lessThan :i 100
    25 assertequals 9009 :max "Project Euler 4"
    26 stop
-    * end

Final code before resolving virtual instructions:

set :max 0
set :i 10
label *label14
set :j :i
jump *label5 greaterThanEq :i 100
label *label15
op mul :num :i :j
jump *label6 lessThanEq :num :max
set :revert:num :num
set :revert:res 0
jump *label20 lessThanEq :num 0
label *label18
op mul *tmp5 10 :revert:res
op mod *tmp6 :revert:num 10
op add :revert:res *tmp5 *tmp6
op idiv :revert:num :revert:num 10
jump *label18 greaterThan :revert:num 0
label *label20
select :max equal :num :revert:res :num :max
label *label6
op add :j :j 1
jump *label15 lessThan :j 100
label *label5
op add :i :i 1
jump *label14 lessThan :i 100
assertequals 9009 :max "Project Euler 4"
stop
