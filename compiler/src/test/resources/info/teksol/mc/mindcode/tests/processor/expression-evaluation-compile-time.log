   155 instructions before optimizations.
     3 instructions eliminated by Temp Variables Elimination (2 iterations).
     1 instructions eliminated by Single Step Elimination (5 iterations).
     3 instructions modified by Expression Optimization (2 iterations).
    83 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
    11 instructions added by Function Inlining (3 iterations).
     6 function calls inlined by Function Inlining.
    79 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 889):
  * Inline function 'assertEqualsRound' defined at line 3:1      size   +19, benefit       27.0, efficiency      1.421 (-31 instructions)
    Inline function call at line 78:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 79:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 80:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 82:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 83:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 84:1                            size    +4, benefit        4.5, efficiency      1.125

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-3 instructions):
 
    49 set :logn:base 2
    50 op log *tmp4 :logn:number
    51 op log *tmp5 :logn:base
-    * op div *tmp6 *tmp4 *tmp5
-    * set *tmp3 *tmp6
+   52 op div *tmp3 *tmp4 *tmp5
    53 label *label4
    54 assertequals 4 *tmp3 "logn"
    55 assertequals 2 2 "floor"
 
   150 stop
   151 end
   152 label *label3
-    * op mul *tmp9 :assertEqualsRound:actual 100000000
-    * set :round:x *tmp9
+  153 op mul :round:x :assertEqualsRound:actual 100000000
   154 op add *tmp11 :round:x 0.5
-    * op floor *tmp12 *tmp11
-    * set *tmp10 *tmp12
+  155 op floor *tmp10 *tmp11
   156 label *label12
   157 op div *tmp13 *tmp10 100000000
   158 assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
 
   136 op xor :a :a 2
   137 assertequals 1 :a "^="
   138 set :a 1
-    * op land :a :a 0
+  139 set :a false
   140 assertequals false :a "&&="
   141 set :a 1
   142 op land :a :a 2
   143 assertequals true :a "&&="
   144 set :a 0
-    * op or *tmp7 :a 2
+  145 set *tmp7 true
   146 op notEqual :a *tmp7 false
   147 assertequals true :a "||="
-    * sensor *tmp8 @copper-wall @id
+  148 set *tmp8 17
   149 assertequals 17 *tmp8 "Logic ID"
   150 stop
   151 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
    33 assertequals -1 -1 "not 1"
    34 assertequals -65536 -65536 "not 2"
    35 set :a 0xabcdefabcdef
-    * op add *tmp0 :a 1
-    * op sub *tmp1 0 *tmp0
-    * op not *tmp2 :a
-    * assertequals *tmp1 *tmp2 "not 3"
+   36 op add *tmp0 0xabcdefabcdef 1
+   37 op sub *tmp1 0 188900977659376
+   38 op not *tmp2 0xabcdefabcdef
+   39 assertequals -188900977659376 -188900977659376 "not 3"
    40 assertequals 4 4 "max"
    41 assertequals 2 2 "min"
    42 assertequals 2 2 "abs"
 
    47 assertequals 1 1 "log10"
    48 set :logn:number 16
    49 set :logn:base 2
-    * op log *tmp4 :logn:number
-    * op log *tmp5 :logn:base
-    * op div *tmp3 *tmp4 *tmp5
+   50 op log *tmp4 16
+   51 op log *tmp5 2
+   52 op div *tmp3 2.772588722239781 0.6931471805599453
    53 label *label4
-    * assertequals 4 *tmp3 "logn"
+   54 assertequals 4 4 "logn"
    55 assertequals 2 2 "floor"
    56 assertequals 3 3 "ceil"
    57 assertequals 3 3 "round"
 
   100 assertequals 0 false "boolean negation 2"
   101 assertequals 0 false "boolean negation 3"
   102 set :a 2
-    * op pow :a :a 4
-    * assertequals 16 :a "**="
+  103 op pow :a 2 4
+  104 assertequals 16 16 "**="
   105 set :a 2
-    * op mul :a :a 4
-    * assertequals 8 :a "*="
+  106 op mul :a 2 4
+  107 assertequals 8 8 "*="
   108 set :a 6
-    * op div :a :a 4
-    * assertequals 1.5 :a "/="
+  109 op div :a 6 4
+  110 assertequals 1.5 1.5 "/="
   111 set :a 6
-    * op idiv :a :a 4
-    * assertequals 1 :a "\="
+  112 op idiv :a 6 4
+  113 assertequals 1 1 "\="
   114 set :a 6
-    * op mod :a :a 4
-    * assertequals 2 :a "%="
+  115 op mod :a 6 4
+  116 assertequals 2 2 "%="
   117 set :a 4
-    * op add :a :a 2
-    * assertequals 6 :a "+="
+  118 op add :a 4 2
+  119 assertequals 6 6 "+="
   120 set :a 4
-    * op sub :a :a 2
-    * assertequals 2 :a "-="
+  121 op sub :a 4 2
+  122 assertequals 2 2 "-="
   123 set :a 1
-    * op shl :a :a 2
-    * assertequals 4 :a "<<="
+  124 op shl :a 1 2
+  125 assertequals 4 4 "<<="
   126 set :a 9
-    * op shr :a :a 2
-    * assertequals 2 :a ">>="
+  127 op shr :a 9 2
+  128 assertequals 2 2 ">>="
   129 set :a 1
-    * op or :a :a 2
-    * assertequals 3 :a "|="
+  130 op or :a 1 2
+  131 assertequals 3 3 "|="
   132 set :a 3
-    * op and :a :a 2
-    * assertequals 2 :a "&="
+  133 op and :a 3 2
+  134 assertequals 2 2 "&="
   135 set :a 3
-    * op xor :a :a 2
-    * assertequals 1 :a "^="
-    * set :a 1
+  136 op xor :a 3 2
+  137 assertequals 1 1 "^="
   138 set :a false
-    * assertequals false :a "&&="
+  139 assertequals false false "&&="
   140 set :a 1
-    * op land :a :a 2
-    * assertequals true :a "&&="
-    * set :a 0
+  141 op land :a 1 2
+  142 assertequals true true "&&="
   143 set *tmp7 true
-    * op notEqual :a *tmp7 false
-    * assertequals true :a "||="
+  144 op notEqual :a true false
+  145 assertequals true true "||="
   146 set *tmp8 17
-    * assertequals 17 *tmp8 "Logic ID"
+  147 assertequals 17 17 "Logic ID"
   148 stop
   149 end
   150 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-39 instructions):
 
    32 assertequals 1 1 "xor"
    33 assertequals -1 -1 "not 1"
    34 assertequals -65536 -65536 "not 2"
-    * set :a 0xabcdefabcdef
-    * op add *tmp0 0xabcdefabcdef 1
-    * op sub *tmp1 0 188900977659376
-    * op not *tmp2 0xabcdefabcdef
    35 assertequals -188900977659376 -188900977659376 "not 3"
    36 assertequals 4 4 "max"
    37 assertequals 2 2 "min"
 
    41 assertequals 0 0 "sign(0)"
    42 assertequals 1 1 "log"
    43 assertequals 1 1 "log10"
-    * set :logn:number 16
-    * set :logn:base 2
-    * op log *tmp4 16
-    * op log *tmp5 2
-    * op div *tmp3 2.772588722239781 0.6931471805599453
    44 label *label4
    45 assertequals 4 4 "logn"
    46 assertequals 2 2 "floor"
 
    90 assertequals 1 true "boolean negation 1"
    91 assertequals 0 false "boolean negation 2"
    92 assertequals 0 false "boolean negation 3"
-    * set :a 2
-    * op pow :a 2 4
    93 assertequals 16 16 "**="
-    * set :a 2
-    * op mul :a 2 4
    94 assertequals 8 8 "*="
-    * set :a 6
-    * op div :a 6 4
    95 assertequals 1.5 1.5 "/="
-    * set :a 6
-    * op idiv :a 6 4
    96 assertequals 1 1 "\="
-    * set :a 6
-    * op mod :a 6 4
    97 assertequals 2 2 "%="
-    * set :a 4
-    * op add :a 4 2
    98 assertequals 6 6 "+="
-    * set :a 4
-    * op sub :a 4 2
    99 assertequals 2 2 "-="
-    * set :a 1
-    * op shl :a 1 2
   100 assertequals 4 4 "<<="
-    * set :a 9
-    * op shr :a 9 2
   101 assertequals 2 2 ">>="
-    * set :a 1
-    * op or :a 1 2
   102 assertequals 3 3 "|="
-    * set :a 3
-    * op and :a 3 2
   103 assertequals 2 2 "&="
-    * set :a 3
-    * op xor :a 3 2
   104 assertequals 1 1 "^="
-    * set :a false
   105 assertequals false false "&&="
-    * set :a 1
-    * op land :a 1 2
   106 assertequals true true "&&="
-    * set *tmp7 true
-    * op notEqual :a true false
   107 assertequals true true "||="
-    * set *tmp8 17
   108 assertequals 17 17 "Logic ID"
   109 stop
   110 end

Modifications by Inline function 'assertEqualsRound' defined at line 3:1 (+11 instructions):
 
    53 set :assertEqualsRound:expected 1
    54 set :assertEqualsRound:actual 1
    55 set :assertEqualsRound:title "sin"
-    * setaddr :assertEqualsRound*retaddr *label5 (h:*label5)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label5) (h:*label5)
-    * label *label5
+   56 label *label13
+   57 op mul :round:x :assertEqualsRound:actual 100000000
+   58 op add *tmp11 :round:x 0.5
+   59 op floor *tmp10 *tmp11
+   60 label *label14
+   61 op div *tmp13 *tmp10 100000000
+   62 assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+   63 label *label15
    64 set :assertEqualsRound:expected -1
    65 set :assertEqualsRound:actual -1
    66 set :assertEqualsRound:title "cos"
-    * setaddr :assertEqualsRound*retaddr *label6 (h:*label6)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label6) (h:*label6)
-    * label *label6
+   67 label *label16
+   68 op mul :round:x :assertEqualsRound:actual 100000000
+   69 op add *tmp11 :round:x 0.5
+   70 op floor *tmp10 *tmp11
+   71 label *label17
+   72 op div *tmp13 *tmp10 100000000
+   73 assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+   74 label *label18
    75 set :assertEqualsRound:expected 1
    76 set :assertEqualsRound:actual 0.9999999999999999
    77 set :assertEqualsRound:title "tan"
-    * setaddr :assertEqualsRound*retaddr *label7 (h:*label7)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label7) (h:*label7)
-    * label *label7
+   78 label *label19
+   79 op mul :round:x :assertEqualsRound:actual 100000000
+   80 op add *tmp11 :round:x 0.5
+   81 op floor *tmp10 *tmp11
+   82 label *label20
+   83 op div *tmp13 *tmp10 100000000
+   84 assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+   85 label *label21
    86 set :assertEqualsRound:expected 90
    87 set :assertEqualsRound:actual 90
    88 set :assertEqualsRound:title "asin"
-    * setaddr :assertEqualsRound*retaddr *label8 (h:*label8)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label8) (h:*label8)
-    * label *label8
+   89 label *label22
+   90 op mul :round:x :assertEqualsRound:actual 100000000
+   91 op add *tmp11 :round:x 0.5
+   92 op floor *tmp10 *tmp11
+   93 label *label23
+   94 op div *tmp13 *tmp10 100000000
+   95 assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+   96 label *label24
    97 set :assertEqualsRound:expected 0
    98 set :assertEqualsRound:actual 0
    99 set :assertEqualsRound:title "acos"
-    * setaddr :assertEqualsRound*retaddr *label9 (h:*label9)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label9) (h:*label9)
-    * label *label9
+  100 label *label25
+  101 op mul :round:x :assertEqualsRound:actual 100000000
+  102 op add *tmp11 :round:x 0.5
+  103 op floor *tmp10 *tmp11
+  104 label *label26
+  105 op div *tmp13 *tmp10 100000000
+  106 assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+  107 label *label27
   108 set :assertEqualsRound:expected 45
   109 set :assertEqualsRound:actual 45
   110 set :assertEqualsRound:title "atan"
-    * setaddr :assertEqualsRound*retaddr *label10 (h:*label10)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label10) (h:*label10)
-    * label *label10
+  111 label *label28
+  112 op mul :round:x :assertEqualsRound:actual 100000000
+  113 op add *tmp11 :round:x 0.5
+  114 op floor *tmp10 *tmp11
+  115 label *label29
+  116 op div *tmp13 *tmp10 100000000
+  117 assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+  118 label *label30
   119 assertequals -8 -8 "unary minus"
   120 assertequals 1 true "boolean negation 1"
   121 assertequals 0 false "boolean negation 2"
 
   138 assertequals 17 17 "Logic ID"
   139 stop
   140 end
-    * label *label3
-    * op mul :round:x :assertEqualsRound:actual 100000000
-    * op add *tmp11 :round:x 0.5
-    * op floor *tmp10 *tmp11
-    * label *label12
-    * op div *tmp13 *tmp10 100000000
-    * assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
-    * label *label11
-    * return :assertEqualsRound*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    54 set :assertEqualsRound:actual 1
    55 set :assertEqualsRound:title "sin"
    56 label *label13
-    * op mul :round:x :assertEqualsRound:actual 100000000
-    * op add *tmp11 :round:x 0.5
-    * op floor *tmp10 *tmp11
+   57 op mul :round:x 1 100000000
+   58 op add *tmp11 100000000 0.5
+   59 op floor *tmp10 100000000.5
    60 label *label14
-    * op div *tmp13 *tmp10 100000000
-    * assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+   61 op div *tmp13 100000000 100000000
+   62 assertequals 1 1 "sin"
    63 label *label15
    64 set :assertEqualsRound:expected -1
    65 set :assertEqualsRound:actual -1
    66 set :assertEqualsRound:title "cos"
    67 label *label16
-    * op mul :round:x :assertEqualsRound:actual 100000000
-    * op add *tmp11 :round:x 0.5
-    * op floor *tmp10 *tmp11
+   68 op mul :round:x -1 100000000
+   69 op add *tmp11 -100000000 0.5
+   70 op floor *tmp10 -99999999.5
    71 label *label17
-    * op div *tmp13 *tmp10 100000000
-    * assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+   72 op div *tmp13 -100000000 100000000
+   73 assertequals -1 -1 "cos"
    74 label *label18
    75 set :assertEqualsRound:expected 1
    76 set :assertEqualsRound:actual 0.9999999999999999
    77 set :assertEqualsRound:title "tan"
    78 label *label19
-    * op mul :round:x :assertEqualsRound:actual 100000000
-    * op add *tmp11 :round:x 0.5
-    * op floor *tmp10 *tmp11
+   79 op mul :round:x 0.9999999999999999 100000000
+   80 op add *tmp11 99999999.99999999 0.5
+   81 op floor *tmp10 100000000.49999999
    82 label *label20
-    * op div *tmp13 *tmp10 100000000
-    * assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+   83 op div *tmp13 100000000 100000000
+   84 assertequals 1 1 "tan"
    85 label *label21
    86 set :assertEqualsRound:expected 90
    87 set :assertEqualsRound:actual 90
    88 set :assertEqualsRound:title "asin"
    89 label *label22
-    * op mul :round:x :assertEqualsRound:actual 100000000
-    * op add *tmp11 :round:x 0.5
-    * op floor *tmp10 *tmp11
+   90 op mul :round:x 90 100000000
+   91 op add *tmp11 9000000000 0.5
+   92 op floor *tmp10 9000000000.5
    93 label *label23
-    * op div *tmp13 *tmp10 100000000
-    * assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+   94 op div *tmp13 9000000000 100000000
+   95 assertequals 90 90 "asin"
    96 label *label24
    97 set :assertEqualsRound:expected 0
    98 set :assertEqualsRound:actual 0
    99 set :assertEqualsRound:title "acos"
   100 label *label25
-    * op mul :round:x :assertEqualsRound:actual 100000000
-    * op add *tmp11 :round:x 0.5
-    * op floor *tmp10 *tmp11
+  101 op mul :round:x 0 100000000
+  102 op add *tmp11 0 0.5
+  103 op floor *tmp10 0.5
   104 label *label26
-    * op div *tmp13 *tmp10 100000000
-    * assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+  105 op div *tmp13 0 100000000
+  106 assertequals 0 0 "acos"
   107 label *label27
   108 set :assertEqualsRound:expected 45
   109 set :assertEqualsRound:actual 45
   110 set :assertEqualsRound:title "atan"
   111 label *label28
-    * op mul :round:x :assertEqualsRound:actual 100000000
-    * op add *tmp11 :round:x 0.5
-    * op floor *tmp10 *tmp11
+  112 op mul :round:x 45 100000000
+  113 op add *tmp11 4500000000 0.5
+  114 op floor *tmp10 4500000000.5
   115 label *label29
-    * op div *tmp13 *tmp10 100000000
-    * assertequals :assertEqualsRound:expected *tmp13 :assertEqualsRound:title
+  116 op div *tmp13 4500000000 100000000
+  117 assertequals 45 45 "atan"
   118 label *label30
   119 assertequals -8 -8 "unary minus"
   120 assertequals 1 true "boolean negation 1"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-42 instructions):
 
    50 assertequals 45 45 "angle"
    51 assertequals 90 90 "angleDiff"
    52 assertequals 5 5 "len"
-    * set :assertEqualsRound:expected 1
-    * set :assertEqualsRound:actual 1
-    * set :assertEqualsRound:title "sin"
    53 label *label13
-    * op mul :round:x 1 100000000
-    * op add *tmp11 100000000 0.5
-    * op floor *tmp10 100000000.5
    54 label *label14
-    * op div *tmp13 100000000 100000000
    55 assertequals 1 1 "sin"
    56 label *label15
-    * set :assertEqualsRound:expected -1
-    * set :assertEqualsRound:actual -1
-    * set :assertEqualsRound:title "cos"
    57 label *label16
-    * op mul :round:x -1 100000000
-    * op add *tmp11 -100000000 0.5
-    * op floor *tmp10 -99999999.5
    58 label *label17
-    * op div *tmp13 -100000000 100000000
    59 assertequals -1 -1 "cos"
    60 label *label18
-    * set :assertEqualsRound:expected 1
-    * set :assertEqualsRound:actual 0.9999999999999999
-    * set :assertEqualsRound:title "tan"
    61 label *label19
-    * op mul :round:x 0.9999999999999999 100000000
-    * op add *tmp11 99999999.99999999 0.5
-    * op floor *tmp10 100000000.49999999
    62 label *label20
-    * op div *tmp13 100000000 100000000
    63 assertequals 1 1 "tan"
    64 label *label21
-    * set :assertEqualsRound:expected 90
-    * set :assertEqualsRound:actual 90
-    * set :assertEqualsRound:title "asin"
    65 label *label22
-    * op mul :round:x 90 100000000
-    * op add *tmp11 9000000000 0.5
-    * op floor *tmp10 9000000000.5
    66 label *label23
-    * op div *tmp13 9000000000 100000000
    67 assertequals 90 90 "asin"
    68 label *label24
-    * set :assertEqualsRound:expected 0
-    * set :assertEqualsRound:actual 0
-    * set :assertEqualsRound:title "acos"
    69 label *label25
-    * op mul :round:x 0 100000000
-    * op add *tmp11 0 0.5
-    * op floor *tmp10 0.5
    70 label *label26
-    * op div *tmp13 0 100000000
    71 assertequals 0 0 "acos"
    72 label *label27
-    * set :assertEqualsRound:expected 45
-    * set :assertEqualsRound:actual 45
-    * set :assertEqualsRound:title "atan"
    73 label *label28
-    * op mul :round:x 45 100000000
-    * op add *tmp11 4500000000 0.5
-    * op floor *tmp10 4500000000.5
    74 label *label29
-    * op div *tmp13 4500000000 100000000
    75 assertequals 45 45 "atan"
    76 label *label30
    77 assertequals -8 -8 "unary minus"

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
    41 assertequals 0 0 "sign(0)"
    42 assertequals 1 1 "log"
    43 assertequals 1 1 "log10"
-    * label *label4
    44 assertequals 4 4 "logn"
    45 assertequals 2 2 "floor"
    46 assertequals 3 3 "ceil"
 
    49 assertequals 45 45 "angle"
    50 assertequals 90 90 "angleDiff"
    51 assertequals 5 5 "len"
-    * label *label13
-    * label *label14
    52 assertequals 1 1 "sin"
-    * label *label15
-    * label *label16
-    * label *label17
    53 assertequals -1 -1 "cos"
-    * label *label18
-    * label *label19
-    * label *label20
    54 assertequals 1 1 "tan"
-    * label *label21
-    * label *label22
-    * label *label23
    55 assertequals 90 90 "asin"
-    * label *label24
-    * label *label25
-    * label *label26
    56 assertequals 0 0 "acos"
-    * label *label27
-    * label *label28
-    * label *label29
    57 assertequals 45 45 "atan"
-    * label *label30
    58 assertequals -8 -8 "unary minus"
    59 assertequals 1 true "boolean negation 1"
    60 assertequals 0 false "boolean negation 2"

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
    76 assertequals true true "||="
    77 assertequals 17 17 "Logic ID"
    78 stop
-    * end

Final code before resolving virtual instructions:

assertequals 5 5 "add"
assertequals 1 1 "sub"
assertequals 6 6 "mul"
assertequals 1.5 1.5 "div"
assertequals 0.00001 0.00001 "div exp"
assertequals 1 1 "idiv"
assertequals 2 2 "mod"
assertequals 5 5 "emod"
assertequals 16 16 "pow"
assertequals true true "equal 1"
assertequals false false "equal 2"
assertequals true true "equal null"
assertequals false false "notEqual 1"
assertequals true true "notEqual 2"
assertequals false false "notEqual null"
assertequals false false "land 1"
assertequals true true "land 2"
assertequals true true "lessThan 1"
assertequals false false "lessThan 2"
assertequals true true "lessThanEq 1"
assertequals false false "lessThanEq 2"
assertequals true true "greaterThan 1"
assertequals false false "greaterThan 2"
assertequals true true "greaterThanEq 1"
assertequals false false "greaterThanEq 2"
assertequals false false "strictEqual 1"
assertequals true true "strictEqual 2"
assertequals 4 4 "shl"
assertequals 2 2 "shr"
assertequals 7 7 "ushr"
assertequals 3 3 "or"
assertequals 2 2 "and"
assertequals 1 1 "xor"
assertequals -1 -1 "not 1"
assertequals -65536 -65536 "not 2"
assertequals -188900977659376 -188900977659376 "not 3"
assertequals 4 4 "max"
assertequals 2 2 "min"
assertequals 2 2 "abs"
assertequals -1 -1 "sign(-2)"
assertequals 1 1 "sign(2)"
assertequals 0 0 "sign(0)"
assertequals 1 1 "log"
assertequals 1 1 "log10"
assertequals 4 4 "logn"
assertequals 2 2 "floor"
assertequals 3 3 "ceil"
assertequals 3 3 "round"
assertequals 4 4 "sqrt"
assertequals 45 45 "angle"
assertequals 90 90 "angleDiff"
assertequals 5 5 "len"
assertequals 1 1 "sin"
assertequals -1 -1 "cos"
assertequals 1 1 "tan"
assertequals 90 90 "asin"
assertequals 0 0 "acos"
assertequals 45 45 "atan"
assertequals -8 -8 "unary minus"
assertequals 1 true "boolean negation 1"
assertequals 0 false "boolean negation 2"
assertequals 0 false "boolean negation 3"
assertequals 16 16 "**="
assertequals 8 8 "*="
assertequals 1.5 1.5 "/="
assertequals 1 1 "\="
assertequals 2 2 "%="
assertequals 6 6 "+="
assertequals 2 2 "-="
assertequals 4 4 "<<="
assertequals 2 2 ">>="
assertequals 3 3 "|="
assertequals 2 2 "&="
assertequals 1 1 "^="
assertequals false false "&&="
assertequals true true "&&="
assertequals true true "||="
assertequals 17 17 "Logic ID"
stop
