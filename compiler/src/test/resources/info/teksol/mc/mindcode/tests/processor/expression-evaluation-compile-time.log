   100 instructions before optimizations.
     1 instructions eliminated by Single Step Elimination (4 iterations).
     2 instructions modified by Expression Optimization (2 iterations).
    35 instructions eliminated by Data Flow Optimization (4 iterations).
    64 instructions after optimizations.

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
 
    86 op xor :a :a 2
    87 assertequals 1 :a "^="
    88 set :a 1
-    * op land :a :a 0
+   89 set :a false
    90 assertequals false :a "&&="
    91 set :a 1
    92 op land :a :a 2
    93 assertequals true :a "&&="
    94 set :a 0
-    * op or *tmp3 :a 2
+   95 set *tmp3 true
    96 op notEqual :a *tmp3 false
    97 assertequals true :a "||="
    98 stop

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
    31 assertequals -1 -1 "not 1"
    32 assertequals -65536 -65536 "not 2"
    33 set :a 0xabcdefabcdef
-    * op add *tmp0 :a 1
-    * op sub *tmp1 0 *tmp0
-    * op not *tmp2 :a
-    * assertequals *tmp1 *tmp2 "not 3"
+   34 op add *tmp0 0xabcdefabcdef 1
+   35 op sub *tmp1 0 188900977659376
+   36 op not *tmp2 0xabcdefabcdef
+   37 assertequals -188900977659376 -188900977659376 "not 3"
    38 assertequals 4 4 "max"
    39 assertequals 2 2 "min"
    40 assertequals 2 2 "abs"
 
    50 assertequals 0 false "boolean negation 2"
    51 assertequals 0 false "boolean negation 3"
    52 set :a 2
-    * op pow :a :a 4
-    * assertequals 16 :a "**="
+   53 op pow :a 2 4
+   54 assertequals 16 16 "**="
    55 set :a 2
-    * op mul :a :a 4
-    * assertequals 8 :a "*="
+   56 op mul :a 2 4
+   57 assertequals 8 8 "*="
    58 set :a 6
-    * op div :a :a 4
-    * assertequals 1.5 :a "/="
+   59 op div :a 6 4
+   60 assertequals 1.5 1.5 "/="
    61 set :a 6
-    * op idiv :a :a 4
-    * assertequals 1 :a "\="
+   62 op idiv :a 6 4
+   63 assertequals 1 1 "\="
    64 set :a 6
-    * op mod :a :a 4
-    * assertequals 2 :a "%="
+   65 op mod :a 6 4
+   66 assertequals 2 2 "%="
    67 set :a 4
-    * op add :a :a 2
-    * assertequals 6 :a "+="
+   68 op add :a 4 2
+   69 assertequals 6 6 "+="
    70 set :a 4
-    * op sub :a :a 2
-    * assertequals 2 :a "-="
+   71 op sub :a 4 2
+   72 assertequals 2 2 "-="
    73 set :a 1
-    * op shl :a :a 2
-    * assertequals 4 :a "<<="
+   74 op shl :a 1 2
+   75 assertequals 4 4 "<<="
    76 set :a 9
-    * op shr :a :a 2
-    * assertequals 2 :a ">>="
+   77 op shr :a 9 2
+   78 assertequals 2 2 ">>="
    79 set :a 1
-    * op or :a :a 2
-    * assertequals 3 :a "|="
+   80 op or :a 1 2
+   81 assertequals 3 3 "|="
    82 set :a 3
-    * op and :a :a 2
-    * assertequals 2 :a "&="
+   83 op and :a 3 2
+   84 assertequals 2 2 "&="
    85 set :a 3
-    * op xor :a :a 2
-    * assertequals 1 :a "^="
-    * set :a 1
+   86 op xor :a 3 2
+   87 assertequals 1 1 "^="
    88 set :a false
-    * assertequals false :a "&&="
+   89 assertequals false false "&&="
    90 set :a 1
-    * op land :a :a 2
-    * assertequals true :a "&&="
-    * set :a 0
+   91 op land :a 1 2
+   92 assertequals true true "&&="
    93 set *tmp3 true
-    * op notEqual :a *tmp3 false
-    * assertequals true :a "||="
+   94 op notEqual :a true false
+   95 assertequals true true "||="
    96 stop
    97 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-33 instructions):
 
    30 assertequals 1 1 "xor"
    31 assertequals -1 -1 "not 1"
    32 assertequals -65536 -65536 "not 2"
-    * set :a 0xabcdefabcdef
-    * op add *tmp0 0xabcdefabcdef 1
-    * op sub *tmp1 0 188900977659376
-    * op not *tmp2 0xabcdefabcdef
    33 assertequals -188900977659376 -188900977659376 "not 3"
    34 assertequals 4 4 "max"
    35 assertequals 2 2 "min"
 
    45 assertequals 1 true "boolean negation 1"
    46 assertequals 0 false "boolean negation 2"
    47 assertequals 0 false "boolean negation 3"
-    * set :a 2
-    * op pow :a 2 4
    48 assertequals 16 16 "**="
-    * set :a 2
-    * op mul :a 2 4
    49 assertequals 8 8 "*="
-    * set :a 6
-    * op div :a 6 4
    50 assertequals 1.5 1.5 "/="
-    * set :a 6
-    * op idiv :a 6 4
    51 assertequals 1 1 "\="
-    * set :a 6
-    * op mod :a 6 4
    52 assertequals 2 2 "%="
-    * set :a 4
-    * op add :a 4 2
    53 assertequals 6 6 "+="
-    * set :a 4
-    * op sub :a 4 2
    54 assertequals 2 2 "-="
-    * set :a 1
-    * op shl :a 1 2
    55 assertequals 4 4 "<<="
-    * set :a 9
-    * op shr :a 9 2
    56 assertequals 2 2 ">>="
-    * set :a 1
-    * op or :a 1 2
    57 assertequals 3 3 "|="
-    * set :a 3
-    * op and :a 3 2
    58 assertequals 2 2 "&="
-    * set :a 3
-    * op xor :a 3 2
    59 assertequals 1 1 "^="
-    * set :a false
    60 assertequals false false "&&="
-    * set :a 1
-    * op land :a 1 2
    61 assertequals true true "&&="
-    * set *tmp3 true
-    * op notEqual :a true false
    62 assertequals true true "||="
    63 stop
    64 end

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
    61 assertequals true true "&&="
    62 assertequals true true "||="
    63 stop
-    * end

Final code before resolving virtual instructions:

assertequals 5 5 "add"
assertequals 1 1 "sub"
assertequals 6 6 "mul"
assertequals 1.5 1.5 "div"
assertequals 0.00001 0.00001 "div exp"
assertequals 1 1 "idiv"
assertequals 2 2 "mod"
assertequals 16 16 "pow"
assertequals true true "equal 1"
assertequals false false "equal 2"
assertequals true true "equal null"
assertequals false false "notEqual 1"
assertequals true true "notEqual 2"
assertequals false false "notEqual null"
assertequals false false "land 1"
assertequals true true "land 2"
assertequals true true "lessThan 1"
assertequals false false "lessThan 2"
assertequals true true "lessThanEq 1"
assertequals false false "lessThanEq 2"
assertequals true true "greaterThan 1"
assertequals false false "greaterThan 2"
assertequals true true "greaterThanEq 1"
assertequals false false "greaterThanEq 2"
assertequals false false "strictEqual 1"
assertequals true true "strictEqual 2"
assertequals 4 4 "shl"
assertequals 2 2 "shr"
assertequals 3 3 "or"
assertequals 2 2 "and"
assertequals 1 1 "xor"
assertequals -1 -1 "not 1"
assertequals -65536 -65536 "not 2"
assertequals -188900977659376 -188900977659376 "not 3"
assertequals 4 4 "max"
assertequals 2 2 "min"
assertequals 2 2 "abs"
assertequals 1 1 "log"
assertequals 1 1 "log10"
assertequals 2 2 "floor"
assertequals 3 3 "ceil"
assertequals 4 4 "sqrt"
assertequals 45 45 "angle"
assertequals 90 90 "angleDiff"
assertequals -8 -8 "unary minus"
assertequals 1 true "boolean negation 1"
assertequals 0 false "boolean negation 2"
assertequals 0 false "boolean negation 3"
assertequals 16 16 "**="
assertequals 8 8 "*="
assertequals 1.5 1.5 "/="
assertequals 1 1 "\="
assertequals 2 2 "%="
assertequals 6 6 "+="
assertequals 2 2 "-="
assertequals 4 4 "<<="
assertequals 2 2 ">>="
assertequals 3 3 "|="
assertequals 2 2 "&="
assertequals 1 1 "^="
assertequals false false "&&="
assertequals true true "&&="
assertequals true true "||="
stop
