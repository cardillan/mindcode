   140 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
     6 instructions eliminated by Dead Code Elimination (4 iterations).
     1 instructions eliminated by Single Step Elimination (5 iterations).
     2 instructions modified by Expression Optimization (2 iterations).
    77 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
    17 instructions added by Function Inlining (3 iterations).
     6 function calls inlined by Function Inlining.
    71 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 897):
  * Inline function 'assertEqualsRound' defined at line 3:1      cost    19, benefit       27.0, efficiency        1.4 (-25 instructions)
    Inline function call at line 71:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 72:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 73:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 75:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 76:1                            cost     4, benefit        4.5, efficiency        1.1
    Inline function call at line 77:1                            cost     4, benefit        4.5, efficiency        1.1

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
   135 stop
   136 end
   137 label *label3
-    * op mul *tmp4 :assertEqualsRound.0:actual 100000000
-    * set :round.0:x *tmp4
+  138 op mul :round.0:x :assertEqualsRound.0:actual 100000000
   139 op add *tmp6 :round.0:x 0.5
-    * op floor *tmp7 *tmp6
-    * set *tmp5 *tmp7
+  140 op floor *tmp5 *tmp6
   141 label *label11
   142 op div *tmp8 *tmp5 100000000
   143 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1:
 
   123 op xor :a :a 2
   124 assertequals 1 :a "^="
   125 set :a 1
-    * op land :a :a 0
+  126 set :a false
   127 assertequals false :a "&&="
   128 set :a 1
   129 op land :a :a 2
   130 assertequals true :a "&&="
   131 set :a 0
-    * op or *tmp3 :a 2
+  132 set *tmp3 true
   133 op notEqual :a *tmp3 false
   134 assertequals true :a "||="
   135 stop

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
    31 assertequals -1 -1 "not 1"
    32 assertequals -65536 -65536 "not 2"
    33 set :a 0xabcdefabcdef
-    * op add *tmp0 :a 1
-    * op sub *tmp1 0 *tmp0
-    * op not *tmp2 :a
-    * assertequals *tmp1 *tmp2 "not 3"
+   34 op add *tmp0 0xabcdefabcdef 1
+   35 op sub *tmp1 0 188900977659376
+   36 op not *tmp2 0xabcdefabcdef
+   37 assertequals -188900977659376 -188900977659376 "not 3"
    38 assertequals 4 4 "max"
    39 assertequals 2 2 "min"
    40 assertequals 2 2 "abs"
 
    87 assertequals 0 false "boolean negation 2"
    88 assertequals 0 false "boolean negation 3"
    89 set :a 2
-    * op pow :a :a 4
-    * assertequals 16 :a "**="
+   90 op pow :a 2 4
+   91 assertequals 16 16 "**="
    92 set :a 2
-    * op mul :a :a 4
-    * assertequals 8 :a "*="
+   93 op mul :a 2 4
+   94 assertequals 8 8 "*="
    95 set :a 6
-    * op div :a :a 4
-    * assertequals 1.5 :a "/="
+   96 op div :a 6 4
+   97 assertequals 1.5 1.5 "/="
    98 set :a 6
-    * op idiv :a :a 4
-    * assertequals 1 :a "\="
+   99 op idiv :a 6 4
+  100 assertequals 1 1 "\="
   101 set :a 6
-    * op mod :a :a 4
-    * assertequals 2 :a "%="
+  102 op mod :a 6 4
+  103 assertequals 2 2 "%="
   104 set :a 4
-    * op add :a :a 2
-    * assertequals 6 :a "+="
+  105 op add :a 4 2
+  106 assertequals 6 6 "+="
   107 set :a 4
-    * op sub :a :a 2
-    * assertequals 2 :a "-="
+  108 op sub :a 4 2
+  109 assertequals 2 2 "-="
   110 set :a 1
-    * op shl :a :a 2
-    * assertequals 4 :a "<<="
+  111 op shl :a 1 2
+  112 assertequals 4 4 "<<="
   113 set :a 9
-    * op shr :a :a 2
-    * assertequals 2 :a ">>="
+  114 op shr :a 9 2
+  115 assertequals 2 2 ">>="
   116 set :a 1
-    * op or :a :a 2
-    * assertequals 3 :a "|="
+  117 op or :a 1 2
+  118 assertequals 3 3 "|="
   119 set :a 3
-    * op and :a :a 2
-    * assertequals 2 :a "&="
+  120 op and :a 3 2
+  121 assertequals 2 2 "&="
   122 set :a 3
-    * op xor :a :a 2
-    * assertequals 1 :a "^="
-    * set :a 1
+  123 op xor :a 3 2
+  124 assertequals 1 1 "^="
   125 set :a false
-    * assertequals false :a "&&="
+  126 assertequals false false "&&="
   127 set :a 1
-    * op land :a :a 2
-    * assertequals true :a "&&="
-    * set :a 0
+  128 op land :a 1 2
+  129 assertequals true true "&&="
   130 set *tmp3 true
-    * op notEqual :a *tmp3 false
-    * assertequals true :a "||="
+  131 op notEqual :a true false
+  132 assertequals true true "||="
   133 stop
   134 end
   135 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-33 instructions):
 
    30 assertequals 1 1 "xor"
    31 assertequals -1 -1 "not 1"
    32 assertequals -65536 -65536 "not 2"
-    * set :a 0xabcdefabcdef
-    * op add *tmp0 0xabcdefabcdef 1
-    * op sub *tmp1 0 188900977659376
-    * op not *tmp2 0xabcdefabcdef
    33 assertequals -188900977659376 -188900977659376 "not 3"
    34 assertequals 4 4 "max"
    35 assertequals 2 2 "min"
 
    82 assertequals 1 true "boolean negation 1"
    83 assertequals 0 false "boolean negation 2"
    84 assertequals 0 false "boolean negation 3"
-    * set :a 2
-    * op pow :a 2 4
    85 assertequals 16 16 "**="
-    * set :a 2
-    * op mul :a 2 4
    86 assertequals 8 8 "*="
-    * set :a 6
-    * op div :a 6 4
    87 assertequals 1.5 1.5 "/="
-    * set :a 6
-    * op idiv :a 6 4
    88 assertequals 1 1 "\="
-    * set :a 6
-    * op mod :a 6 4
    89 assertequals 2 2 "%="
-    * set :a 4
-    * op add :a 4 2
    90 assertequals 6 6 "+="
-    * set :a 4
-    * op sub :a 4 2
    91 assertequals 2 2 "-="
-    * set :a 1
-    * op shl :a 1 2
    92 assertequals 4 4 "<<="
-    * set :a 9
-    * op shr :a 9 2
    93 assertequals 2 2 ">>="
-    * set :a 1
-    * op or :a 1 2
    94 assertequals 3 3 "|="
-    * set :a 3
-    * op and :a 3 2
    95 assertequals 2 2 "&="
-    * set :a 3
-    * op xor :a 3 2
    96 assertequals 1 1 "^="
-    * set :a false
    97 assertequals false false "&&="
-    * set :a 1
-    * op land :a 1 2
    98 assertequals true true "&&="
-    * set *tmp3 true
-    * op notEqual :a true false
    99 assertequals true true "||="
   100 stop
   101 end

Modifications by Inline function 'assertEqualsRound' defined at line 3:1 (+17 instructions):
 
    46 set :assertEqualsRound.0:actual 1
    47 set :assertEqualsRound.0:title "sin"
    48 setaddr :assertEqualsRound.0*retaddr *label4 (h:*label4)
-    * call *label3 *invalid :assertEqualsRound.0*retval (m:*label4) (h:*label4)
-    * label *label4
+   49 label *label12
+   50 op mul :round.0:x :assertEqualsRound.0:actual 100000000
+   51 op add *tmp6 :round.0:x 0.5
+   52 op floor *tmp5 *tmp6
+   53 label *label13
+   54 op div *tmp8 *tmp5 100000000
+   55 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   56 label *label14
    57 set :assertEqualsRound.0:expected -1
    58 set :assertEqualsRound.0:actual -1
    59 set :assertEqualsRound.0:title "cos"
    60 setaddr :assertEqualsRound.0*retaddr *label5 (h:*label5)
-    * call *label3 *invalid :assertEqualsRound.0*retval (m:*label5) (h:*label5)
-    * label *label5
+   61 label *label15
+   62 op mul :round.0:x :assertEqualsRound.0:actual 100000000
+   63 op add *tmp6 :round.0:x 0.5
+   64 op floor *tmp5 *tmp6
+   65 label *label16
+   66 op div *tmp8 *tmp5 100000000
+   67 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   68 label *label17
    69 set :assertEqualsRound.0:expected 1
    70 set :assertEqualsRound.0:actual 0.9999999999999999
    71 set :assertEqualsRound.0:title "tan"
    72 setaddr :assertEqualsRound.0*retaddr *label6 (h:*label6)
-    * call *label3 *invalid :assertEqualsRound.0*retval (m:*label6) (h:*label6)
-    * label *label6
+   73 label *label18
+   74 op mul :round.0:x :assertEqualsRound.0:actual 100000000
+   75 op add *tmp6 :round.0:x 0.5
+   76 op floor *tmp5 *tmp6
+   77 label *label19
+   78 op div *tmp8 *tmp5 100000000
+   79 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   80 label *label20
    81 set :assertEqualsRound.0:expected 90
    82 set :assertEqualsRound.0:actual 90
    83 set :assertEqualsRound.0:title "asin"
    84 setaddr :assertEqualsRound.0*retaddr *label7 (h:*label7)
-    * call *label3 *invalid :assertEqualsRound.0*retval (m:*label7) (h:*label7)
-    * label *label7
+   85 label *label21
+   86 op mul :round.0:x :assertEqualsRound.0:actual 100000000
+   87 op add *tmp6 :round.0:x 0.5
+   88 op floor *tmp5 *tmp6
+   89 label *label22
+   90 op div *tmp8 *tmp5 100000000
+   91 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   92 label *label23
    93 set :assertEqualsRound.0:expected 0
    94 set :assertEqualsRound.0:actual 0
    95 set :assertEqualsRound.0:title "acos"
    96 setaddr :assertEqualsRound.0*retaddr *label8 (h:*label8)
-    * call *label3 *invalid :assertEqualsRound.0*retval (m:*label8) (h:*label8)
-    * label *label8
+   97 label *label24
+   98 op mul :round.0:x :assertEqualsRound.0:actual 100000000
+   99 op add *tmp6 :round.0:x 0.5
+  100 op floor *tmp5 *tmp6
+  101 label *label25
+  102 op div *tmp8 *tmp5 100000000
+  103 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+  104 label *label26
   105 set :assertEqualsRound.0:expected 45
   106 set :assertEqualsRound.0:actual 45
   107 set :assertEqualsRound.0:title "atan"
   108 setaddr :assertEqualsRound.0*retaddr *label9 (h:*label9)
-    * call *label3 *invalid :assertEqualsRound.0*retval (m:*label9) (h:*label9)
-    * label *label9
+  109 label *label27
+  110 op mul :round.0:x :assertEqualsRound.0:actual 100000000
+  111 op add *tmp6 :round.0:x 0.5
+  112 op floor *tmp5 *tmp6
+  113 label *label28
+  114 op div *tmp8 *tmp5 100000000
+  115 assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+  116 label *label29
   117 assertequals -8 -8 "unary minus"
   118 assertequals 1 true "boolean negation 1"
   119 assertequals 0 false "boolean negation 2"
 
   135 assertequals true true "||="
   136 stop
   137 end
-    * label *label3
-    * op mul :round.0:x :assertEqualsRound.0:actual 100000000
-    * op add *tmp6 :round.0:x 0.5
-    * op floor *tmp5 *tmp6
-    * label *label11
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
-    * label *label10
-    * return :assertEqualsRound.0*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    47 set :assertEqualsRound.0:title "sin"
    48 setaddr :assertEqualsRound.0*retaddr *label4 (h:*label4)
    49 label *label12
-    * op mul :round.0:x :assertEqualsRound.0:actual 100000000
-    * op add *tmp6 :round.0:x 0.5
-    * op floor *tmp5 *tmp6
+   50 op mul :round.0:x 1 100000000
+   51 op add *tmp6 100000000 0.5
+   52 op floor *tmp5 100000000.5
    53 label *label13
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   54 op div *tmp8 100000000 100000000
+   55 assertequals 1 1 "sin"
    56 label *label14
    57 set :assertEqualsRound.0:expected -1
    58 set :assertEqualsRound.0:actual -1
    59 set :assertEqualsRound.0:title "cos"
    60 setaddr :assertEqualsRound.0*retaddr *label5 (h:*label5)
    61 label *label15
-    * op mul :round.0:x :assertEqualsRound.0:actual 100000000
-    * op add *tmp6 :round.0:x 0.5
-    * op floor *tmp5 *tmp6
+   62 op mul :round.0:x -1 100000000
+   63 op add *tmp6 -100000000 0.5
+   64 op floor *tmp5 -99999999.5
    65 label *label16
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   66 op div *tmp8 -100000000 100000000
+   67 assertequals -1 -1 "cos"
    68 label *label17
    69 set :assertEqualsRound.0:expected 1
    70 set :assertEqualsRound.0:actual 0.9999999999999999
    71 set :assertEqualsRound.0:title "tan"
    72 setaddr :assertEqualsRound.0*retaddr *label6 (h:*label6)
    73 label *label18
-    * op mul :round.0:x :assertEqualsRound.0:actual 100000000
-    * op add *tmp6 :round.0:x 0.5
-    * op floor *tmp5 *tmp6
+   74 op mul :round.0:x 0.9999999999999999 100000000
+   75 op add *tmp6 99999999.99999999 0.5
+   76 op floor *tmp5 100000000.49999999
    77 label *label19
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   78 op div *tmp8 100000000 100000000
+   79 assertequals 1 1 "tan"
    80 label *label20
    81 set :assertEqualsRound.0:expected 90
    82 set :assertEqualsRound.0:actual 90
    83 set :assertEqualsRound.0:title "asin"
    84 setaddr :assertEqualsRound.0*retaddr *label7 (h:*label7)
    85 label *label21
-    * op mul :round.0:x :assertEqualsRound.0:actual 100000000
-    * op add *tmp6 :round.0:x 0.5
-    * op floor *tmp5 *tmp6
+   86 op mul :round.0:x 90 100000000
+   87 op add *tmp6 9000000000 0.5
+   88 op floor *tmp5 9000000000.5
    89 label *label22
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+   90 op div *tmp8 9000000000 100000000
+   91 assertequals 90 90 "asin"
    92 label *label23
    93 set :assertEqualsRound.0:expected 0
    94 set :assertEqualsRound.0:actual 0
    95 set :assertEqualsRound.0:title "acos"
    96 setaddr :assertEqualsRound.0*retaddr *label8 (h:*label8)
    97 label *label24
-    * op mul :round.0:x :assertEqualsRound.0:actual 100000000
-    * op add *tmp6 :round.0:x 0.5
-    * op floor *tmp5 *tmp6
+   98 op mul :round.0:x 0 100000000
+   99 op add *tmp6 0 0.5
+  100 op floor *tmp5 0.5
   101 label *label25
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+  102 op div *tmp8 0 100000000
+  103 assertequals 0 0 "acos"
   104 label *label26
   105 set :assertEqualsRound.0:expected 45
   106 set :assertEqualsRound.0:actual 45
   107 set :assertEqualsRound.0:title "atan"
   108 setaddr :assertEqualsRound.0*retaddr *label9 (h:*label9)
   109 label *label27
-    * op mul :round.0:x :assertEqualsRound.0:actual 100000000
-    * op add *tmp6 :round.0:x 0.5
-    * op floor *tmp5 *tmp6
+  110 op mul :round.0:x 45 100000000
+  111 op add *tmp6 4500000000 0.5
+  112 op floor *tmp5 4500000000.5
   113 label *label28
-    * op div *tmp8 *tmp5 100000000
-    * assertequals :assertEqualsRound.0:expected *tmp8 :assertEqualsRound.0:title
+  114 op div *tmp8 4500000000 100000000
+  115 assertequals 45 45 "atan"
   116 label *label29
   117 assertequals -8 -8 "unary minus"
   118 assertequals 1 true "boolean negation 1"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-42 instructions):
 
    42 assertequals 45 45 "angle"
    43 assertequals 90 90 "angleDiff"
    44 assertequals 5 5 "len"
-    * set :assertEqualsRound.0:expected 1
-    * set :assertEqualsRound.0:actual 1
-    * set :assertEqualsRound.0:title "sin"
    45 setaddr :assertEqualsRound.0*retaddr *label4 (h:*label4)
    46 label *label12
-    * op mul :round.0:x 1 100000000
-    * op add *tmp6 100000000 0.5
-    * op floor *tmp5 100000000.5
    47 label *label13
-    * op div *tmp8 100000000 100000000
    48 assertequals 1 1 "sin"
    49 label *label14
-    * set :assertEqualsRound.0:expected -1
-    * set :assertEqualsRound.0:actual -1
-    * set :assertEqualsRound.0:title "cos"
    50 setaddr :assertEqualsRound.0*retaddr *label5 (h:*label5)
    51 label *label15
-    * op mul :round.0:x -1 100000000
-    * op add *tmp6 -100000000 0.5
-    * op floor *tmp5 -99999999.5
    52 label *label16
-    * op div *tmp8 -100000000 100000000
    53 assertequals -1 -1 "cos"
    54 label *label17
-    * set :assertEqualsRound.0:expected 1
-    * set :assertEqualsRound.0:actual 0.9999999999999999
-    * set :assertEqualsRound.0:title "tan"
    55 setaddr :assertEqualsRound.0*retaddr *label6 (h:*label6)
    56 label *label18
-    * op mul :round.0:x 0.9999999999999999 100000000
-    * op add *tmp6 99999999.99999999 0.5
-    * op floor *tmp5 100000000.49999999
    57 label *label19
-    * op div *tmp8 100000000 100000000
    58 assertequals 1 1 "tan"
    59 label *label20
-    * set :assertEqualsRound.0:expected 90
-    * set :assertEqualsRound.0:actual 90
-    * set :assertEqualsRound.0:title "asin"
    60 setaddr :assertEqualsRound.0*retaddr *label7 (h:*label7)
    61 label *label21
-    * op mul :round.0:x 90 100000000
-    * op add *tmp6 9000000000 0.5
-    * op floor *tmp5 9000000000.5
    62 label *label22
-    * op div *tmp8 9000000000 100000000
    63 assertequals 90 90 "asin"
    64 label *label23
-    * set :assertEqualsRound.0:expected 0
-    * set :assertEqualsRound.0:actual 0
-    * set :assertEqualsRound.0:title "acos"
    65 setaddr :assertEqualsRound.0*retaddr *label8 (h:*label8)
    66 label *label24
-    * op mul :round.0:x 0 100000000
-    * op add *tmp6 0 0.5
-    * op floor *tmp5 0.5
    67 label *label25
-    * op div *tmp8 0 100000000
    68 assertequals 0 0 "acos"
    69 label *label26
-    * set :assertEqualsRound.0:expected 45
-    * set :assertEqualsRound.0:actual 45
-    * set :assertEqualsRound.0:title "atan"
    70 setaddr :assertEqualsRound.0*retaddr *label9 (h:*label9)
    71 label *label27
-    * op mul :round.0:x 45 100000000
-    * op add *tmp6 4500000000 0.5
-    * op floor *tmp5 4500000000.5
    72 label *label28
-    * op div *tmp8 4500000000 100000000
    73 assertequals 45 45 "atan"
    74 label *label29
    75 assertequals -8 -8 "unary minus"

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
    43 assertequals 90 90 "angleDiff"
    44 assertequals 5 5 "len"
    45 setaddr :assertEqualsRound.0*retaddr *label4 (h:*label4)
-    * label *label12
-    * label *label13
    46 assertequals 1 1 "sin"
-    * label *label14
    47 setaddr :assertEqualsRound.0*retaddr *label5 (h:*label5)
-    * label *label15
-    * label *label16
    48 assertequals -1 -1 "cos"
-    * label *label17
    49 setaddr :assertEqualsRound.0*retaddr *label6 (h:*label6)
-    * label *label18
-    * label *label19
    50 assertequals 1 1 "tan"
-    * label *label20
    51 setaddr :assertEqualsRound.0*retaddr *label7 (h:*label7)
-    * label *label21
-    * label *label22
    52 assertequals 90 90 "asin"
-    * label *label23
    53 setaddr :assertEqualsRound.0*retaddr *label8 (h:*label8)
-    * label *label24
-    * label *label25
    54 assertequals 0 0 "acos"
-    * label *label26
    55 setaddr :assertEqualsRound.0*retaddr *label9 (h:*label9)
-    * label *label27
-    * label *label28
    56 assertequals 45 45 "atan"
-    * label *label29
    57 assertequals -8 -8 "unary minus"
    58 assertequals 1 true "boolean negation 1"
    59 assertequals 0 false "boolean negation 2"

Modifications by Jumps phase, Dead Code Elimination, pass 3, iteration 1 (-6 instructions):
 
    42 assertequals 45 45 "angle"
    43 assertequals 90 90 "angleDiff"
    44 assertequals 5 5 "len"
-    * setaddr :assertEqualsRound.0*retaddr *label4 (h:*label4)
    45 assertequals 1 1 "sin"
-    * setaddr :assertEqualsRound.0*retaddr *label5 (h:*label5)
    46 assertequals -1 -1 "cos"
-    * setaddr :assertEqualsRound.0*retaddr *label6 (h:*label6)
    47 assertequals 1 1 "tan"
-    * setaddr :assertEqualsRound.0*retaddr *label7 (h:*label7)
    48 assertequals 90 90 "asin"
-    * setaddr :assertEqualsRound.0*retaddr *label8 (h:*label8)
    49 assertequals 0 0 "acos"
-    * setaddr :assertEqualsRound.0*retaddr *label9 (h:*label9)
    50 assertequals 45 45 "atan"
    51 assertequals -8 -8 "unary minus"
    52 assertequals 1 true "boolean negation 1"

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
    68 assertequals true true "&&="
    69 assertequals true true "||="
    70 stop
-    * end

Final code before resolving virtual instructions:

assertequals 5 5 "add"
assertequals 1 1 "sub"
assertequals 6 6 "mul"
assertequals 1.5 1.5 "div"
assertequals 0.00001 0.00001 "div exp"
assertequals 1 1 "idiv"
assertequals 2 2 "mod"
assertequals 16 16 "pow"
assertequals true true "equal 1"
assertequals false false "equal 2"
assertequals true true "equal null"
assertequals false false "notEqual 1"
assertequals true true "notEqual 2"
assertequals false false "notEqual null"
assertequals false false "land 1"
assertequals true true "land 2"
assertequals true true "lessThan 1"
assertequals false false "lessThan 2"
assertequals true true "lessThanEq 1"
assertequals false false "lessThanEq 2"
assertequals true true "greaterThan 1"
assertequals false false "greaterThan 2"
assertequals true true "greaterThanEq 1"
assertequals false false "greaterThanEq 2"
assertequals false false "strictEqual 1"
assertequals true true "strictEqual 2"
assertequals 4 4 "shl"
assertequals 2 2 "shr"
assertequals 3 3 "or"
assertequals 2 2 "and"
assertequals 1 1 "xor"
assertequals -1 -1 "not 1"
assertequals -65536 -65536 "not 2"
assertequals -188900977659376 -188900977659376 "not 3"
assertequals 4 4 "max"
assertequals 2 2 "min"
assertequals 2 2 "abs"
assertequals 1 1 "log"
assertequals 1 1 "log10"
assertequals 2 2 "floor"
assertequals 3 3 "ceil"
assertequals 4 4 "sqrt"
assertequals 45 45 "angle"
assertequals 90 90 "angleDiff"
assertequals 5 5 "len"
assertequals 1 1 "sin"
assertequals -1 -1 "cos"
assertequals 1 1 "tan"
assertequals 90 90 "asin"
assertequals 0 0 "acos"
assertequals 45 45 "atan"
assertequals -8 -8 "unary minus"
assertequals 1 true "boolean negation 1"
assertequals 0 false "boolean negation 2"
assertequals 0 false "boolean negation 3"
assertequals 16 16 "**="
assertequals 8 8 "*="
assertequals 1.5 1.5 "/="
assertequals 1 1 "\="
assertequals 2 2 "%="
assertequals 6 6 "+="
assertequals 2 2 "-="
assertequals 4 4 "<<="
assertequals 2 2 ">>="
assertequals 3 3 "|="
assertequals 2 2 "&="
assertequals 1 1 "^="
assertequals false false "&&="
assertequals true true "&&="
assertequals true true "||="
stop
