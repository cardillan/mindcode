    39 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
     5 instructions eliminated by Dead Code Elimination (3 iterations).
     2 instructions eliminated by Jump Optimization (4 iterations).
     2 instructions eliminated by Single Step Elimination (5 iterations).
     1 instructions eliminated by Data Flow Optimization (5 iterations).
     1 instructions modified by Loop Optimization (3 iterations).
     1 loops improved by Loop Optimization.
     2 instructions eliminated by Jump Straightening (4 iterations).
     1 instructions eliminated by Unreachable Code Elimination.
    24 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-5 instructions):
 
    12 op equal *tmp4 :test.0:i 3
    13 jump *label5 equal *tmp4 false
    14 jump *label3 always
-    * set *tmp5 null
    15 jump *label6 always
    16 label *label5
-    * set *tmp5 null
    17 label *label6
    18 print :test.0:i
    19 print "|"
 
    23 op equal *tmp7 :test.0:i *tmp6
    24 jump *label7 equal *tmp7 false
    25 jump *label4 always
-    * set *tmp8 null
    26 jump *label8 always
    27 label *label7
-    * set *tmp8 null
    28 label *label8
    29 label *label3
    30 op add :test.0:i :test.0:i 1
    31 jump *label2 always
    32 label *label4
-    * set *tmp0 null
    33 label *label1
    34 assertprints "1|2|4|5|" "iterated-for-loop-break-continue"
    35 stop

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
 
     4 set *tmp1 :d.0*retval
     5 set :d.0:n 10
     6 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp2 :d.0*retval
-    * set *tmp3 *tmp2
+    7 set *tmp3 :d.0*retval
     8 set :test.0:i *tmp1
     9 label *label2
    10 jump *label4 greaterThanEq :test.0:i *tmp3
 
    18 print "|"
    19 set :d.0:n 5
    20 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp6 :d.0*retval
-    * op equal *tmp7 :test.0:i *tmp6
+   21 op equal *tmp7 :test.0:i :d.0*retval
    22 jump *label7 equal *tmp7 false
    23 jump *label4 always
    24 jump *label8 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-2 instructions):
 
     8 set :test.0:i *tmp1
     9 label *label2
    10 jump *label4 greaterThanEq :test.0:i *tmp3
-    * op equal *tmp4 :test.0:i 3
-    * jump *label5 equal *tmp4 false
+   11 jump *label5 notEqual :test.0:i 3
    12 jump *label3 always
    13 jump *label6 always
    14 label *label5
 
    17 print "|"
    18 set :d.0:n 5
    19 call *label0 :d.0*retaddr :d.0*retval
-    * op equal *tmp7 :test.0:i :d.0*retval
-    * jump *label7 equal *tmp7 false
+   20 jump *label7 notEqual :test.0:i :d.0*retval
    21 jump *label4 always
    22 jump *label8 always
    23 label *label7

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    10 jump *label4 greaterThanEq :test.0:i *tmp3
    11 jump *label5 notEqual :test.0:i 3
    12 jump *label3 always
-    * jump *label6 always
    13 label *label5
    14 label *label6
    15 print :test.0:i
 
    18 call *label0 :d.0*retaddr :d.0*retval
    19 jump *label7 notEqual :test.0:i :d.0*retval
    20 jump *label4 always
-    * jump *label8 always
    21 label *label7
    22 label *label8
    23 label *label3

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     8 set :test.0:i *tmp1
     9 label *label2
    10 jump *label4 greaterThanEq :test.0:i *tmp3
+   11 label *label10
    12 jump *label5 notEqual :test.0:i 3
    13 jump *label3 always
    14 label *label5
 
    23 label *label8
    24 label *label3
    25 op add :test.0:i :test.0:i 1
-    * jump *label2 always
+   26 jump *label10 lessThan :test.0:i *tmp3
    27 label *label4
    28 label *label1
    29 assertprints "1|2|4|5|" "iterated-for-loop-break-continue"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
     1 # "Function: def test()"
     2 set :d.0:n 1
     3 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp1 :d.0*retval
+    4 set :test.0:i :d.0*retval
     5 set :d.0:n 10
     6 call *label0 :d.0*retaddr :d.0*retval
     7 set *tmp3 :d.0*retval
-    * set :test.0:i *tmp1
     8 label *label2
     9 jump *label4 greaterThanEq :test.0:i *tmp3
    10 label *label10

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2:
 
     6 call *label0 :d.0*retaddr :d.0*retval
     7 set *tmp3 :d.0*retval
     8 label *label2
-    * jump *label4 greaterThanEq :test.0:i *tmp3
+    9 jump *label4 greaterThanEq :test.0:i :d.0*retval
    10 label *label10
    11 jump *label5 notEqual :test.0:i 3
    12 jump *label3 always

Modifications by Final phase, Jump Straightening, iteration 1 (-2 instructions):
 
     8 label *label2
     9 jump *label4 greaterThanEq :test.0:i :d.0*retval
    10 label *label10
-    * jump *label5 notEqual :test.0:i 3
-    * jump *label3 always
+   11 jump *label3 equal :test.0:i 3
    12 label *label5
    13 label *label6
    14 print :test.0:i
    15 print "|"
    16 set :d.0:n 5
    17 call *label0 :d.0*retaddr :d.0*retval
-    * jump *label7 notEqual :test.0:i :d.0*retval
-    * jump *label4 always
+   18 jump *label4 equal :test.0:i :d.0*retval
    19 label *label7
    20 label *label8
    21 label *label3

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-1 instructions):
 
    31 set :d.0*retval :d.0:n
    32 label *label9
    33 return :d.0*retaddr
-    * end

Final code before resolving virtual instructions:

assertflush
# "Function: def test()"
set :d.0:n 1
call *label0 :d.0*retaddr :d.0*retval
set :test.0:i :d.0*retval
set :d.0:n 10
call *label0 :d.0*retaddr :d.0*retval
set *tmp3 :d.0*retval
jump *label4 greaterThanEq :test.0:i :d.0*retval
label *label10
jump *label3 equal :test.0:i 3
print :test.0:i
print "|"
set :d.0:n 5
call *label0 :d.0*retaddr :d.0*retval
jump *label4 equal :test.0:i :d.0*retval
label *label3
op add :test.0:i :test.0:i 1
jump *label10 lessThan :test.0:i *tmp3
label *label4
assertprints "1|2|4|5|" "iterated-for-loop-break-continue"
stop
end
label *label0
# "Function: noinline def d(in n)"
set :d.0*retval :d.0:n
return :d.0*retaddr
