    70 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (6 iterations).
     1 instructions eliminated by Case Expression Optimization.
     1 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
       1 loop conditions were partially rotated.
     7 instructions eliminated by Jump Straightening (3 passes, 9 iterations).
     1 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (3 iterations).
    49 instructions after optimizations.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
     9 set :test:i *tmp1
    10 label *label2
    11 jump *label4 greaterThan :test:i *tmp3
-    * set *tmp5 :test:i
    12 set :d:n 1
    13 call *label0 :d*retaddr :d*retval
    14 set *tmp6 :d*retval
-    * jump *label7 equal *tmp5 *tmp6
+   15 jump *label7 equal :test:i *tmp6
    16 jump *label6 always
    17 label *label7
    18 set *tmp4 "A"
 
    21 set :d:n 2
    22 call *label0 :d*retaddr :d*retval
    23 set *tmp7 :d*retval
-    * jump *label9 equal *tmp5 *tmp7
+   24 jump *label9 equal :test:i *tmp7
    25 set :d:n 3
    26 call *label0 :d*retaddr :d*retval
    27 set *tmp8 :d*retval
-    * jump *label9 equal *tmp5 *tmp8
-    * jump *label9 equal *tmp5 4
+   28 jump *label9 equal :test:i *tmp8
+   29 jump *label9 equal :test:i 4
    30 jump *label8 always
    31 label *label9
    32 set *tmp4 "B"
    33 jump *label5 always
    34 label *label8
-    * jump *label11 equal *tmp5 5
+   35 jump *label11 equal :test:i 5
    36 jump *label10 always
    37 label *label11
    38 jump *label3 always
 
    42 set :d:n 6
    43 call *label0 :d*retaddr :d*retval
    44 set *tmp9 :d*retval
-    * jump *label14 lessThan *tmp5 *tmp9
+   45 jump *label14 lessThan :test:i *tmp9
    46 set :d:n 8
    47 call *label0 :d*retaddr :d*retval
    48 set *tmp10 :d*retval
-    * jump *label13 lessThanEq *tmp5 *tmp10
+   49 jump *label13 lessThanEq :test:i *tmp10
    50 label *label14
    51 jump *label12 always
    52 label *label13
    53 set *tmp4 "C"
    54 jump *label5 always
    55 label *label12
-    * jump *label16 equal *tmp5 10
+   56 jump *label16 equal :test:i 10
    57 jump *label15 always
    58 label *label16
    59 jump *label4 always

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-1 instructions):
 
    68 op add :test:i :test:i 1
    69 jump *label2 always
    70 label *label4
-    * set *tmp0 null
    71 label *label1
    72 assertprints "ABBBCCCD" "complex-case-expression"
    73 stop

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
     4 set *tmp1 :d*retval
     5 set :d:n 10
     6 call *label0 :d*retaddr :d*retval
-    * set *tmp2 :d*retval
-    * set *tmp3 *tmp2
+    7 set *tmp3 :d*retval
     8 set :test:i *tmp1
     9 label *label2
    10 jump *label4 greaterThan :test:i *tmp3
    11 set :d:n 1
    12 call *label0 :d*retaddr :d*retval
-    * set *tmp6 :d*retval
-    * jump *label7 equal :test:i *tmp6
+   13 jump *label7 equal :test:i :d*retval
    14 jump *label6 always
    15 label *label7
    16 set *tmp4 "A"
 
    18 label *label6
    19 set :d:n 2
    20 call *label0 :d*retaddr :d*retval
-    * set *tmp7 :d*retval
-    * jump *label9 equal :test:i *tmp7
+   21 jump *label9 equal :test:i :d*retval
    22 set :d:n 3
    23 call *label0 :d*retaddr :d*retval
-    * set *tmp8 :d*retval
-    * jump *label9 equal :test:i *tmp8
+   24 jump *label9 equal :test:i :d*retval
    25 jump *label9 equal :test:i 4
    26 jump *label8 always
    27 label *label9
 
    37 label *label10
    38 set :d:n 6
    39 call *label0 :d*retaddr :d*retval
-    * set *tmp9 :d*retval
-    * jump *label14 lessThan :test:i *tmp9
+   40 jump *label14 lessThan :test:i :d*retval
    41 set :d:n 8
    42 call *label0 :d*retaddr :d*retval
-    * set *tmp10 :d*retval
-    * jump *label13 lessThanEq :test:i *tmp10
+   43 jump *label13 lessThanEq :test:i :d*retval
    44 label *label14
    45 jump *label12 always
    46 label *label13

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-4 instructions):
 
    10 jump *label4 greaterThan :test:i *tmp3
    11 set :d:n 1
    12 call *label0 :d*retaddr :d*retval
-    * jump *label7 equal :test:i :d*retval
-    * jump *label6 always
+   13 jump *label6 notEqual :test:i :d*retval
    14 label *label7
    15 set *tmp4 "A"
    16 jump *label5 always
 
    21 set :d:n 3
    22 call *label0 :d*retaddr :d*retval
    23 jump *label9 equal :test:i :d*retval
-    * jump *label9 equal :test:i 4
-    * jump *label8 always
+   24 jump *label8 notEqual :test:i 4
    25 label *label9
    26 set *tmp4 "B"
    27 jump *label5 always
    28 label *label8
-    * jump *label11 equal :test:i 5
-    * jump *label10 always
+   29 jump *label10 notEqual :test:i 5
    30 label *label11
    31 jump *label3 always
    32 set *tmp4 null
 
    44 set *tmp4 "C"
    45 jump *label5 always
    46 label *label12
-    * jump *label16 equal :test:i 10
-    * jump *label15 always
+   47 jump *label15 notEqual :test:i 10
    48 label *label16
    49 jump *label4 always
    50 set *tmp4 null

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
    29 jump *label10 notEqual :test:i 5
    30 label *label11
    31 jump *label3 always
-    * set *tmp4 null
    32 jump *label5 always
    33 label *label10
    34 set :d:n 6
 
    46 jump *label15 notEqual :test:i 10
    47 label *label16
    48 jump *label4 always
-    * set *tmp4 null
    49 jump *label5 always
    50 label *label15
    51 set *tmp4 "D"
    52 label *label5
    53 set :test:str *tmp4
-    * print :test:str
+   54 print *tmp4
    55 label *label3
    56 op add :test:i :test:i 1
    57 jump *label2 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    50 label *label15
    51 set *tmp4 "D"
    52 label *label5
-    * set :test:str *tmp4
    53 print *tmp4
    54 label *label3
    55 op add :test:i :test:i 1

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     8 set :test:i *tmp1
     9 label *label2
    10 jump *label4 greaterThan :test:i *tmp3
+   11 label *label18
    12 set :d:n 1
    13 call *label0 :d*retaddr :d*retval
    14 jump *label6 notEqual :test:i :d*retval
 
    54 print *tmp4
    55 label *label3
    56 op add :test:i :test:i 1
-    * jump *label2 always
+   57 jump *label18 lessThanEq :test:i *tmp3
    58 label *label4
    59 label *label1
    60 assertprints "ABBBCCCD" "complex-case-expression"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
     7 set *tmp3 :d*retval
     8 set :test:i *tmp1
     9 label *label2
-    * jump *label4 greaterThan :test:i *tmp3
+   10 jump *label4 greaterThan *tmp1 :d*retval
    11 label *label18
    12 set :d:n 1
    13 call *label0 :d*retaddr :d*retval

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
     6 call *label0 :d*retaddr :d*retval
     7 set *tmp3 :d*retval
     8 set :test:i *tmp1
-    * label *label2
     9 jump *label4 greaterThan *tmp1 :d*retval
    10 label *label18
    11 set :d:n 1
    12 call *label0 :d*retaddr :d*retval
    13 jump *label6 notEqual :test:i :d*retval
-    * label *label7
    14 set *tmp4 "A"
    15 jump *label5 always
    16 label *label6
 
    26 jump *label5 always
    27 label *label8
    28 jump *label10 notEqual :test:i 5
-    * label *label11
    29 jump *label3 always
-    * jump *label5 always
    30 label *label10
    31 set :d:n 6
    32 call *label0 :d*retaddr :d*retval
 
    41 jump *label5 always
    42 label *label12
    43 jump *label15 notEqual :test:i 10
-    * label *label16
    44 jump *label4 always
-    * jump *label5 always
    45 label *label15
    46 set *tmp4 "D"
    47 label *label5
 
    50 op add :test:i :test:i 1
    51 jump *label18 lessThanEq :test:i *tmp3
    52 label *label4
-    * label *label1
    53 assertprints "ABBBCCCD" "complex-case-expression"
    54 stop
    55 end
    56 label *label0
    57 # "Function: noinline def d(in n)"
    58 set :d*retval :d:n
-    * label *label17
    59 return :d*retaddr
-    * end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-2 instructions):
 
    25 set *tmp4 "B"
    26 jump *label5 always
    27 label *label8
-    * jump *label10 notEqual :test:i 5
-    * jump *label3 always
+   28 jump *label3 equal :test:i 5
    29 label *label10
    30 set :d:n 6
    31 call *label0 :d*retaddr :d*retval
 
    39 set *tmp4 "C"
    40 jump *label5 always
    41 label *label12
-    * jump *label15 notEqual :test:i 10
-    * jump *label4 always
+   42 jump *label4 equal :test:i 10
    43 label *label15
    44 set *tmp4 "D"
    45 label *label5

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    28 jump *label3 equal :test:i 5
    29 set :d:n 6
    30 call *label0 :d*retaddr :d*retval
-    * jump *label14 lessThan :test:i :d*retval
+   31 jump *label12 lessThan :test:i :d*retval
    32 set :d:n 8
    33 call *label0 :d*retaddr :d*retval
    34 jump *label13 lessThanEq :test:i :d*retval

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-1 instructions):
 
    31 jump *label12 lessThan :test:i :d*retval
    32 set :d:n 8
    33 call *label0 :d*retaddr :d*retval
-    * jump *label13 lessThanEq :test:i :d*retval
-    * jump *label12 always
+   34 jump *label12 greaterThan :test:i :d*retval
    35 label *label13
    36 set *tmp4 "C"
    37 jump *label5 always

Final code before resolving virtual instructions:

assertflush
# "Function: def test()"
set :d:n 1
call *label0 :d*retaddr :d*retval
set *tmp1 :d*retval
set :d:n 10
call *label0 :d*retaddr :d*retval
set *tmp3 :d*retval
set :test:i *tmp1
jump *label4 greaterThan *tmp1 :d*retval
label *label18
set :d:n 1
call *label0 :d*retaddr :d*retval
jump *label6 notEqual :test:i :d*retval
set *tmp4 "A"
jump *label5 always
label *label6
set :d:n 2
call *label0 :d*retaddr :d*retval
jump *label9 equal :test:i :d*retval
set :d:n 3
call *label0 :d*retaddr :d*retval
jump *label9 equal :test:i :d*retval
jump *label8 notEqual :test:i 4
label *label9
set *tmp4 "B"
jump *label5 always
label *label8
jump *label3 equal :test:i 5
set :d:n 6
call *label0 :d*retaddr :d*retval
jump *label12 lessThan :test:i :d*retval
set :d:n 8
call *label0 :d*retaddr :d*retval
jump *label12 greaterThan :test:i :d*retval
set *tmp4 "C"
jump *label5 always
label *label12
jump *label4 equal :test:i 10
set *tmp4 "D"
label *label5
print *tmp4
label *label3
op add :test:i :test:i 1
jump *label18 lessThanEq :test:i *tmp3
label *label4
assertprints "ABBBCCCD" "complex-case-expression"
stop
end
label *label0
# "Function: noinline def d(in n)"
set :d*retval :d:n
return :d*retaddr
