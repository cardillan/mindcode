    70 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
     1 instructions eliminated by Dead Code Elimination (3 iterations).
     4 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     1 instructions modified by Loop Optimization (3 iterations).
     1 loops improved by Loop Optimization.
     4 instructions eliminated by Jump Straightening (2 passes, 4 iterations).
     1 instructions updated by JumpThreading.
     3 instructions eliminated by Unreachable Code Elimination.
    51 instructions after optimizations.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
     8 set :test.0:i *tmp1
     9 label *label2
    10 jump *label4 greaterThan :test.0:i *tmp3
-    * set *tmp5 :test.0:i
    11 set :d.0:n 1
    12 call *label0 :d.0*retaddr :d.0*retval
    13 set *tmp6 :d.0*retval
-    * jump *label7 equal *tmp5 *tmp6
+   14 jump *label7 equal :test.0:i *tmp6
    15 jump *label6 always
    16 label *label7
    17 set *tmp4 "A"
 
    20 set :d.0:n 2
    21 call *label0 :d.0*retaddr :d.0*retval
    22 set *tmp7 :d.0*retval
-    * jump *label9 equal *tmp5 *tmp7
+   23 jump *label9 equal :test.0:i *tmp7
    24 set :d.0:n 3
    25 call *label0 :d.0*retaddr :d.0*retval
    26 set *tmp8 :d.0*retval
-    * jump *label9 equal *tmp5 *tmp8
-    * jump *label9 equal *tmp5 4
+   27 jump *label9 equal :test.0:i *tmp8
+   28 jump *label9 equal :test.0:i 4
    29 jump *label8 always
    30 label *label9
    31 set *tmp4 "B"
    32 jump *label5 always
    33 label *label8
-    * jump *label11 equal *tmp5 5
+   34 jump *label11 equal :test.0:i 5
    35 jump *label10 always
    36 label *label11
    37 jump *label3 always
 
    41 set :d.0:n 6
    42 call *label0 :d.0*retaddr :d.0*retval
    43 set *tmp9 :d.0*retval
-    * jump *label14 lessThan *tmp5 *tmp9
+   44 jump *label14 lessThan :test.0:i *tmp9
    45 set :d.0:n 8
    46 call *label0 :d.0*retaddr :d.0*retval
    47 set *tmp10 :d.0*retval
-    * jump *label13 lessThanEq *tmp5 *tmp10
+   48 jump *label13 lessThanEq :test.0:i *tmp10
    49 label *label14
    50 jump *label12 always
    51 label *label13
    52 set *tmp4 "C"
    53 jump *label5 always
    54 label *label12
-    * jump *label16 equal *tmp5 10
+   55 jump *label16 equal :test.0:i 10
    56 jump *label15 always
    57 label *label16
    58 jump *label4 always

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-1 instructions):
 
    67 op add :test.0:i :test.0:i 1
    68 jump *label2 always
    69 label *label4
-    * set *tmp0 null
    70 label *label1
    71 assertprints "ABBBCCCD" "complex-case-expression"
    72 stop

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
     3 set *tmp1 :d.0*retval
     4 set :d.0:n 10
     5 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp2 :d.0*retval
-    * set *tmp3 *tmp2
+    6 set *tmp3 :d.0*retval
     7 set :test.0:i *tmp1
     8 label *label2
     9 jump *label4 greaterThan :test.0:i *tmp3
    10 set :d.0:n 1
    11 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp6 :d.0*retval
-    * jump *label7 equal :test.0:i *tmp6
+   12 jump *label7 equal :test.0:i :d.0*retval
    13 jump *label6 always
    14 label *label7
    15 set *tmp4 "A"
 
    17 label *label6
    18 set :d.0:n 2
    19 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp7 :d.0*retval
-    * jump *label9 equal :test.0:i *tmp7
+   20 jump *label9 equal :test.0:i :d.0*retval
    21 set :d.0:n 3
    22 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp8 :d.0*retval
-    * jump *label9 equal :test.0:i *tmp8
+   23 jump *label9 equal :test.0:i :d.0*retval
    24 jump *label9 equal :test.0:i 4
    25 jump *label8 always
    26 label *label9
 
    36 label *label10
    37 set :d.0:n 6
    38 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp9 :d.0*retval
-    * jump *label14 lessThan :test.0:i *tmp9
+   39 jump *label14 lessThan :test.0:i :d.0*retval
    40 set :d.0:n 8
    41 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp10 :d.0*retval
-    * jump *label13 lessThanEq :test.0:i *tmp10
+   42 jump *label13 lessThanEq :test.0:i :d.0*retval
    43 label *label14
    44 jump *label12 always
    45 label *label13

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
    21 set :d.0:n 3
    22 call *label0 :d.0*retaddr :d.0*retval
    23 jump *label9 equal :test.0:i :d.0*retval
-    * jump *label9 equal :test.0:i 4
-    * jump *label8 always
+   24 jump *label8 notEqual :test.0:i 4
    25 label *label9
    26 set *tmp4 "B"
    27 jump *label5 always
    28 label *label8
-    * jump *label11 equal :test.0:i 5
-    * jump *label10 always
+   29 jump *label10 notEqual :test.0:i 5
    30 label *label11
    31 jump *label3 always
    32 set *tmp4 null
 
    44 set *tmp4 "C"
    45 jump *label5 always
    46 label *label12
-    * jump *label16 equal :test.0:i 10
-    * jump *label15 always
+   47 jump *label15 notEqual :test.0:i 10
    48 label *label16
    49 jump *label4 always
    50 set *tmp4 null

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
    29 jump *label10 notEqual :test.0:i 5
    30 label *label11
    31 jump *label3 always
-    * set *tmp4 null
    32 jump *label5 always
    33 label *label10
    34 set :d.0:n 6
 
    46 jump *label15 notEqual :test.0:i 10
    47 label *label16
    48 jump *label4 always
-    * set *tmp4 null
    49 jump *label5 always
    50 label *label15
    51 set *tmp4 "D"
    52 label *label5
    53 set :test.0:str *tmp4
-    * print :test.0:str
+   54 print *tmp4
    55 label *label3
    56 op add :test.0:i :test.0:i 1
    57 jump *label2 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    50 label *label15
    51 set *tmp4 "D"
    52 label *label5
-    * set :test.0:str *tmp4
    53 print *tmp4
    54 label *label3
    55 op add :test.0:i :test.0:i 1

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     7 set :test.0:i *tmp1
     8 label *label2
     9 jump *label4 greaterThan :test.0:i *tmp3
+   10 label *label18
    11 set :d.0:n 1
    12 call *label0 :d.0*retaddr :d.0*retval
    13 jump *label7 equal :test.0:i :d.0*retval
 
    54 print *tmp4
    55 label *label3
    56 op add :test.0:i :test.0:i 1
-    * jump *label2 always
+   57 jump *label18 lessThanEq :test.0:i *tmp3
    58 label *label4
    59 label *label1
    60 assertprints "ABBBCCCD" "complex-case-expression"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
     0 assertflush
     1 set :d.0:n 1
     2 call *label0 :d.0*retaddr :d.0*retval
-    * set *tmp1 :d.0*retval
+    3 set :test.0:i :d.0*retval
     4 set :d.0:n 10
     5 call *label0 :d.0*retaddr :d.0*retval
     6 set *tmp3 :d.0*retval
-    * set :test.0:i *tmp1
     7 label *label2
     8 jump *label4 greaterThan :test.0:i *tmp3
     9 label *label18

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2:
 
     5 call *label0 :d.0*retaddr :d.0*retval
     6 set *tmp3 :d.0*retval
     7 label *label2
-    * jump *label4 greaterThan :test.0:i *tmp3
+    8 jump *label4 greaterThan :test.0:i :d.0*retval
     9 label *label18
    10 set :d.0:n 1
    11 call *label0 :d.0*retaddr :d.0*retval

Modifications by Final phase, Jump Straightening, iteration 1 (-1 instructions):
 
     9 label *label18
    10 set :d.0:n 1
    11 call *label0 :d.0*retaddr :d.0*retval
-    * jump *label7 equal :test.0:i :d.0*retval
-    * jump *label6 always
+   12 jump *label6 notEqual :test.0:i :d.0*retval
    13 label *label7
    14 set *tmp4 "A"
    15 jump *label5 always

Modifications by Final phase, Jump Threading, iteration 1:
 
    32 label *label10
    33 set :d.0:n 6
    34 call *label0 :d.0*retaddr :d.0*retval
-    * jump *label14 lessThan :test.0:i :d.0*retval
+   35 jump *label12 lessThan :test.0:i :d.0*retval
    36 set :d.0:n 8
    37 call *label0 :d.0*retaddr :d.0*retval
    38 jump *label13 lessThanEq :test.0:i :d.0*retval

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-3 instructions):
 
    28 jump *label10 notEqual :test.0:i 5
    29 label *label11
    30 jump *label3 always
-    * jump *label5 always
    31 label *label10
    32 set :d.0:n 6
    33 call *label0 :d.0*retaddr :d.0*retval
 
    44 jump *label15 notEqual :test.0:i 10
    45 label *label16
    46 jump *label4 always
-    * jump *label5 always
    47 label *label15
    48 set *tmp4 "D"
    49 label *label5
 
    60 set :d.0*retval :d.0:n
    61 label *label17
    62 return :d.0*retaddr
-    * end

Final code before resolving virtual instructions:

assertflush
set :d.0:n 1
call *label0 :d.0*retaddr :d.0*retval
set :test.0:i :d.0*retval
set :d.0:n 10
call *label0 :d.0*retaddr :d.0*retval
set *tmp3 :d.0*retval
jump *label4 greaterThan :test.0:i :d.0*retval
label *label18
set :d.0:n 1
call *label0 :d.0*retaddr :d.0*retval
jump *label6 notEqual :test.0:i :d.0*retval
set *tmp4 "A"
jump *label5 always
label *label6
set :d.0:n 2
call *label0 :d.0*retaddr :d.0*retval
jump *label9 equal :test.0:i :d.0*retval
set :d.0:n 3
call *label0 :d.0*retaddr :d.0*retval
jump *label9 equal :test.0:i :d.0*retval
jump *label8 notEqual :test.0:i 4
label *label9
set *tmp4 "B"
jump *label5 always
label *label8
jump *label10 notEqual :test.0:i 5
jump *label3 always
label *label10
set :d.0:n 6
call *label0 :d.0*retaddr :d.0*retval
jump *label12 lessThan :test.0:i :d.0*retval
set :d.0:n 8
call *label0 :d.0*retaddr :d.0*retval
jump *label13 lessThanEq :test.0:i :d.0*retval
jump *label12 always
label *label13
set *tmp4 "C"
jump *label5 always
label *label12
jump *label15 notEqual :test.0:i 10
jump *label4 always
label *label15
set *tmp4 "D"
label *label5
print *tmp4
label *label3
op add :test.0:i :test.0:i 1
jump *label18 lessThanEq :test.0:i *tmp3
label *label4
assertprints "ABBBCCCD" "complex-case-expression"
stop
end
label *label0
set :d.0*retval :d.0:n
return :d.0*retaddr
