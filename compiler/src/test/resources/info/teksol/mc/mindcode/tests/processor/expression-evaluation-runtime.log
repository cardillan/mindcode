   437 instructions before optimizations.
    75 instructions eliminated by Temp Variables Elimination (2 iterations).
     1 instructions eliminated by Single Step Elimination (6 iterations).
     1 instructions modified by Expression Optimization (3 iterations).
     3 instructions eliminated by If Expression Optimization (3 iterations).
   201 instructions eliminated by Data Flow Optimization (3 passes, 13 iterations).
    11 instructions added by Function Inlining (4 iterations).
     6 function calls inlined by Function Inlining.
   168 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 799):
  * Inline function 'assertEqualsRound' defined at line 3:1      size   +19, benefit       27.0, efficiency      1.421 (-31 instructions)
    Inline function call at line 87:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 88:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 89:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 91:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 92:1                            size    +4, benefit        4.5, efficiency      1.125
    Inline function call at line 93:1                            size    +4, benefit        4.5, efficiency      1.125

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-75 instructions):
     0 set NULL null
     1 set zero 0
     2 set :d:n 3
-    * op add *tmp1 zero :d:n
-    * set *tmp0 *tmp1
+    3 op add *tmp0 zero :d:n
     4 label *label4
     5 op add *tmp2 2 *tmp0
     6 assertequals 5 *tmp2 "add"
     7 set :d.1:n 6
-    * op add *tmp4 zero :d.1:n
-    * set *tmp3 *tmp4
+    8 op add *tmp3 zero :d.1:n
     9 label *label5
    10 op sub *tmp5 7 *tmp3
    11 assertequals 1 *tmp5 "sub"
    12 set :d.2:n 2
-    * op add *tmp7 zero :d.2:n
-    * set *tmp6 *tmp7
+   13 op add *tmp6 zero :d.2:n
    14 label *label6
    15 op mul *tmp8 3 *tmp6
    16 assertequals 6 *tmp8 "mul"
    17 set :d.3:n 4
-    * op add *tmp10 zero :d.3:n
-    * set *tmp9 *tmp10
+   18 op add *tmp9 zero :d.3:n
    19 label *label7
    20 op div *tmp11 6 *tmp9
    21 assertequals 1.5 *tmp11 "div"
    22 set :d.4:n 100000
-    * op add *tmp13 zero :d.4:n
-    * set *tmp12 *tmp13
+   23 op add *tmp12 zero :d.4:n
    24 label *label8
    25 op div *tmp14 1 *tmp12
    26 assertequals 0.00001 *tmp14 "div exp"
    27 set :d.5:n 4
-    * op add *tmp16 zero :d.5:n
-    * set *tmp15 *tmp16
+   28 op add *tmp15 zero :d.5:n
    29 label *label9
    30 op idiv *tmp17 6 *tmp15
    31 assertequals 1 *tmp17 "idiv"
    32 set :d.6:n 4
-    * op add *tmp19 zero :d.6:n
-    * set *tmp18 *tmp19
+   33 op add *tmp18 zero :d.6:n
    34 label *label10
    35 op mod *tmp20 6 *tmp18
    36 assertequals 2 *tmp20 "mod"
    37 set :d.7:n 8
-    * op add *tmp22 zero :d.7:n
-    * set *tmp21 *tmp22
+   38 op add *tmp21 zero :d.7:n
    39 label *label11
    40 op emod *tmp23 -3 *tmp21
    41 assertequals 5 *tmp23 "emod"
    42 set :d.8:n 4
-    * op add *tmp25 zero :d.8:n
-    * set *tmp24 *tmp25
+   43 op add *tmp24 zero :d.8:n
    44 label *label12
    45 op pow *tmp26 2 *tmp24
    46 assertequals 16 *tmp26 "pow"
    47 set :d.9:n 5
-    * op add *tmp28 zero :d.9:n
-    * set *tmp27 *tmp28
+   48 op add *tmp27 zero :d.9:n
    49 label *label13
    50 op equal *tmp29 5 *tmp27
    51 assertequals true *tmp29 "equal 1"
    52 set :d.10:n 6
-    * op add *tmp31 zero :d.10:n
-    * set *tmp30 *tmp31
+   53 op add *tmp30 zero :d.10:n
    54 label *label14
    55 op equal *tmp32 5 *tmp30
    56 assertequals false *tmp32 "equal 2"
    57 set :d.11:n null
-    * op add *tmp34 zero :d.11:n
-    * set *tmp33 *tmp34
+   58 op add *tmp33 zero :d.11:n
    59 label *label15
    60 op equal *tmp35 0 *tmp33
    61 assertequals true *tmp35 "equal null"
    62 set :d.12:n 5
-    * op add *tmp37 zero :d.12:n
-    * set *tmp36 *tmp37
+   63 op add *tmp36 zero :d.12:n
    64 label *label16
    65 op notEqual *tmp38 5 *tmp36
    66 assertequals false *tmp38 "notEqual 1"
    67 set :d.13:n 6
-    * op add *tmp40 zero :d.13:n
-    * set *tmp39 *tmp40
+   68 op add *tmp39 zero :d.13:n
    69 label *label17
    70 op notEqual *tmp41 5 *tmp39
    71 assertequals true *tmp41 "notEqual 2"
    72 set :d.14:n null
-    * op add *tmp43 zero :d.14:n
-    * set *tmp42 *tmp43
+   73 op add *tmp42 zero :d.14:n
    74 label *label18
    75 op notEqual *tmp44 0 *tmp42
    76 assertequals false *tmp44 "notEqual null"
    77 set :d.15:n 0
-    * op add *tmp46 zero :d.15:n
-    * set *tmp45 *tmp46
+   78 op add *tmp45 zero :d.15:n
    79 label *label19
    80 op land *tmp47 1 *tmp45
    81 assertequals false *tmp47 "land 1"
    82 set :d.16:n 2
-    * op add *tmp49 zero :d.16:n
-    * set *tmp48 *tmp49
+   83 op add *tmp48 zero :d.16:n
    84 label *label20
    85 op land *tmp50 1 *tmp48
    86 assertequals true *tmp50 "land 2"
    87 set :d.17:n 1
-    * op add *tmp52 zero :d.17:n
-    * set *tmp51 *tmp52
+   88 op add *tmp51 zero :d.17:n
    89 label *label21
    90 op lessThan *tmp53 0 *tmp51
    91 assertequals true *tmp53 "lessThan 1"
    92 set :d.18:n 0
-    * op add *tmp55 zero :d.18:n
-    * set *tmp54 *tmp55
+   93 op add *tmp54 zero :d.18:n
    94 label *label22
    95 op lessThan *tmp56 1 *tmp54
    96 assertequals false *tmp56 "lessThan 2"
    97 set :d.19:n 1
-    * op add *tmp58 zero :d.19:n
-    * set *tmp57 *tmp58
+   98 op add *tmp57 zero :d.19:n
    99 label *label23
   100 op lessThanEq *tmp59 1 *tmp57
   101 assertequals true *tmp59 "lessThanEq 1"
   102 set :d.20:n 0
-    * op add *tmp61 zero :d.20:n
-    * set *tmp60 *tmp61
+  103 op add *tmp60 zero :d.20:n
   104 label *label24
   105 op lessThanEq *tmp62 1 *tmp60
   106 assertequals false *tmp62 "lessThanEq 2"
   107 set :d.21:n 1
-    * op add *tmp64 zero :d.21:n
-    * set *tmp63 *tmp64
+  108 op add *tmp63 zero :d.21:n
   109 label *label25
   110 op greaterThan *tmp65 2 *tmp63
   111 assertequals true *tmp65 "greaterThan 1"
   112 set :d.22:n 2
-    * op add *tmp67 zero :d.22:n
-    * set *tmp66 *tmp67
+  113 op add *tmp66 zero :d.22:n
   114 label *label26
   115 op greaterThan *tmp68 1 *tmp66
   116 assertequals false *tmp68 "greaterThan 2"
   117 set :d.23:n 1
-    * op add *tmp70 zero :d.23:n
-    * set *tmp69 *tmp70
+  118 op add *tmp69 zero :d.23:n
   119 label *label27
   120 op greaterThanEq *tmp71 1 *tmp69
   121 assertequals true *tmp71 "greaterThanEq 1"
   122 set :d.24:n 2
-    * op add *tmp73 zero :d.24:n
-    * set *tmp72 *tmp73
+  123 op add *tmp72 zero :d.24:n
   124 label *label28
   125 op greaterThanEq *tmp74 1 *tmp72
   126 assertequals false *tmp74 "greaterThanEq 2"
 
   129 op strictEqual *tmp76 null NULL
   130 assertequals true *tmp76 "strictEqual 2"
   131 set :d.25:n 2
-    * op add *tmp78 zero :d.25:n
-    * set *tmp77 *tmp78
+  132 op add *tmp77 zero :d.25:n
   133 label *label29
   134 op shl *tmp79 1 *tmp77
   135 assertequals 4 *tmp79 "shl"
   136 set :d.26:n 2
-    * op add *tmp81 zero :d.26:n
-    * set *tmp80 *tmp81
+  137 op add *tmp80 zero :d.26:n
   138 label *label30
   139 op shr *tmp82 9 *tmp80
   140 assertequals 2 *tmp82 "shr"
   141 set :d.27:n 61
-    * op add *tmp84 zero :d.27:n
-    * set *tmp83 *tmp84
+  142 op add *tmp83 zero :d.27:n
   143 label *label31
   144 op ushr *tmp85 -1 *tmp83
   145 assertequals 7 *tmp85 "ushr"
   146 set :d.28:n 2
-    * op add *tmp87 zero :d.28:n
-    * set *tmp86 *tmp87
+  147 op add *tmp86 zero :d.28:n
   148 label *label32
   149 op or *tmp88 1 *tmp86
   150 assertequals 3 *tmp88 "or"
   151 set :d.29:n 2
-    * op add *tmp90 zero :d.29:n
-    * set *tmp89 *tmp90
+  152 op add *tmp89 zero :d.29:n
   153 label *label33
   154 op and *tmp91 3 *tmp89
   155 assertequals 2 *tmp91 "and"
   156 set :d.30:n 2
-    * op add *tmp93 zero :d.30:n
-    * set *tmp92 *tmp93
+  157 op add *tmp92 zero :d.30:n
   158 label *label34
   159 op xor *tmp94 3 *tmp92
   160 assertequals 1 *tmp94 "xor"
   161 set :d.31:n 0
-    * op add *tmp96 zero :d.31:n
-    * set *tmp95 *tmp96
+  162 op add *tmp95 zero :d.31:n
   163 label *label35
   164 op not *tmp97 *tmp95
   165 assertequals -1 *tmp97 "not 1"
   166 set :d.32:n 65535
-    * op add *tmp99 zero :d.32:n
-    * set *tmp98 *tmp99
+  167 op add *tmp98 zero :d.32:n
   168 label *label36
   169 op not *tmp100 *tmp98
   170 assertequals -65536 *tmp100 "not 2"
 
   172 op add *tmp101 :a 1
   173 op sub *tmp102 0 *tmp101
   174 set :d.33:n :a
-    * op add *tmp104 zero :d.33:n
-    * set *tmp103 *tmp104
+  175 op add *tmp103 zero :d.33:n
   176 label *label37
   177 op not *tmp105 *tmp103
   178 assertequals *tmp102 *tmp105 "not 3"
   179 set :d.34:n 4
-    * op add *tmp107 zero :d.34:n
-    * set *tmp106 *tmp107
+  180 op add *tmp106 zero :d.34:n
   181 label *label38
   182 op max *tmp108 2 *tmp106
   183 assertequals 4 *tmp108 "max"
   184 set :d.35:n 4
-    * op add *tmp110 zero :d.35:n
-    * set *tmp109 *tmp110
+  185 op add *tmp109 zero :d.35:n
   186 label *label39
   187 op min *tmp111 2 *tmp109
   188 assertequals 2 *tmp111 "min"
   189 set :d.36:n -2
-    * op add *tmp113 zero :d.36:n
-    * set *tmp112 *tmp113
+  190 op add *tmp112 zero :d.36:n
   191 label *label40
   192 op abs *tmp114 *tmp112
   193 assertequals 2 *tmp114 "abs"
   194 set :d.37:n -2
-    * op add *tmp116 zero :d.37:n
-    * set *tmp115 *tmp116
+  195 op add *tmp115 zero :d.37:n
   196 label *label41
   197 set :sign:x *tmp115
   198 op greaterThan *tmp118 :sign:x 0
   199 op lessThan *tmp119 :sign:x 0
-    * op sub *tmp120 *tmp118 *tmp119
-    * set *tmp117 *tmp120
+  200 op sub *tmp117 *tmp118 *tmp119
   201 label *label42
   202 assertequals -1 *tmp117 "sign(-2)"
   203 set :d.38:n 2
-    * op add *tmp122 zero :d.38:n
-    * set *tmp121 *tmp122
+  204 op add *tmp121 zero :d.38:n
   205 label *label43
   206 set :sign.1:x *tmp121
   207 op greaterThan *tmp124 :sign.1:x 0
   208 op lessThan *tmp125 :sign.1:x 0
-    * op sub *tmp126 *tmp124 *tmp125
-    * set *tmp123 *tmp126
+  209 op sub *tmp123 *tmp124 *tmp125
   210 label *label44
   211 assertequals 1 *tmp123 "sign(2)"
   212 set :d.39:n 0
-    * op add *tmp128 zero :d.39:n
-    * set *tmp127 *tmp128
+  213 op add *tmp127 zero :d.39:n
   214 label *label45
   215 set :sign.2:x *tmp127
   216 op greaterThan *tmp130 :sign.2:x 0
   217 op lessThan *tmp131 :sign.2:x 0
-    * op sub *tmp132 *tmp130 *tmp131
-    * set *tmp129 *tmp132
+  218 op sub *tmp129 *tmp130 *tmp131
   219 label *label46
   220 assertequals 0 *tmp129 "sign(0)"
   221 set :d.40:n 2.718281828459045
-    * op add *tmp134 zero :d.40:n
-    * set *tmp133 *tmp134
+  222 op add *tmp133 zero :d.40:n
   223 label *label47
   224 op log *tmp135 *tmp133
   225 assertequals 1 *tmp135 "log"
   226 set :d.41:n 10
-    * op add *tmp137 zero :d.41:n
-    * set *tmp136 *tmp137
+  227 op add *tmp136 zero :d.41:n
   228 label *label48
   229 op log10 *tmp138 *tmp136
   230 assertequals 1 *tmp138 "log10"
   231 set :d.42:n 2
-    * op add *tmp140 zero :d.42:n
-    * set *tmp139 *tmp140
+  232 op add *tmp139 zero :d.42:n
   233 label *label49
   234 set :logn:number 16
   235 set :logn:base *tmp139
   236 op log *tmp142 :logn:number
   237 op log *tmp143 :logn:base
-    * op div *tmp144 *tmp142 *tmp143
-    * set *tmp141 *tmp144
+  238 op div *tmp141 *tmp142 *tmp143
   239 label *label50
   240 assertequals 4 *tmp141 "logn"
   241 set :d.43:n 2.5
-    * op add *tmp146 zero :d.43:n
-    * set *tmp145 *tmp146
+  242 op add *tmp145 zero :d.43:n
   243 label *label51
   244 op floor *tmp147 *tmp145
   245 assertequals 2 *tmp147 "floor"
   246 set :d.44:n 2.5
-    * op add *tmp149 zero :d.44:n
-    * set *tmp148 *tmp149
+  247 op add *tmp148 zero :d.44:n
   248 label *label52
   249 op ceil *tmp150 *tmp148
   250 assertequals 3 *tmp150 "ceil"
   251 set :d.45:n 2.5
-    * op add *tmp152 zero :d.45:n
-    * set *tmp151 *tmp152
+  252 op add *tmp151 zero :d.45:n
   253 label *label53
   254 set :round:x *tmp151
   255 op add *tmp154 :round:x 0.5
-    * op floor *tmp155 *tmp154
-    * set *tmp153 *tmp155
+  256 op floor *tmp153 *tmp154
   257 label *label54
   258 assertequals 3 *tmp153 "round"
   259 set :d.46:n 16
-    * op add *tmp157 zero :d.46:n
-    * set *tmp156 *tmp157
+  260 op add *tmp156 zero :d.46:n
   261 label *label55
   262 op sqrt *tmp158 *tmp156
   263 assertequals 4 *tmp158 "sqrt"
   264 set :d.47:n 1
-    * op add *tmp160 zero :d.47:n
-    * set *tmp159 *tmp160
+  265 op add *tmp159 zero :d.47:n
   266 label *label56
   267 op angle *tmp161 1 *tmp159
   268 assertequals 45 *tmp161 "angle"
   269 set :d.48:n 135
-    * op add *tmp163 zero :d.48:n
-    * set *tmp162 *tmp163
+  270 op add *tmp162 zero :d.48:n
   271 label *label57
   272 op angleDiff *tmp164 45 *tmp162
   273 assertequals 90 *tmp164 "angleDiff"
 
   309 call *label3 *invalid :assertEqualsRound*retval (m:*label63) (h:*label63)
   310 label *label63
   311 set :d.49:n 8
-    * op add *tmp166 zero :d.49:n
-    * set *tmp165 *tmp166
+  312 op add *tmp165 zero :d.49:n
   313 label *label64
   314 op sub *tmp167 0 *tmp165
   315 assertequals -8 *tmp167 "unary minus"
   316 set :d.50:n 0
-    * op add *tmp169 zero :d.50:n
-    * set *tmp168 *tmp169
+  317 op add *tmp168 zero :d.50:n
   318 label *label65
   319 op equal *tmp170 *tmp168 false
   320 assertequals 1 *tmp170 "boolean negation 1"
   321 set :d.51:n 1
-    * op add *tmp172 zero :d.51:n
-    * set *tmp171 *tmp172
+  322 op add *tmp171 zero :d.51:n
   323 label *label66
   324 op equal *tmp173 *tmp171 false
   325 assertequals 0 *tmp173 "boolean negation 2"
   326 set :d.52:n 2
-    * op add *tmp175 zero :d.52:n
-    * set *tmp174 *tmp175
+  327 op add *tmp174 zero :d.52:n
   328 label *label67
   329 op equal *tmp176 *tmp174 false
   330 assertequals 0 *tmp176 "boolean negation 3"
   331 set :a 2
   332 set :d.53:n 4
-    * op add *tmp178 zero :d.53:n
-    * set *tmp177 *tmp178
+  333 op add *tmp177 zero :d.53:n
   334 label *label68
   335 op pow :a :a *tmp177
   336 assertequals 16 :a "**="
   337 set :a 2
   338 set :d.54:n 4
-    * op add *tmp180 zero :d.54:n
-    * set *tmp179 *tmp180
+  339 op add *tmp179 zero :d.54:n
   340 label *label69
   341 op mul :a :a *tmp179
   342 assertequals 8 :a "*="
   343 set :a 6
   344 set :d.55:n 4
-    * op add *tmp182 zero :d.55:n
-    * set *tmp181 *tmp182
+  345 op add *tmp181 zero :d.55:n
   346 label *label70
   347 op div :a :a *tmp181
   348 assertequals 1.5 :a "/="
   349 set :a 6
   350 set :d.56:n 4
-    * op add *tmp184 zero :d.56:n
-    * set *tmp183 *tmp184
+  351 op add *tmp183 zero :d.56:n
   352 label *label71
   353 op idiv :a :a *tmp183
   354 assertequals 1 :a "\="
   355 set :a 6
   356 set :d.57:n 4
-    * op add *tmp186 zero :d.57:n
-    * set *tmp185 *tmp186
+  357 op add *tmp185 zero :d.57:n
   358 label *label72
   359 op mod :a :a *tmp185
   360 assertequals 2 :a "%="
   361 set :a 4
   362 set :d.58:n 2
-    * op add *tmp188 zero :d.58:n
-    * set *tmp187 *tmp188
+  363 op add *tmp187 zero :d.58:n
   364 label *label73
   365 op add :a :a *tmp187
   366 assertequals 6 :a "+="
   367 set :a 4
   368 set :d.59:n 2
-    * op add *tmp190 zero :d.59:n
-    * set *tmp189 *tmp190
+  369 op add *tmp189 zero :d.59:n
   370 label *label74
   371 op sub :a :a *tmp189
   372 assertequals 2 :a "-="
   373 set :a 1
   374 set :d.60:n 2
-    * op add *tmp192 zero :d.60:n
-    * set *tmp191 *tmp192
+  375 op add *tmp191 zero :d.60:n
   376 label *label75
   377 op shl :a :a *tmp191
   378 assertequals 4 :a "<<="
   379 set :a 9
   380 set :d.61:n 2
-    * op add *tmp194 zero :d.61:n
-    * set *tmp193 *tmp194
+  381 op add *tmp193 zero :d.61:n
   382 label *label76
   383 op shr :a :a *tmp193
   384 assertequals 2 :a ">>="
   385 set :a 1
   386 set :d.62:n 2
-    * op add *tmp196 zero :d.62:n
-    * set *tmp195 *tmp196
+  387 op add *tmp195 zero :d.62:n
   388 label *label77
   389 op or :a :a *tmp195
   390 assertequals 3 :a "|="
   391 set :a 3
   392 set :d.63:n 2
-    * op add *tmp198 zero :d.63:n
-    * set *tmp197 *tmp198
+  393 op add *tmp197 zero :d.63:n
   394 label *label78
   395 op and :a :a *tmp197
   396 assertequals 2 :a "&="
   397 set :a 3
   398 set :d.64:n 2
-    * op add *tmp200 zero :d.64:n
-    * set *tmp199 *tmp200
+  399 op add *tmp199 zero :d.64:n
   400 label *label79
   401 op xor :a :a *tmp199
   402 assertequals 1 :a "^="
   403 set :a 1
   404 set :d.65:n 0
-    * op add *tmp202 zero :d.65:n
-    * set *tmp201 *tmp202
+  405 op add *tmp201 zero :d.65:n
   406 label *label80
   407 op land :a :a *tmp201
   408 assertequals false :a "&&="
   409 set :a 1
   410 set :d.66:n 2
-    * op add *tmp204 zero :d.66:n
-    * set *tmp203 *tmp204
+  411 op add *tmp203 zero :d.66:n
   412 label *label81
   413 op land :a :a *tmp203
   414 assertequals true :a "&&="
   415 set :a 0
   416 set :d.67:n 2
-    * op add *tmp206 zero :d.67:n
-    * set *tmp205 *tmp206
+  417 op add *tmp205 zero :d.67:n
   418 label *label82
   419 op or *tmp207 :a *tmp205
   420 op notEqual :a *tmp207 false
 
   435 stop
   436 end
   437 label *label3
-    * op mul *tmp211 :assertEqualsRound:actual 100000000
-    * set :round.1:x *tmp211
+  438 op mul :round.1:x :assertEqualsRound:actual 100000000
   439 op add *tmp213 :round.1:x 0.5
-    * op floor *tmp214 *tmp213
-    * set *tmp212 *tmp214
+  440 op floor *tmp212 *tmp213
   441 label *label87
   442 op div *tmp215 *tmp212 100000000
   443 assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set NULL null
     1 set zero 0
     2 set :d:n 3
-    * op add *tmp0 zero :d:n
+    3 op add *tmp0 zero 3
     4 label *label4
     5 op add *tmp2 2 *tmp0
     6 assertequals 5 *tmp2 "add"
     7 set :d.1:n 6
-    * op add *tmp3 zero :d.1:n
+    8 op add *tmp3 zero 6
     9 label *label5
    10 op sub *tmp5 7 *tmp3
    11 assertequals 1 *tmp5 "sub"
    12 set :d.2:n 2
-    * op add *tmp6 zero :d.2:n
+   13 op add *tmp6 zero 2
    14 label *label6
    15 op mul *tmp8 3 *tmp6
    16 assertequals 6 *tmp8 "mul"
    17 set :d.3:n 4
-    * op add *tmp9 zero :d.3:n
+   18 op add *tmp9 zero 4
    19 label *label7
    20 op div *tmp11 6 *tmp9
    21 assertequals 1.5 *tmp11 "div"
    22 set :d.4:n 100000
-    * op add *tmp12 zero :d.4:n
+   23 op add *tmp12 zero 100000
    24 label *label8
    25 op div *tmp14 1 *tmp12
    26 assertequals 0.00001 *tmp14 "div exp"
    27 set :d.5:n 4
-    * op add *tmp15 zero :d.5:n
+   28 op add *tmp15 zero 4
    29 label *label9
    30 op idiv *tmp17 6 *tmp15
    31 assertequals 1 *tmp17 "idiv"
    32 set :d.6:n 4
-    * op add *tmp18 zero :d.6:n
+   33 op add *tmp18 zero 4
    34 label *label10
    35 op mod *tmp20 6 *tmp18
    36 assertequals 2 *tmp20 "mod"
    37 set :d.7:n 8
-    * op add *tmp21 zero :d.7:n
+   38 op add *tmp21 zero 8
    39 label *label11
    40 op emod *tmp23 -3 *tmp21
    41 assertequals 5 *tmp23 "emod"
    42 set :d.8:n 4
-    * op add *tmp24 zero :d.8:n
+   43 op add *tmp24 zero 4
    44 label *label12
    45 op pow *tmp26 2 *tmp24
    46 assertequals 16 *tmp26 "pow"
    47 set :d.9:n 5
-    * op add *tmp27 zero :d.9:n
+   48 op add *tmp27 zero 5
    49 label *label13
    50 op equal *tmp29 5 *tmp27
    51 assertequals true *tmp29 "equal 1"
    52 set :d.10:n 6
-    * op add *tmp30 zero :d.10:n
+   53 op add *tmp30 zero 6
    54 label *label14
    55 op equal *tmp32 5 *tmp30
    56 assertequals false *tmp32 "equal 2"
    57 set :d.11:n null
-    * op add *tmp33 zero :d.11:n
+   58 op add *tmp33 zero null
    59 label *label15
    60 op equal *tmp35 0 *tmp33
    61 assertequals true *tmp35 "equal null"
    62 set :d.12:n 5
-    * op add *tmp36 zero :d.12:n
+   63 op add *tmp36 zero 5
    64 label *label16
    65 op notEqual *tmp38 5 *tmp36
    66 assertequals false *tmp38 "notEqual 1"
    67 set :d.13:n 6
-    * op add *tmp39 zero :d.13:n
+   68 op add *tmp39 zero 6
    69 label *label17
    70 op notEqual *tmp41 5 *tmp39
    71 assertequals true *tmp41 "notEqual 2"
    72 set :d.14:n null
-    * op add *tmp42 zero :d.14:n
+   73 op add *tmp42 zero null
    74 label *label18
    75 op notEqual *tmp44 0 *tmp42
    76 assertequals false *tmp44 "notEqual null"
    77 set :d.15:n 0
-    * op add *tmp45 zero :d.15:n
+   78 op add *tmp45 zero 0
    79 label *label19
    80 op land *tmp47 1 *tmp45
    81 assertequals false *tmp47 "land 1"
    82 set :d.16:n 2
-    * op add *tmp48 zero :d.16:n
+   83 op add *tmp48 zero 2
    84 label *label20
    85 op land *tmp50 1 *tmp48
    86 assertequals true *tmp50 "land 2"
    87 set :d.17:n 1
-    * op add *tmp51 zero :d.17:n
+   88 op add *tmp51 zero 1
    89 label *label21
    90 op lessThan *tmp53 0 *tmp51
    91 assertequals true *tmp53 "lessThan 1"
    92 set :d.18:n 0
-    * op add *tmp54 zero :d.18:n
+   93 op add *tmp54 zero 0
    94 label *label22
    95 op lessThan *tmp56 1 *tmp54
    96 assertequals false *tmp56 "lessThan 2"
    97 set :d.19:n 1
-    * op add *tmp57 zero :d.19:n
+   98 op add *tmp57 zero 1
    99 label *label23
   100 op lessThanEq *tmp59 1 *tmp57
   101 assertequals true *tmp59 "lessThanEq 1"
   102 set :d.20:n 0
-    * op add *tmp60 zero :d.20:n
+  103 op add *tmp60 zero 0
   104 label *label24
   105 op lessThanEq *tmp62 1 *tmp60
   106 assertequals false *tmp62 "lessThanEq 2"
   107 set :d.21:n 1
-    * op add *tmp63 zero :d.21:n
+  108 op add *tmp63 zero 1
   109 label *label25
   110 op greaterThan *tmp65 2 *tmp63
   111 assertequals true *tmp65 "greaterThan 1"
   112 set :d.22:n 2
-    * op add *tmp66 zero :d.22:n
+  113 op add *tmp66 zero 2
   114 label *label26
   115 op greaterThan *tmp68 1 *tmp66
   116 assertequals false *tmp68 "greaterThan 2"
   117 set :d.23:n 1
-    * op add *tmp69 zero :d.23:n
+  118 op add *tmp69 zero 1
   119 label *label27
   120 op greaterThanEq *tmp71 1 *tmp69
   121 assertequals true *tmp71 "greaterThanEq 1"
   122 set :d.24:n 2
-    * op add *tmp72 zero :d.24:n
+  123 op add *tmp72 zero 2
   124 label *label28
   125 op greaterThanEq *tmp74 1 *tmp72
   126 assertequals false *tmp74 "greaterThanEq 2"
 
   129 op strictEqual *tmp76 null NULL
   130 assertequals true *tmp76 "strictEqual 2"
   131 set :d.25:n 2
-    * op add *tmp77 zero :d.25:n
+  132 op add *tmp77 zero 2
   133 label *label29
   134 op shl *tmp79 1 *tmp77
   135 assertequals 4 *tmp79 "shl"
   136 set :d.26:n 2
-    * op add *tmp80 zero :d.26:n
+  137 op add *tmp80 zero 2
   138 label *label30
   139 op shr *tmp82 9 *tmp80
   140 assertequals 2 *tmp82 "shr"
   141 set :d.27:n 61
-    * op add *tmp83 zero :d.27:n
+  142 op add *tmp83 zero 61
   143 label *label31
   144 op ushr *tmp85 -1 *tmp83
   145 assertequals 7 *tmp85 "ushr"
   146 set :d.28:n 2
-    * op add *tmp86 zero :d.28:n
+  147 op add *tmp86 zero 2
   148 label *label32
   149 op or *tmp88 1 *tmp86
   150 assertequals 3 *tmp88 "or"
   151 set :d.29:n 2
-    * op add *tmp89 zero :d.29:n
+  152 op add *tmp89 zero 2
   153 label *label33
   154 op and *tmp91 3 *tmp89
   155 assertequals 2 *tmp91 "and"
   156 set :d.30:n 2
-    * op add *tmp92 zero :d.30:n
+  157 op add *tmp92 zero 2
   158 label *label34
   159 op xor *tmp94 3 *tmp92
   160 assertequals 1 *tmp94 "xor"
   161 set :d.31:n 0
-    * op add *tmp95 zero :d.31:n
+  162 op add *tmp95 zero 0
   163 label *label35
   164 op not *tmp97 *tmp95
   165 assertequals -1 *tmp97 "not 1"
   166 set :d.32:n 65535
-    * op add *tmp98 zero :d.32:n
+  167 op add *tmp98 zero 65535
   168 label *label36
   169 op not *tmp100 *tmp98
   170 assertequals -65536 *tmp100 "not 2"
   171 set :a 0xabcdefabcdef
-    * op add *tmp101 :a 1
-    * op sub *tmp102 0 *tmp101
-    * set :d.33:n :a
-    * op add *tmp103 zero :d.33:n
+  172 op add *tmp101 0xabcdefabcdef 1
+  173 op sub *tmp102 0 188900977659376
+  174 set :d.33:n 0xabcdefabcdef
+  175 op add *tmp103 zero :a
   176 label *label37
   177 op not *tmp105 *tmp103
-    * assertequals *tmp102 *tmp105 "not 3"
+  178 assertequals -188900977659376 *tmp105 "not 3"
   179 set :d.34:n 4
-    * op add *tmp106 zero :d.34:n
+  180 op add *tmp106 zero 4
   181 label *label38
   182 op max *tmp108 2 *tmp106
   183 assertequals 4 *tmp108 "max"
   184 set :d.35:n 4
-    * op add *tmp109 zero :d.35:n
+  185 op add *tmp109 zero 4
   186 label *label39
   187 op min *tmp111 2 *tmp109
   188 assertequals 2 *tmp111 "min"
   189 set :d.36:n -2
-    * op add *tmp112 zero :d.36:n
+  190 op add *tmp112 zero -2
   191 label *label40
   192 op abs *tmp114 *tmp112
   193 assertequals 2 *tmp114 "abs"
   194 set :d.37:n -2
-    * op add *tmp115 zero :d.37:n
+  195 op add *tmp115 zero -2
   196 label *label41
   197 set :sign:x *tmp115
-    * op greaterThan *tmp118 :sign:x 0
-    * op lessThan *tmp119 :sign:x 0
+  198 op greaterThan *tmp118 *tmp115 0
+  199 op lessThan *tmp119 *tmp115 0
   200 op sub *tmp117 *tmp118 *tmp119
   201 label *label42
   202 assertequals -1 *tmp117 "sign(-2)"
   203 set :d.38:n 2
-    * op add *tmp121 zero :d.38:n
+  204 op add *tmp121 zero 2
   205 label *label43
   206 set :sign.1:x *tmp121
-    * op greaterThan *tmp124 :sign.1:x 0
-    * op lessThan *tmp125 :sign.1:x 0
+  207 op greaterThan *tmp124 *tmp121 0
+  208 op lessThan *tmp125 *tmp121 0
   209 op sub *tmp123 *tmp124 *tmp125
   210 label *label44
   211 assertequals 1 *tmp123 "sign(2)"
   212 set :d.39:n 0
-    * op add *tmp127 zero :d.39:n
+  213 op add *tmp127 zero 0
   214 label *label45
   215 set :sign.2:x *tmp127
-    * op greaterThan *tmp130 :sign.2:x 0
-    * op lessThan *tmp131 :sign.2:x 0
+  216 op greaterThan *tmp130 *tmp127 0
+  217 op lessThan *tmp131 *tmp127 0
   218 op sub *tmp129 *tmp130 *tmp131
   219 label *label46
   220 assertequals 0 *tmp129 "sign(0)"
   221 set :d.40:n 2.718281828459045
-    * op add *tmp133 zero :d.40:n
+  222 op add *tmp133 zero 2.718281828459045
   223 label *label47
   224 op log *tmp135 *tmp133
   225 assertequals 1 *tmp135 "log"
   226 set :d.41:n 10
-    * op add *tmp136 zero :d.41:n
+  227 op add *tmp136 zero 10
   228 label *label48
   229 op log10 *tmp138 *tmp136
   230 assertequals 1 *tmp138 "log10"
   231 set :d.42:n 2
-    * op add *tmp139 zero :d.42:n
+  232 op add *tmp139 zero 2
   233 label *label49
   234 set :logn:number 16
   235 set :logn:base *tmp139
-    * op log *tmp142 :logn:number
-    * op log *tmp143 :logn:base
-    * op div *tmp141 *tmp142 *tmp143
+  236 op log *tmp142 16
+  237 op log *tmp143 *tmp139
+  238 op div *tmp141 2.772588722239781 *tmp143
   239 label *label50
   240 assertequals 4 *tmp141 "logn"
   241 set :d.43:n 2.5
-    * op add *tmp145 zero :d.43:n
+  242 op add *tmp145 zero 2.5
   243 label *label51
   244 op floor *tmp147 *tmp145
   245 assertequals 2 *tmp147 "floor"
   246 set :d.44:n 2.5
-    * op add *tmp148 zero :d.44:n
+  247 op add *tmp148 zero 2.5
   248 label *label52
   249 op ceil *tmp150 *tmp148
   250 assertequals 3 *tmp150 "ceil"
   251 set :d.45:n 2.5
-    * op add *tmp151 zero :d.45:n
+  252 op add *tmp151 zero 2.5
   253 label *label53
   254 set :round:x *tmp151
-    * op add *tmp154 :round:x 0.5
+  255 op add *tmp154 *tmp151 0.5
   256 op floor *tmp153 *tmp154
   257 label *label54
   258 assertequals 3 *tmp153 "round"
   259 set :d.46:n 16
-    * op add *tmp156 zero :d.46:n
+  260 op add *tmp156 zero 16
   261 label *label55
   262 op sqrt *tmp158 *tmp156
   263 assertequals 4 *tmp158 "sqrt"
   264 set :d.47:n 1
-    * op add *tmp159 zero :d.47:n
+  265 op add *tmp159 zero 1
   266 label *label56
   267 op angle *tmp161 1 *tmp159
   268 assertequals 45 *tmp161 "angle"
   269 set :d.48:n 135
-    * op add *tmp162 zero :d.48:n
+  270 op add *tmp162 zero 135
   271 label *label57
   272 op angleDiff *tmp164 45 *tmp162
   273 assertequals 90 *tmp164 "angleDiff"
 
   309 call *label3 *invalid :assertEqualsRound*retval (m:*label63) (h:*label63)
   310 label *label63
   311 set :d.49:n 8
-    * op add *tmp165 zero :d.49:n
+  312 op add *tmp165 zero 8
   313 label *label64
   314 op sub *tmp167 0 *tmp165
   315 assertequals -8 *tmp167 "unary minus"
   316 set :d.50:n 0
-    * op add *tmp168 zero :d.50:n
+  317 op add *tmp168 zero 0
   318 label *label65
   319 op equal *tmp170 *tmp168 false
   320 assertequals 1 *tmp170 "boolean negation 1"
   321 set :d.51:n 1
-    * op add *tmp171 zero :d.51:n
+  322 op add *tmp171 zero 1
   323 label *label66
   324 op equal *tmp173 *tmp171 false
   325 assertequals 0 *tmp173 "boolean negation 2"
   326 set :d.52:n 2
-    * op add *tmp174 zero :d.52:n
+  327 op add *tmp174 zero 2
   328 label *label67
   329 op equal *tmp176 *tmp174 false
   330 assertequals 0 *tmp176 "boolean negation 3"
   331 set :a 2
   332 set :d.53:n 4
-    * op add *tmp177 zero :d.53:n
+  333 op add *tmp177 zero 4
   334 label *label68
-    * op pow :a :a *tmp177
+  335 op pow :a 2 *tmp177
   336 assertequals 16 :a "**="
   337 set :a 2
   338 set :d.54:n 4
-    * op add *tmp179 zero :d.54:n
+  339 op add *tmp179 zero 4
   340 label *label69
-    * op mul :a :a *tmp179
+  341 op mul :a 2 *tmp179
   342 assertequals 8 :a "*="
   343 set :a 6
   344 set :d.55:n 4
-    * op add *tmp181 zero :d.55:n
+  345 op add *tmp181 zero 4
   346 label *label70
-    * op div :a :a *tmp181
+  347 op div :a 6 *tmp181
   348 assertequals 1.5 :a "/="
   349 set :a 6
   350 set :d.56:n 4
-    * op add *tmp183 zero :d.56:n
+  351 op add *tmp183 zero 4
   352 label *label71
-    * op idiv :a :a *tmp183
+  353 op idiv :a 6 *tmp183
   354 assertequals 1 :a "\="
   355 set :a 6
   356 set :d.57:n 4
-    * op add *tmp185 zero :d.57:n
+  357 op add *tmp185 zero 4
   358 label *label72
-    * op mod :a :a *tmp185
+  359 op mod :a 6 *tmp185
   360 assertequals 2 :a "%="
   361 set :a 4
   362 set :d.58:n 2
-    * op add *tmp187 zero :d.58:n
+  363 op add *tmp187 zero 2
   364 label *label73
-    * op add :a :a *tmp187
+  365 op add :a 4 *tmp187
   366 assertequals 6 :a "+="
   367 set :a 4
   368 set :d.59:n 2
-    * op add *tmp189 zero :d.59:n
+  369 op add *tmp189 zero 2
   370 label *label74
-    * op sub :a :a *tmp189
+  371 op sub :a 4 *tmp189
   372 assertequals 2 :a "-="
   373 set :a 1
   374 set :d.60:n 2
-    * op add *tmp191 zero :d.60:n
+  375 op add *tmp191 zero 2
   376 label *label75
-    * op shl :a :a *tmp191
+  377 op shl :a 1 *tmp191
   378 assertequals 4 :a "<<="
   379 set :a 9
   380 set :d.61:n 2
-    * op add *tmp193 zero :d.61:n
+  381 op add *tmp193 zero 2
   382 label *label76
-    * op shr :a :a *tmp193
+  383 op shr :a 9 *tmp193
   384 assertequals 2 :a ">>="
   385 set :a 1
   386 set :d.62:n 2
-    * op add *tmp195 zero :d.62:n
+  387 op add *tmp195 zero 2
   388 label *label77
-    * op or :a :a *tmp195
+  389 op or :a 1 *tmp195
   390 assertequals 3 :a "|="
   391 set :a 3
   392 set :d.63:n 2
-    * op add *tmp197 zero :d.63:n
+  393 op add *tmp197 zero 2
   394 label *label78
-    * op and :a :a *tmp197
+  395 op and :a 3 *tmp197
   396 assertequals 2 :a "&="
   397 set :a 3
   398 set :d.64:n 2
-    * op add *tmp199 zero :d.64:n
+  399 op add *tmp199 zero 2
   400 label *label79
-    * op xor :a :a *tmp199
+  401 op xor :a 3 *tmp199
   402 assertequals 1 :a "^="
   403 set :a 1
   404 set :d.65:n 0
-    * op add *tmp201 zero :d.65:n
+  405 op add *tmp201 zero 0
   406 label *label80
-    * op land :a :a *tmp201
+  407 op land :a 1 *tmp201
   408 assertequals false :a "&&="
   409 set :a 1
   410 set :d.66:n 2
-    * op add *tmp203 zero :d.66:n
+  411 op add *tmp203 zero 2
   412 label *label81
-    * op land :a :a *tmp203
+  413 op land :a 1 *tmp203
   414 assertequals true :a "&&="
   415 set :a 0
   416 set :d.67:n 2
-    * op add *tmp205 zero :d.67:n
+  417 op add *tmp205 zero 2
   418 label *label82
-    * op or *tmp207 :a *tmp205
+  419 op or *tmp207 0 *tmp205
   420 op notEqual :a *tmp207 false
   421 assertequals true :a "||="
   422 assertequals %ff0000ff %ff0000 "short color literals"
 
   426 set *tmp209 null
   427 jump *label85 always
   428 label *label84
-    * set *tmp209 :o:n
+  429 set *tmp209 @copper-wall
   430 label *label85
   431 set *tmp208 *tmp209
   432 label *label83
-    * sensor *tmp210 *tmp208 @id
+  433 sensor *tmp210 *tmp209 @id
   434 assertequals 17 *tmp210 "Logic ID"
   435 stop
   436 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-89 instructions):
     0 set NULL null
     1 set zero 0
-    * set :d:n 3
     2 op add *tmp0 zero 3
     3 label *label4
-    * op add *tmp2 2 *tmp0
+    4 op add *tmp2 zero 5
     5 assertequals 5 *tmp2 "add"
-    * set :d.1:n 6
     6 op add *tmp3 zero 6
     7 label *label5
-    * op sub *tmp5 7 *tmp3
+    8 op sub *tmp5 1 zero
     9 assertequals 1 *tmp5 "sub"
-    * set :d.2:n 2
    10 op add *tmp6 zero 2
    11 label *label6
    12 op mul *tmp8 3 *tmp6
    13 assertequals 6 *tmp8 "mul"
-    * set :d.3:n 4
    14 op add *tmp9 zero 4
    15 label *label7
    16 op div *tmp11 6 *tmp9
    17 assertequals 1.5 *tmp11 "div"
-    * set :d.4:n 100000
    18 op add *tmp12 zero 100000
    19 label *label8
    20 op div *tmp14 1 *tmp12
    21 assertequals 0.00001 *tmp14 "div exp"
-    * set :d.5:n 4
    22 op add *tmp15 zero 4
    23 label *label9
-    * op idiv *tmp17 6 *tmp15
+   24 op idiv *tmp17 6 *tmp9
    25 assertequals 1 *tmp17 "idiv"
-    * set :d.6:n 4
    26 op add *tmp18 zero 4
    27 label *label10
-    * op mod *tmp20 6 *tmp18
+   28 op mod *tmp20 6 *tmp9
    29 assertequals 2 *tmp20 "mod"
-    * set :d.7:n 8
    30 op add *tmp21 zero 8
    31 label *label11
    32 op emod *tmp23 -3 *tmp21
    33 assertequals 5 *tmp23 "emod"
-    * set :d.8:n 4
    34 op add *tmp24 zero 4
    35 label *label12
-    * op pow *tmp26 2 *tmp24
+   36 op pow *tmp26 2 *tmp9
    37 assertequals 16 *tmp26 "pow"
-    * set :d.9:n 5
    38 op add *tmp27 zero 5
    39 label *label13
    40 op equal *tmp29 5 *tmp27
    41 assertequals true *tmp29 "equal 1"
-    * set :d.10:n 6
    42 op add *tmp30 zero 6
    43 label *label14
-    * op equal *tmp32 5 *tmp30
+   44 op equal *tmp32 5 *tmp3
    45 assertequals false *tmp32 "equal 2"
-    * set :d.11:n null
    46 op add *tmp33 zero null
    47 label *label15
    48 op equal *tmp35 0 *tmp33
    49 assertequals true *tmp35 "equal null"
-    * set :d.12:n 5
    50 op add *tmp36 zero 5
    51 label *label16
-    * op notEqual *tmp38 5 *tmp36
+   52 op notEqual *tmp38 5 *tmp27
    53 assertequals false *tmp38 "notEqual 1"
-    * set :d.13:n 6
    54 op add *tmp39 zero 6
    55 label *label17
-    * op notEqual *tmp41 5 *tmp39
+   56 op notEqual *tmp41 5 *tmp3
    57 assertequals true *tmp41 "notEqual 2"
-    * set :d.14:n null
    58 op add *tmp42 zero null
    59 label *label18
-    * op notEqual *tmp44 0 *tmp42
+   60 op notEqual *tmp44 0 *tmp33
    61 assertequals false *tmp44 "notEqual null"
-    * set :d.15:n 0
    62 op add *tmp45 zero 0
    63 label *label19
    64 op land *tmp47 1 *tmp45
    65 assertequals false *tmp47 "land 1"
-    * set :d.16:n 2
    66 op add *tmp48 zero 2
    67 label *label20
-    * op land *tmp50 1 *tmp48
+   68 op land *tmp50 1 *tmp6
    69 assertequals true *tmp50 "land 2"
-    * set :d.17:n 1
    70 op add *tmp51 zero 1
    71 label *label21
    72 op lessThan *tmp53 0 *tmp51
    73 assertequals true *tmp53 "lessThan 1"
-    * set :d.18:n 0
    74 op add *tmp54 zero 0
    75 label *label22
-    * op lessThan *tmp56 1 *tmp54
+   76 op lessThan *tmp56 1 *tmp45
    77 assertequals false *tmp56 "lessThan 2"
-    * set :d.19:n 1
    78 op add *tmp57 zero 1
    79 label *label23
-    * op lessThanEq *tmp59 1 *tmp57
+   80 op lessThanEq *tmp59 1 *tmp51
    81 assertequals true *tmp59 "lessThanEq 1"
-    * set :d.20:n 0
    82 op add *tmp60 zero 0
    83 label *label24
-    * op lessThanEq *tmp62 1 *tmp60
+   84 op lessThanEq *tmp62 1 *tmp45
    85 assertequals false *tmp62 "lessThanEq 2"
-    * set :d.21:n 1
    86 op add *tmp63 zero 1
    87 label *label25
-    * op greaterThan *tmp65 2 *tmp63
+   88 op greaterThan *tmp65 2 *tmp51
    89 assertequals true *tmp65 "greaterThan 1"
-    * set :d.22:n 2
    90 op add *tmp66 zero 2
    91 label *label26
-    * op greaterThan *tmp68 1 *tmp66
+   92 op greaterThan *tmp68 1 *tmp6
    93 assertequals false *tmp68 "greaterThan 2"
-    * set :d.23:n 1
    94 op add *tmp69 zero 1
    95 label *label27
-    * op greaterThanEq *tmp71 1 *tmp69
+   96 op greaterThanEq *tmp71 1 *tmp51
    97 assertequals true *tmp71 "greaterThanEq 1"
-    * set :d.24:n 2
    98 op add *tmp72 zero 2
    99 label *label28
-    * op greaterThanEq *tmp74 1 *tmp72
+  100 op greaterThanEq *tmp74 1 *tmp6
   101 assertequals false *tmp74 "greaterThanEq 2"
   102 op strictEqual *tmp75 0 NULL
   103 assertequals false *tmp75 "strictEqual 1"
   104 op strictEqual *tmp76 null NULL
   105 assertequals true *tmp76 "strictEqual 2"
-    * set :d.25:n 2
   106 op add *tmp77 zero 2
   107 label *label29
-    * op shl *tmp79 1 *tmp77
+  108 op shl *tmp79 1 *tmp6
   109 assertequals 4 *tmp79 "shl"
-    * set :d.26:n 2
   110 op add *tmp80 zero 2
   111 label *label30
-    * op shr *tmp82 9 *tmp80
+  112 op shr *tmp82 9 *tmp6
   113 assertequals 2 *tmp82 "shr"
-    * set :d.27:n 61
   114 op add *tmp83 zero 61
   115 label *label31
   116 op ushr *tmp85 -1 *tmp83
   117 assertequals 7 *tmp85 "ushr"
-    * set :d.28:n 2
   118 op add *tmp86 zero 2
   119 label *label32
-    * op or *tmp88 1 *tmp86
+  120 op or *tmp88 1 *tmp6
   121 assertequals 3 *tmp88 "or"
-    * set :d.29:n 2
   122 op add *tmp89 zero 2
   123 label *label33
-    * op and *tmp91 3 *tmp89
+  124 op and *tmp91 3 *tmp6
   125 assertequals 2 *tmp91 "and"
-    * set :d.30:n 2
   126 op add *tmp92 zero 2
   127 label *label34
-    * op xor *tmp94 3 *tmp92
+  128 op xor *tmp94 3 *tmp6
   129 assertequals 1 *tmp94 "xor"
-    * set :d.31:n 0
   130 op add *tmp95 zero 0
   131 label *label35
-    * op not *tmp97 *tmp95
+  132 op not *tmp97 *tmp45
   133 assertequals -1 *tmp97 "not 1"
-    * set :d.32:n 65535
   134 op add *tmp98 zero 65535
   135 label *label36
   136 op not *tmp100 *tmp98
   137 assertequals -65536 *tmp100 "not 2"
   138 set :a 0xabcdefabcdef
-    * op add *tmp101 0xabcdefabcdef 1
-    * op sub *tmp102 0 188900977659376
-    * set :d.33:n 0xabcdefabcdef
-    * op add *tmp103 zero :a
+  139 op add *tmp103 zero 0xabcdefabcdef
   140 label *label37
   141 op not *tmp105 *tmp103
   142 assertequals -188900977659376 *tmp105 "not 3"
-    * set :d.34:n 4
   143 op add *tmp106 zero 4
   144 label *label38
-    * op max *tmp108 2 *tmp106
+  145 op max *tmp108 2 *tmp9
   146 assertequals 4 *tmp108 "max"
-    * set :d.35:n 4
   147 op add *tmp109 zero 4
   148 label *label39
-    * op min *tmp111 2 *tmp109
+  149 op min *tmp111 2 *tmp9
   150 assertequals 2 *tmp111 "min"
-    * set :d.36:n -2
   151 op add *tmp112 zero -2
   152 label *label40
   153 op abs *tmp114 *tmp112
   154 assertequals 2 *tmp114 "abs"
-    * set :d.37:n -2
   155 op add *tmp115 zero -2
   156 label *label41
-    * set :sign:x *tmp115
-    * op greaterThan *tmp118 *tmp115 0
-    * op lessThan *tmp119 *tmp115 0
+  157 set :sign:x *tmp112
+  158 op greaterThan *tmp118 *tmp112 0
+  159 op lessThan *tmp119 *tmp112 0
   160 op sub *tmp117 *tmp118 *tmp119
   161 label *label42
   162 assertequals -1 *tmp117 "sign(-2)"
-    * set :d.38:n 2
   163 op add *tmp121 zero 2
   164 label *label43
-    * set :sign.1:x *tmp121
-    * op greaterThan *tmp124 *tmp121 0
-    * op lessThan *tmp125 *tmp121 0
+  165 set :sign.1:x *tmp6
+  166 op greaterThan *tmp124 *tmp6 0
+  167 op lessThan *tmp125 *tmp6 0
   168 op sub *tmp123 *tmp124 *tmp125
   169 label *label44
   170 assertequals 1 *tmp123 "sign(2)"
-    * set :d.39:n 0
   171 op add *tmp127 zero 0
   172 label *label45
-    * set :sign.2:x *tmp127
-    * op greaterThan *tmp130 *tmp127 0
-    * op lessThan *tmp131 *tmp127 0
+  173 set :sign.2:x *tmp45
+  174 op greaterThan *tmp130 *tmp45 0
+  175 op lessThan *tmp131 *tmp45 0
   176 op sub *tmp129 *tmp130 *tmp131
   177 label *label46
   178 assertequals 0 *tmp129 "sign(0)"
-    * set :d.40:n 2.718281828459045
   179 op add *tmp133 zero 2.718281828459045
   180 label *label47
   181 op log *tmp135 *tmp133
   182 assertequals 1 *tmp135 "log"
-    * set :d.41:n 10
   183 op add *tmp136 zero 10
   184 label *label48
   185 op log10 *tmp138 *tmp136
   186 assertequals 1 *tmp138 "log10"
-    * set :d.42:n 2
   187 op add *tmp139 zero 2
   188 label *label49
-    * set :logn:number 16
-    * set :logn:base *tmp139
-    * op log *tmp142 16
-    * op log *tmp143 *tmp139
+  189 set :logn:base *tmp6
+  190 op log *tmp143 *tmp6
   191 op div *tmp141 2.772588722239781 *tmp143
   192 label *label50
   193 assertequals 4 *tmp141 "logn"
-    * set :d.43:n 2.5
   194 op add *tmp145 zero 2.5
   195 label *label51
   196 op floor *tmp147 *tmp145
   197 assertequals 2 *tmp147 "floor"
-    * set :d.44:n 2.5
   198 op add *tmp148 zero 2.5
   199 label *label52
-    * op ceil *tmp150 *tmp148
+  200 op ceil *tmp150 *tmp145
   201 assertequals 3 *tmp150 "ceil"
-    * set :d.45:n 2.5
   202 op add *tmp151 zero 2.5
   203 label *label53
-    * set :round:x *tmp151
-    * op add *tmp154 *tmp151 0.5
+  204 set :round:x *tmp145
+  205 op add *tmp154 *tmp145 0.5
   206 op floor *tmp153 *tmp154
   207 label *label54
   208 assertequals 3 *tmp153 "round"
-    * set :d.46:n 16
   209 op add *tmp156 zero 16
   210 label *label55
   211 op sqrt *tmp158 *tmp156
   212 assertequals 4 *tmp158 "sqrt"
-    * set :d.47:n 1
   213 op add *tmp159 zero 1
   214 label *label56
-    * op angle *tmp161 1 *tmp159
+  215 op angle *tmp161 1 *tmp51
   216 assertequals 45 *tmp161 "angle"
-    * set :d.48:n 135
   217 op add *tmp162 zero 135
   218 label *label57
   219 op angleDiff *tmp164 45 *tmp162
 
   255 setaddr :assertEqualsRound*retaddr *label63 (h:*label63)
   256 call *label3 *invalid :assertEqualsRound*retval (m:*label63) (h:*label63)
   257 label *label63
-    * set :d.49:n 8
   258 op add *tmp165 zero 8
   259 label *label64
-    * op sub *tmp167 0 *tmp165
+  260 op sub *tmp167 0 *tmp21
   261 assertequals -8 *tmp167 "unary minus"
-    * set :d.50:n 0
   262 op add *tmp168 zero 0
   263 label *label65
-    * op equal *tmp170 *tmp168 false
+  264 op equal *tmp170 *tmp45 false
   265 assertequals 1 *tmp170 "boolean negation 1"
-    * set :d.51:n 1
   266 op add *tmp171 zero 1
   267 label *label66
-    * op equal *tmp173 *tmp171 false
+  268 op equal *tmp173 *tmp51 false
   269 assertequals 0 *tmp173 "boolean negation 2"
-    * set :d.52:n 2
   270 op add *tmp174 zero 2
   271 label *label67
-    * op equal *tmp176 *tmp174 false
+  272 op equal *tmp176 *tmp6 false
   273 assertequals 0 *tmp176 "boolean negation 3"
-    * set :a 2
-    * set :d.53:n 4
   274 op add *tmp177 zero 4
   275 label *label68
-    * op pow :a 2 *tmp177
-    * assertequals 16 :a "**="
-    * set :a 2
-    * set :d.54:n 4
+  276 op pow :a 2 *tmp9
+  277 assertequals 16 *tmp26 "**="
   278 op add *tmp179 zero 4
   279 label *label69
-    * op mul :a 2 *tmp179
+  280 op mul :a 2 *tmp9
   281 assertequals 8 :a "*="
-    * set :a 6
-    * set :d.55:n 4
   282 op add *tmp181 zero 4
   283 label *label70
-    * op div :a 6 *tmp181
-    * assertequals 1.5 :a "/="
-    * set :a 6
-    * set :d.56:n 4
+  284 op div :a 6 *tmp9
+  285 assertequals 1.5 *tmp11 "/="
   286 op add *tmp183 zero 4
   287 label *label71
-    * op idiv :a 6 *tmp183
-    * assertequals 1 :a "\="
-    * set :a 6
-    * set :d.57:n 4
+  288 op idiv :a 6 *tmp9
+  289 assertequals 1 *tmp17 "\="
   290 op add *tmp185 zero 4
   291 label *label72
-    * op mod :a 6 *tmp185
-    * assertequals 2 :a "%="
-    * set :a 4
-    * set :d.58:n 2
+  292 op mod :a 6 *tmp9
+  293 assertequals 2 *tmp20 "%="
   294 op add *tmp187 zero 2
   295 label *label73
-    * op add :a 4 *tmp187
+  296 op add :a 4 *tmp6
   297 assertequals 6 :a "+="
-    * set :a 4
-    * set :d.59:n 2
   298 op add *tmp189 zero 2
   299 label *label74
-    * op sub :a 4 *tmp189
+  300 op sub :a 4 *tmp6
   301 assertequals 2 :a "-="
-    * set :a 1
-    * set :d.60:n 2
   302 op add *tmp191 zero 2
   303 label *label75
-    * op shl :a 1 *tmp191
-    * assertequals 4 :a "<<="
-    * set :a 9
-    * set :d.61:n 2
+  304 op shl :a 1 *tmp6
+  305 assertequals 4 *tmp79 "<<="
   306 op add *tmp193 zero 2
   307 label *label76
-    * op shr :a 9 *tmp193
-    * assertequals 2 :a ">>="
-    * set :a 1
-    * set :d.62:n 2
+  308 op shr :a 9 *tmp6
+  309 assertequals 2 *tmp82 ">>="
   310 op add *tmp195 zero 2
   311 label *label77
-    * op or :a 1 *tmp195
-    * assertequals 3 :a "|="
-    * set :a 3
-    * set :d.63:n 2
+  312 op or :a 1 *tmp6
+  313 assertequals 3 *tmp88 "|="
   314 op add *tmp197 zero 2
   315 label *label78
-    * op and :a 3 *tmp197
-    * assertequals 2 :a "&="
-    * set :a 3
-    * set :d.64:n 2
+  316 op and :a 3 *tmp6
+  317 assertequals 2 *tmp91 "&="
   318 op add *tmp199 zero 2
   319 label *label79
-    * op xor :a 3 *tmp199
-    * assertequals 1 :a "^="
-    * set :a 1
-    * set :d.65:n 0
+  320 op xor :a 3 *tmp6
+  321 assertequals 1 *tmp94 "^="
   322 op add *tmp201 zero 0
   323 label *label80
-    * op land :a 1 *tmp201
-    * assertequals false :a "&&="
-    * set :a 1
-    * set :d.66:n 2
+  324 op land :a 1 *tmp45
+  325 assertequals false *tmp47 "&&="
   326 op add *tmp203 zero 2
   327 label *label81
-    * op land :a 1 *tmp203
-    * assertequals true :a "&&="
-    * set :a 0
-    * set :d.67:n 2
+  328 op land :a 1 *tmp6
+  329 assertequals true *tmp50 "&&="
   330 op add *tmp205 zero 2
   331 label *label82
-    * op or *tmp207 0 *tmp205
+  332 op or *tmp207 0 *tmp6
   333 op notEqual :a *tmp207 false
   334 assertequals true :a "||="
   335 assertequals %ff0000ff %ff0000 "short color literals"
   336 assertequals %ffffffff %[white] "named color literals"
-    * set :o:n @copper-wall
   337 jump *label84 equal zero false
   338 set *tmp209 null
   339 jump *label85 always
   340 label *label84
   341 set *tmp209 @copper-wall
   342 label *label85
-    * set *tmp208 *tmp209
   343 label *label83
   344 sensor *tmp210 *tmp209 @id
   345 assertequals 17 *tmp210 "Logic ID"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-67 instructions):
     0 set NULL null
     1 set zero 0
-    * op add *tmp0 zero 3
     2 label *label4
     3 op add *tmp2 zero 5
     4 assertequals 5 *tmp2 "add"
 
    18 label *label8
    19 op div *tmp14 1 *tmp12
    20 assertequals 0.00001 *tmp14 "div exp"
-    * op add *tmp15 zero 4
    21 label *label9
    22 op idiv *tmp17 6 *tmp9
    23 assertequals 1 *tmp17 "idiv"
-    * op add *tmp18 zero 4
    24 label *label10
    25 op mod *tmp20 6 *tmp9
    26 assertequals 2 *tmp20 "mod"
 
    28 label *label11
    29 op emod *tmp23 -3 *tmp21
    30 assertequals 5 *tmp23 "emod"
-    * op add *tmp24 zero 4
    31 label *label12
    32 op pow *tmp26 2 *tmp9
    33 assertequals 16 *tmp26 "pow"
    34 op add *tmp27 zero 5
    35 label *label13
-    * op equal *tmp29 5 *tmp27
+   36 op equal *tmp29 5 *tmp2
    37 assertequals true *tmp29 "equal 1"
-    * op add *tmp30 zero 6
    38 label *label14
    39 op equal *tmp32 5 *tmp3
    40 assertequals false *tmp32 "equal 2"
 
    42 label *label15
    43 op equal *tmp35 0 *tmp33
    44 assertequals true *tmp35 "equal null"
-    * op add *tmp36 zero 5
    45 label *label16
-    * op notEqual *tmp38 5 *tmp27
+   46 op notEqual *tmp38 5 *tmp2
    47 assertequals false *tmp38 "notEqual 1"
-    * op add *tmp39 zero 6
    48 label *label17
    49 op notEqual *tmp41 5 *tmp3
    50 assertequals true *tmp41 "notEqual 2"
-    * op add *tmp42 zero null
    51 label *label18
    52 op notEqual *tmp44 0 *tmp33
    53 assertequals false *tmp44 "notEqual null"
 
    55 label *label19
    56 op land *tmp47 1 *tmp45
    57 assertequals false *tmp47 "land 1"
-    * op add *tmp48 zero 2
    58 label *label20
    59 op land *tmp50 1 *tmp6
    60 assertequals true *tmp50 "land 2"
 
    62 label *label21
    63 op lessThan *tmp53 0 *tmp51
    64 assertequals true *tmp53 "lessThan 1"
-    * op add *tmp54 zero 0
    65 label *label22
    66 op lessThan *tmp56 1 *tmp45
    67 assertequals false *tmp56 "lessThan 2"
-    * op add *tmp57 zero 1
    68 label *label23
    69 op lessThanEq *tmp59 1 *tmp51
    70 assertequals true *tmp59 "lessThanEq 1"
-    * op add *tmp60 zero 0
    71 label *label24
    72 op lessThanEq *tmp62 1 *tmp45
    73 assertequals false *tmp62 "lessThanEq 2"
-    * op add *tmp63 zero 1
    74 label *label25
    75 op greaterThan *tmp65 2 *tmp51
    76 assertequals true *tmp65 "greaterThan 1"
-    * op add *tmp66 zero 2
    77 label *label26
    78 op greaterThan *tmp68 1 *tmp6
    79 assertequals false *tmp68 "greaterThan 2"
-    * op add *tmp69 zero 1
    80 label *label27
    81 op greaterThanEq *tmp71 1 *tmp51
    82 assertequals true *tmp71 "greaterThanEq 1"
-    * op add *tmp72 zero 2
    83 label *label28
    84 op greaterThanEq *tmp74 1 *tmp6
    85 assertequals false *tmp74 "greaterThanEq 2"
 
    87 assertequals false *tmp75 "strictEqual 1"
    88 op strictEqual *tmp76 null NULL
    89 assertequals true *tmp76 "strictEqual 2"
-    * op add *tmp77 zero 2
    90 label *label29
    91 op shl *tmp79 1 *tmp6
    92 assertequals 4 *tmp79 "shl"
-    * op add *tmp80 zero 2
    93 label *label30
    94 op shr *tmp82 9 *tmp6
    95 assertequals 2 *tmp82 "shr"
 
    97 label *label31
    98 op ushr *tmp85 -1 *tmp83
    99 assertequals 7 *tmp85 "ushr"
-    * op add *tmp86 zero 2
   100 label *label32
   101 op or *tmp88 1 *tmp6
   102 assertequals 3 *tmp88 "or"
-    * op add *tmp89 zero 2
   103 label *label33
   104 op and *tmp91 3 *tmp6
   105 assertequals 2 *tmp91 "and"
-    * op add *tmp92 zero 2
   106 label *label34
   107 op xor *tmp94 3 *tmp6
   108 assertequals 1 *tmp94 "xor"
-    * op add *tmp95 zero 0
   109 label *label35
   110 op not *tmp97 *tmp45
   111 assertequals -1 *tmp97 "not 1"
 
   113 label *label36
   114 op not *tmp100 *tmp98
   115 assertequals -65536 *tmp100 "not 2"
-    * set :a 0xabcdefabcdef
   116 op add *tmp103 zero 0xabcdefabcdef
   117 label *label37
   118 op not *tmp105 *tmp103
   119 assertequals -188900977659376 *tmp105 "not 3"
-    * op add *tmp106 zero 4
   120 label *label38
   121 op max *tmp108 2 *tmp9
   122 assertequals 4 *tmp108 "max"
-    * op add *tmp109 zero 4
   123 label *label39
   124 op min *tmp111 2 *tmp9
   125 assertequals 2 *tmp111 "min"
 
   127 label *label40
   128 op abs *tmp114 *tmp112
   129 assertequals 2 *tmp114 "abs"
-    * op add *tmp115 zero -2
   130 label *label41
-    * set :sign:x *tmp112
   131 op greaterThan *tmp118 *tmp112 0
   132 op lessThan *tmp119 *tmp112 0
   133 op sub *tmp117 *tmp118 *tmp119
   134 label *label42
   135 assertequals -1 *tmp117 "sign(-2)"
-    * op add *tmp121 zero 2
   136 label *label43
-    * set :sign.1:x *tmp6
   137 op greaterThan *tmp124 *tmp6 0
   138 op lessThan *tmp125 *tmp6 0
   139 op sub *tmp123 *tmp124 *tmp125
   140 label *label44
   141 assertequals 1 *tmp123 "sign(2)"
-    * op add *tmp127 zero 0
   142 label *label45
-    * set :sign.2:x *tmp45
   143 op greaterThan *tmp130 *tmp45 0
   144 op lessThan *tmp131 *tmp45 0
   145 op sub *tmp129 *tmp130 *tmp131
 
   153 label *label48
   154 op log10 *tmp138 *tmp136
   155 assertequals 1 *tmp138 "log10"
-    * op add *tmp139 zero 2
   156 label *label49
-    * set :logn:base *tmp6
   157 op log *tmp143 *tmp6
   158 op div *tmp141 2.772588722239781 *tmp143
   159 label *label50
 
   162 label *label51
   163 op floor *tmp147 *tmp145
   164 assertequals 2 *tmp147 "floor"
-    * op add *tmp148 zero 2.5
   165 label *label52
   166 op ceil *tmp150 *tmp145
   167 assertequals 3 *tmp150 "ceil"
-    * op add *tmp151 zero 2.5
   168 label *label53
-    * set :round:x *tmp145
-    * op add *tmp154 *tmp145 0.5
+  169 op add *tmp154 zero 3
   170 op floor *tmp153 *tmp154
   171 label *label54
   172 assertequals 3 *tmp153 "round"
 
   174 label *label55
   175 op sqrt *tmp158 *tmp156
   176 assertequals 4 *tmp158 "sqrt"
-    * op add *tmp159 zero 1
   177 label *label56
   178 op angle *tmp161 1 *tmp51
   179 assertequals 45 *tmp161 "angle"
 
   218 setaddr :assertEqualsRound*retaddr *label63 (h:*label63)
   219 call *label3 *invalid :assertEqualsRound*retval (m:*label63) (h:*label63)
   220 label *label63
-    * op add *tmp165 zero 8
   221 label *label64
-    * op sub *tmp167 0 *tmp21
+  222 op sub *tmp167 -8 zero
   223 assertequals -8 *tmp167 "unary minus"
-    * op add *tmp168 zero 0
   224 label *label65
   225 op equal *tmp170 *tmp45 false
   226 assertequals 1 *tmp170 "boolean negation 1"
-    * op add *tmp171 zero 1
   227 label *label66
   228 op equal *tmp173 *tmp51 false
   229 assertequals 0 *tmp173 "boolean negation 2"
-    * op add *tmp174 zero 2
   230 label *label67
   231 op equal *tmp176 *tmp6 false
   232 assertequals 0 *tmp176 "boolean negation 3"
-    * op add *tmp177 zero 4
   233 label *label68
-    * op pow :a 2 *tmp9
   234 assertequals 16 *tmp26 "**="
-    * op add *tmp179 zero 4
   235 label *label69
   236 op mul :a 2 *tmp9
   237 assertequals 8 :a "*="
-    * op add *tmp181 zero 4
   238 label *label70
-    * op div :a 6 *tmp9
   239 assertequals 1.5 *tmp11 "/="
-    * op add *tmp183 zero 4
   240 label *label71
-    * op idiv :a 6 *tmp9
   241 assertequals 1 *tmp17 "\="
-    * op add *tmp185 zero 4
   242 label *label72
-    * op mod :a 6 *tmp9
   243 assertequals 2 *tmp20 "%="
-    * op add *tmp187 zero 2
   244 label *label73
-    * op add :a 4 *tmp6
+  245 op add :a zero 6
   246 assertequals 6 :a "+="
-    * op add *tmp189 zero 2
   247 label *label74
-    * op sub :a 4 *tmp6
+  248 op sub :a 2 zero
   249 assertequals 2 :a "-="
-    * op add *tmp191 zero 2
   250 label *label75
-    * op shl :a 1 *tmp6
   251 assertequals 4 *tmp79 "<<="
-    * op add *tmp193 zero 2
   252 label *label76
-    * op shr :a 9 *tmp6
   253 assertequals 2 *tmp82 ">>="
-    * op add *tmp195 zero 2
   254 label *label77
-    * op or :a 1 *tmp6
   255 assertequals 3 *tmp88 "|="
-    * op add *tmp197 zero 2
   256 label *label78
-    * op and :a 3 *tmp6
   257 assertequals 2 *tmp91 "&="
-    * op add *tmp199 zero 2
   258 label *label79
-    * op xor :a 3 *tmp6
   259 assertequals 1 *tmp94 "^="
-    * op add *tmp201 zero 0
   260 label *label80
-    * op land :a 1 *tmp45
   261 assertequals false *tmp47 "&&="
-    * op add *tmp203 zero 2
   262 label *label81
-    * op land :a 1 *tmp6
   263 assertequals true *tmp50 "&&="
-    * op add *tmp205 zero 2
   264 label *label82
   265 op or *tmp207 0 *tmp6
   266 op notEqual :a *tmp207 false

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-1 instructions):
 
    31 label *label12
    32 op pow *tmp26 2 *tmp9
    33 assertequals 16 *tmp26 "pow"
-    * op add *tmp27 zero 5
    34 label *label13
    35 op equal *tmp29 5 *tmp2
    36 assertequals true *tmp29 "equal 1"
 
   242 assertequals 2 *tmp20 "%="
   243 label *label73
   244 op add :a zero 6
-    * assertequals 6 :a "+="
+  245 assertequals 6 *tmp3 "+="
   246 label *label74
   247 op sub :a 2 zero
   248 assertequals 2 :a "-="

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 5 (-1 instructions):
 
   241 label *label72
   242 assertequals 2 *tmp20 "%="
   243 label *label73
-    * op add :a zero 6
   244 assertequals 6 *tmp3 "+="
   245 label *label74
   246 op sub :a 2 zero

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-3 instructions):
 
   265 assertequals true :a "||="
   266 assertequals %ff0000ff %ff0000 "short color literals"
   267 assertequals %ffffffff %[white] "named color literals"
-    * jump *label84 equal zero false
-    * set *tmp209 null
-    * jump *label85 always
+  268 select *tmp209 notEqual zero false null @copper-wall
   269 label *label84
-    * set *tmp209 @copper-wall
   270 label *label85
   271 label *label83
   272 sensor *tmp210 *tmp209 @id

Modifications by Inline function 'assertEqualsRound' defined at line 3:1 (+11 instructions):
 
   184 set :assertEqualsRound:expected 1
   185 set :assertEqualsRound:actual 1
   186 set :assertEqualsRound:title "sin"
-    * setaddr :assertEqualsRound*retaddr *label58 (h:*label58)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label58) (h:*label58)
-    * label *label58
+  187 label *label88
+  188 op mul :round.1:x :assertEqualsRound:actual 100000000
+  189 op add *tmp213 :round.1:x 0.5
+  190 op floor *tmp212 *tmp213
+  191 label *label89
+  192 op div *tmp215 *tmp212 100000000
+  193 assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  194 label *label90
   195 set :assertEqualsRound:expected -1
   196 set :assertEqualsRound:actual -1
   197 set :assertEqualsRound:title "cos"
-    * setaddr :assertEqualsRound*retaddr *label59 (h:*label59)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label59) (h:*label59)
-    * label *label59
+  198 label *label91
+  199 op mul :round.1:x :assertEqualsRound:actual 100000000
+  200 op add *tmp213 :round.1:x 0.5
+  201 op floor *tmp212 *tmp213
+  202 label *label92
+  203 op div *tmp215 *tmp212 100000000
+  204 assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  205 label *label93
   206 set :assertEqualsRound:expected 1
   207 set :assertEqualsRound:actual 0.9999999999999999
   208 set :assertEqualsRound:title "tan"
-    * setaddr :assertEqualsRound*retaddr *label60 (h:*label60)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label60) (h:*label60)
-    * label *label60
+  209 label *label94
+  210 op mul :round.1:x :assertEqualsRound:actual 100000000
+  211 op add *tmp213 :round.1:x 0.5
+  212 op floor *tmp212 *tmp213
+  213 label *label95
+  214 op div *tmp215 *tmp212 100000000
+  215 assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  216 label *label96
   217 set :assertEqualsRound:expected 90
   218 set :assertEqualsRound:actual 90
   219 set :assertEqualsRound:title "asin"
-    * setaddr :assertEqualsRound*retaddr *label61 (h:*label61)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label61) (h:*label61)
-    * label *label61
+  220 label *label97
+  221 op mul :round.1:x :assertEqualsRound:actual 100000000
+  222 op add *tmp213 :round.1:x 0.5
+  223 op floor *tmp212 *tmp213
+  224 label *label98
+  225 op div *tmp215 *tmp212 100000000
+  226 assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  227 label *label99
   228 set :assertEqualsRound:expected 0
   229 set :assertEqualsRound:actual 0
   230 set :assertEqualsRound:title "acos"
-    * setaddr :assertEqualsRound*retaddr *label62 (h:*label62)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label62) (h:*label62)
-    * label *label62
+  231 label *label100
+  232 op mul :round.1:x :assertEqualsRound:actual 100000000
+  233 op add *tmp213 :round.1:x 0.5
+  234 op floor *tmp212 *tmp213
+  235 label *label101
+  236 op div *tmp215 *tmp212 100000000
+  237 assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  238 label *label102
   239 set :assertEqualsRound:expected 45
   240 set :assertEqualsRound:actual 45
   241 set :assertEqualsRound:title "atan"
-    * setaddr :assertEqualsRound*retaddr *label63 (h:*label63)
-    * call *label3 *invalid :assertEqualsRound*retval (m:*label63) (h:*label63)
-    * label *label63
+  242 label *label103
+  243 op mul :round.1:x :assertEqualsRound:actual 100000000
+  244 op add *tmp213 :round.1:x 0.5
+  245 op floor *tmp212 *tmp213
+  246 label *label104
+  247 op div *tmp215 *tmp212 100000000
+  248 assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  249 label *label105
   250 label *label64
   251 op sub *tmp167 -8 zero
   252 assertequals -8 *tmp167 "unary minus"
 
   303 assertequals 17 *tmp210 "Logic ID"
   304 stop
   305 end
-    * label *label3
-    * op mul :round.1:x :assertEqualsRound:actual 100000000
-    * op add *tmp213 :round.1:x 0.5
-    * op floor *tmp212 *tmp213
-    * label *label87
-    * op div *tmp215 *tmp212 100000000
-    * assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
-    * label *label86
-    * return :assertEqualsRound*retaddr
-    * end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   185 set :assertEqualsRound:actual 1
   186 set :assertEqualsRound:title "sin"
   187 label *label88
-    * op mul :round.1:x :assertEqualsRound:actual 100000000
-    * op add *tmp213 :round.1:x 0.5
-    * op floor *tmp212 *tmp213
+  188 op mul :round.1:x 1 100000000
+  189 op add *tmp213 100000000 0.5
+  190 op floor *tmp212 100000000.5
   191 label *label89
-    * op div *tmp215 *tmp212 100000000
-    * assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  192 op div *tmp215 100000000 100000000
+  193 assertequals 1 1 "sin"
   194 label *label90
   195 set :assertEqualsRound:expected -1
   196 set :assertEqualsRound:actual -1
   197 set :assertEqualsRound:title "cos"
   198 label *label91
-    * op mul :round.1:x :assertEqualsRound:actual 100000000
-    * op add *tmp213 :round.1:x 0.5
-    * op floor *tmp212 *tmp213
+  199 op mul :round.1:x -1 100000000
+  200 op add *tmp213 -100000000 0.5
+  201 op floor *tmp212 -99999999.5
   202 label *label92
-    * op div *tmp215 *tmp212 100000000
-    * assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  203 op div *tmp215 -100000000 100000000
+  204 assertequals -1 -1 "cos"
   205 label *label93
   206 set :assertEqualsRound:expected 1
   207 set :assertEqualsRound:actual 0.9999999999999999
   208 set :assertEqualsRound:title "tan"
   209 label *label94
-    * op mul :round.1:x :assertEqualsRound:actual 100000000
-    * op add *tmp213 :round.1:x 0.5
-    * op floor *tmp212 *tmp213
+  210 op mul :round.1:x 0.9999999999999999 100000000
+  211 op add *tmp213 99999999.99999999 0.5
+  212 op floor *tmp212 100000000.49999999
   213 label *label95
-    * op div *tmp215 *tmp212 100000000
-    * assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  214 op div *tmp215 100000000 100000000
+  215 assertequals 1 1 "tan"
   216 label *label96
   217 set :assertEqualsRound:expected 90
   218 set :assertEqualsRound:actual 90
   219 set :assertEqualsRound:title "asin"
   220 label *label97
-    * op mul :round.1:x :assertEqualsRound:actual 100000000
-    * op add *tmp213 :round.1:x 0.5
-    * op floor *tmp212 *tmp213
+  221 op mul :round.1:x 90 100000000
+  222 op add *tmp213 9000000000 0.5
+  223 op floor *tmp212 9000000000.5
   224 label *label98
-    * op div *tmp215 *tmp212 100000000
-    * assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  225 op div *tmp215 9000000000 100000000
+  226 assertequals 90 90 "asin"
   227 label *label99
   228 set :assertEqualsRound:expected 0
   229 set :assertEqualsRound:actual 0
   230 set :assertEqualsRound:title "acos"
   231 label *label100
-    * op mul :round.1:x :assertEqualsRound:actual 100000000
-    * op add *tmp213 :round.1:x 0.5
-    * op floor *tmp212 *tmp213
+  232 op mul :round.1:x 0 100000000
+  233 op add *tmp213 0 0.5
+  234 op floor *tmp212 0.5
   235 label *label101
-    * op div *tmp215 *tmp212 100000000
-    * assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  236 op div *tmp215 0 100000000
+  237 assertequals 0 0 "acos"
   238 label *label102
   239 set :assertEqualsRound:expected 45
   240 set :assertEqualsRound:actual 45
   241 set :assertEqualsRound:title "atan"
   242 label *label103
-    * op mul :round.1:x :assertEqualsRound:actual 100000000
-    * op add *tmp213 :round.1:x 0.5
-    * op floor *tmp212 *tmp213
+  243 op mul :round.1:x 45 100000000
+  244 op add *tmp213 4500000000 0.5
+  245 op floor *tmp212 4500000000.5
   246 label *label104
-    * op div *tmp215 *tmp212 100000000
-    * assertequals :assertEqualsRound:expected *tmp215 :assertEqualsRound:title
+  247 op div *tmp215 4500000000 100000000
+  248 assertequals 45 45 "atan"
   249 label *label105
   250 label *label64
   251 op sub *tmp167 -8 zero

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-42 instructions):
 
   181 op angleDiff *tmp164 45 *tmp162
   182 assertequals 90 *tmp164 "angleDiff"
   183 assertequals 5 5 "len"
-    * set :assertEqualsRound:expected 1
-    * set :assertEqualsRound:actual 1
-    * set :assertEqualsRound:title "sin"
   184 label *label88
-    * op mul :round.1:x 1 100000000
-    * op add *tmp213 100000000 0.5
-    * op floor *tmp212 100000000.5
   185 label *label89
-    * op div *tmp215 100000000 100000000
   186 assertequals 1 1 "sin"
   187 label *label90
-    * set :assertEqualsRound:expected -1
-    * set :assertEqualsRound:actual -1
-    * set :assertEqualsRound:title "cos"
   188 label *label91
-    * op mul :round.1:x -1 100000000
-    * op add *tmp213 -100000000 0.5
-    * op floor *tmp212 -99999999.5
   189 label *label92
-    * op div *tmp215 -100000000 100000000
   190 assertequals -1 -1 "cos"
   191 label *label93
-    * set :assertEqualsRound:expected 1
-    * set :assertEqualsRound:actual 0.9999999999999999
-    * set :assertEqualsRound:title "tan"
   192 label *label94
-    * op mul :round.1:x 0.9999999999999999 100000000
-    * op add *tmp213 99999999.99999999 0.5
-    * op floor *tmp212 100000000.49999999
   193 label *label95
-    * op div *tmp215 100000000 100000000
   194 assertequals 1 1 "tan"
   195 label *label96
-    * set :assertEqualsRound:expected 90
-    * set :assertEqualsRound:actual 90
-    * set :assertEqualsRound:title "asin"
   196 label *label97
-    * op mul :round.1:x 90 100000000
-    * op add *tmp213 9000000000 0.5
-    * op floor *tmp212 9000000000.5
   197 label *label98
-    * op div *tmp215 9000000000 100000000
   198 assertequals 90 90 "asin"
   199 label *label99
-    * set :assertEqualsRound:expected 0
-    * set :assertEqualsRound:actual 0
-    * set :assertEqualsRound:title "acos"
   200 label *label100
-    * op mul :round.1:x 0 100000000
-    * op add *tmp213 0 0.5
-    * op floor *tmp212 0.5
   201 label *label101
-    * op div *tmp215 0 100000000
   202 assertequals 0 0 "acos"
   203 label *label102
-    * set :assertEqualsRound:expected 45
-    * set :assertEqualsRound:actual 45
-    * set :assertEqualsRound:title "atan"
   204 label *label103
-    * op mul :round.1:x 45 100000000
-    * op add *tmp213 4500000000 0.5
-    * op floor *tmp212 4500000000.5
   205 label *label104
-    * op div *tmp215 4500000000 100000000
   206 assertequals 45 45 "atan"
   207 label *label105
   208 label *label64

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    50 label *label18
    51 op notEqual *tmp44 0 *tmp33
    52 assertequals false *tmp44 "notEqual null"
-    * op add *tmp45 zero 0
+   53 set *tmp45 zero
    54 label *label19
    55 op land *tmp47 1 *tmp45
    56 assertequals false *tmp47 "land 1"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    52 assertequals false *tmp44 "notEqual null"
    53 set *tmp45 zero
    54 label *label19
-    * op land *tmp47 1 *tmp45
+   55 op land *tmp47 1 zero
    56 assertequals false *tmp47 "land 1"
    57 label *label20
    58 op land *tmp50 1 *tmp6
 
    62 op lessThan *tmp53 0 *tmp51
    63 assertequals true *tmp53 "lessThan 1"
    64 label *label22
-    * op lessThan *tmp56 1 *tmp45
+   65 op lessThan *tmp56 1 zero
    66 assertequals false *tmp56 "lessThan 2"
    67 label *label23
    68 op lessThanEq *tmp59 1 *tmp51
    69 assertequals true *tmp59 "lessThanEq 1"
    70 label *label24
-    * op lessThanEq *tmp62 1 *tmp45
+   71 op lessThanEq *tmp62 1 zero
    72 assertequals false *tmp62 "lessThanEq 2"
    73 label *label25
    74 op greaterThan *tmp65 2 *tmp51
 
   106 op xor *tmp94 3 *tmp6
   107 assertequals 1 *tmp94 "xor"
   108 label *label35
-    * op not *tmp97 *tmp45
+  109 op not *tmp97 zero
   110 assertequals -1 *tmp97 "not 1"
   111 op add *tmp98 zero 65535
   112 label *label36
 
   139 label *label44
   140 assertequals 1 *tmp123 "sign(2)"
   141 label *label45
-    * op greaterThan *tmp130 *tmp45 0
-    * op lessThan *tmp131 *tmp45 0
+  142 op greaterThan *tmp130 zero 0
+  143 op lessThan *tmp131 zero 0
   144 op sub *tmp129 *tmp130 *tmp131
   145 label *label46
   146 assertequals 0 *tmp129 "sign(0)"
 
   209 op sub *tmp167 -8 zero
   210 assertequals -8 *tmp167 "unary minus"
   211 label *label65
-    * op equal *tmp170 *tmp45 false
+  212 op equal *tmp170 zero false
   213 assertequals 1 *tmp170 "boolean negation 1"
   214 label *label66
   215 op equal *tmp173 *tmp51 false

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
    50 label *label18
    51 op notEqual *tmp44 0 *tmp33
    52 assertequals false *tmp44 "notEqual null"
-    * set *tmp45 zero
    53 label *label19
    54 op land *tmp47 1 zero
    55 assertequals false *tmp47 "land 1"

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
     0 set NULL null
     1 set zero 0
-    * label *label4
     2 op add *tmp2 zero 5
     3 assertequals 5 *tmp2 "add"
     4 op add *tmp3 zero 6
-    * label *label5
     5 op sub *tmp5 1 zero
     6 assertequals 1 *tmp5 "sub"
     7 op add *tmp6 zero 2
-    * label *label6
     8 op mul *tmp8 3 *tmp6
     9 assertequals 6 *tmp8 "mul"
    10 op add *tmp9 zero 4
-    * label *label7
    11 op div *tmp11 6 *tmp9
    12 assertequals 1.5 *tmp11 "div"
    13 op add *tmp12 zero 100000
-    * label *label8
    14 op div *tmp14 1 *tmp12
    15 assertequals 0.00001 *tmp14 "div exp"
-    * label *label9
    16 op idiv *tmp17 6 *tmp9
    17 assertequals 1 *tmp17 "idiv"
-    * label *label10
    18 op mod *tmp20 6 *tmp9
    19 assertequals 2 *tmp20 "mod"
    20 op add *tmp21 zero 8
-    * label *label11
    21 op emod *tmp23 -3 *tmp21
    22 assertequals 5 *tmp23 "emod"
-    * label *label12
    23 op pow *tmp26 2 *tmp9
    24 assertequals 16 *tmp26 "pow"
-    * label *label13
    25 op equal *tmp29 5 *tmp2
    26 assertequals true *tmp29 "equal 1"
-    * label *label14
    27 op equal *tmp32 5 *tmp3
    28 assertequals false *tmp32 "equal 2"
    29 op add *tmp33 zero null
-    * label *label15
    30 op equal *tmp35 0 *tmp33
    31 assertequals true *tmp35 "equal null"
-    * label *label16
    32 op notEqual *tmp38 5 *tmp2
    33 assertequals false *tmp38 "notEqual 1"
-    * label *label17
    34 op notEqual *tmp41 5 *tmp3
    35 assertequals true *tmp41 "notEqual 2"
-    * label *label18
    36 op notEqual *tmp44 0 *tmp33
    37 assertequals false *tmp44 "notEqual null"
-    * label *label19
    38 op land *tmp47 1 zero
    39 assertequals false *tmp47 "land 1"
-    * label *label20
    40 op land *tmp50 1 *tmp6
    41 assertequals true *tmp50 "land 2"
    42 op add *tmp51 zero 1
-    * label *label21
    43 op lessThan *tmp53 0 *tmp51
    44 assertequals true *tmp53 "lessThan 1"
-    * label *label22
    45 op lessThan *tmp56 1 zero
    46 assertequals false *tmp56 "lessThan 2"
-    * label *label23
    47 op lessThanEq *tmp59 1 *tmp51
    48 assertequals true *tmp59 "lessThanEq 1"
-    * label *label24
    49 op lessThanEq *tmp62 1 zero
    50 assertequals false *tmp62 "lessThanEq 2"
-    * label *label25
    51 op greaterThan *tmp65 2 *tmp51
    52 assertequals true *tmp65 "greaterThan 1"
-    * label *label26
    53 op greaterThan *tmp68 1 *tmp6
    54 assertequals false *tmp68 "greaterThan 2"
-    * label *label27
    55 op greaterThanEq *tmp71 1 *tmp51
    56 assertequals true *tmp71 "greaterThanEq 1"
-    * label *label28
    57 op greaterThanEq *tmp74 1 *tmp6
    58 assertequals false *tmp74 "greaterThanEq 2"
    59 op strictEqual *tmp75 0 NULL
    60 assertequals false *tmp75 "strictEqual 1"
    61 op strictEqual *tmp76 null NULL
    62 assertequals true *tmp76 "strictEqual 2"
-    * label *label29
    63 op shl *tmp79 1 *tmp6
    64 assertequals 4 *tmp79 "shl"
-    * label *label30
    65 op shr *tmp82 9 *tmp6
    66 assertequals 2 *tmp82 "shr"
    67 op add *tmp83 zero 61
-    * label *label31
    68 op ushr *tmp85 -1 *tmp83
    69 assertequals 7 *tmp85 "ushr"
-    * label *label32
    70 op or *tmp88 1 *tmp6
    71 assertequals 3 *tmp88 "or"
-    * label *label33
    72 op and *tmp91 3 *tmp6
    73 assertequals 2 *tmp91 "and"
-    * label *label34
    74 op xor *tmp94 3 *tmp6
    75 assertequals 1 *tmp94 "xor"
-    * label *label35
    76 op not *tmp97 zero
    77 assertequals -1 *tmp97 "not 1"
    78 op add *tmp98 zero 65535
-    * label *label36
    79 op not *tmp100 *tmp98
    80 assertequals -65536 *tmp100 "not 2"
    81 op add *tmp103 zero 0xabcdefabcdef
-    * label *label37
    82 op not *tmp105 *tmp103
    83 assertequals -188900977659376 *tmp105 "not 3"
-    * label *label38
    84 op max *tmp108 2 *tmp9
    85 assertequals 4 *tmp108 "max"
-    * label *label39
    86 op min *tmp111 2 *tmp9
    87 assertequals 2 *tmp111 "min"
    88 op add *tmp112 zero -2
-    * label *label40
    89 op abs *tmp114 *tmp112
    90 assertequals 2 *tmp114 "abs"
-    * label *label41
    91 op greaterThan *tmp118 *tmp112 0
    92 op lessThan *tmp119 *tmp112 0
    93 op sub *tmp117 *tmp118 *tmp119
-    * label *label42
    94 assertequals -1 *tmp117 "sign(-2)"
-    * label *label43
    95 op greaterThan *tmp124 *tmp6 0
    96 op lessThan *tmp125 *tmp6 0
    97 op sub *tmp123 *tmp124 *tmp125
-    * label *label44
    98 assertequals 1 *tmp123 "sign(2)"
-    * label *label45
    99 op greaterThan *tmp130 zero 0
   100 op lessThan *tmp131 zero 0
   101 op sub *tmp129 *tmp130 *tmp131
-    * label *label46
   102 assertequals 0 *tmp129 "sign(0)"
   103 op add *tmp133 zero 2.718281828459045
-    * label *label47
   104 op log *tmp135 *tmp133
   105 assertequals 1 *tmp135 "log"
   106 op add *tmp136 zero 10
-    * label *label48
   107 op log10 *tmp138 *tmp136
   108 assertequals 1 *tmp138 "log10"
-    * label *label49
   109 op log *tmp143 *tmp6
   110 op div *tmp141 2.772588722239781 *tmp143
-    * label *label50
   111 assertequals 4 *tmp141 "logn"
   112 op add *tmp145 zero 2.5
-    * label *label51
   113 op floor *tmp147 *tmp145
   114 assertequals 2 *tmp147 "floor"
-    * label *label52
   115 op ceil *tmp150 *tmp145
   116 assertequals 3 *tmp150 "ceil"
-    * label *label53
   117 op add *tmp154 zero 3
   118 op floor *tmp153 *tmp154
-    * label *label54
   119 assertequals 3 *tmp153 "round"
   120 op add *tmp156 zero 16
-    * label *label55
   121 op sqrt *tmp158 *tmp156
   122 assertequals 4 *tmp158 "sqrt"
-    * label *label56
   123 op angle *tmp161 1 *tmp51
   124 assertequals 45 *tmp161 "angle"
   125 op add *tmp162 zero 135
-    * label *label57
   126 op angleDiff *tmp164 45 *tmp162
   127 assertequals 90 *tmp164 "angleDiff"
   128 assertequals 5 5 "len"
-    * label *label88
-    * label *label89
   129 assertequals 1 1 "sin"
-    * label *label90
-    * label *label91
-    * label *label92
   130 assertequals -1 -1 "cos"
-    * label *label93
-    * label *label94
-    * label *label95
   131 assertequals 1 1 "tan"
-    * label *label96
-    * label *label97
-    * label *label98
   132 assertequals 90 90 "asin"
-    * label *label99
-    * label *label100
-    * label *label101
   133 assertequals 0 0 "acos"
-    * label *label102
-    * label *label103
-    * label *label104
   134 assertequals 45 45 "atan"
-    * label *label105
-    * label *label64
   135 op sub *tmp167 -8 zero
   136 assertequals -8 *tmp167 "unary minus"
-    * label *label65
   137 op equal *tmp170 zero false
   138 assertequals 1 *tmp170 "boolean negation 1"
-    * label *label66
   139 op equal *tmp173 *tmp51 false
   140 assertequals 0 *tmp173 "boolean negation 2"
-    * label *label67
   141 op equal *tmp176 *tmp6 false
   142 assertequals 0 *tmp176 "boolean negation 3"
-    * label *label68
   143 assertequals 16 *tmp26 "**="
-    * label *label69
   144 op mul :a 2 *tmp9
   145 assertequals 8 :a "*="
-    * label *label70
   146 assertequals 1.5 *tmp11 "/="
-    * label *label71
   147 assertequals 1 *tmp17 "\="
-    * label *label72
   148 assertequals 2 *tmp20 "%="
-    * label *label73
   149 assertequals 6 *tmp3 "+="
-    * label *label74
   150 op sub :a 2 zero
   151 assertequals 2 :a "-="
-    * label *label75
   152 assertequals 4 *tmp79 "<<="
-    * label *label76
   153 assertequals 2 *tmp82 ">>="
-    * label *label77
   154 assertequals 3 *tmp88 "|="
-    * label *label78
   155 assertequals 2 *tmp91 "&="
-    * label *label79
   156 assertequals 1 *tmp94 "^="
-    * label *label80
   157 assertequals false *tmp47 "&&="
-    * label *label81
   158 assertequals true *tmp50 "&&="
-    * label *label82
   159 op or *tmp207 0 *tmp6
   160 op notEqual :a *tmp207 false
   161 assertequals true :a "||="
   162 assertequals %ff0000ff %ff0000 "short color literals"
   163 assertequals %ffffffff %[white] "named color literals"
   164 select *tmp209 notEqual zero false null @copper-wall
-    * label *label84
-    * label *label85
-    * label *label83
   165 sensor *tmp210 *tmp209 @id
   166 assertequals 17 *tmp210 "Logic ID"
   167 stop

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   165 sensor *tmp210 *tmp209 @id
   166 assertequals 17 *tmp210 "Logic ID"
   167 stop
-    * end

Final code before resolving virtual instructions:

set NULL null
set zero 0
op add *tmp2 zero 5
assertequals 5 *tmp2 "add"
op add *tmp3 zero 6
op sub *tmp5 1 zero
assertequals 1 *tmp5 "sub"
op add *tmp6 zero 2
op mul *tmp8 3 *tmp6
assertequals 6 *tmp8 "mul"
op add *tmp9 zero 4
op div *tmp11 6 *tmp9
assertequals 1.5 *tmp11 "div"
op add *tmp12 zero 100000
op div *tmp14 1 *tmp12
assertequals 0.00001 *tmp14 "div exp"
op idiv *tmp17 6 *tmp9
assertequals 1 *tmp17 "idiv"
op mod *tmp20 6 *tmp9
assertequals 2 *tmp20 "mod"
op add *tmp21 zero 8
op emod *tmp23 -3 *tmp21
assertequals 5 *tmp23 "emod"
op pow *tmp26 2 *tmp9
assertequals 16 *tmp26 "pow"
op equal *tmp29 5 *tmp2
assertequals true *tmp29 "equal 1"
op equal *tmp32 5 *tmp3
assertequals false *tmp32 "equal 2"
op add *tmp33 zero null
op equal *tmp35 0 *tmp33
assertequals true *tmp35 "equal null"
op notEqual *tmp38 5 *tmp2
assertequals false *tmp38 "notEqual 1"
op notEqual *tmp41 5 *tmp3
assertequals true *tmp41 "notEqual 2"
op notEqual *tmp44 0 *tmp33
assertequals false *tmp44 "notEqual null"
op land *tmp47 1 zero
assertequals false *tmp47 "land 1"
op land *tmp50 1 *tmp6
assertequals true *tmp50 "land 2"
op add *tmp51 zero 1
op lessThan *tmp53 0 *tmp51
assertequals true *tmp53 "lessThan 1"
op lessThan *tmp56 1 zero
assertequals false *tmp56 "lessThan 2"
op lessThanEq *tmp59 1 *tmp51
assertequals true *tmp59 "lessThanEq 1"
op lessThanEq *tmp62 1 zero
assertequals false *tmp62 "lessThanEq 2"
op greaterThan *tmp65 2 *tmp51
assertequals true *tmp65 "greaterThan 1"
op greaterThan *tmp68 1 *tmp6
assertequals false *tmp68 "greaterThan 2"
op greaterThanEq *tmp71 1 *tmp51
assertequals true *tmp71 "greaterThanEq 1"
op greaterThanEq *tmp74 1 *tmp6
assertequals false *tmp74 "greaterThanEq 2"
op strictEqual *tmp75 0 NULL
assertequals false *tmp75 "strictEqual 1"
op strictEqual *tmp76 null NULL
assertequals true *tmp76 "strictEqual 2"
op shl *tmp79 1 *tmp6
assertequals 4 *tmp79 "shl"
op shr *tmp82 9 *tmp6
assertequals 2 *tmp82 "shr"
op add *tmp83 zero 61
op ushr *tmp85 -1 *tmp83
assertequals 7 *tmp85 "ushr"
op or *tmp88 1 *tmp6
assertequals 3 *tmp88 "or"
op and *tmp91 3 *tmp6
assertequals 2 *tmp91 "and"
op xor *tmp94 3 *tmp6
assertequals 1 *tmp94 "xor"
op not *tmp97 zero
assertequals -1 *tmp97 "not 1"
op add *tmp98 zero 65535
op not *tmp100 *tmp98
assertequals -65536 *tmp100 "not 2"
op add *tmp103 zero 0xabcdefabcdef
op not *tmp105 *tmp103
assertequals -188900977659376 *tmp105 "not 3"
op max *tmp108 2 *tmp9
assertequals 4 *tmp108 "max"
op min *tmp111 2 *tmp9
assertequals 2 *tmp111 "min"
op add *tmp112 zero -2
op abs *tmp114 *tmp112
assertequals 2 *tmp114 "abs"
op greaterThan *tmp118 *tmp112 0
op lessThan *tmp119 *tmp112 0
op sub *tmp117 *tmp118 *tmp119
assertequals -1 *tmp117 "sign(-2)"
op greaterThan *tmp124 *tmp6 0
op lessThan *tmp125 *tmp6 0
op sub *tmp123 *tmp124 *tmp125
assertequals 1 *tmp123 "sign(2)"
op greaterThan *tmp130 zero 0
op lessThan *tmp131 zero 0
op sub *tmp129 *tmp130 *tmp131
assertequals 0 *tmp129 "sign(0)"
op add *tmp133 zero 2.718281828459045
op log *tmp135 *tmp133
assertequals 1 *tmp135 "log"
op add *tmp136 zero 10
op log10 *tmp138 *tmp136
assertequals 1 *tmp138 "log10"
op log *tmp143 *tmp6
op div *tmp141 2.772588722239781 *tmp143
assertequals 4 *tmp141 "logn"
op add *tmp145 zero 2.5
op floor *tmp147 *tmp145
assertequals 2 *tmp147 "floor"
op ceil *tmp150 *tmp145
assertequals 3 *tmp150 "ceil"
op add *tmp154 zero 3
op floor *tmp153 *tmp154
assertequals 3 *tmp153 "round"
op add *tmp156 zero 16
op sqrt *tmp158 *tmp156
assertequals 4 *tmp158 "sqrt"
op angle *tmp161 1 *tmp51
assertequals 45 *tmp161 "angle"
op add *tmp162 zero 135
op angleDiff *tmp164 45 *tmp162
assertequals 90 *tmp164 "angleDiff"
assertequals 5 5 "len"
assertequals 1 1 "sin"
assertequals -1 -1 "cos"
assertequals 1 1 "tan"
assertequals 90 90 "asin"
assertequals 0 0 "acos"
assertequals 45 45 "atan"
op sub *tmp167 -8 zero
assertequals -8 *tmp167 "unary minus"
op equal *tmp170 zero false
assertequals 1 *tmp170 "boolean negation 1"
op equal *tmp173 *tmp51 false
assertequals 0 *tmp173 "boolean negation 2"
op equal *tmp176 *tmp6 false
assertequals 0 *tmp176 "boolean negation 3"
assertequals 16 *tmp26 "**="
op mul :a 2 *tmp9
assertequals 8 :a "*="
assertequals 1.5 *tmp11 "/="
assertequals 1 *tmp17 "\="
assertequals 2 *tmp20 "%="
assertequals 6 *tmp3 "+="
op sub :a 2 zero
assertequals 2 :a "-="
assertequals 4 *tmp79 "<<="
assertequals 2 *tmp82 ">>="
assertequals 3 *tmp88 "|="
assertequals 2 *tmp91 "&="
assertequals 1 *tmp94 "^="
assertequals false *tmp47 "&&="
assertequals true *tmp50 "&&="
op or *tmp207 0 *tmp6
op notEqual :a *tmp207 false
assertequals true :a "||="
assertequals %ff0000ff %ff0000 "short color literals"
assertequals %ffffffff %[white] "named color literals"
select *tmp209 notEqual zero false null @copper-wall
sensor *tmp210 *tmp209 @id
assertequals 17 *tmp210 "Logic ID"
stop
