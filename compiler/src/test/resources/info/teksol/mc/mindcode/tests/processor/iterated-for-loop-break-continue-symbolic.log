    47 instructions before optimizations.
     3 instructions eliminated by Temp Variables Elimination (2 iterations).
     5 instructions eliminated by Dead Code Elimination (4 iterations).
     3 instructions eliminated by Jump Optimization (4 iterations).
     2 instructions eliminated by Single Step Elimination (5 iterations).
     2 instructions modified by Data Flow Optimization (4 iterations).
     7 instructions added by Loop Optimization (2 iterations).
     1 loops improved by Loop Optimization.
     2 instructions eliminated by Jump Straightening (4 iterations).
     1 instructions eliminated by Unreachable Code Elimination (2 iterations).
     1 instructions eliminated by Print Merging.
    37 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 966):
  * Replicate loop condition at line 4:5                         size    +7, benefit       25.0, efficiency      3.571 (+7 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-5 instructions):
 
    16 op equal *tmp5 *tmp4 4
    17 jump *label5 equal *tmp5 false
    18 jump *label3 always
-    * set *tmp6 null
    19 jump *label6 always
    20 label *label5
-    * set *tmp6 null
    21 label *label6
    22 print :test:i
    23 print "|"
 
    29 op equal *tmp8 *tmp7 10
    30 jump *label7 equal *tmp8 false
    31 jump *label4 always
-    * set *tmp9 null
    32 jump *label8 always
    33 label *label7
-    * set *tmp9 null
    34 label *label8
    35 label *label3
    36 op add :test:i :test:i 2
    37 op add :test:j :test:j 1
    38 jump *label2 always
    39 label *label4
-    * set *tmp0 null
    40 label *label1
    41 assertprints "0|10|2|11|6|13|8|14|10|15|" "iterated-for-loop-break-continue"
    42 stop

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-3 instructions):
 
     7 set *tmp1 :d*retval
     8 set :d:n :test:j
     9 call *label0 :d*retaddr :d*retval
-    * set *tmp2 :d*retval
-    * op lessThanEq *tmp3 *tmp1 *tmp2
+   10 op lessThanEq *tmp3 *tmp1 :d*retval
    11 jump *label4 equal *tmp3 false
    12 set :d:n :test:i
    13 call *label0 :d*retaddr :d*retval
-    * set *tmp4 :d*retval
-    * op equal *tmp5 *tmp4 4
+   14 op equal *tmp5 :d*retval 4
    15 jump *label5 equal *tmp5 false
    16 jump *label3 always
    17 jump *label6 always
 
    23 print "|"
    24 set :d:n :test:i
    25 call *label0 :d*retaddr :d*retval
-    * set *tmp7 :d*retval
-    * op equal *tmp8 *tmp7 10
+   26 op equal *tmp8 :d*retval 10
    27 jump *label7 equal *tmp8 false
    28 jump *label4 always
    29 jump *label8 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-3 instructions):
 
     7 set *tmp1 :d*retval
     8 set :d:n :test:j
     9 call *label0 :d*retaddr :d*retval
-    * op lessThanEq *tmp3 *tmp1 :d*retval
-    * jump *label4 equal *tmp3 false
+   10 jump *label4 greaterThan *tmp1 :d*retval
    11 set :d:n :test:i
    12 call *label0 :d*retaddr :d*retval
-    * op equal *tmp5 :d*retval 4
-    * jump *label5 equal *tmp5 false
+   13 jump *label5 notEqual :d*retval 4
    14 jump *label3 always
    15 jump *label6 always
    16 label *label5
 
    21 print "|"
    22 set :d:n :test:i
    23 call *label0 :d*retaddr :d*retval
-    * op equal *tmp8 :d*retval 10
-    * jump *label7 equal *tmp8 false
+   24 jump *label7 notEqual :d*retval 10
    25 jump *label4 always
    26 jump *label8 always
    27 label *label7

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    12 call *label0 :d*retaddr :d*retval
    13 jump *label5 notEqual :d*retval 4
    14 jump *label3 always
-    * jump *label6 always
    15 label *label5
    16 label *label6
    17 print :test:i
 
    22 call *label0 :d*retaddr :d*retval
    23 jump *label7 notEqual :d*retval 10
    24 jump *label4 always
-    * jump *label8 always
    25 label *label7
    26 label *label8
    27 label *label3

Modifications by Replicate loop condition at line 4:5 (+7 instructions):
 
     8 set :d:n :test:j
     9 call *label0 :d*retaddr :d*retval
    10 jump *label4 greaterThan *tmp1 :d*retval
+   11 label *label10
    12 set :d:n :test:i
    13 call *label0 :d*retaddr :d*retval
    14 jump *label5 notEqual :d*retval 4
 
    28 label *label3
    29 op add :test:i :test:i 2
    30 op add :test:j :test:j 1
-    * jump *label2 always
+   31 set :d:n :test:i
+   32 call *label0 :d*retaddr :d*retval
+   33 set *tmp1 :d*retval
+   34 set :d:n :test:j
+   35 call *label0 :d*retaddr :d*retval
+   36 jump *label10 lessThanEq *tmp1 :d*retval
    37 label *label4
    38 label *label1
    39 assertprints "0|10|2|11|6|13|8|14|10|15|" "iterated-for-loop-break-continue"

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set :test:i 0
     3 set :test:j 10
     4 label *label2
-    * set :d:n :test:i
+    5 set :d:n 0
     6 call *label0 :d*retaddr :d*retval
     7 set *tmp1 :d*retval
-    * set :d:n :test:j
+    8 set :d:n 10
     9 call *label0 :d*retaddr :d*retval
    10 jump *label4 greaterThan *tmp1 :d*retval
    11 label *label10

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
     1 # "Function: def test()"
     2 set :test:i 0
     3 set :test:j 10
-    * label *label2
     4 set :d:n 0
     5 call *label0 :d*retaddr :d*retval
     6 set *tmp1 :d*retval
 
    13 jump *label5 notEqual :d*retval 4
    14 jump *label3 always
    15 label *label5
-    * label *label6
    16 print :test:i
    17 print "|"
    18 print :test:j
 
    22 jump *label7 notEqual :d*retval 10
    23 jump *label4 always
    24 label *label7
-    * label *label8
    25 label *label3
    26 op add :test:i :test:i 2
    27 op add :test:j :test:j 1
 
    32 call *label0 :d*retaddr :d*retval
    33 jump *label10 lessThanEq *tmp1 :d*retval
    34 label *label4
-    * label *label1
    35 assertprints "0|10|2|11|6|13|8|14|10|15|" "iterated-for-loop-break-continue"
    36 stop
    37 end
    38 label *label0
    39 # "Function: noinline def d(in n)"
    40 set :d*retval :d:n
-    * label *label9
    41 return :d*retaddr
    42 end

Modifications by Jumps phase, Jump Straightening, pass 3, iteration 1 (-2 instructions):
 
    10 label *label10
    11 set :d:n :test:i
    12 call *label0 :d*retaddr :d*retval
-    * jump *label5 notEqual :d*retval 4
-    * jump *label3 always
+   13 jump *label3 equal :d*retval 4
    14 label *label5
    15 print :test:i
    16 print "|"
 
    18 print "|"
    19 set :d:n :test:i
    20 call *label0 :d*retaddr :d*retval
-    * jump *label7 notEqual :d*retval 10
-    * jump *label4 always
+   21 jump *label4 equal :d*retval 10
    22 label *label7
    23 label *label3
    24 op add :test:i :test:i 2

Modifications by Jumps phase, Jump Optimization, pass 3, iteration 1:
 
    11 set :d:n :test:i
    12 call *label0 :d*retaddr :d*retval
    13 jump *label3 equal :d*retval 4
-    * label *label5
    14 print :test:i
    15 print "|"
    16 print :test:j
 
    18 set :d:n :test:i
    19 call *label0 :d*retaddr :d*retval
    20 jump *label4 equal :d*retval 10
-    * label *label7
    21 label *label3
    22 op add :test:i :test:i 2
    23 op add :test:j :test:j 1

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-1 instructions):
 
    35 # "Function: noinline def d(in n)"
    36 set :d*retval :d:n
    37 return :d*retaddr
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-1 instructions):
 
    12 call *label0 :d*retaddr :d*retval
    13 jump *label3 equal :d*retval 4
    14 print :test:i
-    * print "|"
-    * print :test:j
-    * print "|"
+   15 print "|{0}|"
+   16 format :test:j
    17 set :d:n :test:i
    18 call *label0 :d*retaddr :d*retval
    19 jump *label4 equal :d*retval 10

Final code before resolving virtual instructions:

assertflush
# "Function: def test()"
set :test:i 0
set :test:j 10
set :d:n 0
call *label0 :d*retaddr :d*retval
set *tmp1 :d*retval
set :d:n 10
call *label0 :d*retaddr :d*retval
jump *label4 greaterThan *tmp1 :d*retval
label *label10
set :d:n :test:i
call *label0 :d*retaddr :d*retval
jump *label3 equal :d*retval 4
print :test:i
print "|{0}|"
format :test:j
set :d:n :test:i
call *label0 :d*retaddr :d*retval
jump *label4 equal :d*retval 10
label *label3
op add :test:i :test:i 2
op add :test:j :test:j 1
set :d:n :test:i
call *label0 :d*retaddr :d*retval
set *tmp1 :d*retval
set :d:n :test:j
call *label0 :d*retaddr :d*retval
jump *label10 lessThanEq *tmp1 :d*retval
label *label4
assertprints "0|10|2|11|6|13|8|14|10|15|" "iterated-for-loop-break-continue"
stop
end
label *label0
# "Function: noinline def d(in n)"
set :d*retval :d:n
return :d*retaddr
