   117 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination.
     2 instructions eliminated by Dead Code Elimination (3 iterations).
     5 instructions eliminated by Jump Normalization (5 iterations).
     1 instructions eliminated by Jump Optimization (5 iterations).
    17 instructions eliminated by Single Step Elimination (3 passes, 17 iterations).
   200 instructions eliminated by Expression Optimization (4 iterations).
    85 instructions eliminated by Data Flow Optimization (4 passes, 34 iterations).
     1 instructions eliminated by Loop Optimization (4 iterations).
     1 loops improved by Loop Optimization.
   212 instructions added by Loop Unrolling (7 iterations).
     2 loops unrolled by Loop Unrolling.
     1 jump tables inlined by Array Optimization.
     9 instructions eliminated by Print Merging.
     3 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 893):
    Unroll loop at line 6:5                                      cost     3, benefit      500.0, efficiency      166.7
  * Unroll iteration loop at line 18:5                           cost     0, benefit       69.0, efficiency   Infinity (-31 instructions)
    Inline write jump table of array 'array'                     cost     0, benefit       50.0, efficiency   Infinity
    Inline array access at line 7:9                              cost    17, benefit       50.0, efficiency        2.9

Pass 1: speed optimization selection (cost limit 924):
    Unroll loop at line 6:5                                      cost     3, benefit      500.0, efficiency      166.7
  * Inline write jump table of array 'array'                     cost     0, benefit       50.0, efficiency   Infinity (-4 instructions)
    Inline array access at line 7:9                              cost    17, benefit       50.0, efficiency        2.9

Pass 1: speed optimization selection (cost limit 928):
  * Unroll loop at line 6:5                                      cost     0, benefit      500.0, efficiency   Infinity (+186 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    83 op lessThan *tmp4 :reverse.0:count 0
    84 jump *label19 equal *tmp4 false
    85 jump *label6 always
-    * set *tmp5 null
    86 jump *label20 always
    87 label *label19
-    * set *tmp5 null
    88 label *label20
    89 set :reverse.0:t :reverse.0:i
    90 set :reverse.0:i :reverse.0:j

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
     0 set :i 0
     1 label *label0
     2 jump *label2 greaterThanEq :i 10
-    * set *tmp0 :i
-    * writearr<regular> :i .array[] *tmp0
+    3 writearr<regular> :i .array[] :i
     4 label *label1
     5 op add :i :i 1
     6 jump *label0 always
     7 label *label2
     8 # "Function: inline void reverse(in array...)"
-    * op idiv *tmp2 10 2
-    * set :reverse.0:count *tmp2
+    9 op idiv :reverse.0:count 10 2
    10 set :reverse.0:i .array*0
    11 set :reverse.0:j .array*9
    12 op add *tmp3 @counter 1

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-1 instructions):
 
    78 jump *label18 always
    79 label *label4
    80 op sub :reverse.0:count :reverse.0:count 1
-    * op lessThan *tmp4 :reverse.0:count 0
-    * jump *label19 equal *tmp4 false
+   81 jump *label19 greaterThanEq :reverse.0:count 0
    82 jump *label6 always
    83 jump *label20 always
    84 label *label19

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-1 instructions):
 
    80 op sub :reverse.0:count :reverse.0:count 1
    81 jump *label19 greaterThanEq :reverse.0:count 0
    82 jump *label6 always
-    * jump *label20 always
    83 label *label19
    84 label *label20
    85 set :reverse.0:t :reverse.0:i

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    13 jump *label4 always
    14 multilabel *label7
    15 set .array*0 :reverse.0:i
-    * set .array*9 :reverse.0:j
+   16 set .array*9 :reverse.0:t
    17 set :reverse.0:i .array*1
    18 set :reverse.0:j .array*8
    19 op add *tmp3 @counter 1
    20 jump *label4 always
    21 multilabel *label8
    22 set .array*1 :reverse.0:i
-    * set .array*8 :reverse.0:j
+   23 set .array*8 :reverse.0:t
    24 set :reverse.0:i .array*2
    25 set :reverse.0:j .array*7
    26 op add *tmp3 @counter 1
    27 jump *label4 always
    28 multilabel *label9
    29 set .array*2 :reverse.0:i
-    * set .array*7 :reverse.0:j
+   30 set .array*7 :reverse.0:t
    31 set :reverse.0:i .array*3
    32 set :reverse.0:j .array*6
    33 op add *tmp3 @counter 1
    34 jump *label4 always
    35 multilabel *label10
    36 set .array*3 :reverse.0:i
-    * set .array*6 :reverse.0:j
+   37 set .array*6 :reverse.0:t
    38 set :reverse.0:i .array*4
    39 set :reverse.0:j .array*5
    40 op add *tmp3 @counter 1
    41 jump *label4 always
    42 multilabel *label11
    43 set .array*4 :reverse.0:i
-    * set .array*5 :reverse.0:j
+   44 set .array*5 :reverse.0:t
    45 set :reverse.0:i .array*5
    46 set :reverse.0:j .array*4
    47 op add *tmp3 @counter 1
    48 jump *label4 always
    49 multilabel *label12
    50 set .array*5 :reverse.0:i
-    * set .array*4 :reverse.0:j
+   51 set .array*4 :reverse.0:t
    52 set :reverse.0:i .array*6
    53 set :reverse.0:j .array*3
    54 op add *tmp3 @counter 1
    55 jump *label4 always
    56 multilabel *label13
    57 set .array*6 :reverse.0:i
-    * set .array*3 :reverse.0:j
+   58 set .array*3 :reverse.0:t
    59 set :reverse.0:i .array*7
    60 set :reverse.0:j .array*2
    61 op add *tmp3 @counter 1
    62 jump *label4 always
    63 multilabel *label14
    64 set .array*7 :reverse.0:i
-    * set .array*2 :reverse.0:j
+   65 set .array*2 :reverse.0:t
    66 set :reverse.0:i .array*8
    67 set :reverse.0:j .array*1
    68 op add *tmp3 @counter 1
    69 jump *label4 always
    70 multilabel *label15
    71 set .array*8 :reverse.0:i
-    * set .array*1 :reverse.0:j
+   72 set .array*1 :reverse.0:t
    73 set :reverse.0:i .array*9
    74 set :reverse.0:j .array*0
    75 op add *tmp3 @counter 1
 
    90 multilabel *label16
    91 label *label18
    92 set .array*9 :reverse.0:i
-    * set .array*0 :reverse.0:j
+   93 set .array*0 :reverse.0:t
    94 label *label6
    95 label *label3
    96 assertflush

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    84 label *label20
    85 set :reverse.0:t :reverse.0:i
    86 set :reverse.0:i :reverse.0:j
-    * set :reverse.0:j :reverse.0:t
    87 label *label5
    88 multijump *tmp3 0 0
    89 multilabel *label16

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3:
 
    12 op add *tmp3 @counter 1
    13 jump *label4 always
    14 multilabel *label7
-    * set .array*0 :reverse.0:i
+   15 set .array*0 :reverse.0:j
    16 set .array*9 :reverse.0:t
    17 set :reverse.0:i .array*1
    18 set :reverse.0:j .array*8
    19 op add *tmp3 @counter 1
    20 jump *label4 always
    21 multilabel *label8
-    * set .array*1 :reverse.0:i
+   22 set .array*1 :reverse.0:j
    23 set .array*8 :reverse.0:t
    24 set :reverse.0:i .array*2
    25 set :reverse.0:j .array*7
    26 op add *tmp3 @counter 1
    27 jump *label4 always
    28 multilabel *label9
-    * set .array*2 :reverse.0:i
+   29 set .array*2 :reverse.0:j
    30 set .array*7 :reverse.0:t
    31 set :reverse.0:i .array*3
    32 set :reverse.0:j .array*6
    33 op add *tmp3 @counter 1
    34 jump *label4 always
    35 multilabel *label10
-    * set .array*3 :reverse.0:i
+   36 set .array*3 :reverse.0:j
    37 set .array*6 :reverse.0:t
    38 set :reverse.0:i .array*4
    39 set :reverse.0:j .array*5
    40 op add *tmp3 @counter 1
    41 jump *label4 always
    42 multilabel *label11
-    * set .array*4 :reverse.0:i
+   43 set .array*4 :reverse.0:j
    44 set .array*5 :reverse.0:t
    45 set :reverse.0:i .array*5
    46 set :reverse.0:j .array*4
    47 op add *tmp3 @counter 1
    48 jump *label4 always
    49 multilabel *label12
-    * set .array*5 :reverse.0:i
+   50 set .array*5 :reverse.0:j
    51 set .array*4 :reverse.0:t
    52 set :reverse.0:i .array*6
    53 set :reverse.0:j .array*3
    54 op add *tmp3 @counter 1
    55 jump *label4 always
    56 multilabel *label13
-    * set .array*6 :reverse.0:i
+   57 set .array*6 :reverse.0:j
    58 set .array*3 :reverse.0:t
    59 set :reverse.0:i .array*7
    60 set :reverse.0:j .array*2
    61 op add *tmp3 @counter 1
    62 jump *label4 always
    63 multilabel *label14
-    * set .array*7 :reverse.0:i
+   64 set .array*7 :reverse.0:j
    65 set .array*2 :reverse.0:t
    66 set :reverse.0:i .array*8
    67 set :reverse.0:j .array*1
    68 op add *tmp3 @counter 1
    69 jump *label4 always
    70 multilabel *label15
-    * set .array*8 :reverse.0:i
+   71 set .array*8 :reverse.0:j
    72 set .array*1 :reverse.0:t
    73 set :reverse.0:i .array*9
    74 set :reverse.0:j .array*0
 
    88 multijump *tmp3 0 0
    89 multilabel *label16
    90 label *label18
-    * set .array*9 :reverse.0:i
+   91 set .array*9 :reverse.0:j
    92 set .array*0 :reverse.0:t
    93 label *label6
    94 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-1 instructions):
 
    83 label *label19
    84 label *label20
    85 set :reverse.0:t :reverse.0:i
-    * set :reverse.0:i :reverse.0:j
    86 label *label5
    87 multijump *tmp3 0 0
    88 multilabel *label16

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 5:
 
    13 jump *label4 always
    14 multilabel *label7
    15 set .array*0 :reverse.0:j
-    * set .array*9 :reverse.0:t
+   16 set .array*9 :reverse.0:i
    17 set :reverse.0:i .array*1
    18 set :reverse.0:j .array*8
    19 op add *tmp3 @counter 1
    20 jump *label4 always
    21 multilabel *label8
    22 set .array*1 :reverse.0:j
-    * set .array*8 :reverse.0:t
+   23 set .array*8 :reverse.0:i
    24 set :reverse.0:i .array*2
    25 set :reverse.0:j .array*7
    26 op add *tmp3 @counter 1
    27 jump *label4 always
    28 multilabel *label9
    29 set .array*2 :reverse.0:j
-    * set .array*7 :reverse.0:t
+   30 set .array*7 :reverse.0:i
    31 set :reverse.0:i .array*3
    32 set :reverse.0:j .array*6
    33 op add *tmp3 @counter 1
    34 jump *label4 always
    35 multilabel *label10
    36 set .array*3 :reverse.0:j
-    * set .array*6 :reverse.0:t
+   37 set .array*6 :reverse.0:i
    38 set :reverse.0:i .array*4
    39 set :reverse.0:j .array*5
    40 op add *tmp3 @counter 1
    41 jump *label4 always
    42 multilabel *label11
    43 set .array*4 :reverse.0:j
-    * set .array*5 :reverse.0:t
+   44 set .array*5 :reverse.0:i
    45 set :reverse.0:i .array*5
    46 set :reverse.0:j .array*4
    47 op add *tmp3 @counter 1
    48 jump *label4 always
    49 multilabel *label12
    50 set .array*5 :reverse.0:j
-    * set .array*4 :reverse.0:t
+   51 set .array*4 :reverse.0:i
    52 set :reverse.0:i .array*6
    53 set :reverse.0:j .array*3
    54 op add *tmp3 @counter 1
    55 jump *label4 always
    56 multilabel *label13
    57 set .array*6 :reverse.0:j
-    * set .array*3 :reverse.0:t
+   58 set .array*3 :reverse.0:i
    59 set :reverse.0:i .array*7
    60 set :reverse.0:j .array*2
    61 op add *tmp3 @counter 1
    62 jump *label4 always
    63 multilabel *label14
    64 set .array*7 :reverse.0:j
-    * set .array*2 :reverse.0:t
+   65 set .array*2 :reverse.0:i
    66 set :reverse.0:i .array*8
    67 set :reverse.0:j .array*1
    68 op add *tmp3 @counter 1
    69 jump *label4 always
    70 multilabel *label15
    71 set .array*8 :reverse.0:j
-    * set .array*1 :reverse.0:t
+   72 set .array*1 :reverse.0:i
    73 set :reverse.0:i .array*9
    74 set :reverse.0:j .array*0
    75 op add *tmp3 @counter 1
 
    88 multilabel *label16
    89 label *label18
    90 set .array*9 :reverse.0:j
-    * set .array*0 :reverse.0:t
+   91 set .array*0 :reverse.0:i
    92 label *label6
    93 label *label3
    94 assertflush

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 6 (-1 instructions):
 
    82 jump *label6 always
    83 label *label19
    84 label *label20
-    * set :reverse.0:t :reverse.0:i
    85 label *label5
    86 multijump *tmp3 0 0
    87 multilabel *label16

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
     0 set :i 0
     1 label *label0
-    * jump *label2 greaterThanEq :i 10
+    2 label *label21
     3 writearr<regular> :i .array[] :i
     4 label *label1
     5 op add :i :i 1
-    * jump *label0 always
+    6 jump *label21 lessThan :i 10
     7 label *label2
     8 # "Function: inline void reverse(in array...)"
     9 op idiv :reverse.0:count 10 2

Modifications by Unroll iteration loop at line 18:5 (+15 instructions):
 
     7 label *label2
     8 # "Function: inline void reverse(in array...)"
     9 op idiv :reverse.0:count 10 2
-    * set :reverse.0:i .array*0
-    * set :reverse.0:j .array*9
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label7
-    * set .array*0 :reverse.0:j
-    * set .array*9 :reverse.0:i
-    * set :reverse.0:i .array*1
-    * set :reverse.0:j .array*8
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label8
-    * set .array*1 :reverse.0:j
-    * set .array*8 :reverse.0:i
-    * set :reverse.0:i .array*2
-    * set :reverse.0:j .array*7
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label9
-    * set .array*2 :reverse.0:j
-    * set .array*7 :reverse.0:i
-    * set :reverse.0:i .array*3
-    * set :reverse.0:j .array*6
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label10
-    * set .array*3 :reverse.0:j
-    * set .array*6 :reverse.0:i
-    * set :reverse.0:i .array*4
-    * set :reverse.0:j .array*5
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label11
-    * set .array*4 :reverse.0:j
-    * set .array*5 :reverse.0:i
-    * set :reverse.0:i .array*5
-    * set :reverse.0:j .array*4
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label12
-    * set .array*5 :reverse.0:j
-    * set .array*4 :reverse.0:i
-    * set :reverse.0:i .array*6
-    * set :reverse.0:j .array*3
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label13
-    * set .array*6 :reverse.0:j
-    * set .array*3 :reverse.0:i
-    * set :reverse.0:i .array*7
-    * set :reverse.0:j .array*2
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label14
-    * set .array*7 :reverse.0:j
-    * set .array*2 :reverse.0:i
-    * set :reverse.0:i .array*8
-    * set :reverse.0:j .array*1
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label15
-    * set .array*8 :reverse.0:j
-    * set .array*1 :reverse.0:i
-    * set :reverse.0:i .array*9
-    * set :reverse.0:j .array*0
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label17
-    * jump *label18 always
-    * label *label4
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label19 greaterThanEq :reverse.0:count 0
-    * jump *label6 always
-    * label *label19
-    * label *label20
-    * label *label5
-    * multijump *tmp3 0 0
-    * multilabel *label16
-    * label *label18
-    * set .array*9 :reverse.0:j
-    * set .array*0 :reverse.0:i
-    * label *label6
+   10 set :reverse.0:i .array*0
+   11 set :reverse.0:j .array*9
+   12 op add *tmp3 @counter 1
+   13 label *label22
+   14 op sub :reverse.0:count :reverse.0:count 1
+   15 jump *label23 greaterThanEq :reverse.0:count 0
+   16 jump *label6 always
+   17 label *label23
+   18 label *label24
+   19 label *label25
+   20 set .array*0 :reverse.0:j
+   21 set .array*9 :reverse.0:i
+   22 set :reverse.0:i .array*1
+   23 set :reverse.0:j .array*8
+   24 op add *tmp3 @counter 1
+   25 label *label28
+   26 op sub :reverse.0:count :reverse.0:count 1
+   27 jump *label29 greaterThanEq :reverse.0:count 0
+   28 jump *label6 always
+   29 label *label29
+   30 label *label30
+   31 label *label31
+   32 set .array*1 :reverse.0:j
+   33 set .array*8 :reverse.0:i
+   34 set :reverse.0:i .array*2
+   35 set :reverse.0:j .array*7
+   36 op add *tmp3 @counter 1
+   37 label *label34
+   38 op sub :reverse.0:count :reverse.0:count 1
+   39 jump *label35 greaterThanEq :reverse.0:count 0
+   40 jump *label6 always
+   41 label *label35
+   42 label *label36
+   43 label *label37
+   44 set .array*2 :reverse.0:j
+   45 set .array*7 :reverse.0:i
+   46 set :reverse.0:i .array*3
+   47 set :reverse.0:j .array*6
+   48 op add *tmp3 @counter 1
+   49 label *label40
+   50 op sub :reverse.0:count :reverse.0:count 1
+   51 jump *label41 greaterThanEq :reverse.0:count 0
+   52 jump *label6 always
+   53 label *label41
+   54 label *label42
+   55 label *label43
+   56 set .array*3 :reverse.0:j
+   57 set .array*6 :reverse.0:i
+   58 set :reverse.0:i .array*4
+   59 set :reverse.0:j .array*5
+   60 op add *tmp3 @counter 1
+   61 label *label46
+   62 op sub :reverse.0:count :reverse.0:count 1
+   63 jump *label47 greaterThanEq :reverse.0:count 0
+   64 jump *label6 always
+   65 label *label47
+   66 label *label48
+   67 label *label49
+   68 set .array*4 :reverse.0:j
+   69 set .array*5 :reverse.0:i
+   70 set :reverse.0:i .array*5
+   71 set :reverse.0:j .array*4
+   72 op add *tmp3 @counter 1
+   73 label *label52
+   74 op sub :reverse.0:count :reverse.0:count 1
+   75 jump *label53 greaterThanEq :reverse.0:count 0
+   76 jump *label6 always
+   77 label *label53
+   78 label *label54
+   79 label *label55
+   80 set .array*5 :reverse.0:j
+   81 set .array*4 :reverse.0:i
+   82 set :reverse.0:i .array*6
+   83 set :reverse.0:j .array*3
+   84 op add *tmp3 @counter 1
+   85 label *label58
+   86 op sub :reverse.0:count :reverse.0:count 1
+   87 jump *label59 greaterThanEq :reverse.0:count 0
+   88 jump *label6 always
+   89 label *label59
+   90 label *label60
+   91 label *label61
+   92 set .array*6 :reverse.0:j
+   93 set .array*3 :reverse.0:i
+   94 set :reverse.0:i .array*7
+   95 set :reverse.0:j .array*2
+   96 op add *tmp3 @counter 1
+   97 label *label64
+   98 op sub :reverse.0:count :reverse.0:count 1
+   99 jump *label65 greaterThanEq :reverse.0:count 0
+  100 jump *label6 always
+  101 label *label65
+  102 label *label66
+  103 label *label67
+  104 set .array*7 :reverse.0:j
+  105 set .array*2 :reverse.0:i
+  106 set :reverse.0:i .array*8
+  107 set :reverse.0:j .array*1
+  108 op add *tmp3 @counter 1
+  109 label *label70
+  110 op sub :reverse.0:count :reverse.0:count 1
+  111 jump *label71 greaterThanEq :reverse.0:count 0
+  112 jump *label6 always
+  113 label *label71
+  114 label *label72
+  115 label *label73
+  116 set .array*8 :reverse.0:j
+  117 set .array*1 :reverse.0:i
+  118 set :reverse.0:i .array*9
+  119 set :reverse.0:j .array*0
+  120 op add *tmp3 @counter 1
+  121 label *label76
+  122 op sub :reverse.0:count :reverse.0:count 1
+  123 jump *label77 greaterThanEq :reverse.0:count 0
+  124 jump *label6 always
+  125 label *label77
+  126 label *label78
+  127 label *label79
+  128 set .array*9 :reverse.0:j
+  129 set .array*0 :reverse.0:i
+  130 label *label18
+  131 label *label6
   132 label *label3
   133 assertflush
   134 print .array*0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     9 op idiv :reverse.0:count 10 2
    10 set :reverse.0:i .array*0
    11 set :reverse.0:j .array*9
-    * op add *tmp3 @counter 1
    12 label *label22
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label23 greaterThanEq :reverse.0:count 0
+   13 op sub :reverse.0:count 5 1
+   14 jump *label23 greaterThanEq 4 0
    15 jump *label6 always
    16 label *label23
    17 label *label24
    18 label *label25
-    * set .array*0 :reverse.0:j
+   19 set .array*0 .array*9
    20 set .array*9 :reverse.0:i
    21 set :reverse.0:i .array*1
    22 set :reverse.0:j .array*8
-    * op add *tmp3 @counter 1
    23 label *label28
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label29 greaterThanEq :reverse.0:count 0
+   24 op sub :reverse.0:count 4 1
+   25 jump *label29 greaterThanEq 3 0
    26 jump *label6 always
    27 label *label29
    28 label *label30
    29 label *label31
-    * set .array*1 :reverse.0:j
+   30 set .array*1 .array*8
    31 set .array*8 :reverse.0:i
    32 set :reverse.0:i .array*2
    33 set :reverse.0:j .array*7
-    * op add *tmp3 @counter 1
    34 label *label34
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label35 greaterThanEq :reverse.0:count 0
+   35 op sub :reverse.0:count 3 1
+   36 jump *label35 greaterThanEq 2 0
    37 jump *label6 always
    38 label *label35
    39 label *label36
    40 label *label37
-    * set .array*2 :reverse.0:j
+   41 set .array*2 .array*7
    42 set .array*7 :reverse.0:i
    43 set :reverse.0:i .array*3
    44 set :reverse.0:j .array*6
-    * op add *tmp3 @counter 1
    45 label *label40
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label41 greaterThanEq :reverse.0:count 0
+   46 op sub :reverse.0:count 2 1
+   47 jump *label41 greaterThanEq 1 0
    48 jump *label6 always
    49 label *label41
    50 label *label42
    51 label *label43
-    * set .array*3 :reverse.0:j
+   52 set .array*3 .array*6
    53 set .array*6 :reverse.0:i
    54 set :reverse.0:i .array*4
    55 set :reverse.0:j .array*5
-    * op add *tmp3 @counter 1
    56 label *label46
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label47 greaterThanEq :reverse.0:count 0
+   57 op sub :reverse.0:count 1 1
+   58 jump *label47 greaterThanEq 0 0
    59 jump *label6 always
    60 label *label47
    61 label *label48
    62 label *label49
-    * set .array*4 :reverse.0:j
+   63 set .array*4 .array*5
    64 set .array*5 :reverse.0:i
-    * set :reverse.0:i .array*5
-    * set :reverse.0:j .array*4
-    * op add *tmp3 @counter 1
+   65 set :reverse.0:i :reverse.0:i
+   66 set :reverse.0:j :reverse.0:j
    67 label *label52
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label53 greaterThanEq :reverse.0:count 0
+   68 op sub :reverse.0:count 0 1
+   69 jump *label53 greaterThanEq -1 0
    70 jump *label6 always
    71 label *label53
    72 label *label54
    73 label *label55
-    * set .array*5 :reverse.0:j
-    * set .array*4 :reverse.0:i
+   74 set .array*5 .array*4
    75 set :reverse.0:i .array*6
    76 set :reverse.0:j .array*3
-    * op add *tmp3 @counter 1
    77 label *label58
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label59 greaterThanEq :reverse.0:count 0
+   78 op sub :reverse.0:count -1 1
+   79 jump *label59 greaterThanEq -2 0
    80 jump *label6 always
    81 label *label59
    82 label *label60
    83 label *label61
-    * set .array*6 :reverse.0:j
-    * set .array*3 :reverse.0:i
+   84 set .array*6 .array*3
    85 set :reverse.0:i .array*7
    86 set :reverse.0:j .array*2
-    * op add *tmp3 @counter 1
    87 label *label64
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label65 greaterThanEq :reverse.0:count 0
+   88 op sub :reverse.0:count -2 1
+   89 jump *label65 greaterThanEq -3 0
    90 jump *label6 always
    91 label *label65
    92 label *label66
    93 label *label67
-    * set .array*7 :reverse.0:j
-    * set .array*2 :reverse.0:i
+   94 set .array*7 .array*2
    95 set :reverse.0:i .array*8
    96 set :reverse.0:j .array*1
-    * op add *tmp3 @counter 1
    97 label *label70
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label71 greaterThanEq :reverse.0:count 0
+   98 op sub :reverse.0:count -3 1
+   99 jump *label71 greaterThanEq -4 0
   100 jump *label6 always
   101 label *label71
   102 label *label72
   103 label *label73
-    * set .array*8 :reverse.0:j
-    * set .array*1 :reverse.0:i
+  104 set .array*8 .array*1
   105 set :reverse.0:i .array*9
   106 set :reverse.0:j .array*0
-    * op add *tmp3 @counter 1
   107 label *label76
-    * op sub :reverse.0:count :reverse.0:count 1
-    * jump *label77 greaterThanEq :reverse.0:count 0
+  108 op sub :reverse.0:count -4 1
+  109 jump *label77 greaterThanEq -5 0
   110 jump *label6 always
   111 label *label77
   112 label *label78
   113 label *label79
-    * set .array*9 :reverse.0:j
-    * set .array*0 :reverse.0:i
+  114 set .array*9 .array*0
   115 label *label18
   116 label *label6
   117 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-30 instructions):
 
     6 jump *label21 lessThan :i 10
     7 label *label2
     8 # "Function: inline void reverse(in array...)"
-    * op idiv :reverse.0:count 10 2
     9 set :reverse.0:i .array*0
-    * set :reverse.0:j .array*9
    10 label *label22
-    * op sub :reverse.0:count 5 1
    11 jump *label23 greaterThanEq 4 0
    12 jump *label6 always
    13 label *label23
 
    16 set .array*0 .array*9
    17 set .array*9 :reverse.0:i
    18 set :reverse.0:i .array*1
-    * set :reverse.0:j .array*8
    19 label *label28
-    * op sub :reverse.0:count 4 1
    20 jump *label29 greaterThanEq 3 0
    21 jump *label6 always
    22 label *label29
 
    25 set .array*1 .array*8
    26 set .array*8 :reverse.0:i
    27 set :reverse.0:i .array*2
-    * set :reverse.0:j .array*7
    28 label *label34
-    * op sub :reverse.0:count 3 1
    29 jump *label35 greaterThanEq 2 0
    30 jump *label6 always
    31 label *label35
 
    34 set .array*2 .array*7
    35 set .array*7 :reverse.0:i
    36 set :reverse.0:i .array*3
-    * set :reverse.0:j .array*6
    37 label *label40
-    * op sub :reverse.0:count 2 1
    38 jump *label41 greaterThanEq 1 0
    39 jump *label6 always
    40 label *label41
 
    45 set :reverse.0:i .array*4
    46 set :reverse.0:j .array*5
    47 label *label46
-    * op sub :reverse.0:count 1 1
    48 jump *label47 greaterThanEq 0 0
    49 jump *label6 always
    50 label *label47
 
    52 label *label49
    53 set .array*4 .array*5
    54 set .array*5 :reverse.0:i
-    * set :reverse.0:i :reverse.0:i
-    * set :reverse.0:j :reverse.0:j
    55 label *label52
-    * op sub :reverse.0:count 0 1
    56 jump *label53 greaterThanEq -1 0
    57 jump *label6 always
    58 label *label53
    59 label *label54
    60 label *label55
-    * set .array*5 .array*4
-    * set :reverse.0:i .array*6
-    * set :reverse.0:j .array*3
    61 label *label58
-    * op sub :reverse.0:count -1 1
    62 jump *label59 greaterThanEq -2 0
    63 jump *label6 always
    64 label *label59
    65 label *label60
    66 label *label61
-    * set .array*6 .array*3
-    * set :reverse.0:i .array*7
-    * set :reverse.0:j .array*2
    67 label *label64
-    * op sub :reverse.0:count -2 1
    68 jump *label65 greaterThanEq -3 0
    69 jump *label6 always
    70 label *label65
    71 label *label66
    72 label *label67
-    * set .array*7 .array*2
-    * set :reverse.0:i .array*8
-    * set :reverse.0:j .array*1
    73 label *label70
-    * op sub :reverse.0:count -3 1
    74 jump *label71 greaterThanEq -4 0
    75 jump *label6 always
    76 label *label71
    77 label *label72
    78 label *label73
-    * set .array*8 .array*1
-    * set :reverse.0:i .array*9
-    * set :reverse.0:j .array*0
    79 label *label76
-    * op sub :reverse.0:count -4 1
    80 jump *label77 greaterThanEq -5 0
    81 jump *label6 always
    82 label *label77
    83 label *label78
    84 label *label79
-    * set .array*9 .array*0
    85 label *label18
    86 label *label6
    87 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
    43 set .array*3 .array*6
    44 set .array*6 :reverse.0:i
    45 set :reverse.0:i .array*4
-    * set :reverse.0:j .array*5
    46 label *label46
    47 jump *label47 greaterThanEq 0 0
    48 jump *label6 always
 
    90 print .array*2
    91 print .array*3
    92 print .array*4
-    * print .array*5
+   93 print :reverse.0:i
    94 print .array*6
    95 print .array*7
    96 print .array*8

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
     0 set :i 0
     1 label *label0
     2 label *label21
-    * writearr<regular> :i .array[] :i
+    3 writearr<inlined> :i .array[] :i
     4 label *label1
     5 op add :i :i 1
     6 jump *label21 lessThan :i 10

Modifications by Unroll loop at line 6:5 (+197 instructions):
-    * set :i 0
-    * label *label0
-    * label *label21
-    * writearr<inlined> :i .array[] :i
-    * label *label1
-    * op add :i :i 1
-    * jump *label21 lessThan :i 10
-    * label *label2
+    0 set :i 0
+    1 label *label84
+    2 label *label85
+    3 writearr<inlined> :i .array[] :i
+    4 label *label86
+    5 op add :i :i 1
+    6 label *label87
+    7 writearr<inlined> :i .array[] :i
+    8 label *label88
+    9 op add :i :i 1
+   10 label *label89
+   11 writearr<inlined> :i .array[] :i
+   12 label *label90
+   13 op add :i :i 1
+   14 label *label91
+   15 writearr<inlined> :i .array[] :i
+   16 label *label92
+   17 op add :i :i 1
+   18 label *label93
+   19 writearr<inlined> :i .array[] :i
+   20 label *label94
+   21 op add :i :i 1
+   22 label *label95
+   23 writearr<inlined> :i .array[] :i
+   24 label *label96
+   25 op add :i :i 1
+   26 label *label97
+   27 writearr<inlined> :i .array[] :i
+   28 label *label98
+   29 op add :i :i 1
+   30 label *label99
+   31 writearr<inlined> :i .array[] :i
+   32 label *label100
+   33 op add :i :i 1
+   34 label *label101
+   35 writearr<inlined> :i .array[] :i
+   36 label *label102
+   37 op add :i :i 1
+   38 label *label103
+   39 writearr<inlined> :i .array[] :i
+   40 label *label104
+   41 op add :i :i 1
+   42 label *label2
    43 # "Function: inline void reverse(in array...)"
    44 set :reverse.0:i .array*0
    45 label *label22

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set :i 0
     1 label *label84
     2 label *label85
-    * writearr<inlined> :i .array[] :i
+    3 writearr<inlined> 0 .array[] 0
     4 label *label86
-    * op add :i :i 1
+    5 op add :i 0 1
     6 label *label87
-    * writearr<inlined> :i .array[] :i
+    7 writearr<inlined> 1 .array[] 1
     8 label *label88
-    * op add :i :i 1
+    9 op add :i 1 1
    10 label *label89
-    * writearr<inlined> :i .array[] :i
+   11 writearr<inlined> 2 .array[] 2
    12 label *label90
-    * op add :i :i 1
+   13 op add :i 2 1
    14 label *label91
-    * writearr<inlined> :i .array[] :i
+   15 writearr<inlined> 3 .array[] 3
    16 label *label92
-    * op add :i :i 1
+   17 op add :i 3 1
    18 label *label93
-    * writearr<inlined> :i .array[] :i
+   19 writearr<inlined> 4 .array[] 4
    20 label *label94
-    * op add :i :i 1
+   21 op add :i 4 1
    22 label *label95
-    * writearr<inlined> :i .array[] :i
+   23 writearr<inlined> 5 .array[] 5
    24 label *label96
-    * op add :i :i 1
+   25 op add :i 5 1
    26 label *label97
-    * writearr<inlined> :i .array[] :i
+   27 writearr<inlined> 6 .array[] 6
    28 label *label98
-    * op add :i :i 1
+   29 op add :i 6 1
    30 label *label99
-    * writearr<inlined> :i .array[] :i
+   31 writearr<inlined> 7 .array[] 7
    32 label *label100
-    * op add :i :i 1
+   33 op add :i 7 1
    34 label *label101
-    * writearr<inlined> :i .array[] :i
+   35 writearr<inlined> 8 .array[] 8
    36 label *label102
-    * op add :i :i 1
+   37 op add :i 8 1
    38 label *label103
-    * writearr<inlined> :i .array[] :i
+   39 writearr<inlined> 9 .array[] 9
    40 label *label104
-    * op add :i :i 1
+   41 op add :i 9 1
    42 label *label2
    43 # "Function: inline void reverse(in array...)"
    44 set :reverse.0:i .array*0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-11 instructions):
-    * set :i 0
     0 label *label84
     1 label *label85
     2 writearr<inlined> 0 .array[] 0
     3 label *label86
-    * op add :i 0 1
     4 label *label87
     5 writearr<inlined> 1 .array[] 1
     6 label *label88
-    * op add :i 1 1
     7 label *label89
     8 writearr<inlined> 2 .array[] 2
     9 label *label90
-    * op add :i 2 1
    10 label *label91
    11 writearr<inlined> 3 .array[] 3
    12 label *label92
-    * op add :i 3 1
    13 label *label93
    14 writearr<inlined> 4 .array[] 4
    15 label *label94
-    * op add :i 4 1
    16 label *label95
    17 writearr<inlined> 5 .array[] 5
    18 label *label96
-    * op add :i 5 1
    19 label *label97
    20 writearr<inlined> 6 .array[] 6
    21 label *label98
-    * op add :i 6 1
    22 label *label99
    23 writearr<inlined> 7 .array[] 7
    24 label *label100
-    * op add :i 7 1
    25 label *label101
    26 writearr<inlined> 8 .array[] 8
    27 label *label102
-    * op add :i 8 1
    28 label *label103
    29 writearr<inlined> 9 .array[] 9
    30 label *label104
-    * op add :i 9 1
    31 label *label2
    32 # "Function: inline void reverse(in array...)"
    33 set :reverse.0:i .array*0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-5 instructions):
 
    32 # "Function: inline void reverse(in array...)"
    33 set :reverse.0:i .array*0
    34 label *label22
-    * jump *label23 greaterThanEq 4 0
+   35 jump *label23 always
    36 jump *label6 always
    37 label *label23
    38 label *label24
 
    41 set .array*9 :reverse.0:i
    42 set :reverse.0:i .array*1
    43 label *label28
-    * jump *label29 greaterThanEq 3 0
+   44 jump *label29 always
    45 jump *label6 always
    46 label *label29
    47 label *label30
 
    50 set .array*8 :reverse.0:i
    51 set :reverse.0:i .array*2
    52 label *label34
-    * jump *label35 greaterThanEq 2 0
+   53 jump *label35 always
    54 jump *label6 always
    55 label *label35
    56 label *label36
 
    59 set .array*7 :reverse.0:i
    60 set :reverse.0:i .array*3
    61 label *label40
-    * jump *label41 greaterThanEq 1 0
+   62 jump *label41 always
    63 jump *label6 always
    64 label *label41
    65 label *label42
 
    68 set .array*6 :reverse.0:i
    69 set :reverse.0:i .array*4
    70 label *label46
-    * jump *label47 greaterThanEq 0 0
+   71 jump *label47 always
    72 jump *label6 always
    73 label *label47
    74 label *label48
 
    76 set .array*4 .array*5
    77 set .array*5 :reverse.0:i
    78 label *label52
-    * jump *label53 greaterThanEq -1 0
    79 jump *label6 always
    80 label *label53
    81 label *label54
    82 label *label55
    83 label *label58
-    * jump *label59 greaterThanEq -2 0
    84 jump *label6 always
    85 label *label59
    86 label *label60
    87 label *label61
    88 label *label64
-    * jump *label65 greaterThanEq -3 0
    89 jump *label6 always
    90 label *label65
    91 label *label66
    92 label *label67
    93 label *label70
-    * jump *label71 greaterThanEq -4 0
    94 jump *label6 always
    95 label *label71
    96 label *label72
    97 label *label73
    98 label *label76
-    * jump *label77 greaterThanEq -5 0
    99 jump *label6 always
   100 label *label77
   101 label *label78

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-200 instructions):
     0 label *label84
     1 label *label85
-    * writearr<inlined> 0 .array[] 0
+    2 set .array*0 0
     3 label *label86
     4 label *label87
-    * writearr<inlined> 1 .array[] 1
+    5 set .array*1 1
     6 label *label88
     7 label *label89
-    * writearr<inlined> 2 .array[] 2
+    8 set .array*2 2
     9 label *label90
    10 label *label91
-    * writearr<inlined> 3 .array[] 3
+   11 set .array*3 3
    12 label *label92
    13 label *label93
-    * writearr<inlined> 4 .array[] 4
+   14 set .array*4 4
    15 label *label94
    16 label *label95
-    * writearr<inlined> 5 .array[] 5
+   17 set .array*5 5
    18 label *label96
    19 label *label97
-    * writearr<inlined> 6 .array[] 6
+   20 set .array*6 6
    21 label *label98
    22 label *label99
-    * writearr<inlined> 7 .array[] 7
+   23 set .array*7 7
    24 label *label100
    25 label *label101
-    * writearr<inlined> 8 .array[] 8
+   26 set .array*8 8
    27 label *label102
    28 label *label103
-    * writearr<inlined> 9 .array[] 9
+   29 set .array*9 9
    30 label *label104
    31 label *label2
    32 # "Function: inline void reverse(in array...)"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
     0 label *label84
     1 label *label85
-    * set .array*0 0
+    2 set :reverse.0:i 0
     3 label *label86
     4 label *label87
     5 set .array*1 1
 
    30 label *label104
    31 label *label2
    32 # "Function: inline void reverse(in array...)"
-    * set :reverse.0:i .array*0
    33 label *label22
    34 jump *label23 always
    35 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
    26 set .array*8 8
    27 label *label102
    28 label *label103
-    * set .array*9 9
+   29 set .array*0 9
    30 label *label104
    31 label *label2
    32 # "Function: inline void reverse(in array...)"
 
    36 label *label23
    37 label *label24
    38 label *label25
-    * set .array*0 .array*9
    39 set .array*9 :reverse.0:i
    40 set :reverse.0:i .array*1
    41 label *label28

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-1 instructions):
     0 label *label84
     1 label *label85
-    * set :reverse.0:i 0
+    2 set .array*9 0
     3 label *label86
     4 label *label87
     5 set .array*1 1
 
    36 label *label23
    37 label *label24
    38 label *label25
-    * set .array*9 :reverse.0:i
    39 set :reverse.0:i .array*1
    40 label *label28
    41 jump *label29 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 4 (-1 instructions):
 
     2 set .array*9 0
     3 label *label86
     4 label *label87
-    * set .array*1 1
+    5 set :reverse.0:i 1
     6 label *label88
     7 label *label89
     8 set .array*2 2
 
    36 label *label23
    37 label *label24
    38 label *label25
-    * set :reverse.0:i .array*1
    39 label *label28
    40 jump *label29 always
    41 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 5 (-1 instructions):
 
    23 set .array*7 7
    24 label *label100
    25 label *label101
-    * set .array*8 8
+   26 set .array*1 8
    27 label *label102
    28 label *label103
    29 set .array*0 9
 
    42 label *label29
    43 label *label30
    44 label *label31
-    * set .array*1 .array*8
    45 set .array*8 :reverse.0:i
    46 set :reverse.0:i .array*2
    47 label *label34

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 6 (-1 instructions):
 
     2 set .array*9 0
     3 label *label86
     4 label *label87
-    * set :reverse.0:i 1
+    5 set .array*8 1
     6 label *label88
     7 label *label89
     8 set .array*2 2
 
    42 label *label29
    43 label *label30
    44 label *label31
-    * set .array*8 :reverse.0:i
    45 set :reverse.0:i .array*2
    46 label *label34
    47 jump *label35 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 7 (-1 instructions):
 
     5 set .array*8 1
     6 label *label88
     7 label *label89
-    * set .array*2 2
+    8 set :reverse.0:i 2
     9 label *label90
    10 label *label91
    11 set .array*3 3
 
    42 label *label29
    43 label *label30
    44 label *label31
-    * set :reverse.0:i .array*2
    45 label *label34
    46 jump *label35 always
    47 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 8 (-1 instructions):
 
    20 set .array*6 6
    21 label *label98
    22 label *label99
-    * set .array*7 7
+   23 set .array*2 7
    24 label *label100
    25 label *label101
    26 set .array*1 8
 
    48 label *label35
    49 label *label36
    50 label *label37
-    * set .array*2 .array*7
    51 set .array*7 :reverse.0:i
    52 set :reverse.0:i .array*3
    53 label *label40

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 9 (-1 instructions):
 
     5 set .array*8 1
     6 label *label88
     7 label *label89
-    * set :reverse.0:i 2
+    8 set .array*7 2
     9 label *label90
    10 label *label91
    11 set .array*3 3
 
    48 label *label35
    49 label *label36
    50 label *label37
-    * set .array*7 :reverse.0:i
    51 set :reverse.0:i .array*3
    52 label *label40
    53 jump *label41 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 10 (-1 instructions):
 
     8 set .array*7 2
     9 label *label90
    10 label *label91
-    * set .array*3 3
+   11 set :reverse.0:i 3
    12 label *label92
    13 label *label93
    14 set .array*4 4
 
    48 label *label35
    49 label *label36
    50 label *label37
-    * set :reverse.0:i .array*3
    51 label *label40
    52 jump *label41 always
    53 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 11 (-1 instructions):
 
    17 set .array*5 5
    18 label *label96
    19 label *label97
-    * set .array*6 6
+   20 set .array*3 6
    21 label *label98
    22 label *label99
    23 set .array*2 7
 
    54 label *label41
    55 label *label42
    56 label *label43
-    * set .array*3 .array*6
    57 set .array*6 :reverse.0:i
    58 set :reverse.0:i .array*4
    59 label *label46

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 12 (-1 instructions):
 
     8 set .array*7 2
     9 label *label90
    10 label *label91
-    * set :reverse.0:i 3
+   11 set .array*6 3
    12 label *label92
    13 label *label93
    14 set .array*4 4
 
    54 label *label41
    55 label *label42
    56 label *label43
-    * set .array*6 :reverse.0:i
    57 set :reverse.0:i .array*4
    58 label *label46
    59 jump *label47 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 13 (-1 instructions):
 
    11 set .array*6 3
    12 label *label92
    13 label *label93
-    * set .array*4 4
+   14 set :reverse.0:i 4
    15 label *label94
    16 label *label95
    17 set .array*5 5
 
    54 label *label41
    55 label *label42
    56 label *label43
-    * set :reverse.0:i .array*4
    57 label *label46
    58 jump *label47 always
    59 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 14 (-1 instructions):
 
    14 set :reverse.0:i 4
    15 label *label94
    16 label *label95
-    * set .array*5 5
+   17 set .array*4 5
    18 label *label96
    19 label *label97
    20 set .array*3 6
 
    60 label *label47
    61 label *label48
    62 label *label49
-    * set .array*4 .array*5
    63 set .array*5 :reverse.0:i
    64 label *label52
    65 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 15:
 
    60 label *label47
    61 label *label48
    62 label *label49
-    * set .array*5 :reverse.0:i
+   63 set .array*5 4
    64 label *label52
    65 jump *label6 always
    66 label *label53
 
    90 label *label6
    91 label *label3
    92 assertflush
-    * print .array*0
-    * print .array*1
-    * print .array*2
-    * print .array*3
-    * print .array*4
-    * print :reverse.0:i
-    * print .array*6
-    * print .array*7
-    * print .array*8
-    * print .array*9
+   93 print 9
+   94 print 8
+   95 print 7
+   96 print 6
+   97 print 5
+   98 print 4
+   99 print 3
+  100 print 2
+  101 print 1
+  102 print 0
   103 assertprints "9876543210" "reverse array"
   104 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 16 (-11 instructions):
     0 label *label84
     1 label *label85
-    * set .array*9 0
     2 label *label86
     3 label *label87
-    * set .array*8 1
     4 label *label88
     5 label *label89
-    * set .array*7 2
     6 label *label90
     7 label *label91
-    * set .array*6 3
     8 label *label92
     9 label *label93
-    * set :reverse.0:i 4
    10 label *label94
    11 label *label95
-    * set .array*4 5
    12 label *label96
    13 label *label97
-    * set .array*3 6
    14 label *label98
    15 label *label99
-    * set .array*2 7
    16 label *label100
    17 label *label101
-    * set .array*1 8
    18 label *label102
    19 label *label103
-    * set .array*0 9
    20 label *label104
    21 label *label2
    22 # "Function: inline void reverse(in array...)"
 
    50 label *label47
    51 label *label48
    52 label *label49
-    * set .array*5 4
    53 label *label52
    54 jump *label6 always
    55 label *label53

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-6 instructions):
 
    46 label *label43
    47 label *label46
    48 jump *label47 always
-    * jump *label6 always
    49 label *label47
    50 label *label48
    51 label *label49
    52 label *label52
-    * jump *label6 always
    53 label *label53
    54 label *label54
    55 label *label55
    56 label *label58
-    * jump *label6 always
    57 label *label59
    58 label *label60
    59 label *label61
    60 label *label64
-    * jump *label6 always
    61 label *label65
    62 label *label66
    63 label *label67
    64 label *label70
-    * jump *label6 always
    65 label *label71
    66 label *label72
    67 label *label73
    68 label *label76
-    * jump *label6 always
    69 label *label77
    70 label *label78
    71 label *label79

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 2 (-1 instructions):
 
    45 label *label42
    46 label *label43
    47 label *label46
-    * jump *label47 always
    48 label *label47
    49 label *label48
    50 label *label49

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 3 (-1 instructions):
 
    40 label *label37
    41 label *label40
    42 jump *label41 always
-    * jump *label6 always
    43 label *label41
    44 label *label42
    45 label *label43

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 4 (-1 instructions):
 
    39 label *label36
    40 label *label37
    41 label *label40
-    * jump *label41 always
    42 label *label41
    43 label *label42
    44 label *label43

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 5 (-1 instructions):
 
    34 label *label31
    35 label *label34
    36 jump *label35 always
-    * jump *label6 always
    37 label *label35
    38 label *label36
    39 label *label37

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 6 (-1 instructions):
 
    33 label *label30
    34 label *label31
    35 label *label34
-    * jump *label35 always
    36 label *label35
    37 label *label36
    38 label *label37

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 7 (-1 instructions):
 
    28 label *label25
    29 label *label28
    30 jump *label29 always
-    * jump *label6 always
    31 label *label29
    32 label *label30
    33 label *label31

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 8 (-1 instructions):
 
    27 label *label24
    28 label *label25
    29 label *label28
-    * jump *label29 always
    30 label *label29
    31 label *label30
    32 label *label31

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 9 (-1 instructions):
 
    22 # "Function: inline void reverse(in array...)"
    23 label *label22
    24 jump *label23 always
-    * jump *label6 always
    25 label *label23
    26 label *label24
    27 label *label25

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 10 (-1 instructions):
 
    21 label *label2
    22 # "Function: inline void reverse(in array...)"
    23 label *label22
-    * jump *label23 always
    24 label *label23
    25 label *label24
    26 label *label25

Modifications by Final phase, Single Step Elimination, iteration 1 (-1 instructions):
 
    75 print 1
    76 print 0
    77 assertprints "9876543210" "reverse array"
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-9 instructions):
 
    64 label *label6
    65 label *label3
    66 assertflush
-    * print 9
-    * print 8
-    * print 7
-    * print 6
-    * print 5
-    * print 4
-    * print 3
-    * print 2
-    * print 1
-    * print 0
+   67 print "9876543210"
    68 assertprints "9876543210" "reverse array"

Final code before resolving virtual instructions:

# "Function: inline void reverse(in array...)"
assertflush
print "9876543210"
assertprints "9876543210" "reverse array"
