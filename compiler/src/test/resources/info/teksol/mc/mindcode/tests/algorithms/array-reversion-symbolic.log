   117 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (2 iterations).
    12 instructions eliminated by Dead Code Elimination (2 passes, 5 iterations).
     5 instructions eliminated by Jump Normalization (5 iterations).
     1 instructions eliminated by Jump Optimization (5 iterations).
     4 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
   201 instructions eliminated by Expression Optimization (3 iterations).
    64 instructions eliminated by Data Flow Optimization (4 passes, 35 iterations).
     1 instructions eliminated by Loop Optimization (3 iterations).
     1 loops improved by Loop Optimization.
   212 instructions added by Loop Unrolling (6 iterations).
     2 loops unrolled by Loop Unrolling.
     1 jump tables inlined by Array Optimization.
     4 instructions updated by Jump Threading.
    23 instructions eliminated by Unreachable Code Elimination (2 iterations).
     9 instructions eliminated by Print Merging.
     3 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 893):
    Unroll loop at line 6:5                                      size    +3, benefit      500.0, efficiency    166.667
  * Unroll iteration loop at line 18:5                           size   -39, benefit       69.0, efficiency   Infinity (-16 instructions)
    Inline write jump table of array 'array'                     size    -4, benefit       50.0, efficiency   Infinity
    Inline 'array' write access at line 7:9                      size   +17, benefit       50.0, efficiency      2.941

Pass 1: speed optimization selection (cost limit 909):
    Unroll loop at line 6:5                                      size    +3, benefit      500.0, efficiency    166.667
  * Inline write jump table of array 'array'                     size    -4, benefit       50.0, efficiency   Infinity (-4 instructions)
    Inline 'array' write access at line 7:9                      size   +17, benefit       50.0, efficiency      2.941

Pass 1: speed optimization selection (cost limit 913):
  * Unroll loop at line 6:5                                      size   -14, benefit      500.0, efficiency   Infinity (+186 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    83 op lessThan *tmp4 :reverse:count 0
    84 jump *label19 equal *tmp4 false
    85 jump *label6 always
-    * set *tmp5 null
    86 jump *label20 always
    87 label *label19
-    * set *tmp5 null
    88 label *label20
    89 set :reverse:t :reverse:i
    90 set :reverse:i :reverse:j

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
     0 set :i 0
     1 label *label0
     2 jump *label2 greaterThanEq :i 10
-    * set *tmp0 :i
-    * writearr<regular> :i .array[] *tmp0
+    3 writearr<regular> :i .array[] :i
     4 label *label1
     5 op add :i :i 1
     6 jump *label0 always
     7 label *label2
     8 # "Function: inline void reverse(in array...)"
-    * op idiv *tmp2 10 2
-    * set :reverse:count *tmp2
+    9 op idiv :reverse:count 10 2
    10 set :reverse:i .array*0
    11 set :reverse:j .array*9
    12 op add *tmp3 @counter 1

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-1 instructions):
 
    78 jump *label18 always
    79 label *label4
    80 op sub :reverse:count :reverse:count 1
-    * op lessThan *tmp4 :reverse:count 0
-    * jump *label19 equal *tmp4 false
+   81 jump *label19 greaterThanEq :reverse:count 0
    82 jump *label6 always
    83 jump *label20 always
    84 label *label19

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-1 instructions):
 
    80 op sub :reverse:count :reverse:count 1
    81 jump *label19 greaterThanEq :reverse:count 0
    82 jump *label6 always
-    * jump *label20 always
    83 label *label19
    84 label *label20
    85 set :reverse:t :reverse:i

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    13 jump *label4 always
    14 multilabel *label7 (m:marker0)
    15 set .array*0 :reverse:i
-    * set .array*9 :reverse:j
+   16 set .array*9 :reverse:t
    17 set :reverse:i .array*1
    18 set :reverse:j .array*8
    19 op add *tmp3 @counter 1
    20 jump *label4 always
    21 multilabel *label8 (m:marker0)
    22 set .array*1 :reverse:i
-    * set .array*8 :reverse:j
+   23 set .array*8 :reverse:t
    24 set :reverse:i .array*2
    25 set :reverse:j .array*7
    26 op add *tmp3 @counter 1
    27 jump *label4 always
    28 multilabel *label9 (m:marker0)
    29 set .array*2 :reverse:i
-    * set .array*7 :reverse:j
+   30 set .array*7 :reverse:t
    31 set :reverse:i .array*3
    32 set :reverse:j .array*6
    33 op add *tmp3 @counter 1
    34 jump *label4 always
    35 multilabel *label10 (m:marker0)
    36 set .array*3 :reverse:i
-    * set .array*6 :reverse:j
+   37 set .array*6 :reverse:t
    38 set :reverse:i .array*4
    39 set :reverse:j .array*5
    40 op add *tmp3 @counter 1
    41 jump *label4 always
    42 multilabel *label11 (m:marker0)
    43 set .array*4 :reverse:i
-    * set .array*5 :reverse:j
+   44 set .array*5 :reverse:t
    45 set :reverse:i .array*5
    46 set :reverse:j .array*4
    47 op add *tmp3 @counter 1
    48 jump *label4 always
    49 multilabel *label12 (m:marker0)
    50 set .array*5 :reverse:i
-    * set .array*4 :reverse:j
+   51 set .array*4 :reverse:t
    52 set :reverse:i .array*6
    53 set :reverse:j .array*3
    54 op add *tmp3 @counter 1
    55 jump *label4 always
    56 multilabel *label13 (m:marker0)
    57 set .array*6 :reverse:i
-    * set .array*3 :reverse:j
+   58 set .array*3 :reverse:t
    59 set :reverse:i .array*7
    60 set :reverse:j .array*2
    61 op add *tmp3 @counter 1
    62 jump *label4 always
    63 multilabel *label14 (m:marker0)
    64 set .array*7 :reverse:i
-    * set .array*2 :reverse:j
+   65 set .array*2 :reverse:t
    66 set :reverse:i .array*8
    67 set :reverse:j .array*1
    68 op add *tmp3 @counter 1
    69 jump *label4 always
    70 multilabel *label15 (m:marker0)
    71 set .array*8 :reverse:i
-    * set .array*1 :reverse:j
+   72 set .array*1 :reverse:t
    73 set :reverse:i .array*9
    74 set :reverse:j .array*0
    75 op add *tmp3 @counter 1
 
    90 multilabel *label16 (m:marker0)
    91 label *label18
    92 set .array*9 :reverse:i
-    * set .array*0 :reverse:j
+   93 set .array*0 :reverse:t
    94 label *label6
    95 label *label3
    96 assertflush

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    84 label *label20
    85 set :reverse:t :reverse:i
    86 set :reverse:i :reverse:j
-    * set :reverse:j :reverse:t
    87 label *label5
    88 multijump *tmp3 0 0 (m:marker0)
    89 multilabel *label16 (m:marker0)

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3:
 
    12 op add *tmp3 @counter 1
    13 jump *label4 always
    14 multilabel *label7 (m:marker0)
-    * set .array*0 :reverse:i
+   15 set .array*0 :reverse:j
    16 set .array*9 :reverse:t
    17 set :reverse:i .array*1
    18 set :reverse:j .array*8
    19 op add *tmp3 @counter 1
    20 jump *label4 always
    21 multilabel *label8 (m:marker0)
-    * set .array*1 :reverse:i
+   22 set .array*1 :reverse:j
    23 set .array*8 :reverse:t
    24 set :reverse:i .array*2
    25 set :reverse:j .array*7
    26 op add *tmp3 @counter 1
    27 jump *label4 always
    28 multilabel *label9 (m:marker0)
-    * set .array*2 :reverse:i
+   29 set .array*2 :reverse:j
    30 set .array*7 :reverse:t
    31 set :reverse:i .array*3
    32 set :reverse:j .array*6
    33 op add *tmp3 @counter 1
    34 jump *label4 always
    35 multilabel *label10 (m:marker0)
-    * set .array*3 :reverse:i
+   36 set .array*3 :reverse:j
    37 set .array*6 :reverse:t
    38 set :reverse:i .array*4
    39 set :reverse:j .array*5
    40 op add *tmp3 @counter 1
    41 jump *label4 always
    42 multilabel *label11 (m:marker0)
-    * set .array*4 :reverse:i
+   43 set .array*4 :reverse:j
    44 set .array*5 :reverse:t
    45 set :reverse:i .array*5
    46 set :reverse:j .array*4
    47 op add *tmp3 @counter 1
    48 jump *label4 always
    49 multilabel *label12 (m:marker0)
-    * set .array*5 :reverse:i
+   50 set .array*5 :reverse:j
    51 set .array*4 :reverse:t
    52 set :reverse:i .array*6
    53 set :reverse:j .array*3
    54 op add *tmp3 @counter 1
    55 jump *label4 always
    56 multilabel *label13 (m:marker0)
-    * set .array*6 :reverse:i
+   57 set .array*6 :reverse:j
    58 set .array*3 :reverse:t
    59 set :reverse:i .array*7
    60 set :reverse:j .array*2
    61 op add *tmp3 @counter 1
    62 jump *label4 always
    63 multilabel *label14 (m:marker0)
-    * set .array*7 :reverse:i
+   64 set .array*7 :reverse:j
    65 set .array*2 :reverse:t
    66 set :reverse:i .array*8
    67 set :reverse:j .array*1
    68 op add *tmp3 @counter 1
    69 jump *label4 always
    70 multilabel *label15 (m:marker0)
-    * set .array*8 :reverse:i
+   71 set .array*8 :reverse:j
    72 set .array*1 :reverse:t
    73 set :reverse:i .array*9
    74 set :reverse:j .array*0
 
    88 multijump *tmp3 0 0 (m:marker0)
    89 multilabel *label16 (m:marker0)
    90 label *label18
-    * set .array*9 :reverse:i
+   91 set .array*9 :reverse:j
    92 set .array*0 :reverse:t
    93 label *label6
    94 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-1 instructions):
 
    83 label *label19
    84 label *label20
    85 set :reverse:t :reverse:i
-    * set :reverse:i :reverse:j
    86 label *label5
    87 multijump *tmp3 0 0 (m:marker0)
    88 multilabel *label16 (m:marker0)

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 5:
 
    13 jump *label4 always
    14 multilabel *label7 (m:marker0)
    15 set .array*0 :reverse:j
-    * set .array*9 :reverse:t
+   16 set .array*9 :reverse:i
    17 set :reverse:i .array*1
    18 set :reverse:j .array*8
    19 op add *tmp3 @counter 1
    20 jump *label4 always
    21 multilabel *label8 (m:marker0)
    22 set .array*1 :reverse:j
-    * set .array*8 :reverse:t
+   23 set .array*8 :reverse:i
    24 set :reverse:i .array*2
    25 set :reverse:j .array*7
    26 op add *tmp3 @counter 1
    27 jump *label4 always
    28 multilabel *label9 (m:marker0)
    29 set .array*2 :reverse:j
-    * set .array*7 :reverse:t
+   30 set .array*7 :reverse:i
    31 set :reverse:i .array*3
    32 set :reverse:j .array*6
    33 op add *tmp3 @counter 1
    34 jump *label4 always
    35 multilabel *label10 (m:marker0)
    36 set .array*3 :reverse:j
-    * set .array*6 :reverse:t
+   37 set .array*6 :reverse:i
    38 set :reverse:i .array*4
    39 set :reverse:j .array*5
    40 op add *tmp3 @counter 1
    41 jump *label4 always
    42 multilabel *label11 (m:marker0)
    43 set .array*4 :reverse:j
-    * set .array*5 :reverse:t
+   44 set .array*5 :reverse:i
    45 set :reverse:i .array*5
    46 set :reverse:j .array*4
    47 op add *tmp3 @counter 1
    48 jump *label4 always
    49 multilabel *label12 (m:marker0)
    50 set .array*5 :reverse:j
-    * set .array*4 :reverse:t
+   51 set .array*4 :reverse:i
    52 set :reverse:i .array*6
    53 set :reverse:j .array*3
    54 op add *tmp3 @counter 1
    55 jump *label4 always
    56 multilabel *label13 (m:marker0)
    57 set .array*6 :reverse:j
-    * set .array*3 :reverse:t
+   58 set .array*3 :reverse:i
    59 set :reverse:i .array*7
    60 set :reverse:j .array*2
    61 op add *tmp3 @counter 1
    62 jump *label4 always
    63 multilabel *label14 (m:marker0)
    64 set .array*7 :reverse:j
-    * set .array*2 :reverse:t
+   65 set .array*2 :reverse:i
    66 set :reverse:i .array*8
    67 set :reverse:j .array*1
    68 op add *tmp3 @counter 1
    69 jump *label4 always
    70 multilabel *label15 (m:marker0)
    71 set .array*8 :reverse:j
-    * set .array*1 :reverse:t
+   72 set .array*1 :reverse:i
    73 set :reverse:i .array*9
    74 set :reverse:j .array*0
    75 op add *tmp3 @counter 1
 
    88 multilabel *label16 (m:marker0)
    89 label *label18
    90 set .array*9 :reverse:j
-    * set .array*0 :reverse:t
+   91 set .array*0 :reverse:i
    92 label *label6
    93 label *label3
    94 assertflush

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 6 (-1 instructions):
 
    82 jump *label6 always
    83 label *label19
    84 label *label20
-    * set :reverse:t :reverse:i
    85 label *label5
    86 multijump *tmp3 0 0 (m:marker0)
    87 multilabel *label16 (m:marker0)

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
     0 set :i 0
     1 label *label0
-    * jump *label2 greaterThanEq :i 10
+    2 label *label21
     3 writearr<regular> :i .array[] :i
     4 label *label1
     5 op add :i :i 1
-    * jump *label0 always
+    6 jump *label21 lessThan :i 10
     7 label *label2
     8 # "Function: inline void reverse(in array...)"
     9 op idiv :reverse:count 10 2

Modifications by Unroll iteration loop at line 18:5 (+15 instructions):
 
     7 label *label2
     8 # "Function: inline void reverse(in array...)"
     9 op idiv :reverse:count 10 2
-    * set :reverse:i .array*0
-    * set :reverse:j .array*9
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label7 (m:marker0)
-    * set .array*0 :reverse:j
-    * set .array*9 :reverse:i
-    * set :reverse:i .array*1
-    * set :reverse:j .array*8
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label8 (m:marker0)
-    * set .array*1 :reverse:j
-    * set .array*8 :reverse:i
-    * set :reverse:i .array*2
-    * set :reverse:j .array*7
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label9 (m:marker0)
-    * set .array*2 :reverse:j
-    * set .array*7 :reverse:i
-    * set :reverse:i .array*3
-    * set :reverse:j .array*6
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label10 (m:marker0)
-    * set .array*3 :reverse:j
-    * set .array*6 :reverse:i
-    * set :reverse:i .array*4
-    * set :reverse:j .array*5
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label11 (m:marker0)
-    * set .array*4 :reverse:j
-    * set .array*5 :reverse:i
-    * set :reverse:i .array*5
-    * set :reverse:j .array*4
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label12 (m:marker0)
-    * set .array*5 :reverse:j
-    * set .array*4 :reverse:i
-    * set :reverse:i .array*6
-    * set :reverse:j .array*3
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label13 (m:marker0)
-    * set .array*6 :reverse:j
-    * set .array*3 :reverse:i
-    * set :reverse:i .array*7
-    * set :reverse:j .array*2
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label14 (m:marker0)
-    * set .array*7 :reverse:j
-    * set .array*2 :reverse:i
-    * set :reverse:i .array*8
-    * set :reverse:j .array*1
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label15 (m:marker0)
-    * set .array*8 :reverse:j
-    * set .array*1 :reverse:i
-    * set :reverse:i .array*9
-    * set :reverse:j .array*0
-    * op add *tmp3 @counter 1
-    * jump *label4 always
-    * multilabel *label17 (m:marker0)
-    * jump *label18 always
-    * label *label4
-    * op sub :reverse:count :reverse:count 1
-    * jump *label19 greaterThanEq :reverse:count 0
-    * jump *label6 always
-    * label *label19
-    * label *label20
-    * label *label5
-    * multijump *tmp3 0 0 (m:marker0)
-    * multilabel *label16 (m:marker0)
-    * label *label18
-    * set .array*9 :reverse:j
-    * set .array*0 :reverse:i
-    * label *label6
+   10 set :reverse:i .array*0
+   11 set :reverse:j .array*9
+   12 op add *tmp3 @counter 1
+   13 label *label22
+   14 op sub :reverse:count :reverse:count 1
+   15 jump *label23 greaterThanEq :reverse:count 0
+   16 jump *label6 always
+   17 label *label23
+   18 label *label24
+   19 label *label25
+   20 set .array*0 :reverse:j
+   21 set .array*9 :reverse:i
+   22 set :reverse:i .array*1
+   23 set :reverse:j .array*8
+   24 op add *tmp3 @counter 1
+   25 label *label28
+   26 op sub :reverse:count :reverse:count 1
+   27 jump *label29 greaterThanEq :reverse:count 0
+   28 jump *label6 always
+   29 label *label29
+   30 label *label30
+   31 label *label31
+   32 set .array*1 :reverse:j
+   33 set .array*8 :reverse:i
+   34 set :reverse:i .array*2
+   35 set :reverse:j .array*7
+   36 op add *tmp3 @counter 1
+   37 label *label34
+   38 op sub :reverse:count :reverse:count 1
+   39 jump *label35 greaterThanEq :reverse:count 0
+   40 jump *label6 always
+   41 label *label35
+   42 label *label36
+   43 label *label37
+   44 set .array*2 :reverse:j
+   45 set .array*7 :reverse:i
+   46 set :reverse:i .array*3
+   47 set :reverse:j .array*6
+   48 op add *tmp3 @counter 1
+   49 label *label40
+   50 op sub :reverse:count :reverse:count 1
+   51 jump *label41 greaterThanEq :reverse:count 0
+   52 jump *label6 always
+   53 label *label41
+   54 label *label42
+   55 label *label43
+   56 set .array*3 :reverse:j
+   57 set .array*6 :reverse:i
+   58 set :reverse:i .array*4
+   59 set :reverse:j .array*5
+   60 op add *tmp3 @counter 1
+   61 label *label46
+   62 op sub :reverse:count :reverse:count 1
+   63 jump *label47 greaterThanEq :reverse:count 0
+   64 jump *label6 always
+   65 label *label47
+   66 label *label48
+   67 label *label49
+   68 set .array*4 :reverse:j
+   69 set .array*5 :reverse:i
+   70 set :reverse:i .array*5
+   71 set :reverse:j .array*4
+   72 op add *tmp3 @counter 1
+   73 label *label52
+   74 op sub :reverse:count :reverse:count 1
+   75 jump *label53 greaterThanEq :reverse:count 0
+   76 jump *label6 always
+   77 label *label53
+   78 label *label54
+   79 label *label55
+   80 set .array*5 :reverse:j
+   81 set .array*4 :reverse:i
+   82 set :reverse:i .array*6
+   83 set :reverse:j .array*3
+   84 op add *tmp3 @counter 1
+   85 label *label58
+   86 op sub :reverse:count :reverse:count 1
+   87 jump *label59 greaterThanEq :reverse:count 0
+   88 jump *label6 always
+   89 label *label59
+   90 label *label60
+   91 label *label61
+   92 set .array*6 :reverse:j
+   93 set .array*3 :reverse:i
+   94 set :reverse:i .array*7
+   95 set :reverse:j .array*2
+   96 op add *tmp3 @counter 1
+   97 label *label64
+   98 op sub :reverse:count :reverse:count 1
+   99 jump *label65 greaterThanEq :reverse:count 0
+  100 jump *label6 always
+  101 label *label65
+  102 label *label66
+  103 label *label67
+  104 set .array*7 :reverse:j
+  105 set .array*2 :reverse:i
+  106 set :reverse:i .array*8
+  107 set :reverse:j .array*1
+  108 op add *tmp3 @counter 1
+  109 label *label70
+  110 op sub :reverse:count :reverse:count 1
+  111 jump *label71 greaterThanEq :reverse:count 0
+  112 jump *label6 always
+  113 label *label71
+  114 label *label72
+  115 label *label73
+  116 set .array*8 :reverse:j
+  117 set .array*1 :reverse:i
+  118 set :reverse:i .array*9
+  119 set :reverse:j .array*0
+  120 op add *tmp3 @counter 1
+  121 label *label76
+  122 op sub :reverse:count :reverse:count 1
+  123 jump *label77 greaterThanEq :reverse:count 0
+  124 jump *label6 always
+  125 label *label77
+  126 label *label78
+  127 label *label79
+  128 set .array*9 :reverse:j
+  129 set .array*0 :reverse:i
+  130 label *label18
+  131 label *label6
   132 label *label3
   133 assertflush
   134 print .array*0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-10 instructions):
 
     9 op idiv :reverse:count 10 2
    10 set :reverse:i .array*0
    11 set :reverse:j .array*9
-    * op add *tmp3 @counter 1
    12 label *label22
-    * op sub :reverse:count :reverse:count 1
-    * jump *label23 greaterThanEq :reverse:count 0
+   13 op sub :reverse:count 5 1
+   14 jump *label23 greaterThanEq 4 0
    15 jump *label6 always
    16 label *label23
    17 label *label24
    18 label *label25
-    * set .array*0 :reverse:j
+   19 set .array*0 .array*9
    20 set .array*9 :reverse:i
    21 set :reverse:i .array*1
    22 set :reverse:j .array*8
-    * op add *tmp3 @counter 1
    23 label *label28
-    * op sub :reverse:count :reverse:count 1
-    * jump *label29 greaterThanEq :reverse:count 0
+   24 op sub :reverse:count 4 1
+   25 jump *label29 greaterThanEq 3 0
    26 jump *label6 always
    27 label *label29
    28 label *label30
    29 label *label31
-    * set .array*1 :reverse:j
+   30 set .array*1 .array*8
    31 set .array*8 :reverse:i
    32 set :reverse:i .array*2
    33 set :reverse:j .array*7
-    * op add *tmp3 @counter 1
    34 label *label34
-    * op sub :reverse:count :reverse:count 1
-    * jump *label35 greaterThanEq :reverse:count 0
+   35 op sub :reverse:count 3 1
+   36 jump *label35 greaterThanEq 2 0
    37 jump *label6 always
    38 label *label35
    39 label *label36
    40 label *label37
-    * set .array*2 :reverse:j
+   41 set .array*2 .array*7
    42 set .array*7 :reverse:i
    43 set :reverse:i .array*3
    44 set :reverse:j .array*6
-    * op add *tmp3 @counter 1
    45 label *label40
-    * op sub :reverse:count :reverse:count 1
-    * jump *label41 greaterThanEq :reverse:count 0
+   46 op sub :reverse:count 2 1
+   47 jump *label41 greaterThanEq 1 0
    48 jump *label6 always
    49 label *label41
    50 label *label42
    51 label *label43
-    * set .array*3 :reverse:j
+   52 set .array*3 .array*6
    53 set .array*6 :reverse:i
    54 set :reverse:i .array*4
    55 set :reverse:j .array*5
-    * op add *tmp3 @counter 1
    56 label *label46
-    * op sub :reverse:count :reverse:count 1
-    * jump *label47 greaterThanEq :reverse:count 0
+   57 op sub :reverse:count 1 1
+   58 jump *label47 greaterThanEq 0 0
    59 jump *label6 always
    60 label *label47
    61 label *label48
    62 label *label49
-    * set .array*4 :reverse:j
+   63 set .array*4 .array*5
    64 set .array*5 :reverse:i
-    * set :reverse:i .array*5
-    * set :reverse:j .array*4
-    * op add *tmp3 @counter 1
+   65 set :reverse:i :reverse:i
+   66 set :reverse:j :reverse:j
    67 label *label52
-    * op sub :reverse:count :reverse:count 1
-    * jump *label53 greaterThanEq :reverse:count 0
+   68 op sub :reverse:count 0 1
+   69 jump *label53 greaterThanEq -1 0
    70 jump *label6 always
    71 label *label53
    72 label *label54
    73 label *label55
-    * set .array*5 :reverse:j
+   74 set .array*5 .array*4
    75 set .array*4 :reverse:i
    76 set :reverse:i .array*6
    77 set :reverse:j .array*3
-    * op add *tmp3 @counter 1
    78 label *label58
-    * op sub :reverse:count :reverse:count 1
-    * jump *label59 greaterThanEq :reverse:count 0
+   79 op sub :reverse:count -1 1
+   80 jump *label59 greaterThanEq -2 0
    81 jump *label6 always
    82 label *label59
    83 label *label60
    84 label *label61
-    * set .array*6 :reverse:j
+   85 set .array*6 .array*3
    86 set .array*3 :reverse:i
    87 set :reverse:i .array*7
    88 set :reverse:j .array*2
-    * op add *tmp3 @counter 1
    89 label *label64
-    * op sub :reverse:count :reverse:count 1
-    * jump *label65 greaterThanEq :reverse:count 0
+   90 op sub :reverse:count -2 1
+   91 jump *label65 greaterThanEq -3 0
    92 jump *label6 always
    93 label *label65
    94 label *label66
    95 label *label67
-    * set .array*7 :reverse:j
+   96 set .array*7 .array*2
    97 set .array*2 :reverse:i
    98 set :reverse:i .array*8
    99 set :reverse:j .array*1
-    * op add *tmp3 @counter 1
   100 label *label70
-    * op sub :reverse:count :reverse:count 1
-    * jump *label71 greaterThanEq :reverse:count 0
+  101 op sub :reverse:count -3 1
+  102 jump *label71 greaterThanEq -4 0
   103 jump *label6 always
   104 label *label71
   105 label *label72
   106 label *label73
-    * set .array*8 :reverse:j
+  107 set .array*8 .array*1
   108 set .array*1 :reverse:i
   109 set :reverse:i .array*9
   110 set :reverse:j .array*0
-    * op add *tmp3 @counter 1
   111 label *label76
-    * op sub :reverse:count :reverse:count 1
-    * jump *label77 greaterThanEq :reverse:count 0
+  112 op sub :reverse:count -4 1
+  113 jump *label77 greaterThanEq -5 0
   114 jump *label6 always
   115 label *label77
   116 label *label78
   117 label *label79
-    * set .array*9 :reverse:j
+  118 set .array*9 .array*0
   119 set .array*0 :reverse:i
   120 label *label18
   121 label *label6

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-20 instructions):
 
     6 jump *label21 lessThan :i 10
     7 label *label2
     8 # "Function: inline void reverse(in array...)"
-    * op idiv :reverse:count 10 2
     9 set :reverse:i .array*0
-    * set :reverse:j .array*9
    10 label *label22
-    * op sub :reverse:count 5 1
    11 jump *label23 greaterThanEq 4 0
    12 jump *label6 always
    13 label *label23
 
    16 set .array*0 .array*9
    17 set .array*9 :reverse:i
    18 set :reverse:i .array*1
-    * set :reverse:j .array*8
    19 label *label28
-    * op sub :reverse:count 4 1
    20 jump *label29 greaterThanEq 3 0
    21 jump *label6 always
    22 label *label29
 
    25 set .array*1 .array*8
    26 set .array*8 :reverse:i
    27 set :reverse:i .array*2
-    * set :reverse:j .array*7
    28 label *label34
-    * op sub :reverse:count 3 1
    29 jump *label35 greaterThanEq 2 0
    30 jump *label6 always
    31 label *label35
 
    34 set .array*2 .array*7
    35 set .array*7 :reverse:i
    36 set :reverse:i .array*3
-    * set :reverse:j .array*6
    37 label *label40
-    * op sub :reverse:count 2 1
    38 jump *label41 greaterThanEq 1 0
    39 jump *label6 always
    40 label *label41
 
    45 set :reverse:i .array*4
    46 set :reverse:j .array*5
    47 label *label46
-    * op sub :reverse:count 1 1
    48 jump *label47 greaterThanEq 0 0
    49 jump *label6 always
    50 label *label47
 
    53 set .array*4 .array*5
    54 set .array*5 :reverse:i
    55 set :reverse:i :reverse:i
-    * set :reverse:j :reverse:j
    56 label *label52
-    * op sub :reverse:count 0 1
    57 jump *label53 greaterThanEq -1 0
    58 jump *label6 always
    59 label *label53
 
    62 set .array*5 .array*4
    63 set .array*4 :reverse:i
    64 set :reverse:i .array*6
-    * set :reverse:j .array*3
    65 label *label58
-    * op sub :reverse:count -1 1
    66 jump *label59 greaterThanEq -2 0
    67 jump *label6 always
    68 label *label59
 
    71 set .array*6 .array*3
    72 set .array*3 :reverse:i
    73 set :reverse:i .array*7
-    * set :reverse:j .array*2
    74 label *label64
-    * op sub :reverse:count -2 1
    75 jump *label65 greaterThanEq -3 0
    76 jump *label6 always
    77 label *label65
 
    80 set .array*7 .array*2
    81 set .array*2 :reverse:i
    82 set :reverse:i .array*8
-    * set :reverse:j .array*1
    83 label *label70
-    * op sub :reverse:count -3 1
    84 jump *label71 greaterThanEq -4 0
    85 jump *label6 always
    86 label *label71
 
    89 set .array*8 .array*1
    90 set .array*1 :reverse:i
    91 set :reverse:i .array*9
-    * set :reverse:j .array*0
    92 label *label76
-    * op sub :reverse:count -4 1
    93 jump *label77 greaterThanEq -5 0
    94 jump *label6 always
    95 label *label77

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
    43 set .array*3 .array*6
    44 set .array*6 :reverse:i
    45 set :reverse:i .array*4
-    * set :reverse:j .array*5
    46 label *label46
    47 jump *label47 greaterThanEq 0 0
    48 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
     0 set :i 0
     1 label *label0
     2 label *label21
-    * writearr<regular> :i .array[] :i
+    3 writearr<inlined> :i .array[] :i
     4 label *label1
     5 op add :i :i 1
     6 jump *label21 lessThan :i 10

Modifications by Unroll loop at line 6:5 (+197 instructions):
-    * set :i 0
-    * label *label0
-    * label *label21
-    * writearr<inlined> :i .array[] :i
-    * label *label1
-    * op add :i :i 1
-    * jump *label21 lessThan :i 10
-    * label *label2
+    0 set :i 0
+    1 label *label84
+    2 label *label85
+    3 writearr<inlined> :i .array[] :i
+    4 label *label86
+    5 op add :i :i 1
+    6 label *label87
+    7 writearr<inlined> :i .array[] :i
+    8 label *label88
+    9 op add :i :i 1
+   10 label *label89
+   11 writearr<inlined> :i .array[] :i
+   12 label *label90
+   13 op add :i :i 1
+   14 label *label91
+   15 writearr<inlined> :i .array[] :i
+   16 label *label92
+   17 op add :i :i 1
+   18 label *label93
+   19 writearr<inlined> :i .array[] :i
+   20 label *label94
+   21 op add :i :i 1
+   22 label *label95
+   23 writearr<inlined> :i .array[] :i
+   24 label *label96
+   25 op add :i :i 1
+   26 label *label97
+   27 writearr<inlined> :i .array[] :i
+   28 label *label98
+   29 op add :i :i 1
+   30 label *label99
+   31 writearr<inlined> :i .array[] :i
+   32 label *label100
+   33 op add :i :i 1
+   34 label *label101
+   35 writearr<inlined> :i .array[] :i
+   36 label *label102
+   37 op add :i :i 1
+   38 label *label103
+   39 writearr<inlined> :i .array[] :i
+   40 label *label104
+   41 op add :i :i 1
+   42 label *label2
    43 # "Function: inline void reverse(in array...)"
    44 set :reverse:i .array*0
    45 label *label22

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set :i 0
     1 label *label84
     2 label *label85
-    * writearr<inlined> :i .array[] :i
+    3 writearr<inlined> 0 .array[] 0
     4 label *label86
-    * op add :i :i 1
+    5 op add :i 0 1
     6 label *label87
-    * writearr<inlined> :i .array[] :i
+    7 writearr<inlined> 1 .array[] 1
     8 label *label88
-    * op add :i :i 1
+    9 op add :i 1 1
    10 label *label89
-    * writearr<inlined> :i .array[] :i
+   11 writearr<inlined> 2 .array[] 2
    12 label *label90
-    * op add :i :i 1
+   13 op add :i 2 1
    14 label *label91
-    * writearr<inlined> :i .array[] :i
+   15 writearr<inlined> 3 .array[] 3
    16 label *label92
-    * op add :i :i 1
+   17 op add :i 3 1
    18 label *label93
-    * writearr<inlined> :i .array[] :i
+   19 writearr<inlined> 4 .array[] 4
    20 label *label94
-    * op add :i :i 1
+   21 op add :i 4 1
    22 label *label95
-    * writearr<inlined> :i .array[] :i
+   23 writearr<inlined> 5 .array[] 5
    24 label *label96
-    * op add :i :i 1
+   25 op add :i 5 1
    26 label *label97
-    * writearr<inlined> :i .array[] :i
+   27 writearr<inlined> 6 .array[] 6
    28 label *label98
-    * op add :i :i 1
+   29 op add :i 6 1
    30 label *label99
-    * writearr<inlined> :i .array[] :i
+   31 writearr<inlined> 7 .array[] 7
    32 label *label100
-    * op add :i :i 1
+   33 op add :i 7 1
    34 label *label101
-    * writearr<inlined> :i .array[] :i
+   35 writearr<inlined> 8 .array[] 8
    36 label *label102
-    * op add :i :i 1
+   37 op add :i 8 1
    38 label *label103
-    * writearr<inlined> :i .array[] :i
+   39 writearr<inlined> 9 .array[] 9
    40 label *label104
-    * op add :i :i 1
+   41 op add :i 9 1
    42 label *label2
    43 # "Function: inline void reverse(in array...)"
    44 set :reverse:i .array*0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-11 instructions):
-    * set :i 0
     0 label *label84
     1 label *label85
     2 writearr<inlined> 0 .array[] 0
     3 label *label86
-    * op add :i 0 1
     4 label *label87
     5 writearr<inlined> 1 .array[] 1
     6 label *label88
-    * op add :i 1 1
     7 label *label89
     8 writearr<inlined> 2 .array[] 2
     9 label *label90
-    * op add :i 2 1
    10 label *label91
    11 writearr<inlined> 3 .array[] 3
    12 label *label92
-    * op add :i 3 1
    13 label *label93
    14 writearr<inlined> 4 .array[] 4
    15 label *label94
-    * op add :i 4 1
    16 label *label95
    17 writearr<inlined> 5 .array[] 5
    18 label *label96
-    * op add :i 5 1
    19 label *label97
    20 writearr<inlined> 6 .array[] 6
    21 label *label98
-    * op add :i 6 1
    22 label *label99
    23 writearr<inlined> 7 .array[] 7
    24 label *label100
-    * op add :i 7 1
    25 label *label101
    26 writearr<inlined> 8 .array[] 8
    27 label *label102
-    * op add :i 8 1
    28 label *label103
    29 writearr<inlined> 9 .array[] 9
    30 label *label104
-    * op add :i 9 1
    31 label *label2
    32 # "Function: inline void reverse(in array...)"
    33 set :reverse:i .array*0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-5 instructions):
 
    32 # "Function: inline void reverse(in array...)"
    33 set :reverse:i .array*0
    34 label *label22
-    * jump *label23 greaterThanEq 4 0
+   35 jump *label23 always
    36 jump *label6 always
    37 label *label23
    38 label *label24
 
    41 set .array*9 :reverse:i
    42 set :reverse:i .array*1
    43 label *label28
-    * jump *label29 greaterThanEq 3 0
+   44 jump *label29 always
    45 jump *label6 always
    46 label *label29
    47 label *label30
 
    50 set .array*8 :reverse:i
    51 set :reverse:i .array*2
    52 label *label34
-    * jump *label35 greaterThanEq 2 0
+   53 jump *label35 always
    54 jump *label6 always
    55 label *label35
    56 label *label36
 
    59 set .array*7 :reverse:i
    60 set :reverse:i .array*3
    61 label *label40
-    * jump *label41 greaterThanEq 1 0
+   62 jump *label41 always
    63 jump *label6 always
    64 label *label41
    65 label *label42
 
    68 set .array*6 :reverse:i
    69 set :reverse:i .array*4
    70 label *label46
-    * jump *label47 greaterThanEq 0 0
+   71 jump *label47 always
    72 jump *label6 always
    73 label *label47
    74 label *label48
 
    77 set .array*5 :reverse:i
    78 set :reverse:i :reverse:i
    79 label *label52
-    * jump *label53 greaterThanEq -1 0
    80 jump *label6 always
    81 label *label53
    82 label *label54
 
    85 set .array*4 :reverse:i
    86 set :reverse:i .array*6
    87 label *label58
-    * jump *label59 greaterThanEq -2 0
    88 jump *label6 always
    89 label *label59
    90 label *label60
 
    93 set .array*3 :reverse:i
    94 set :reverse:i .array*7
    95 label *label64
-    * jump *label65 greaterThanEq -3 0
    96 jump *label6 always
    97 label *label65
    98 label *label66
 
   101 set .array*2 :reverse:i
   102 set :reverse:i .array*8
   103 label *label70
-    * jump *label71 greaterThanEq -4 0
   104 jump *label6 always
   105 label *label71
   106 label *label72
 
   109 set .array*1 :reverse:i
   110 set :reverse:i .array*9
   111 label *label76
-    * jump *label77 greaterThanEq -5 0
   112 jump *label6 always
   113 label *label77
   114 label *label78

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-201 instructions):
     0 label *label84
     1 label *label85
-    * writearr<inlined> 0 .array[] 0
+    2 set .array*0 0
     3 label *label86
     4 label *label87
-    * writearr<inlined> 1 .array[] 1
+    5 set .array*1 1
     6 label *label88
     7 label *label89
-    * writearr<inlined> 2 .array[] 2
+    8 set .array*2 2
     9 label *label90
    10 label *label91
-    * writearr<inlined> 3 .array[] 3
+   11 set .array*3 3
    12 label *label92
    13 label *label93
-    * writearr<inlined> 4 .array[] 4
+   14 set .array*4 4
    15 label *label94
    16 label *label95
-    * writearr<inlined> 5 .array[] 5
+   17 set .array*5 5
    18 label *label96
    19 label *label97
-    * writearr<inlined> 6 .array[] 6
+   20 set .array*6 6
    21 label *label98
    22 label *label99
-    * writearr<inlined> 7 .array[] 7
+   23 set .array*7 7
    24 label *label100
    25 label *label101
-    * writearr<inlined> 8 .array[] 8
+   26 set .array*8 8
    27 label *label102
    28 label *label103
-    * writearr<inlined> 9 .array[] 9
+   29 set .array*9 9
    30 label *label104
    31 label *label2
    32 # "Function: inline void reverse(in array...)"
 
    75 label *label49
    76 set .array*4 .array*5
    77 set .array*5 :reverse:i
-    * set :reverse:i :reverse:i
    78 label *label52
    79 jump *label6 always
    80 label *label53

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
     0 label *label84
     1 label *label85
-    * set .array*0 0
+    2 set :reverse:i 0
     3 label *label86
     4 label *label87
     5 set .array*1 1
 
    30 label *label104
    31 label *label2
    32 # "Function: inline void reverse(in array...)"
-    * set :reverse:i .array*0
    33 label *label22
    34 jump *label23 always
    35 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
    26 set .array*8 8
    27 label *label102
    28 label *label103
-    * set .array*9 9
+   29 set .array*0 9
    30 label *label104
    31 label *label2
    32 # "Function: inline void reverse(in array...)"
 
    36 label *label23
    37 label *label24
    38 label *label25
-    * set .array*0 .array*9
    39 set .array*9 :reverse:i
    40 set :reverse:i .array*1
    41 label *label28

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-1 instructions):
     0 label *label84
     1 label *label85
-    * set :reverse:i 0
+    2 set .array*9 0
     3 label *label86
     4 label *label87
     5 set .array*1 1
 
    36 label *label23
    37 label *label24
    38 label *label25
-    * set .array*9 :reverse:i
    39 set :reverse:i .array*1
    40 label *label28
    41 jump *label29 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 4 (-1 instructions):
 
     2 set .array*9 0
     3 label *label86
     4 label *label87
-    * set .array*1 1
+    5 set :reverse:i 1
     6 label *label88
     7 label *label89
     8 set .array*2 2
 
    36 label *label23
    37 label *label24
    38 label *label25
-    * set :reverse:i .array*1
    39 label *label28
    40 jump *label29 always
    41 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 5 (-1 instructions):
 
    23 set .array*7 7
    24 label *label100
    25 label *label101
-    * set .array*8 8
+   26 set .array*1 8
    27 label *label102
    28 label *label103
    29 set .array*0 9
 
    42 label *label29
    43 label *label30
    44 label *label31
-    * set .array*1 .array*8
    45 set .array*8 :reverse:i
    46 set :reverse:i .array*2
    47 label *label34

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 6 (-1 instructions):
 
     2 set .array*9 0
     3 label *label86
     4 label *label87
-    * set :reverse:i 1
+    5 set .array*8 1
     6 label *label88
     7 label *label89
     8 set .array*2 2
 
    42 label *label29
    43 label *label30
    44 label *label31
-    * set .array*8 :reverse:i
    45 set :reverse:i .array*2
    46 label *label34
    47 jump *label35 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 7 (-1 instructions):
 
     5 set .array*8 1
     6 label *label88
     7 label *label89
-    * set .array*2 2
+    8 set :reverse:i 2
     9 label *label90
    10 label *label91
    11 set .array*3 3
 
    42 label *label29
    43 label *label30
    44 label *label31
-    * set :reverse:i .array*2
    45 label *label34
    46 jump *label35 always
    47 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 8 (-1 instructions):
 
    20 set .array*6 6
    21 label *label98
    22 label *label99
-    * set .array*7 7
+   23 set .array*2 7
    24 label *label100
    25 label *label101
    26 set .array*1 8
 
    48 label *label35
    49 label *label36
    50 label *label37
-    * set .array*2 .array*7
    51 set .array*7 :reverse:i
    52 set :reverse:i .array*3
    53 label *label40

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 9 (-1 instructions):
 
     5 set .array*8 1
     6 label *label88
     7 label *label89
-    * set :reverse:i 2
+    8 set .array*7 2
     9 label *label90
    10 label *label91
    11 set .array*3 3
 
    48 label *label35
    49 label *label36
    50 label *label37
-    * set .array*7 :reverse:i
    51 set :reverse:i .array*3
    52 label *label40
    53 jump *label41 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 10 (-1 instructions):
 
     8 set .array*7 2
     9 label *label90
    10 label *label91
-    * set .array*3 3
+   11 set :reverse:i 3
    12 label *label92
    13 label *label93
    14 set .array*4 4
 
    48 label *label35
    49 label *label36
    50 label *label37
-    * set :reverse:i .array*3
    51 label *label40
    52 jump *label41 always
    53 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 11 (-1 instructions):
 
    17 set .array*5 5
    18 label *label96
    19 label *label97
-    * set .array*6 6
+   20 set .array*3 6
    21 label *label98
    22 label *label99
    23 set .array*2 7
 
    54 label *label41
    55 label *label42
    56 label *label43
-    * set .array*3 .array*6
    57 set .array*6 :reverse:i
    58 set :reverse:i .array*4
    59 label *label46

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 12 (-1 instructions):
 
     8 set .array*7 2
     9 label *label90
    10 label *label91
-    * set :reverse:i 3
+   11 set .array*6 3
    12 label *label92
    13 label *label93
    14 set .array*4 4
 
    54 label *label41
    55 label *label42
    56 label *label43
-    * set .array*6 :reverse:i
    57 set :reverse:i .array*4
    58 label *label46
    59 jump *label47 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 13 (-1 instructions):
 
    11 set .array*6 3
    12 label *label92
    13 label *label93
-    * set .array*4 4
+   14 set :reverse:i 4
    15 label *label94
    16 label *label95
    17 set .array*5 5
 
    54 label *label41
    55 label *label42
    56 label *label43
-    * set :reverse:i .array*4
    57 label *label46
    58 jump *label47 always
    59 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 14 (-1 instructions):
 
    14 set :reverse:i 4
    15 label *label94
    16 label *label95
-    * set .array*5 5
+   17 set .array*4 5
    18 label *label96
    19 label *label97
    20 set .array*3 6
 
    60 label *label47
    61 label *label48
    62 label *label49
-    * set .array*4 .array*5
    63 set .array*5 :reverse:i
    64 label *label52
    65 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 15:
 
    60 label *label47
    61 label *label48
    62 label *label49
-    * set .array*5 :reverse:i
+   63 set .array*5 4
    64 label *label52
    65 jump *label6 always
    66 label *label53
    67 label *label54
    68 label *label55
-    * set .array*5 .array*4
-    * set .array*4 :reverse:i
-    * set :reverse:i .array*6
+   69 set .array*5 5
+   70 set .array*4 4
+   71 set :reverse:i 3
    72 label *label58
    73 jump *label6 always
    74 label *label59
    75 label *label60
    76 label *label61
-    * set .array*6 .array*3
+   77 set .array*6 6
    78 set .array*3 :reverse:i
-    * set :reverse:i .array*7
+   79 set :reverse:i 2
    80 label *label64
    81 jump *label6 always
    82 label *label65
    83 label *label66
    84 label *label67
-    * set .array*7 .array*2
+   85 set .array*7 7
    86 set .array*2 :reverse:i
-    * set :reverse:i .array*8
+   87 set :reverse:i 1
    88 label *label70
    89 jump *label6 always
    90 label *label71
    91 label *label72
    92 label *label73
-    * set .array*8 .array*1
+   93 set .array*8 8
    94 set .array*1 :reverse:i
-    * set :reverse:i .array*9
+   95 set :reverse:i 0
    96 label *label76
    97 jump *label6 always
    98 label *label77
    99 label *label78
   100 label *label79
-    * set .array*9 .array*0
+  101 set .array*9 9
   102 set .array*0 :reverse:i
   103 label *label18
   104 label *label6
   105 label *label3
   106 assertflush
-    * print .array*0
-    * print .array*1
-    * print .array*2
-    * print .array*3
-    * print .array*4
-    * print .array*5
-    * print .array*6
-    * print .array*7
-    * print .array*8
-    * print .array*9
+  107 print 9
+  108 print 8
+  109 print 7
+  110 print 6
+  111 print 5
+  112 print :reverse:i
+  113 print 3
+  114 print 2
+  115 print 1
+  116 print 0
   117 assertprints "9876543210" "reverse array"
   118 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 16 (-4 instructions):
 
    68 label *label55
    69 set .array*5 5
    70 set .array*4 4
-    * set :reverse:i 3
+   71 set .array*3 3
    72 label *label58
    73 jump *label6 always
    74 label *label59
    75 label *label60
    76 label *label61
    77 set .array*6 6
-    * set .array*3 :reverse:i
-    * set :reverse:i 2
+   78 set .array*2 2
    79 label *label64
    80 jump *label6 always
    81 label *label65
    82 label *label66
    83 label *label67
    84 set .array*7 7
-    * set .array*2 :reverse:i
-    * set :reverse:i 1
+   85 set .array*1 1
    86 label *label70
    87 jump *label6 always
    88 label *label71
    89 label *label72
    90 label *label73
    91 set .array*8 8
-    * set .array*1 :reverse:i
-    * set :reverse:i 0
+   92 set .array*0 0
    93 label *label76
    94 jump *label6 always
    95 label *label77
    96 label *label78
    97 label *label79
    98 set .array*9 9
-    * set .array*0 :reverse:i
    99 label *label18
   100 label *label6
   101 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 17:
 
   105 print 7
   106 print 6
   107 print 5
-    * print :reverse:i
+  108 print 4
   109 print 3
   110 print 2
   111 print 1

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 18 (-1 instructions):
 
    11 set .array*6 3
    12 label *label92
    13 label *label93
-    * set :reverse:i 4
    14 label *label94
    15 label *label95
    16 set .array*4 5

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
-    * label *label84
-    * label *label85
     0 set .array*9 0
-    * label *label86
-    * label *label87
     1 set .array*8 1
-    * label *label88
-    * label *label89
     2 set .array*7 2
-    * label *label90
-    * label *label91
     3 set .array*6 3
-    * label *label92
-    * label *label93
-    * label *label94
-    * label *label95
     4 set .array*4 5
-    * label *label96
-    * label *label97
     5 set .array*3 6
-    * label *label98
-    * label *label99
     6 set .array*2 7
-    * label *label100
-    * label *label101
     7 set .array*1 8
-    * label *label102
-    * label *label103
     8 set .array*0 9
-    * label *label104
-    * label *label2
     9 # "Function: inline void reverse(in array...)"
-    * label *label22
    10 jump *label23 always
    11 jump *label6 always
    12 label *label23
-    * label *label24
-    * label *label25
-    * label *label28
    13 jump *label29 always
    14 jump *label6 always
    15 label *label29
-    * label *label30
-    * label *label31
-    * label *label34
    16 jump *label35 always
    17 jump *label6 always
    18 label *label35
-    * label *label36
-    * label *label37
-    * label *label40
    19 jump *label41 always
    20 jump *label6 always
    21 label *label41
-    * label *label42
-    * label *label43
-    * label *label46
    22 jump *label47 always
    23 jump *label6 always
    24 label *label47
-    * label *label48
-    * label *label49
    25 set .array*5 4
-    * label *label52
    26 jump *label6 always
-    * label *label53
-    * label *label54
-    * label *label55
    27 set .array*5 5
    28 set .array*4 4
    29 set .array*3 3
-    * label *label58
    30 jump *label6 always
-    * label *label59
-    * label *label60
-    * label *label61
    31 set .array*6 6
    32 set .array*2 2
-    * label *label64
    33 jump *label6 always
-    * label *label65
-    * label *label66
-    * label *label67
    34 set .array*7 7
    35 set .array*1 1
-    * label *label70
    36 jump *label6 always
-    * label *label71
-    * label *label72
-    * label *label73
    37 set .array*8 8
    38 set .array*0 0
-    * label *label76
    39 jump *label6 always
-    * label *label77
-    * label *label78
-    * label *label79
    40 set .array*9 9
-    * label *label18
    41 label *label6
-    * label *label3
    42 assertflush
    43 print 9
    44 print 8

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
     7 set .array*1 8
     8 set .array*0 9
     9 # "Function: inline void reverse(in array...)"
-    * jump *label23 always
+   10 jump *label47 always
    11 jump *label6 always
    12 label *label23
-    * jump *label29 always
+   13 jump *label47 always
    14 jump *label6 always
    15 label *label29
-    * jump *label35 always
+   16 jump *label47 always
    17 jump *label6 always
    18 label *label35
-    * jump *label41 always
+   19 jump *label47 always
    20 jump *label6 always
    21 label *label41
    22 jump *label47 always

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-23 instructions):
 
     8 set .array*0 9
     9 # "Function: inline void reverse(in array...)"
    10 jump *label47 always
-    * jump *label6 always
-    * label *label23
-    * jump *label47 always
-    * jump *label6 always
-    * label *label29
-    * jump *label47 always
-    * jump *label6 always
-    * label *label35
-    * jump *label47 always
-    * jump *label6 always
-    * label *label41
-    * jump *label47 always
-    * jump *label6 always
    11 label *label47
    12 set .array*5 4
    13 jump *label6 always
-    * set .array*5 5
-    * set .array*4 4
-    * set .array*3 3
-    * jump *label6 always
-    * set .array*6 6
-    * set .array*2 2
-    * jump *label6 always
-    * set .array*7 7
-    * set .array*1 1
-    * jump *label6 always
-    * set .array*8 8
-    * set .array*0 0
-    * jump *label6 always
-    * set .array*9 9
    14 label *label6
    15 assertflush
    16 print 9

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1 (-10 instructions):
-    * set .array*9 0
-    * set .array*8 1
-    * set .array*7 2
-    * set .array*6 3
-    * set .array*4 5
-    * set .array*3 6
-    * set .array*2 7
-    * set .array*1 8
-    * set .array*0 9
     0 # "Function: inline void reverse(in array...)"
     1 jump *label47 always
     2 label *label47
-    * set .array*5 4
     3 jump *label6 always
     4 label *label6
     5 assertflush

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-3 instructions):
     0 # "Function: inline void reverse(in array...)"
-    * jump *label47 always
     1 label *label47
-    * jump *label6 always
     2 label *label6
     3 assertflush
     4 print 9
 
    12 print 1
    13 print 0
    14 assertprints "9876543210" "reverse array"
-    * end

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
     0 # "Function: inline void reverse(in array...)"
-    * label *label47
-    * label *label6
     1 assertflush
     2 print 9
     3 print 8

Modifications by Final phase, Print Merging, iteration 1 (-9 instructions):
     0 # "Function: inline void reverse(in array...)"
     1 assertflush
-    * print 9
-    * print 8
-    * print 7
-    * print 6
-    * print 5
-    * print 4
-    * print 3
-    * print 2
-    * print 1
-    * print 0
+    2 print "9876543210"
     3 assertprints "9876543210" "reverse array"

Final code before resolving virtual instructions:

# "Function: inline void reverse(in array...)"
assertflush
print "9876543210"
assertprints "9876543210" "reverse array"
