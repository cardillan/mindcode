    97 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (2 iterations).
     3 instructions eliminated by Dead Code Elimination (4 iterations).
     6 instructions eliminated by Jump Optimization (4 iterations).
     1 instructions eliminated by Single Step Elimination (5 iterations).
     1 instructions eliminated by Expression Optimization (2 iterations).
     4 instructions eliminated by Data Flow Optimization (9 iterations).
     5 instructions added by Loop Optimization (2 iterations).
     6 loops improved by Loop Optimization.
     1 instructions updated by Jump Threading.
    10 instructions eliminated by Print Merging.
    71 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 920):
  * Replicate loop condition at line 17:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 24:1                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 32:1                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 45:1                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 58:1                        size    +1, benefit       25.0, efficiency     25.000

Pass 1: speed optimization selection (cost limit 919):
  * Replicate loop condition at line 24:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 32:1                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 45:1                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 58:1                        size    +1, benefit       25.0, efficiency     25.000

Pass 1: speed optimization selection (cost limit 918):
  * Replicate loop condition at line 32:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 45:1                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 58:1                        size    +1, benefit       25.0, efficiency     25.000

Pass 1: speed optimization selection (cost limit 917):
  * Replicate loop condition at line 45:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 58:1                        size    +1, benefit       25.0, efficiency     25.000

Pass 1: speed optimization selection (cost limit 916):
  * Replicate loop condition at line 58:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
     1 set .SX 10
     2 set .SY 10
     3 set .DX 10
-    * op sub *tmp0 @maph 10
-    * set .DY *tmp0
+    4 op sub .DY @maph 10
     5 op sub *tmp1 .DX .SX
     6 op sub *tmp2 .DY .SY
     7 op len *tmp3 *tmp1 *tmp2
 
     9 op add *tmp5 *tmp4 0.5
    10 op floor *tmp6 *tmp5
    11 op div *tmp7 *tmp6 100
-    * op sub *tmp8 *tmp7 2
-    * set :distance *tmp8
+   12 op sub :distance *tmp7 2
    13 ubind UNIT
    14 label *label0
    15 op equal *tmp9 @unit null
 
    57 label *label11
    58 print "Moving to destination"
    59 printflush message1
-    * set *tmp17 @time
-    * set :start *tmp17
+   60 set :start @time
    61 ucontrol move .DX .DY
    62 label *label12
    63 ucontrol within .DX .DY 1 *tmp18
 
    67 label *label13
    68 jump *label12 always
    69 label *label14
-    * set *tmp20 @time
-    * set :finish *tmp20
+   70 set :finish @time
    71 op sub *tmp21 .SX .DX
    72 op abs *tmp22 *tmp21
    73 op div *tmp23 *tmp22 2
 
    76 op div *tmp26 *tmp25 2
    77 ucontrol move *tmp23 *tmp26
    78 ucontrol flag 0
-    * op sub *tmp27 :finish :start
-    * set :elapsed *tmp27
+   79 op sub :elapsed :finish :start
    80 op div *tmp28 :distance :elapsed
    81 op mul *tmp29 *tmp28 100000
    82 op floor *tmp30 *tmp29
-    * op div *tmp31 *tmp30 100
-    * set :speed *tmp31
+   83 op div :speed *tmp30 100
    84 label *label15
    85 sensor *tmp32 switch1 @enabled
    86 op equal *tmp33 *tmp32 false

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-6 instructions):
 
    12 op sub :distance *tmp7 2
    13 ubind UNIT
    14 label *label0
-    * op equal *tmp9 @unit null
-    * jump *label2 equal *tmp9 false
+   15 jump *label2 notEqual @unit null
    16 print UNIT
    17 print ": no active unit found."
    18 printflush message1
 
    22 label *label2
    23 label *label3
    24 sensor *tmp10 switch1 @enabled
-    * op equal *tmp11 *tmp10 false
-    * jump *label5 equal *tmp11 false
+   25 jump *label5 notEqual *tmp10 false
    26 print "Press button to start measuring "
    27 print UNIT
    28 print " speed."
 
    33 control enabled switch1 false
    34 label *label6
    35 sensor *tmp13 @unit @controlled
-    * op notEqual *tmp14 *tmp13 0
-    * jump *label8 equal *tmp14 false
+   36 jump *label8 equal *tmp13 0
    37 print "Searching free "
    38 print UNIT
    39 printflush message1
 
    44 ucontrol flag 1
    45 label *label9
    46 ucontrol within .SX .SY 1 *tmp15
-    * op equal *tmp16 *tmp15 false
-    * jump *label11 equal *tmp16 false
+   47 jump *label11 notEqual *tmp15 false
    48 print "Moving to start"
    49 printflush message1
    50 ucontrol move .SX .SY
 
    57 ucontrol move .DX .DY
    58 label *label12
    59 ucontrol within .DX .DY 1 *tmp18
-    * op equal *tmp19 *tmp18 false
-    * jump *label14 equal *tmp19 false
+   60 jump *label14 notEqual *tmp18 false
    61 ucontrol move .DX .DY
    62 label *label13
    63 jump *label12 always
 
    78 op div :speed *tmp30 100
    79 label *label15
    80 sensor *tmp32 switch1 @enabled
-    * op equal *tmp33 *tmp32 false
-    * jump *label17 equal *tmp33 false
+   81 jump *label17 notEqual *tmp32 false
    82 print "Measurement results ("
    83 print UNIT
    84 print "):"

Modifications by Iterated phase, Expression Optimization, pass 1, iteration 1 (-1 instructions):
 
    73 ucontrol flag 0
    74 op sub :elapsed :finish :start
    75 op div *tmp28 :distance :elapsed
-    * op mul *tmp29 *tmp28 100000
-    * op floor *tmp30 *tmp29
+   76 op idiv *tmp30 *tmp28 0.00001
    77 op div :speed *tmp30 100
    78 label *label15
    79 sensor *tmp32 switch1 @enabled

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set .SY 10
     3 set .DX 10
     4 op sub .DY @maph 10
-    * op sub *tmp1 .DX .SX
-    * op sub *tmp2 .DY .SY
-    * op len *tmp3 *tmp1 *tmp2
+    5 op sub *tmp1 10 10
+    6 op sub *tmp2 .DY 10
+    7 op len *tmp3 0 *tmp2
     8 op mul *tmp4 100 *tmp3
     9 op add *tmp5 *tmp4 0.5
    10 op floor *tmp6 *tmp5
 
    43 label *label8
    44 ucontrol flag 1
    45 label *label9
-    * ucontrol within .SX .SY 1 *tmp15
+   46 ucontrol within 10 10 1 *tmp15
    47 jump *label11 notEqual *tmp15 false
    48 print "Moving to start"
    49 printflush message1
-    * ucontrol move .SX .SY
+   50 ucontrol move 10 10
    51 label *label10
    52 jump *label9 always
    53 label *label11
    54 print "Moving to destination"
    55 printflush message1
    56 set :start @time
-    * ucontrol move .DX .DY
+   57 ucontrol move 10 .DY
    58 label *label12
-    * ucontrol within .DX .DY 1 *tmp18
+   59 ucontrol within 10 .DY 1 *tmp18
    60 jump *label14 notEqual *tmp18 false
-    * ucontrol move .DX .DY
+   61 ucontrol move 10 .DY
    62 label *label13
    63 jump *label12 always
    64 label *label14
    65 set :finish @time
-    * op sub *tmp21 .SX .DX
-    * op abs *tmp22 *tmp21
-    * op div *tmp23 *tmp22 2
-    * op sub *tmp24 .SY .DY
+   66 op sub *tmp21 10 10
+   67 op abs *tmp22 0
+   68 op div *tmp23 0 2
+   69 op sub *tmp24 10 .DY
    70 op abs *tmp25 *tmp24
    71 op div *tmp26 *tmp25 2
-    * ucontrol move *tmp23 *tmp26
+   72 ucontrol move 0 *tmp26
    73 ucontrol flag 0
    74 op sub :elapsed :finish :start
    75 op div *tmp28 :distance :elapsed

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
     2 set .SY 10
     3 set .DX 10
     4 op sub .DY @maph 10
-    * op sub *tmp1 10 10
     5 op sub *tmp2 .DY 10
     6 op len *tmp3 0 *tmp2
     7 op mul *tmp4 100 *tmp3
 
    62 jump *label12 always
    63 label *label14
    64 set :finish @time
-    * op sub *tmp21 10 10
-    * op abs *tmp22 0
-    * op div *tmp23 0 2
    65 op sub *tmp24 10 .DY
    66 op abs *tmp25 *tmp24
    67 op div *tmp26 *tmp25 2

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    12 ubind UNIT
    13 label *label0
    14 jump *label2 notEqual @unit null
+   15 label *label18
    16 print UNIT
    17 print ": no active unit found."
    18 printflush message1
    19 ubind UNIT
    20 label *label1
-    * jump *label0 always
+   21 jump *label18 equal @unit null
    22 label *label2
    23 label *label3
    24 sensor *tmp10 switch1 @enabled

Modifications by Replicate loop condition at line 17:1 (+1 instructions):
 
    23 label *label3
    24 sensor *tmp10 switch1 @enabled
    25 jump *label5 notEqual *tmp10 false
+   26 label *label19
    27 print "Press button to start measuring "
    28 print UNIT
    29 print " speed."
    30 printflush message1
    31 label *label4
-    * jump *label3 always
+   32 sensor *tmp10 switch1 @enabled
+   33 jump *label19 equal *tmp10 false
    34 label *label5
    35 control enabled switch1 false
    36 label *label6

Modifications by Replicate loop condition at line 24:1 (+1 instructions):
 
    36 label *label6
    37 sensor *tmp13 @unit @controlled
    38 jump *label8 equal *tmp13 0
+   39 label *label20
    40 print "Searching free "
    41 print UNIT
    42 printflush message1
    43 ubind UNIT
    44 label *label7
-    * jump *label6 always
+   45 sensor *tmp13 @unit @controlled
+   46 jump *label20 notEqual *tmp13 0
    47 label *label8
    48 ucontrol flag 1
    49 label *label9

Modifications by Replicate loop condition at line 32:1 (+1 instructions):
 
    49 label *label9
    50 ucontrol within 10 10 1 *tmp15
    51 jump *label11 notEqual *tmp15 false
+   52 label *label21
    53 print "Moving to start"
    54 printflush message1
    55 ucontrol move 10 10
    56 label *label10
-    * jump *label9 always
+   57 ucontrol within 10 10 1 *tmp15
+   58 jump *label21 equal *tmp15 false
    59 label *label11
    60 print "Moving to destination"
    61 printflush message1

Modifications by Replicate loop condition at line 45:1 (+1 instructions):
 
    64 label *label12
    65 ucontrol within 10 .DY 1 *tmp18
    66 jump *label14 notEqual *tmp18 false
+   67 label *label22
    68 ucontrol move 10 .DY
    69 label *label13
-    * jump *label12 always
+   70 ucontrol within 10 .DY 1 *tmp18
+   71 jump *label22 equal *tmp18 false
    72 label *label14
    73 set :finish @time
    74 op sub *tmp24 10 .DY

Modifications by Replicate loop condition at line 58:1 (+1 instructions):
 
    83 label *label15
    84 sensor *tmp32 switch1 @enabled
    85 jump *label17 notEqual *tmp32 false
+   86 label *label23
    87 print "Measurement results ("
    88 print UNIT
    89 print "):"
 
   102 print "\nPress button to repeat"
   103 printflush message1
   104 label *label16
-    * jump *label15 always
+  105 sensor *tmp32 switch1 @enabled
+  106 jump *label23 equal *tmp32 false
   107 label *label17
   108 end

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
    10 op div *tmp7 *tmp6 100
    11 op sub :distance *tmp7 2
    12 ubind UNIT
-    * label *label0
    13 jump *label2 notEqual @unit null
    14 label *label18
    15 print UNIT
    16 print ": no active unit found."
    17 printflush message1
    18 ubind UNIT
-    * label *label1
    19 jump *label18 equal @unit null
    20 label *label2
-    * label *label3
    21 sensor *tmp10 switch1 @enabled
    22 jump *label5 notEqual *tmp10 false
    23 label *label19
 
    25 print UNIT
    26 print " speed."
    27 printflush message1
-    * label *label4
    28 sensor *tmp10 switch1 @enabled
    29 jump *label19 equal *tmp10 false
    30 label *label5
    31 control enabled switch1 false
-    * label *label6
    32 sensor *tmp13 @unit @controlled
    33 jump *label8 equal *tmp13 0
    34 label *label20
 
    36 print UNIT
    37 printflush message1
    38 ubind UNIT
-    * label *label7
    39 sensor *tmp13 @unit @controlled
    40 jump *label20 notEqual *tmp13 0
    41 label *label8
    42 ucontrol flag 1
-    * label *label9
    43 ucontrol within 10 10 1 *tmp15
    44 jump *label11 notEqual *tmp15 false
    45 label *label21
    46 print "Moving to start"
    47 printflush message1
    48 ucontrol move 10 10
-    * label *label10
    49 ucontrol within 10 10 1 *tmp15
    50 jump *label21 equal *tmp15 false
    51 label *label11
 
    53 printflush message1
    54 set :start @time
    55 ucontrol move 10 .DY
-    * label *label12
    56 ucontrol within 10 .DY 1 *tmp18
    57 jump *label14 notEqual *tmp18 false
    58 label *label22
    59 ucontrol move 10 .DY
-    * label *label13
    60 ucontrol within 10 .DY 1 *tmp18
    61 jump *label22 equal *tmp18 false
    62 label *label14
 
    70 op div *tmp28 :distance :elapsed
    71 op idiv *tmp30 *tmp28 0.00001
    72 op div :speed *tmp30 100
-    * label *label15
    73 sensor *tmp32 switch1 @enabled
    74 jump *label17 notEqual *tmp32 false
    75 label *label23
 
    90 print "tiles/s"
    91 print "\nPress button to repeat"
    92 printflush message1
-    * label *label16
    93 sensor *tmp32 switch1 @enabled
    94 jump *label23 equal *tmp32 false
    95 label *label17

Modifications by Jumps phase, Jump Threading, pass 3, iteration 1:
+    0 label __start__
     1 set UNIT @flare
     2 set .SX 10
     3 set .SY 10
 
    72 op idiv *tmp30 *tmp28 0.00001
    73 op div :speed *tmp30 100
    74 sensor *tmp32 switch1 @enabled
-    * jump *label17 notEqual *tmp32 false
+   75 jump __start__ notEqual *tmp32 false
    76 label *label23
    77 print "Measurement results ("
    78 print UNIT

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1:
 
    93 printflush message1
    94 sensor *tmp32 switch1 @enabled
    95 jump *label23 equal *tmp32 false
-    * label *label17
    96 end

Modifications by Jumps phase, Dead Code Elimination, pass 3, iteration 1 (-3 instructions):
     0 label __start__
     1 set UNIT @flare
-    * set .SX 10
-    * set .SY 10
-    * set .DX 10
     2 op sub .DY @maph 10
     3 op sub *tmp2 .DY 10
     4 op len *tmp3 0 *tmp2

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
    90 printflush message1
    91 sensor *tmp32 switch1 @enabled
    92 jump *label23 equal *tmp32 false
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-10 instructions):
 
    19 sensor *tmp10 switch1 @enabled
    20 jump *label5 notEqual *tmp10 false
    21 label *label19
-    * print "Press button to start measuring "
-    * print UNIT
-    * print " speed."
+   22 print "Press button to start measuring {0} speed."
+   23 format UNIT
    24 printflush message1
    25 sensor *tmp10 switch1 @enabled
    26 jump *label19 equal *tmp10 false
 
    70 sensor *tmp32 switch1 @enabled
    71 jump __start__ notEqual *tmp32 false
    72 label *label23
-    * print "Measurement results ("
-    * print UNIT
-    * print "):"
-    * print "\nMap dimensions: "
-    * print @mapw
-    * print "x"
-    * print @maph
-    * print "\nElapsed time: "
-    * print :elapsed
-    * print "ms"
-    * print "\nDistance travelled: "
-    * print :distance
-    * print "\nSpeed: "
-    * print :speed
-    * print "tiles/s"
-    * print "\nPress button to repeat"
+   73 print "Measurement results ({0}):\nMap dimensions: {0}x{0}\nElapsed time: {0}ms\nDistance travelled: {0}\nSpeed: {0}tiles/s\nPress button to repeat"
+   74 format UNIT
+   75 format @mapw
+   76 format @maph
+   77 format :elapsed
+   78 format :distance
+   79 format :speed
    80 printflush message1
    81 sensor *tmp32 switch1 @enabled
    82 jump *label23 equal *tmp32 false

Final code before resolving virtual instructions:

label __start__
set UNIT @flare
op sub .DY @maph 10
op sub *tmp2 .DY 10
op len *tmp3 0 *tmp2
op mul *tmp4 100 *tmp3
op add *tmp5 *tmp4 0.5
op floor *tmp6 *tmp5
op div *tmp7 *tmp6 100
op sub :distance *tmp7 2
ubind UNIT
jump *label2 notEqual @unit null
label *label18
print UNIT
print ": no active unit found."
printflush message1
ubind UNIT
jump *label18 equal @unit null
label *label2
sensor *tmp10 switch1 @enabled
jump *label5 notEqual *tmp10 false
label *label19
print "Press button to start measuring {0} speed."
format UNIT
printflush message1
sensor *tmp10 switch1 @enabled
jump *label19 equal *tmp10 false
label *label5
control enabled switch1 false
sensor *tmp13 @unit @controlled
jump *label8 equal *tmp13 0
label *label20
print "Searching free "
print UNIT
printflush message1
ubind UNIT
sensor *tmp13 @unit @controlled
jump *label20 notEqual *tmp13 0
label *label8
ucontrol flag 1
ucontrol within 10 10 1 *tmp15
jump *label11 notEqual *tmp15 false
label *label21
print "Moving to start"
printflush message1
ucontrol move 10 10
ucontrol within 10 10 1 *tmp15
jump *label21 equal *tmp15 false
label *label11
print "Moving to destination"
printflush message1
set :start @time
ucontrol move 10 .DY
ucontrol within 10 .DY 1 *tmp18
jump *label14 notEqual *tmp18 false
label *label22
ucontrol move 10 .DY
ucontrol within 10 .DY 1 *tmp18
jump *label22 equal *tmp18 false
label *label14
set :finish @time
op sub *tmp24 10 .DY
op abs *tmp25 *tmp24
op div *tmp26 *tmp25 2
ucontrol move 0 *tmp26
ucontrol flag 0
op sub :elapsed :finish :start
op div *tmp28 :distance :elapsed
op idiv *tmp30 *tmp28 0.00001
op div :speed *tmp30 100
sensor *tmp32 switch1 @enabled
jump __start__ notEqual *tmp32 false
label *label23
print "Measurement results ({0}):\nMap dimensions: {0}x{0}\nElapsed time: {0}ms\nDistance travelled: {0}\nSpeed: {0}tiles/s\nPress button to repeat"
format UNIT
format @mapw
format @maph
format :elapsed
format :distance
format :speed
printflush message1
sensor *tmp32 switch1 @enabled
jump *label23 equal *tmp32 false
