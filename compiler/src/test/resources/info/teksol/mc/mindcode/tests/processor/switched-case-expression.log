    87 instructions before optimizations.
     1 instructions eliminated by Temp Variables Elimination (5 iterations).
     1 instructions eliminated by Case Expression Optimization.
    13 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Condition Optimization (4 iterations).
     2 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
    26 instructions modified by Data Flow Optimization (2 passes, 8 iterations).
     1 instructions eliminated by Loop Optimization (2 iterations).
     2 loops improved by Loop Optimization.
     8 instructions eliminated by Case Switching (3 iterations).
     1 case expressions converted to fast dispatch by Case Switching.
    10 instructions eliminated by Jump Straightening (5 iterations).
    50 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 941):
  * Fast-dispatch case at line 27:5                              size    -9, benefit     2812.5, efficiency   Infinity (-8 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    16 jump *label6 equal *tmp1 false
    17 op mod *tmp2 :processNumber:n 10
    18 set :processDigit:n *tmp2
-    * set *tmp5 :processDigit:n
-    * jump *label10 equal *tmp5 0
+   19 jump *label10 equal :processDigit:n 0
    20 jump *label9 always
    21 label *label10
    22 op add .S0 .S0 1
    23 set *tmp4 .S0
    24 jump *label8 always
    25 label *label9
-    * jump *label12 equal *tmp5 1
+   26 jump *label12 equal :processDigit:n 1
    27 jump *label11 always
    28 label *label12
    29 op add .S1 .S1 1
    30 set *tmp4 .S1
    31 jump *label8 always
    32 label *label11
-    * jump *label14 equal *tmp5 2
+   33 jump *label14 equal :processDigit:n 2
    34 jump *label13 always
    35 label *label14
    36 op add .S2 .S2 1
    37 set *tmp4 .S2
    38 jump *label8 always
    39 label *label13
-    * jump *label16 equal *tmp5 3
+   40 jump *label16 equal :processDigit:n 3
    41 jump *label15 always
    42 label *label16
    43 op add .S3 .S3 1
    44 set *tmp4 .S3
    45 jump *label8 always
    46 label *label15
-    * jump *label18 equal *tmp5 4
+   47 jump *label18 equal :processDigit:n 4
    48 jump *label17 always
    49 label *label18
    50 op add .S4 .S4 1
    51 set *tmp4 .S4
    52 jump *label8 always
    53 label *label17
-    * jump *label20 equal *tmp5 5
+   54 jump *label20 equal :processDigit:n 5
    55 jump *label19 always
    56 label *label20
    57 op add .S5 .S5 1
    58 set *tmp4 .S5
    59 jump *label8 always
    60 label *label19
-    * jump *label22 equal *tmp5 6
+   61 jump *label22 equal :processDigit:n 6
    62 jump *label21 always
    63 label *label22
    64 op add .S6 .S6 1
    65 set *tmp4 .S6
    66 jump *label8 always
    67 label *label21
-    * jump *label24 equal *tmp5 7
+   68 jump *label24 equal :processDigit:n 7
    69 jump *label23 always
    70 label *label24
    71 op add .S7 .S7 1
    72 set *tmp4 .S7
    73 jump *label8 always
    74 label *label23
-    * jump *label26 equal *tmp5 8
+   75 jump *label26 equal :processDigit:n 8
    76 jump *label25 always
    77 label *label26
    78 op add .S8 .S8 1
    79 set *tmp4 .S8
    80 jump *label8 always
    81 label *label25
-    * jump *label28 equal *tmp5 9
+   82 jump *label28 equal :processDigit:n 9
    83 jump *label27 always
    84 label *label28
    85 op add .S9 .S9 1

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    88 label *label27
    89 set *tmp4 null
    90 label *label8
-    * set *tmp3 *tmp4
    91 label *label7
    92 op idiv :processNumber:n :processNumber:n 10
    93 label *label5
    94 jump *label4 always
    95 label *label6
-    * set *tmp0 null
    96 label *label3
    97 label *label1
    98 op add :i :i 1

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-11 instructions):
 
    20 jump *label9 always
    21 label *label10
    22 op add .S0 .S0 1
-    * set *tmp4 .S0
    23 jump *label8 always
    24 label *label9
    25 jump *label12 equal :processDigit:n 1
    26 jump *label11 always
    27 label *label12
    28 op add .S1 .S1 1
-    * set *tmp4 .S1
    29 jump *label8 always
    30 label *label11
    31 jump *label14 equal :processDigit:n 2
    32 jump *label13 always
    33 label *label14
    34 op add .S2 .S2 1
-    * set *tmp4 .S2
    35 jump *label8 always
    36 label *label13
    37 jump *label16 equal :processDigit:n 3
    38 jump *label15 always
    39 label *label16
    40 op add .S3 .S3 1
-    * set *tmp4 .S3
    41 jump *label8 always
    42 label *label15
    43 jump *label18 equal :processDigit:n 4
    44 jump *label17 always
    45 label *label18
    46 op add .S4 .S4 1
-    * set *tmp4 .S4
    47 jump *label8 always
    48 label *label17
    49 jump *label20 equal :processDigit:n 5
    50 jump *label19 always
    51 label *label20
    52 op add .S5 .S5 1
-    * set *tmp4 .S5
    53 jump *label8 always
    54 label *label19
    55 jump *label22 equal :processDigit:n 6
    56 jump *label21 always
    57 label *label22
    58 op add .S6 .S6 1
-    * set *tmp4 .S6
    59 jump *label8 always
    60 label *label21
    61 jump *label24 equal :processDigit:n 7
    62 jump *label23 always
    63 label *label24
    64 op add .S7 .S7 1
-    * set *tmp4 .S7
    65 jump *label8 always
    66 label *label23
    67 jump *label26 equal :processDigit:n 8
    68 jump *label25 always
    69 label *label26
    70 op add .S8 .S8 1
-    * set *tmp4 .S8
    71 jump *label8 always
    72 label *label25
    73 jump *label28 equal :processDigit:n 9
    74 jump *label27 always
    75 label *label28
    76 op add .S9 .S9 1
-    * set *tmp4 .S9
    77 jump *label8 always
    78 label *label27
-    * set *tmp4 null
    79 label *label8
    80 label *label7
    81 op idiv :processNumber:n :processNumber:n 10

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-1 instructions):
 
    14 label *label4
    15 op greaterThan *tmp1 :processNumber:n 0
    16 jump *label6 equal *tmp1 false
-    * op mod *tmp2 :processNumber:n 10
-    * set :processDigit:n *tmp2
+   17 op mod :processDigit:n :processNumber:n 10
    18 jump *label10 equal :processDigit:n 0
    19 jump *label9 always
    20 label *label10

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-10 instructions):
 
    15 op greaterThan *tmp1 :processNumber:n 0
    16 jump *label6 equal *tmp1 false
    17 op mod :processDigit:n :processNumber:n 10
-    * jump *label10 equal :processDigit:n 0
-    * jump *label9 always
+   18 jump *label9 notEqual :processDigit:n 0
    19 label *label10
    20 op add .S0 .S0 1
    21 jump *label8 always
    22 label *label9
-    * jump *label12 equal :processDigit:n 1
-    * jump *label11 always
+   23 jump *label11 notEqual :processDigit:n 1
    24 label *label12
    25 op add .S1 .S1 1
    26 jump *label8 always
    27 label *label11
-    * jump *label14 equal :processDigit:n 2
-    * jump *label13 always
+   28 jump *label13 notEqual :processDigit:n 2
    29 label *label14
    30 op add .S2 .S2 1
    31 jump *label8 always
    32 label *label13
-    * jump *label16 equal :processDigit:n 3
-    * jump *label15 always
+   33 jump *label15 notEqual :processDigit:n 3
    34 label *label16
    35 op add .S3 .S3 1
    36 jump *label8 always
    37 label *label15
-    * jump *label18 equal :processDigit:n 4
-    * jump *label17 always
+   38 jump *label17 notEqual :processDigit:n 4
    39 label *label18
    40 op add .S4 .S4 1
    41 jump *label8 always
    42 label *label17
-    * jump *label20 equal :processDigit:n 5
-    * jump *label19 always
+   43 jump *label19 notEqual :processDigit:n 5
    44 label *label20
    45 op add .S5 .S5 1
    46 jump *label8 always
    47 label *label19
-    * jump *label22 equal :processDigit:n 6
-    * jump *label21 always
+   48 jump *label21 notEqual :processDigit:n 6
    49 label *label22
    50 op add .S6 .S6 1
    51 jump *label8 always
    52 label *label21
-    * jump *label24 equal :processDigit:n 7
-    * jump *label23 always
+   53 jump *label23 notEqual :processDigit:n 7
    54 label *label24
    55 op add .S7 .S7 1
    56 jump *label8 always
    57 label *label23
-    * jump *label26 equal :processDigit:n 8
-    * jump *label25 always
+   58 jump *label25 notEqual :processDigit:n 8
    59 label *label26
    60 op add .S8 .S8 1
    61 jump *label8 always
    62 label *label25
-    * jump *label28 equal :processDigit:n 9
-    * jump *label27 always
+   63 jump *label27 notEqual :processDigit:n 9
    64 label *label28
    65 op add .S9 .S9 1
    66 jump *label8 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-1 instructions):
 
    12 jump *label2 greaterThan :i 100
    13 set :processNumber:n :i
    14 label *label4
-    * op greaterThan *tmp1 :processNumber:n 0
-    * jump *label6 equal *tmp1 false
+   15 jump *label6 lessThanEq :processNumber:n 0
    16 op mod :processDigit:n :processNumber:n 10
    17 jump *label9 notEqual :processDigit:n 0
    18 label *label10

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-1 instructions):
 
    62 jump *label27 notEqual :processDigit:n 9
    63 label *label28
    64 op add .S9 .S9 1
-    * jump *label8 always
    65 label *label27
    66 label *label8
    67 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set .S9 0
-    * set .S8 .S9
-    * set .S7 .S8
-    * set .S6 .S7
-    * set .S5 .S6
-    * set .S4 .S5
-    * set .S3 .S4
-    * set .S2 .S3
-    * set .S1 .S2
-    * set .S0 .S1
+    1 set .S8 0
+    2 set .S7 .S9
+    3 set .S6 .S8
+    4 set .S5 .S7
+    5 set .S4 .S6
+    6 set .S3 .S5
+    7 set .S2 .S4
+    8 set .S1 .S3
+    9 set .S0 .S2
    10 set :i 1
    11 label *label0
    12 jump *label2 greaterThan :i 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2:
     0 set .S9 0
     1 set .S8 0
-    * set .S7 .S9
-    * set .S6 .S8
-    * set .S5 .S7
-    * set .S4 .S6
-    * set .S3 .S5
-    * set .S2 .S4
-    * set .S1 .S3
-    * set .S0 .S2
+    2 set .S7 0
+    3 set .S6 0
+    4 set .S5 .S9
+    5 set .S4 .S8
+    6 set .S3 .S7
+    7 set .S2 .S6
+    8 set .S1 .S5
+    9 set .S0 .S4
    10 set :i 1
    11 label *label0
    12 jump *label2 greaterThan :i 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3:
 
     1 set .S8 0
     2 set .S7 0
     3 set .S6 0
-    * set .S5 .S9
-    * set .S4 .S8
-    * set .S3 .S7
-    * set .S2 .S6
-    * set .S1 .S5
-    * set .S0 .S4
+    4 set .S5 0
+    5 set .S4 0
+    6 set .S3 0
+    7 set .S2 0
+    8 set .S1 .S9
+    9 set .S0 .S8
    10 set :i 1
    11 label *label0
    12 jump *label2 greaterThan :i 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4:
 
     5 set .S4 0
     6 set .S3 0
     7 set .S2 0
-    * set .S1 .S9
-    * set .S0 .S8
+    8 set .S1 0
+    9 set .S0 0
    10 set :i 1
    11 label *label0
    12 jump *label2 greaterThan :i 100

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
 
     9 set .S0 0
    10 set :i 1
    11 label *label0
-    * jump *label2 greaterThan :i 100
+   12 label *label29
    13 set :processNumber:n :i
    14 label *label4
    15 jump *label6 lessThanEq :processNumber:n 0
+   16 label *label30
    17 op mod :processDigit:n :processNumber:n 10
    18 jump *label9 notEqual :processDigit:n 0
    19 label *label10
 
    68 label *label7
    69 op idiv :processNumber:n :processNumber:n 10
    70 label *label5
-    * jump *label4 always
+   71 jump *label30 greaterThan :processNumber:n 0
    72 label *label6
    73 label *label3
    74 label *label1
    75 op add :i :i 1
-    * jump *label0 always
+   76 jump *label29 lessThanEq :i 100
    77 label *label2
    78 assertequals 11 .S0 "Unexpected value of S0"
    79 assertequals 21 .S1 "Unexpected value of S1"

Modifications by Fast-dispatch case at line 27:5 (-8 instructions):
 
    15 jump *label6 lessThanEq :processNumber:n 0
    16 label *label30
    17 op mod :processDigit:n :processNumber:n 10
-    * jump *label9 notEqual :processDigit:n 0
+   18 multijump :processDigit:n 0 0 (m:*label32)
+   19 multilabel *label43 (m:*label32)
+   20 label *label31
+   21 jump *label8 always
+   22 multilabel *label33 (m:*label32)
    23 label *label10
    24 op add .S0 .S0 1
    25 jump *label8 always
    26 label *label9
-    * jump *label11 notEqual :processDigit:n 1
+   27 multilabel *label34 (m:*label32)
    28 label *label12
    29 op add .S1 .S1 1
    30 jump *label8 always
    31 label *label11
-    * jump *label13 notEqual :processDigit:n 2
+   32 multilabel *label35 (m:*label32)
    33 label *label14
    34 op add .S2 .S2 1
    35 jump *label8 always
    36 label *label13
-    * jump *label15 notEqual :processDigit:n 3
+   37 multilabel *label36 (m:*label32)
    38 label *label16
    39 op add .S3 .S3 1
    40 jump *label8 always
    41 label *label15
-    * jump *label17 notEqual :processDigit:n 4
+   42 multilabel *label37 (m:*label32)
    43 label *label18
    44 op add .S4 .S4 1
    45 jump *label8 always
    46 label *label17
-    * jump *label19 notEqual :processDigit:n 5
+   47 multilabel *label38 (m:*label32)
    48 label *label20
    49 op add .S5 .S5 1
    50 jump *label8 always
    51 label *label19
-    * jump *label21 notEqual :processDigit:n 6
+   52 multilabel *label39 (m:*label32)
    53 label *label22
    54 op add .S6 .S6 1
    55 jump *label8 always
    56 label *label21
-    * jump *label23 notEqual :processDigit:n 7
+   57 multilabel *label40 (m:*label32)
    58 label *label24
    59 op add .S7 .S7 1
    60 jump *label8 always
    61 label *label23
-    * jump *label25 notEqual :processDigit:n 8
+   62 multilabel *label41 (m:*label32)
    63 label *label26
    64 op add .S8 .S8 1
    65 jump *label8 always
    66 label *label25
-    * jump *label27 notEqual :processDigit:n 9
+   67 multilabel *label42 (m:*label32)
    68 label *label28
    69 op add .S9 .S9 1
-    * label *label27
    70 label *label8
    71 label *label7
    72 op idiv :processNumber:n :processNumber:n 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    12 label *label29
    13 set :processNumber:n :i
    14 label *label4
-    * jump *label6 lessThanEq :processNumber:n 0
+   15 jump *label6 lessThanEq :i 0
    16 label *label30
    17 op mod :processDigit:n :processNumber:n 10
    18 multijump :processDigit:n 0 0 (m:*label32)

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
    62 assertequals 20 .S8 "Unexpected value of S8"
    63 assertequals 20 .S9 "Unexpected value of S9"
    64 stop
-    * end

Final code before resolving virtual instructions:

set .S9 0
set .S8 0
set .S7 0
set .S6 0
set .S5 0
set .S4 0
set .S3 0
set .S2 0
set .S1 0
set .S0 0
set :i 1
label *label29
set :processNumber:n :i
jump *label6 lessThanEq :i 0
label *label30
op mod :processDigit:n :processNumber:n 10
multijump :processDigit:n 0 0
multilabel *label43
jump *label8 always
multilabel *label33
op add .S0 .S0 1                        # Origin: 14, keys: 0
jump *label8 always
multilabel *label34
op add .S1 .S1 1                        # Origin: 14, keys: 1
jump *label8 always
multilabel *label35
op add .S2 .S2 1                        # Origin: 14, keys: 2
jump *label8 always
multilabel *label36
op add .S3 .S3 1                        # Origin: 14, keys: 3
jump *label8 always
multilabel *label37
op add .S4 .S4 1                        # Origin: 14, keys: 4
jump *label8 always
multilabel *label38
op add .S5 .S5 1                        # Origin: 14, keys: 5
jump *label8 always
multilabel *label39
op add .S6 .S6 1                        # Origin: 14, keys: 6
jump *label8 always
multilabel *label40
op add .S7 .S7 1                        # Origin: 14, keys: 7
jump *label8 always
multilabel *label41
op add .S8 .S8 1                        # Origin: 14, keys: 8
jump *label8 always
multilabel *label42
op add .S9 .S9 1                        # Origin: 14, keys: 9
label *label8
op idiv :processNumber:n :processNumber:n 10
jump *label30 greaterThan :processNumber:n 0
label *label6
op add :i :i 1
jump *label29 lessThanEq :i 100
assertequals 11 .S0 "Unexpected value of S0"
assertequals 21 .S1 "Unexpected value of S1"
assertequals 20 .S2 "Unexpected value of S2"
assertequals 20 .S3 "Unexpected value of S3"
assertequals 20 .S4 "Unexpected value of S4"
assertequals 20 .S5 "Unexpected value of S5"
assertequals 20 .S6 "Unexpected value of S6"
assertequals 20 .S7 "Unexpected value of S7"
assertequals 20 .S8 "Unexpected value of S8"
assertequals 20 .S9 "Unexpected value of S9"
stop
