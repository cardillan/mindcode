   602 instructions before optimizations.
    38 instructions eliminated by Temp Variables Elimination.
    86 instructions eliminated by Dead Code Elimination (6 iterations).
     6 instructions eliminated by Jump Normalization (4 iterations).
    42 instructions eliminated by Jump Optimization (4 iterations).
    30 instructions eliminated by Single Step Elimination (3 passes, 7 iterations).
     1 instructions modified by Expression Optimization (3 iterations).
     2 instructions eliminated by If Expression Optimization (3 iterations).
     3 instructions eliminated by Data Flow Optimization (4 passes, 17 iterations).
    18 instructions added by Loop Optimization (3 iterations).
     9 loops improved by Loop Optimization.
     5 instructions eliminated by Jump Straightening (4 iterations).
     8 instructions updated by JumpThreading.
     3 instructions eliminated by Unreachable Code Elimination.
    50 instructions eliminated by Print Merging.
   355 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 596):
  * Replicate loop condition at line 43:1                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
    Replicate loop condition at line 51:1                        cost     2, benefit       25.0, efficiency       12.5
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
    Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3
    Replicate loop condition at line 304:1                       cost     2, benefit       25.0, efficiency       12.5
    Replicate loop condition at line 314:5                       cost     1, benefit       12.5, efficiency       12.5

Pass 1: speed optimization selection (cost limit 595):
    Replicate loop condition at line 51:1                        cost     2, benefit       25.0, efficiency       12.5
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
    Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3
    Replicate loop condition at line 304:1                       cost     2, benefit       25.0, efficiency       12.5
  * Replicate loop condition at line 314:5                       cost     1, benefit       12.5, efficiency       12.5 (+1 instructions)

Pass 1: speed optimization selection (cost limit 594):
  * Replicate loop condition at line 51:1                        cost     2, benefit       25.0, efficiency       12.5 (+2 instructions)
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
    Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3
    Replicate loop condition at line 304:1                       cost     2, benefit       25.0, efficiency       12.5

Pass 1: speed optimization selection (cost limit 592):
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
    Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3
  * Replicate loop condition at line 304:1                       cost     2, benefit       25.0, efficiency       12.5 (+1 instructions)

Pass 1: speed optimization selection (cost limit 591):
    Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3
  * Replicate loop condition at line 129:1                       cost     3, benefit       25.0, efficiency        8.3 (+3 instructions)

Pass 1: speed optimization selection (cost limit 588):
  * Replicate loop condition at line 102:5                       cost     4, benefit       12.5, efficiency        3.1 (+4 instructions)
    Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3

Pass 1: speed optimization selection (cost limit 584):
  * Replicate loop condition at line 110:9                       cost     5, benefit        6.3, efficiency        1.3 (+5 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-52 instructions):
 
    32 set *tmp10 @unit
    33 set :fn0:first_unit *tmp10
    34 jump *label9 always
-    * set *tmp9 null
    35 jump *label11 always
    36 label *label10
-    * set *tmp9 null
    37 label *label11
    38 print "[salmon]No unit of type "
    39 print UNIT
 
    47 sensor *tmp11 @unit @controller
    48 op equal *tmp12 *tmp11 @this
    49 jump *label15 equal *tmp12 false
-    * set *tmp7 null
    50 jump *label6 always
-    * set *tmp13 null
    51 jump *label16 always
    52 label *label15
-    * set *tmp13 null
    53 label *label16
    54 ubind UNIT
    55 print "[gold]Looking for old unit..."
 
    70 print UNIT
    71 print " "
    72 print "found. 2"
-    * set *tmp20 null
    73 jump *label22 always
    74 label *label21
    75 sensor *tmp21 @unit @controlled
 
    86 jump *label17 always
    87 set *tmp23 null
    88 label *label24
-    * set *tmp20 *tmp23
    89 label *label22
    90 printflush message1
    91 label *label19
 
    93 label *label20
    94 set *tmp18 null
    95 label *label17
-    * set *tmp7 *tmp18
    96 label *label6
    97 label *label4
    98 jump *label3 always
 
   121 jump *label31 equal *tmp32 false
   122 set .DROP_TARGET .CONTAINER
   123 set .CONTAINER :block
-    * set *tmp33 .CONTAINER
   124 jump *label32 always
   125 label *label31
-    * set *tmp33 null
   126 label *label32
   127 label *label29
   128 jump *label28 always
 
   131 jump *label33 equal *tmp34 false
   132 print "[salmon]No destination."
   133 print "\n"
-    * set *tmp35 "[salmon]No destination."
   134 jump *label34 always
   135 label *label33
   136 op notEqual *tmp36 .DROP_TARGET null
 
   153 jump *label27 always
   154 set *tmp40 null
   155 label *label36
-    * set *tmp35 *tmp40
   156 label *label34
   157 printflush message1
   158 label *label26
 
   167 printflush message1
   168 ulocate building core false @copper .CORE_X .CORE_Y *tmp44 *tmp43
   169 set .CORE *tmp43
-    * set *tmp42 .CORE
   170 jump *label38 always
   171 label *label37
   172 print "[gold]Locating vault #"
 
   224 label *label42
   225 set *tmp52 null
   226 label *label43
-    * set *tmp42 *tmp52
   227 label *label38
   228 op equal *tmp65 .CORE null
   229 jump *label49 equal *tmp65 false
   230 end
-    * set *tmp66 null
   231 jump *label50 always
   232 label *label49
-    * set *tmp66 null
   233 label *label50
   234 set .SORTER sorter1
   235 sensor *tmp67 .SORTER @type
 
   245 jump *label54 equal *tmp71 false
   246 print "Block found: "
   247 print .SORTER
-    * set *tmp72 .SORTER
   248 jump *label55 always
   249 label *label54
-    * set *tmp72 null
   250 label *label55
   251 printflush message1
   252 set .SORTER sorter1
 
   281 set *tmp84 "[] from vault #"
   282 label *label59
   283 set .DIRECTION *tmp84
-    * set *tmp75 .DIRECTION
   284 jump *label57 always
   285 label *label56
   286 op greaterThan *tmp85 LINK_ID 0
 
   311 set *tmp97 "[] to vault #"
   312 label *label61
   313 set .DIRECTION *tmp97
-    * set *tmp75 .DIRECTION
   314 label *label57
   315 op equal *tmp98 LINK_ID 0
   316 jump *label62 equal *tmp98 false
 
   333 set .DROP_TARGET .CORE
   334 set .DROP_X .CORE_X
   335 set .DROP_Y .CORE_Y
-    * set *tmp105 .DROP_Y
   336 jump *label65 always
   337 label *label64
   338 sensor *tmp106 .DROP_TARGET @x
   339 set .DROP_X *tmp106
   340 sensor *tmp107 .DROP_TARGET @y
   341 set .DROP_Y *tmp107
-    * set *tmp105 .DROP_Y
   342 label *label65
   343 set .LAST_ITEM @mono
   344 set :iter 0
 
   364 print UNIT
   365 print " "
   366 print "found. 2"
-    * set *tmp117 null
   367 jump *label76 always
   368 label *label75
   369 sensor *tmp118 @unit @controlled
 
   376 set *tmp120 null
   377 jump *label78 always
   378 label *label77
-    * set *tmp115 null
   379 jump *label71 always
   380 set *tmp120 null
   381 label *label78
-    * set *tmp117 *tmp120
   382 label *label76
   383 printflush message1
   384 label *label73
   385 jump *label72 always
   386 label *label74
-    * set *tmp115 null
   387 label *label71
   388 ucontrol flag 1
   389 set :state 1
-    * set *tmp114 :state
   390 jump *label70 always
   391 label *label69
-    * set *tmp114 null
   392 label *label70
   393 sensor *tmp121 .SORTER @config
   394 set .ITEM *tmp121
 
   406 label *label83
   407 set .LAST_ITEM .ITEM
   408 set :state 1
-    * set *tmp123 :state
   409 jump *label80 always
   410 label *label79
-    * set *tmp123 null
   411 label *label80
   412 set :show_state 0
   413 op equal *tmp126 :state 1
 
   440 label *label89
   441 set *tmp130 *tmp133
   442 label *label87
-    * set *tmp127 *tmp130
   443 jump *label85 always
   444 label *label84
-    * set *tmp127 null
   445 label *label85
   446 op equal *tmp136 :state 2
   447 jump *label92 equal *tmp136 false
 
   470 set :show_state 2
   471 set *tmp139 :show_state
   472 label *label95
-    * set *tmp137 *tmp139
   473 jump *label93 always
   474 label *label92
-    * set *tmp137 null
   475 label *label93
   476 op equal *tmp146 :state 3
   477 jump *label98 equal *tmp146 false
 
   501 set :show_state 3
   502 set *tmp149 :show_state
   503 label *label101
-    * set *tmp147 *tmp149
   504 jump *label99 always
   505 label *label98
-    * set *tmp147 null
   506 label *label99
   507 op greaterThan *tmp156 :iter 3
   508 jump *label104 equal *tmp156 false
 
   524 print .LOCAL_MARGIN
   525 print "["
   526 print "])"
-    * set *tmp160 null
   527 jump *label107 always
   528 label *label106
-    * set *tmp160 null
   529 label *label107
   530 jump *label108 equal .SHOW_REMOTE_LEVEL false
   531 sensor *tmp162 .CORE .ITEM
 
   545 label *label110
   546 set *tmp164 null
   547 label *label111
-    * set *tmp161 *tmp164
   548 jump *label109 always
   549 label *label108
-    * set *tmp161 null
   550 label *label109
   551 sensor *tmp165 @unit @totalItems
   552 print .MSG
 
   592 label *label117
   593 set *tmp168 *tmp177
   594 label *label115
-    * set *tmp166 *tmp168
   595 jump *label113 always
   596 label *label112
-    * set *tmp166 null
   597 label *label113
   598 op floor *tmp185 :loop_time
   599 print "[lightgray]Loop time: "
 
   605 op equal *tmp187 *tmp186 0
   606 jump *label118 equal *tmp187 false
   607 jump *label68 always
-    * set *tmp188 null
   608 jump *label119 always
   609 label *label118
-    * set *tmp188 null
   610 label *label119
   611 sensor *tmp189 .SRC @dead
   612 op notEqual *tmp190 *tmp189 0
   613 jump *label120 equal *tmp190 false
   614 jump *label68 always
-    * set *tmp191 null
   615 jump *label121 always
   616 label *label120
-    * set *tmp191 null
   617 label *label121
   618 sensor *tmp192 .DST @dead
   619 op notEqual *tmp193 *tmp192 0
   620 jump *label122 equal *tmp193 false
   621 jump *label68 always
-    * set *tmp194 null
   622 jump *label123 always
   623 label *label122
-    * set *tmp194 null
   624 label *label123
   625 sensor *tmp195 .SORTER @dead
   626 op notEqual *tmp196 *tmp195 0
 
   631 label *label124
   632 set *tmp197 null
   633 label *label125
-    * set *tmp157 *tmp197
   634 jump *label105 always
   635 label *label104
   636 op add :iter :iter 1
-    * set *tmp157 :iter
   637 label *label105
   638 op sub *tmp198 @time :start
   639 set :loop_time *tmp198
 
   677 label *label132
   678 jump *label131 always
   679 label *label133
-    * set *tmp209 null
   680 jump *label130 always
   681 label *label129
-    * set *tmp209 null
   682 label *label130
   683 end

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-22 instructions):
 
    79 print UNIT
    80 print "."
    81 print ".."
-    * set *tmp23 null
    82 jump *label24 always
    83 label *label23
-    * set *tmp18 null
    84 jump *label17 always
-    * set *tmp23 null
    85 label *label24
    86 label *label22
    87 printflush message1
    88 label *label19
    89 jump *label18 always
    90 label *label20
-    * set *tmp18 null
    91 label *label17
    92 label *label6
    93 label *label4
 
   143 print "\"
   144 print "n"
   145 print "[salmon]Item dump must be a container or a vault!"
-    * set *tmp40 null
   146 jump *label36 always
   147 label *label35
   148 jump *label27 always
-    * set *tmp40 null
   149 label *label36
   150 label *label34
   151 printflush message1
 
   213 label *label47
   214 set *tmp64 null
   215 label *label48
-    * set *tmp52 *tmp64
   216 jump *label43 always
   217 label *label42
-    * set *tmp52 null
   218 label *label43
   219 label *label38
   220 op equal *tmp65 .CORE null
 
   365 print UNIT
   366 print "."
   367 print ".."
-    * set *tmp120 null
   368 jump *label78 always
   369 label *label77
   370 jump *label71 always
-    * set *tmp120 null
   371 label *label78
   372 label *label76
   373 printflush message1
 
   406 op equal *tmp129 *tmp128 .ITEM
   407 jump *label86 equal *tmp129 false
   408 set :state 3
-    * set *tmp130 :state
   409 jump *label87 always
   410 label *label86
   411 sensor *tmp131 @unit @totalItems
 
   427 label *label91
   428 set *tmp133 *tmp135
   429 label *label89
-    * set *tmp130 *tmp133
   430 label *label87
   431 jump *label85 always
   432 label *label84
 
   450 set .MSG "\nLoading items: [green]"
   451 set *tmp145 .MSG
   452 label *label97
-    * set *tmp139 *tmp145
   453 jump *label95 always
   454 label *label94
   455 ucontrol approach .SRC_X .SRC_Y 6
   456 set .MSG "\nGoing to source: [green]"
   457 set :show_state 2
-    * set *tmp139 :show_state
   458 label *label95
   459 jump *label93 always
   460 label *label92
 
   479 set .MSG "\nDropping items: [green]"
   480 set *tmp155 .MSG
   481 label *label103
-    * set *tmp149 *tmp155
   482 jump *label101 always
   483 label *label100
   484 ucontrol approach .DST_X .DST_Y 6
   485 set .MSG "\nGoing to destination: [green]"
   486 set :show_state 3
-    * set *tmp149 :show_state
   487 label *label101
   488 jump *label99 always
   489 label *label98
 
   524 print .REMOTE_MARGIN
   525 print "["
   526 print "])"
-    * set *tmp164 null
   527 jump *label111 always
   528 label *label110
-    * set *tmp164 null
   529 label *label111
   530 jump *label109 always
   531 label *label108
 
   550 print " "
   551 print "sec[]"
   552 print "\n"
-    * set *tmp168 null
   553 jump *label115 always
   554 label *label114
   555 op equal *tmp176 :show_state 3
 
   571 label *label116
   572 set *tmp177 null
   573 label *label117
-    * set *tmp168 *tmp177
   574 label *label115
   575 jump *label113 always
   576 label *label112
 
   606 op notEqual *tmp196 *tmp195 0
   607 jump *label124 equal *tmp196 false
   608 jump *label68 always
-    * set *tmp197 null
   609 jump *label125 always
   610 label *label124
-    * set *tmp197 null
   611 label *label125
   612 jump *label105 always
   613 label *label104

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   208 op notEqual *tmp63 :b_type @vault
   209 jump *label47 equal *tmp63 false
   210 set .CORE null
-    * set *tmp64 .CORE
   211 jump *label48 always
   212 label *label47
-    * set *tmp64 null
   213 label *label48
   214 jump *label43 always
   215 label *label42
 
   410 op equal *tmp132 *tmp131 0
   411 jump *label88 equal *tmp132 false
   412 set :state 2
-    * set *tmp133 :state
   413 jump *label89 always
   414 label *label88
   415 set .MSG "\nUnloading previous items: [green]"
 
   422 label *label90
   423 set *tmp135 null
   424 label *label91
-    * set *tmp133 *tmp135
   425 label *label89
   426 label *label87
   427 jump *label85 always
 
   440 op greaterThanEq *tmp144 *tmp143 .UNIT_CAPACITY
   441 jump *label96 equal *tmp144 false
   442 set :state 3
-    * set *tmp145 :state
   443 jump *label97 always
   444 label *label96
   445 set .MSG "\nLoading items: [green]"
-    * set *tmp145 .MSG
   446 label *label97
   447 jump *label95 always
   448 label *label94
 
   467 jump *label102 equal *tmp154 false
   468 set :state 2
   469 ucontrol approach .SRC_X .SRC_Y 6
-    * set *tmp155 null
   470 jump *label103 always
   471 label *label102
   472 set .MSG "\nDropping items: [green]"
-    * set *tmp155 .MSG
   473 label *label103
   474 jump *label101 always
   475 label *label100
 
   558 print " "
   559 print "sec[]"
   560 print "\n"
-    * set *tmp177 null
   561 jump *label117 always
   562 label *label116
-    * set *tmp177 null
   563 label *label117
   564 label *label115
   565 jump *label113 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   417 ucontrol within .DROP_X .DROP_Y 8 *tmp134
   418 jump *label90 equal *tmp134 false
   419 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * set *tmp135 null
   420 jump *label91 always
   421 label *label90
-    * set *tmp135 null
   422 label *label91
   423 label *label89
   424 label *label87

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-38 instructions):
 
     1 set LINK_ID 0
     2 set LOCAL_LIMIT 100
     3 set REMOTE_LIMIT 100
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+    4 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+    5 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
 
    27 ubind UNIT
    28 op notEqual *tmp8 @unit null
    29 jump *label10 equal *tmp8 false
-    * set *tmp10 @unit
-    * set :fn0:first_unit *tmp10
+   30 set :fn0:first_unit @unit
    31 jump *label9 always
    32 jump *label11 always
    33 label *label10
 
    90 label *label4
    91 jump *label3 always
    92 label *label5
-    * sensor *tmp24 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp24
+   93 sensor .UNIT_CAPACITY @unit @itemCapacity
    94 sensor *tmp25 @unit @speed
-    * op div *tmp26 *tmp25 10
-    * set .SPEED_SEC *tmp26
+   95 op div .SPEED_SEC *tmp25 10
    96 ucontrol flag 1
    97 label *label25
    98 jump *label27 equal true false
    99 set .CONTAINER null
   100 set .DROP_TARGET null
-    * set *tmp27 @links
-    * set :n *tmp27
+  101 set :n @links
   102 label *label28
   103 op greaterThan *tmp28 :n 0
   104 jump *label30 equal *tmp28 false
-    * op sub *tmp29 :n 1
-    * set :n *tmp29
-    * getlink *tmp30 :n
-    * set :block *tmp30
+  105 op sub :n :n 1
+  106 getlink :block :n
   107 sensor *tmp31 :block @itemCapacity
   108 op greaterThan *tmp32 *tmp31 0
   109 jump *label31 equal *tmp32 false
 
   151 jump *label37 equal *tmp41 false
   152 print "[gold]Locating core..."
   153 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp44 *tmp43
-    * set .CORE *tmp43
+  154 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   155 jump *label38 always
   156 label *label37
   157 print "[gold]Locating vault #"
 
   159 print "."
   160 print ".."
   161 printflush message1
-    * op add *tmp45 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp45
+  162 op add .QUERY_FLAG 99999900 LINK_ID
   163 set :flag .QUERY_FLAG
   164 ucontrol flag :flag
   165 label *label39
 
   169 op land *tmp49 *tmp46 *tmp48
   170 jump *label41 equal *tmp49 false
   171 ucontrol stop
-    * sensor *tmp50 @unit @flag
-    * set :flag *tmp50
+  172 sensor :flag @unit @flag
   173 label *label40
   174 jump *label39 always
   175 label *label41
   176 op notEqual *tmp51 :flag .QUERY_FLAG
   177 jump *label42 equal *tmp51 false
-    * op idiv *tmp53 :flag 100
-    * set :position *tmp53
-    * op mod *tmp54 :position @mapw
-    * set .CORE_X *tmp54
-    * op idiv *tmp55 :position @mapw
-    * set .CORE_Y *tmp55
+  178 op idiv :position :flag 100
+  179 op mod .CORE_X :position @mapw
+  180 op idiv .CORE_Y :position @mapw
   181 label *label44
   182 ucontrol within .CORE_X .CORE_Y 8 *tmp56
   183 op equal *tmp57 *tmp56 false
 
   189 label *label45
   190 jump *label44 always
   191 label *label46
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp61 *tmp62
-    * set .CORE *tmp61
+  192 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   193 op notEqual *tmp63 :b_type @vault
   194 jump *label47 equal *tmp63 false
   195 set .CORE null
 
   207 label *label49
   208 label *label50
   209 set .SORTER sorter1
-    * sensor *tmp67 .SORTER @type
-    * set :sorter_type *tmp67
+  210 sensor :sorter_type .SORTER @type
   211 label *label51
   212 op notEqual *tmp68 :sorter_type @sorter
   213 op notEqual *tmp69 :sorter_type @inverted-sorter
 
   224 label *label55
   225 printflush message1
   226 set .SORTER sorter1
-    * sensor *tmp73 .SORTER @type
-    * set :sorter_type *tmp73
+  227 sensor :sorter_type .SORTER @type
   228 label *label52
   229 jump *label51 always
   230 label *label53
 
   233 set .SHOW_REMOTE_LEVEL true
   234 set .SRC .CORE
   235 set .DST .CONTAINER
-    * sensor *tmp76 .SRC @itemCapacity
-    * set :src_capacity *tmp76
-    * sensor *tmp77 .DST @itemCapacity
-    * set :dst_capacity *tmp77
+  236 sensor :src_capacity .SRC @itemCapacity
+  237 sensor :dst_capacity .DST @itemCapacity
   238 op sub *tmp78 100 .EFF_REMOTE_LIMIT
   239 op mul *tmp79 :src_capacity *tmp78
-    * op idiv *tmp80 *tmp79 100
-    * set .LOAD_LEVEL *tmp80
+  240 op idiv .LOAD_LEVEL *tmp79 100
   241 op mul *tmp81 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp82 *tmp81 100
-    * set .DROP_LEVEL *tmp82
+  242 op idiv .DROP_LEVEL *tmp81 100
   243 set .LOCAL_MARGIN .DROP_LEVEL
   244 set .REMOTE_MARGIN .LOAD_LEVEL
   245 op equal *tmp83 LINK_ID 0
 
   252 set .DIRECTION *tmp84
   253 jump *label57 always
   254 label *label56
-    * op greaterThan *tmp85 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp85
+  255 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   256 set .SRC .CONTAINER
   257 set .DST .CORE
-    * sensor *tmp86 .SRC @itemCapacity
-    * set :src_capacity *tmp86
-    * sensor *tmp87 .DST @itemCapacity
-    * set :dst_capacity *tmp87
+  258 sensor :src_capacity .SRC @itemCapacity
+  259 sensor :dst_capacity .DST @itemCapacity
   260 op sub *tmp88 100 .EFF_LOCAL_LIMIT
   261 op mul *tmp89 :src_capacity *tmp88
-    * op idiv *tmp90 *tmp89 100
-    * set .LOAD_LEVEL *tmp90
+  262 op idiv .LOAD_LEVEL *tmp89 100
   263 op mul *tmp91 :dst_capacity .EFF_REMOTE_LIMIT
   264 op idiv *tmp92 *tmp91 100
   265 op equal *tmp93 LINK_ID 0
   266 op mul *tmp94 *tmp93 .UNIT_CAPACITY
-    * op add *tmp95 *tmp92 *tmp94
-    * set .DROP_LEVEL *tmp95
+  267 op add .DROP_LEVEL *tmp92 *tmp94
   268 set .LOCAL_MARGIN .LOAD_LEVEL
   269 set .REMOTE_MARGIN .DROP_LEVEL
   270 op equal *tmp96 LINK_ID 0
 
   284 set *tmp99 LINK_ID
   285 label *label63
   286 set .LINK_TXT *tmp99
-    * sensor *tmp100 .SRC @x
-    * set .SRC_X *tmp100
-    * sensor *tmp101 .SRC @y
-    * set .SRC_Y *tmp101
-    * sensor *tmp102 .DST @x
-    * set .DST_X *tmp102
-    * sensor *tmp103 .DST @y
-    * set .DST_Y *tmp103
+  287 sensor .SRC_X .SRC @x
+  288 sensor .SRC_Y .SRC @y
+  289 sensor .DST_X .DST @x
+  290 sensor .DST_Y .DST @y
   291 op equal *tmp104 .DROP_TARGET null
   292 jump *label64 equal *tmp104 false
   293 set .DROP_TARGET .CORE
 
   295 set .DROP_Y .CORE_Y
   296 jump *label65 always
   297 label *label64
-    * sensor *tmp106 .DROP_TARGET @x
-    * set .DROP_X *tmp106
-    * sensor *tmp107 .DROP_TARGET @y
-    * set .DROP_Y *tmp107
+  298 sensor .DROP_X .DROP_TARGET @x
+  299 sensor .DROP_Y .DROP_TARGET @y
   300 label *label65
   301 set .LAST_ITEM @mono
   302 set :iter 0
 
   305 ucontrol stop
   306 label *label66
   307 jump *label68 equal true false
-    * set *tmp108 @time
-    * set :start *tmp108
+  308 set :start @time
   309 sensor *tmp109 @unit @dead
   310 op strictEqual *tmp110 *tmp109 0
   311 sensor *tmp111 @unit @controller
 
   345 jump *label70 always
   346 label *label69
   347 label *label70
-    * sensor *tmp121 .SORTER @config
-    * set .ITEM *tmp121
+  348 sensor .ITEM .SORTER @config
   349 op notEqual *tmp122 .ITEM .LAST_ITEM
   350 jump *label79 equal *tmp122 false
   351 label *label81
 
   353 jump *label83 equal *tmp124 false
   354 print "[salmon]No item type selected for transport."
   355 printflush message1
-    * sensor *tmp125 .SORTER @config
-    * set .ITEM *tmp125
+  356 sensor .ITEM .SORTER @config
   357 label *label82
   358 jump *label81 always
   359 label *label83
 
   396 jump *label94 equal *tmp138 false
   397 sensor *tmp140 .SRC .ITEM
   398 op sub *tmp141 *tmp140 .LOAD_LEVEL
-    * op max *tmp142 *tmp141 0
-    * set :max_load *tmp142
+  399 op max :max_load *tmp141 0
   400 ucontrol itemTake .SRC .ITEM :max_load
   401 sensor *tmp143 @unit @totalItems
   402 op greaterThanEq *tmp144 *tmp143 .UNIT_CAPACITY
 
   421 jump *label100 equal *tmp148 false
   422 sensor *tmp150 .DST .ITEM
   423 op sub *tmp151 .DROP_LEVEL *tmp150
-    * op max *tmp152 *tmp151 0
-    * set :max_drop *tmp152
+  424 op max :max_drop *tmp151 0
   425 ucontrol itemDrop .DST :max_drop
   426 sensor *tmp153 @unit @totalItems
   427 op lessThanEq *tmp154 *tmp153 0
 
   564 label *label104
   565 op add :iter :iter 1
   566 label *label105
-    * op sub *tmp198 @time :start
-    * set :loop_time *tmp198
+  567 op sub :loop_time @time :start
   568 label *label67
   569 jump *label66 always
   570 label *label68

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-6 instructions):
 
    23 jump *label5 equal *tmp5 false
    24 set :fn0:first_unit null
    25 label *label7
-    * jump *label9 equal true false
    26 ubind UNIT
    27 op notEqual *tmp8 @unit null
    28 jump *label10 equal *tmp8 false
 
    58 jump *label12 notEqual *tmp17 false
    59 label *label14
    60 label *label18
-    * jump *label20 equal true false
    61 ubind UNIT
    62 op equal *tmp19 @unit null
    63 jump *label21 equal *tmp19 false
 
    93 op div .SPEED_SEC *tmp25 10
    94 ucontrol flag 1
    95 label *label25
-    * jump *label27 equal true false
    96 set .CONTAINER null
    97 set .DROP_TARGET null
    98 set :n @links
 
   301 set :state 1
   302 ucontrol stop
   303 label *label66
-    * jump *label68 equal true false
   304 set :start @time
   305 sensor *tmp109 @unit @dead
   306 op strictEqual *tmp110 *tmp109 0
 
   309 op lessThanEq *tmp113 *tmp110 *tmp112
   310 jump *label69 equal *tmp113 false
   311 label *label72
-    * jump *label74 equal true false
   312 ubind UNIT
   313 op equal *tmp116 @unit null
   314 jump *label75 equal *tmp116 false
 
   483 print *tmp165
   484 print "[]"
   485 print "\n"
-    * jump *label112 equal true false
   486 op equal *tmp167 :show_state 2
   487 jump *label114 equal *tmp167 false
   488 sensor *tmp169 @unit @x

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-42 instructions):
 
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
-    * op equal *tmp3 *tmp2 false
-    * jump *label2 equal *tmp3 false
+    9 jump *label2 notEqual *tmp2 false
    10 print "Unit Transport - Single"
    11 print "\n"
    12 print "Activate switch to start."
 
    18 label *label3
    19 sensor *tmp4 @unit @dead
    20 op strictEqual *tmp6 *tmp4 0
-    * op equal *tmp5 *tmp6 false
-    * jump *label5 equal *tmp5 false
+   21 jump *label5 notEqual *tmp6 false
    22 set :fn0:first_unit null
    23 label *label7
    24 ubind UNIT
-    * op notEqual *tmp8 @unit null
-    * jump *label10 equal *tmp8 false
+   25 jump *label10 equal @unit null
    26 set :fn0:first_unit @unit
    27 jump *label9 always
    28 jump *label11 always
 
    38 label *label9
    39 label *label12
    40 sensor *tmp11 @unit @controller
-    * op equal *tmp12 *tmp11 @this
-    * jump *label15 equal *tmp12 false
+   41 jump *label15 notEqual *tmp11 @this
    42 jump *label6 always
    43 jump *label16 always
    44 label *label15
 
    55 label *label14
    56 label *label18
    57 ubind UNIT
-    * op equal *tmp19 @unit null
-    * jump *label21 equal *tmp19 false
+   58 jump *label21 notEqual @unit null
    59 print "[salmon]No unit of type "
    60 print UNIT
    61 print " "
 
    63 jump *label22 always
    64 label *label21
    65 sensor *tmp21 @unit @controlled
-    * op notEqual *tmp22 *tmp21 0
-    * jump *label23 equal *tmp22 false
+   66 jump *label23 equal *tmp21 0
    67 print "[salmon]Looking for a free "
    68 print UNIT
    69 print "."
 
    91 set .DROP_TARGET null
    92 set :n @links
    93 label *label28
-    * op greaterThan *tmp28 :n 0
-    * jump *label30 equal *tmp28 false
+   94 jump *label30 lessThanEq :n 0
    95 op sub :n :n 1
    96 getlink :block :n
    97 sensor *tmp31 :block @itemCapacity
-    * op greaterThan *tmp32 *tmp31 0
-    * jump *label31 equal *tmp32 false
+   98 jump *label31 lessThanEq *tmp31 0
    99 set .DROP_TARGET .CONTAINER
   100 set .CONTAINER :block
   101 jump *label32 always
 
   104 label *label29
   105 jump *label28 always
   106 label *label30
-    * op equal *tmp34 .CONTAINER null
-    * jump *label33 equal *tmp34 false
+  107 jump *label33 notEqual .CONTAINER null
   108 print "[salmon]No destination."
   109 print "\n"
   110 jump *label34 always
 
   135 set .CORE_Y null
   136 set .CORE_X .CORE_Y
   137 set .CORE .CORE_X
-    * op equal *tmp41 LINK_ID 0
-    * jump *label37 equal *tmp41 false
+  138 jump *label37 notEqual LINK_ID 0
   139 print "[gold]Locating core..."
   140 printflush message1
   141 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
 
   160 label *label40
   161 jump *label39 always
   162 label *label41
-    * op notEqual *tmp51 :flag .QUERY_FLAG
-    * jump *label42 equal *tmp51 false
+  163 jump *label42 equal :flag .QUERY_FLAG
   164 op idiv :position :flag 100
   165 op mod .CORE_X :position @mapw
   166 op idiv .CORE_Y :position @mapw
 
   176 jump *label44 always
   177 label *label46
   178 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
-    * op notEqual *tmp63 :b_type @vault
-    * jump *label47 equal *tmp63 false
+  179 jump *label47 equal :b_type @vault
   180 set .CORE null
   181 jump *label48 always
   182 label *label47
 
   185 label *label42
   186 label *label43
   187 label *label38
-    * op equal *tmp65 .CORE null
-    * jump *label49 equal *tmp65 false
+  188 jump *label49 notEqual .CORE null
   189 end
   190 jump *label50 always
   191 label *label49
 
   199 jump *label53 equal *tmp70 false
   200 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   201 print "\n"
-    * op notEqual *tmp71 .SORTER null
-    * jump *label54 equal *tmp71 false
+  202 jump *label54 equal .SORTER null
   203 print "Block found: "
   204 print .SORTER
   205 jump *label55 always
 
   211 label *label52
   212 jump *label51 always
   213 label *label53
-    * op equal *tmp74 :sorter_type @sorter
-    * jump *label56 equal *tmp74 false
+  214 jump *label56 notEqual :sorter_type @sorter
   215 set .SHOW_REMOTE_LEVEL true
   216 set .SRC .CORE
   217 set .DST .CONTAINER
 
   224 op idiv .DROP_LEVEL *tmp81 100
   225 set .LOCAL_MARGIN .DROP_LEVEL
   226 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op equal *tmp83 LINK_ID 0
-    * jump *label58 equal *tmp83 false
+  227 jump *label58 notEqual LINK_ID 0
   228 set *tmp84 "[] from core"
   229 jump *label59 always
   230 label *label58
 
   248 op add .DROP_LEVEL *tmp92 *tmp94
   249 set .LOCAL_MARGIN .LOAD_LEVEL
   250 set .REMOTE_MARGIN .DROP_LEVEL
-    * op equal *tmp96 LINK_ID 0
-    * jump *label60 equal *tmp96 false
+  251 jump *label60 notEqual LINK_ID 0
   252 set *tmp97 "[] to core"
   253 jump *label61 always
   254 label *label60
 
   256 label *label61
   257 set .DIRECTION *tmp97
   258 label *label57
-    * op equal *tmp98 LINK_ID 0
-    * jump *label62 equal *tmp98 false
+  259 jump *label62 notEqual LINK_ID 0
   260 set *tmp99 ""
   261 jump *label63 always
   262 label *label62
 
   267 sensor .SRC_Y .SRC @y
   268 sensor .DST_X .DST @x
   269 sensor .DST_Y .DST @y
-    * op equal *tmp104 .DROP_TARGET null
-    * jump *label64 equal *tmp104 false
+  270 jump *label64 notEqual .DROP_TARGET null
   271 set .DROP_TARGET .CORE
   272 set .DROP_X .CORE_X
   273 set .DROP_Y .CORE_Y
 
   287 op strictEqual *tmp110 *tmp109 0
   288 sensor *tmp111 @unit @controller
   289 op notEqual *tmp112 *tmp111 @this
-    * op lessThanEq *tmp113 *tmp110 *tmp112
-    * jump *label69 equal *tmp113 false
+  290 jump *label69 greaterThan *tmp110 *tmp112
   291 label *label72
   292 ubind UNIT
-    * op equal *tmp116 @unit null
-    * jump *label75 equal *tmp116 false
+  293 jump *label75 notEqual @unit null
   294 print "[salmon]No unit of type "
   295 print UNIT
   296 print " "
 
   298 jump *label76 always
   299 label *label75
   300 sensor *tmp118 @unit @controlled
-    * op notEqual *tmp119 *tmp118 0
-    * jump *label77 equal *tmp119 false
+  301 jump *label77 equal *tmp118 0
   302 print "[salmon]Looking for a free "
   303 print UNIT
   304 print "."
 
   319 label *label69
   320 label *label70
   321 sensor .ITEM .SORTER @config
-    * op notEqual *tmp122 .ITEM .LAST_ITEM
-    * jump *label79 equal *tmp122 false
+  322 jump *label79 equal .ITEM .LAST_ITEM
   323 label *label81
-    * op equal *tmp124 .ITEM null
-    * jump *label83 equal *tmp124 false
+  324 jump *label83 notEqual .ITEM null
   325 print "[salmon]No item type selected for transport."
   326 printflush message1
   327 sensor .ITEM .SORTER @config
 
   334 label *label79
   335 label *label80
   336 set :show_state 0
-    * op equal *tmp126 :state 1
-    * jump *label84 equal *tmp126 false
+  337 jump *label84 notEqual :state 1
   338 sensor *tmp128 @unit @firstItem
-    * op equal *tmp129 *tmp128 .ITEM
-    * jump *label86 equal *tmp129 false
+  339 jump *label86 notEqual *tmp128 .ITEM
   340 set :state 3
   341 jump *label87 always
   342 label *label86
   343 sensor *tmp131 @unit @totalItems
-    * op equal *tmp132 *tmp131 0
-    * jump *label88 equal *tmp132 false
+  344 jump *label88 notEqual *tmp131 0
   345 set :state 2
   346 jump *label89 always
   347 label *label88
 
   358 jump *label85 always
   359 label *label84
   360 label *label85
-    * op equal *tmp136 :state 2
-    * jump *label92 equal *tmp136 false
+  361 jump *label92 notEqual :state 2
   362 ucontrol within .SRC_X .SRC_Y 8 *tmp138
   363 jump *label94 equal *tmp138 false
   364 sensor *tmp140 .SRC .ITEM
 
   366 op max :max_load *tmp141 0
   367 ucontrol itemTake .SRC .ITEM :max_load
   368 sensor *tmp143 @unit @totalItems
-    * op greaterThanEq *tmp144 *tmp143 .UNIT_CAPACITY
-    * jump *label96 equal *tmp144 false
+  369 jump *label96 lessThan *tmp143 .UNIT_CAPACITY
   370 set :state 3
   371 jump *label97 always
   372 label *label96
 
   381 jump *label93 always
   382 label *label92
   383 label *label93
-    * op equal *tmp146 :state 3
-    * jump *label98 equal *tmp146 false
+  384 jump *label98 notEqual :state 3
   385 ucontrol within .DST_X .DST_Y 8 *tmp148
   386 jump *label100 equal *tmp148 false
   387 sensor *tmp150 .DST .ITEM
 
   389 op max :max_drop *tmp151 0
   390 ucontrol itemDrop .DST :max_drop
   391 sensor *tmp153 @unit @totalItems
-    * op lessThanEq *tmp154 *tmp153 0
-    * jump *label102 equal *tmp154 false
+  392 jump *label102 greaterThan *tmp153 0
   393 set :state 2
   394 ucontrol approach .SRC_X .SRC_Y 6
   395 jump *label103 always
 
   405 jump *label99 always
   406 label *label98
   407 label *label99
-    * op greaterThan *tmp156 :iter 3
-    * jump *label104 equal *tmp156 false
+  408 jump *label104 lessThanEq :iter 3
   409 set :iter 0
   410 print "Moving [green]"
   411 print .ITEM
 
   418 print *tmp158
   419 print "["
   420 print "]"
-    * op lessThan *tmp159 .EFF_LOCAL_LIMIT 100
-    * jump *label106 equal *tmp159 false
+  421 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
   422 print " (limit [orange]"
   423 print .LOCAL_MARGIN
   424 print "["
 
   433 print *tmp162
   434 print "["
   435 print "]"
-    * op lessThan *tmp163 .EFF_REMOTE_LIMIT 100
-    * jump *label110 equal *tmp163 false
+  436 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
   437 print " (limit [orange]"
   438 print .REMOTE_MARGIN
   439 print "["
 
   449 print *tmp165
   450 print "[]"
   451 print "\n"
-    * op equal *tmp167 :show_state 2
-    * jump *label114 equal *tmp167 false
+  452 jump *label114 notEqual :show_state 2
   453 sensor *tmp169 @unit @x
   454 op sub *tmp170 .SRC_X *tmp169
   455 sensor *tmp171 @unit @y
 
   464 print "\n"
   465 jump *label115 always
   466 label *label114
-    * op equal *tmp176 :show_state 3
-    * jump *label116 equal *tmp176 false
+  467 jump *label116 notEqual :show_state 3
   468 sensor *tmp178 @unit @x
   469 op sub *tmp179 .DST_X *tmp178
   470 sensor *tmp180 @unit @y
 
   491 print "\n"
   492 printflush message1
   493 sensor *tmp186 switch1 @enabled
-    * op equal *tmp187 *tmp186 0
-    * jump *label118 equal *tmp187 false
+  494 jump *label118 notEqual *tmp186 0
   495 jump *label68 always
   496 jump *label119 always
   497 label *label118
   498 label *label119
   499 sensor *tmp189 .SRC @dead
-    * op notEqual *tmp190 *tmp189 0
-    * jump *label120 equal *tmp190 false
+  500 jump *label120 equal *tmp189 0
   501 jump *label68 always
   502 jump *label121 always
   503 label *label120
   504 label *label121
   505 sensor *tmp192 .DST @dead
-    * op notEqual *tmp193 *tmp192 0
-    * jump *label122 equal *tmp193 false
+  506 jump *label122 equal *tmp192 0
   507 jump *label68 always
   508 jump *label123 always
   509 label *label122
   510 label *label123
   511 sensor *tmp195 .SORTER @dead
-    * op notEqual *tmp196 *tmp195 0
-    * jump *label124 equal *tmp196 false
+  512 jump *label124 equal *tmp195 0
   513 jump *label68 always
   514 jump *label125 always
   515 label *label124
 
   525 label *label126
   526 sensor *tmp199 .SORTER @dead
   527 op strictEqual *tmp200 *tmp199 0
-    * op equal *tmp201 *tmp200 false
-    * jump *label128 equal *tmp201 false
+  528 jump *label128 notEqual *tmp200 false
   529 print "[salmon]sorter1 is missing!"
   530 print "\n"
   531 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   547 control enabled switch1 false
   548 label *label131
   549 sensor *tmp211 switch1 @enabled
-    * op equal *tmp212 *tmp211 false
-    * jump *label133 equal *tmp212 false
+  550 jump *label133 notEqual *tmp211 false
   551 print "[salmon]Local or remote container became invalid."
   552 print "\n"
   553 print "[gold]Please fix and press button to reinitialize."

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-23 instructions):
 
    25 jump *label10 equal @unit null
    26 set :fn0:first_unit @unit
    27 jump *label9 always
-    * jump *label11 always
    28 label *label10
    29 label *label11
    30 print "[salmon]No unit of type "
 
    39 sensor *tmp11 @unit @controller
    40 jump *label15 notEqual *tmp11 @this
    41 jump *label6 always
-    * jump *label16 always
    42 label *label15
    43 label *label16
    44 ubind UNIT
 
    96 jump *label31 lessThanEq *tmp31 0
    97 set .DROP_TARGET .CONTAINER
    98 set .CONTAINER :block
-    * jump *label32 always
    99 label *label31
   100 label *label32
   101 label *label29
 
   175 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   176 jump *label47 equal :b_type @vault
   177 set .CORE null
-    * jump *label48 always
   178 label *label47
   179 label *label48
-    * jump *label43 always
   180 label *label42
   181 label *label43
   182 label *label38
   183 jump *label49 notEqual .CORE null
   184 end
-    * jump *label50 always
   185 label *label49
   186 label *label50
   187 set .SORTER sorter1
 
   196 jump *label54 equal .SORTER null
   197 print "Block found: "
   198 print .SORTER
-    * jump *label55 always
   199 label *label54
   200 label *label55
   201 printflush message1
 
   308 label *label71
   309 ucontrol flag 1
   310 set :state 1
-    * jump *label70 always
   311 label *label69
   312 label *label70
   313 sensor .ITEM .SORTER @config
 
   322 label *label83
   323 set .LAST_ITEM .ITEM
   324 set :state 1
-    * jump *label80 always
   325 label *label79
   326 label *label80
   327 set :show_state 0
 
   341 ucontrol within .DROP_X .DROP_Y 8 *tmp134
   342 jump *label90 equal *tmp134 false
   343 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * jump *label91 always
   344 label *label90
   345 label *label91
   346 label *label89
   347 label *label87
-    * jump *label85 always
   348 label *label84
   349 label *label85
   350 jump *label92 notEqual :state 2
 
   367 set .MSG "\nGoing to source: [green]"
   368 set :show_state 2
   369 label *label95
-    * jump *label93 always
   370 label *label92
   371 label *label93
   372 jump *label98 notEqual :state 3
 
   390 set .MSG "\nGoing to destination: [green]"
   391 set :show_state 3
   392 label *label101
-    * jump *label99 always
   393 label *label98
   394 label *label99
   395 jump *label104 lessThanEq :iter 3
 
   410 print .LOCAL_MARGIN
   411 print "["
   412 print "])"
-    * jump *label107 always
   413 label *label106
   414 label *label107
   415 jump *label108 equal .SHOW_REMOTE_LEVEL false
 
   424 print .REMOTE_MARGIN
   425 print "["
   426 print "])"
-    * jump *label111 always
   427 label *label110
   428 label *label111
-    * jump *label109 always
   429 label *label108
   430 label *label109
   431 sensor *tmp165 @unit @totalItems
 
   461 print " "
   462 print "sec[]"
   463 print "\n"
-    * jump *label117 always
   464 label *label116
   465 label *label117
   466 label *label115
-    * jump *label113 always
   467 label *label112
   468 label *label113
   469 op floor *tmp185 :loop_time
 
   475 sensor *tmp186 switch1 @enabled
   476 jump *label118 notEqual *tmp186 0
   477 jump *label68 always
-    * jump *label119 always
   478 label *label118
   479 label *label119
   480 sensor *tmp189 .SRC @dead
   481 jump *label120 equal *tmp189 0
   482 jump *label68 always
-    * jump *label121 always
   483 label *label120
   484 label *label121
   485 sensor *tmp192 .DST @dead
   486 jump *label122 equal *tmp192 0
   487 jump *label68 always
-    * jump *label123 always
   488 label *label122
   489 label *label123
   490 sensor *tmp195 .SORTER @dead
   491 jump *label124 equal *tmp195 0
   492 jump *label68 always
-    * jump *label125 always
   493 label *label124
   494 label *label125
   495 jump *label105 always
 
   535 label *label132
   536 jump *label131 always
   537 label *label133
-    * jump *label130 always
   538 label *label129
   539 label *label130
   540 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   130 jump *label25 always
   131 label *label27
   132 set .CORE_Y null
-    * set .CORE_X .CORE_Y
-    * set .CORE .CORE_X
+  133 set .CORE_X null
+  134 set .CORE .CORE_Y
   135 jump *label37 notEqual LINK_ID 0
   136 print "[gold]Locating core..."
   137 printflush message1
 
   145 printflush message1
   146 op add .QUERY_FLAG 99999900 LINK_ID
   147 set :flag .QUERY_FLAG
-    * ucontrol flag :flag
+  148 ucontrol flag .QUERY_FLAG
   149 label *label39
   150 op equal *tmp46 :flag .QUERY_FLAG
   151 sensor *tmp47 @unit @dead
 
   185 label *label49
   186 label *label50
   187 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  188 sensor :sorter_type sorter1 @type
   189 label *label51
   190 op notEqual *tmp68 :sorter_type @sorter
   191 op notEqual *tmp69 :sorter_type @inverted-sorter
 
   200 label *label55
   201 printflush message1
   202 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  203 sensor :sorter_type sorter1 @type
   204 label *label52
   205 jump *label51 always
   206 label *label53
 
   208 set .SHOW_REMOTE_LEVEL true
   209 set .SRC .CORE
   210 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  211 sensor :src_capacity .CORE @itemCapacity
+  212 sensor :dst_capacity .CONTAINER @itemCapacity
   213 op sub *tmp78 100 .EFF_REMOTE_LIMIT
   214 op mul *tmp79 :src_capacity *tmp78
   215 op idiv .LOAD_LEVEL *tmp79 100
 
   229 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   230 set .SRC .CONTAINER
   231 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  232 sensor :src_capacity .CONTAINER @itemCapacity
+  233 sensor :dst_capacity .CORE @itemCapacity
   234 op sub *tmp88 100 .EFF_LOCAL_LIMIT
   235 op mul *tmp89 :src_capacity *tmp88
   236 op idiv .LOAD_LEVEL *tmp89 100
 
   397 print "Moving [green]"
   398 print .ITEM
   399 print .DIRECTION
-    * print .LINK_TXT
+  400 print *tmp99
   401 print "\"
   402 print "n"
   403 sensor *tmp158 .CONTAINER .ITEM

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   131 label *label27
   132 set .CORE_Y null
   133 set .CORE_X null
-    * set .CORE .CORE_Y
+  134 set .CORE null
   135 jump *label37 notEqual LINK_ID 0
   136 print "[gold]Locating core..."
   137 printflush message1
 
   255 label *label62
   256 set *tmp99 LINK_ID
   257 label *label63
-    * set .LINK_TXT *tmp99
   258 sensor .SRC_X .SRC @x
   259 sensor .SRC_Y .SRC @y
   260 sensor .DST_X .DST @x

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    90 set :n @links
    91 label *label28
    92 jump *label30 lessThanEq :n 0
+   93 label *label134
    94 op sub :n :n 1
    95 getlink :block :n
    96 sensor *tmp31 :block @itemCapacity
 
   100 label *label31
   101 label *label32
   102 label *label29
-    * jump *label28 always
+  103 jump *label134 greaterThan :n 0
   104 label *label30
   105 jump *label33 notEqual .CONTAINER null
   106 print "[salmon]No destination."
 
   314 jump *label79 equal .ITEM .LAST_ITEM
   315 label *label81
   316 jump *label83 notEqual .ITEM null
+  317 label *label135
   318 print "[salmon]No item type selected for transport."
   319 printflush message1
   320 sensor .ITEM .SORTER @config
   321 label *label82
-    * jump *label81 always
+  322 jump *label135 equal .ITEM null
   323 label *label83
   324 set .LAST_ITEM .ITEM
   325 set :state 1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
   218 op idiv .DROP_LEVEL *tmp81 100
   219 set .LOCAL_MARGIN .DROP_LEVEL
   220 set .REMOTE_MARGIN .LOAD_LEVEL
-    * jump *label58 notEqual LINK_ID 0
-    * set *tmp84 "[] from core"
+  221 set .DIRECTION "[] from vault #"
+  222 jump *label59 notEqual LINK_ID 0
+  223 set .DIRECTION "[] from core"
   224 jump *label59 always
-    * label *label58
-    * set *tmp84 "[] from vault #"
   225 label *label59
-    * set .DIRECTION *tmp84
   226 jump *label57 always
   227 label *label56
   228 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   240 op add .DROP_LEVEL *tmp92 *tmp94
   241 set .LOCAL_MARGIN .LOAD_LEVEL
   242 set .REMOTE_MARGIN .DROP_LEVEL
-    * jump *label60 notEqual LINK_ID 0
-    * set *tmp97 "[] to core"
+  243 set .DIRECTION "[] to vault #"
+  244 jump *label61 notEqual LINK_ID 0
+  245 set .DIRECTION "[] to core"
   246 jump *label61 always
-    * label *label60
-    * set *tmp97 "[] to vault #"
   247 label *label61
-    * set .DIRECTION *tmp97
   248 label *label57
-    * jump *label62 notEqual LINK_ID 0
+  249 set *tmp99 LINK_ID
+  250 jump *label63 notEqual LINK_ID 0
   251 set *tmp99 ""
   252 jump *label63 always
-    * label *label62
-    * set *tmp99 LINK_ID
   253 label *label63
   254 sensor .SRC_X .SRC @x
   255 sensor .SRC_Y .SRC @y

Modifications by Replicate loop condition at line 43:1 (+1 instructions):
 
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
     9 jump *label2 notEqual *tmp2 false
+   10 label *label136
    11 print "Unit Transport - Single"
    12 print "\n"
    13 print "Activate switch to start."
    14 print "\n"
    15 printflush message1
    16 label *label1
-    * jump *label0 always
+   17 sensor *tmp2 switch1 @enabled
+   18 jump *label136 equal *tmp2 false
    19 label *label2
    20 label *label3
    21 sensor *tmp4 @unit @dead

Modifications by Replicate loop condition at line 314:5 (+1 instructions):
 
   524 label *label131
   525 sensor *tmp211 switch1 @enabled
   526 jump *label133 notEqual *tmp211 false
+  527 label *label137
   528 print "[salmon]Local or remote container became invalid."
   529 print "\n"
   530 print "[gold]Please fix and press button to reinitialize."
 
   532 printflush message1
   533 printflush message2
   534 label *label132
-    * jump *label131 always
+  535 sensor *tmp211 switch1 @enabled
+  536 jump *label137 equal *tmp211 false
   537 label *label133
   538 label *label129
   539 label *label130

Modifications by Replicate loop condition at line 51:1 (+2 instructions):
 
    21 sensor *tmp4 @unit @dead
    22 op strictEqual *tmp6 *tmp4 0
    23 jump *label5 notEqual *tmp6 false
+   24 label *label138
    25 set :fn0:first_unit null
    26 label *label7
    27 ubind UNIT
 
    81 label *label17
    82 label *label6
    83 label *label4
-    * jump *label3 always
+   84 sensor *tmp4 @unit @dead
+   85 op strictEqual *tmp6 *tmp4 0
+   86 jump *label138 equal *tmp6 false
    87 label *label5
    88 sensor .UNIT_CAPACITY @unit @itemCapacity
    89 sensor *tmp25 @unit @speed

Modifications by Replicate loop condition at line 304:1 (+2 instructions):
 
   505 sensor *tmp199 .SORTER @dead
   506 op strictEqual *tmp200 *tmp199 0
   507 jump *label128 notEqual *tmp200 false
+  508 label *label139
   509 print "[salmon]sorter1 is missing!"
   510 print "\n"
   511 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   514 printflush message2
   515 set .SORTER sorter1
   516 label *label127
-    * jump *label126 always
+  517 sensor *tmp199 .SORTER @dead
+  518 op strictEqual *tmp200 *tmp199 0
+  519 jump *label139 equal *tmp200 false
   520 label *label128
   521 sensor *tmp202 .SRC @dead
   522 op strictEqual *tmp204 *tmp202 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   514 printflush message2
   515 set .SORTER sorter1
   516 label *label127
-    * sensor *tmp199 .SORTER @dead
+  517 sensor *tmp199 sorter1 @dead
   518 op strictEqual *tmp200 *tmp199 0
   519 jump *label139 equal *tmp200 false
   520 label *label128

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   512 print "\n"
   513 printflush message1
   514 printflush message2
-    * set .SORTER sorter1
   515 label *label127
   516 sensor *tmp199 sorter1 @dead
   517 op strictEqual *tmp200 *tmp199 0

Modifications by Replicate loop condition at line 129:1 (+3 instructions):
 
   197 op notEqual *tmp69 :sorter_type @inverted-sorter
   198 op land *tmp70 *tmp68 *tmp69
   199 jump *label53 equal *tmp70 false
+  200 label *label140
   201 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   202 print "\n"
   203 jump *label54 equal .SORTER null
 
   209 set .SORTER sorter1
   210 sensor :sorter_type sorter1 @type
   211 label *label52
-    * jump *label51 always
+  212 op notEqual *tmp68 :sorter_type @sorter
+  213 op notEqual *tmp69 :sorter_type @inverted-sorter
+  214 op land *tmp70 *tmp68 *tmp69
+  215 jump *label140 notEqual *tmp70 false
   216 label *label53
   217 jump *label56 notEqual :sorter_type @sorter
   218 set .SHOW_REMOTE_LEVEL true

Modifications by Replicate loop condition at line 102:5 (+4 instructions):
 
   158 op strictEqual *tmp48 *tmp47 0
   159 op land *tmp49 *tmp46 *tmp48
   160 jump *label41 equal *tmp49 false
+  161 label *label141
   162 ucontrol stop
   163 sensor :flag @unit @flag
   164 label *label40
-    * jump *label39 always
+  165 op equal *tmp46 :flag .QUERY_FLAG
+  166 sensor *tmp47 @unit @dead
+  167 op strictEqual *tmp48 *tmp47 0
+  168 op land *tmp49 *tmp46 *tmp48
+  169 jump *label141 notEqual *tmp49 false
   170 label *label41
   171 jump *label42 equal :flag .QUERY_FLAG
   172 op idiv :position :flag 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   153 set :flag .QUERY_FLAG
   154 ucontrol flag .QUERY_FLAG
   155 label *label39
-    * op equal *tmp46 :flag .QUERY_FLAG
+  156 op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
   157 sensor *tmp47 @unit @dead
   158 op strictEqual *tmp48 *tmp47 0
   159 op land *tmp49 *tmp46 *tmp48

Modifications by Replicate loop condition at line 110:9 (+5 instructions):
 
   179 op equal *tmp59 *tmp58 0
   180 op land *tmp60 *tmp57 *tmp59
   181 jump *label46 equal *tmp60 false
+  182 label *label142
   183 ucontrol approach .CORE_X .CORE_Y 6
   184 label *label45
-    * jump *label44 always
+  185 ucontrol within .CORE_X .CORE_Y 8 *tmp56
+  186 op equal *tmp57 *tmp56 false
+  187 sensor *tmp58 @unit @dead
+  188 op equal *tmp59 *tmp58 0
+  189 op land *tmp60 *tmp57 *tmp59
+  190 jump *label142 notEqual *tmp60 false
   191 label *label46
   192 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   193 jump *label47 equal :b_type @vault

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-3 instructions):
 
   241 set .DIRECTION "[] from vault #"
   242 jump *label59 notEqual LINK_ID 0
   243 set .DIRECTION "[] from core"
-    * jump *label59 always
   244 label *label59
   245 jump *label57 always
   246 label *label56
 
   262 set .DIRECTION "[] to vault #"
   263 jump *label61 notEqual LINK_ID 0
   264 set .DIRECTION "[] to core"
-    * jump *label61 always
   265 label *label61
   266 label *label57
   267 set *tmp99 LINK_ID
   268 jump *label63 notEqual LINK_ID 0
   269 set *tmp99 ""
-    * jump *label63 always
   270 label *label63
   271 sensor .SRC_X .SRC @x
   272 sensor .SRC_Y .SRC @y

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   153 set :flag .QUERY_FLAG
   154 ucontrol flag .QUERY_FLAG
   155 label *label39
-    * op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
+  156 set *tmp46 true
   157 sensor *tmp47 @unit @dead
   158 op strictEqual *tmp48 *tmp47 0
   159 op land *tmp49 *tmp46 *tmp48

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   156 set *tmp46 true
   157 sensor *tmp47 @unit @dead
   158 op strictEqual *tmp48 *tmp47 0
-    * op land *tmp49 *tmp46 *tmp48
+  159 op land *tmp49 true *tmp48
   160 jump *label41 equal *tmp49 false
   161 label *label141
   162 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
   153 set :flag .QUERY_FLAG
   154 ucontrol flag .QUERY_FLAG
   155 label *label39
-    * set *tmp46 true
   156 sensor *tmp47 @unit @dead
   157 op strictEqual *tmp48 *tmp47 0
   158 op land *tmp49 true *tmp48

Modifications by Final phase, Jump Straightening, iteration 1 (-5 instructions):
 
    40 label *label9
    41 label *label12
    42 sensor *tmp11 @unit @controller
-    * jump *label15 notEqual *tmp11 @this
-    * jump *label6 always
+   43 jump *label6 equal *tmp11 @this
    44 label *label15
    45 label *label16
    46 ubind UNIT
 
   484 print "\n"
   485 printflush message1
   486 sensor *tmp186 switch1 @enabled
-    * jump *label118 notEqual *tmp186 0
-    * jump *label68 always
+  487 jump *label68 equal *tmp186 0
   488 label *label118
   489 label *label119
   490 sensor *tmp189 .SRC @dead
-    * jump *label120 equal *tmp189 0
-    * jump *label68 always
+  491 jump *label68 notEqual *tmp189 0
   492 label *label120
   493 label *label121
   494 sensor *tmp192 .DST @dead
-    * jump *label122 equal *tmp192 0
-    * jump *label68 always
+  495 jump *label68 notEqual *tmp192 0
   496 label *label122
   497 label *label123
   498 sensor *tmp195 .SORTER @dead
-    * jump *label124 equal *tmp195 0
-    * jump *label68 always
+  499 jump *label68 notEqual *tmp195 0
   500 label *label124
   501 label *label125
   502 jump *label105 always

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 set UNIT @mega
     2 set LINK_ID 0
     3 set LOCAL_LIMIT 100
 
    64 jump *label22 always
    65 label *label21
    66 sensor *tmp21 @unit @controlled
-    * jump *label23 equal *tmp21 0
+   67 jump *label17 equal *tmp21 0
    68 print "[salmon]Looking for a free "
    69 print UNIT
    70 print "."
 
   116 sensor *tmp37 .DROP_TARGET @itemCapacity
   117 op lessThan *tmp38 *tmp37 300
   118 op land *tmp39 *tmp36 *tmp38
-    * jump *label35 equal *tmp39 false
+  119 jump *label27 equal *tmp39 false
   120 print "Destination: "
   121 print .CONTAINER
   122 print "\"
 
   238 set .LOCAL_MARGIN .DROP_LEVEL
   239 set .REMOTE_MARGIN .LOAD_LEVEL
   240 set .DIRECTION "[] from vault #"
-    * jump *label59 notEqual LINK_ID 0
+  241 jump *label57 notEqual LINK_ID 0
   242 set .DIRECTION "[] from core"
   243 label *label59
   244 jump *label57 always
 
   302 jump *label76 always
   303 label *label75
   304 sensor *tmp118 @unit @controlled
-    * jump *label77 equal *tmp118 0
+  305 jump *label71 equal *tmp118 0
   306 print "[salmon]Looking for a free "
   307 print UNIT
   308 print "."
 
   369 sensor *tmp143 @unit @totalItems
   370 jump *label96 lessThan *tmp143 .UNIT_CAPACITY
   371 set :state 3
-    * jump *label97 always
+  372 jump *label95 always
   373 label *label96
   374 set .MSG "\nLoading items: [green]"
   375 label *label97
 
   392 jump *label102 greaterThan *tmp153 0
   393 set :state 2
   394 ucontrol approach .SRC_X .SRC_Y 6
-    * jump *label103 always
+  395 jump *label101 always
   396 label *label102
   397 set .MSG "\nDropping items: [green]"
   398 label *label103
 
   531 op strictEqual *tmp207 *tmp205 0
   532 op equal *tmp206 *tmp207 false
   533 op or *tmp208 *tmp203 *tmp206
-    * jump *label129 equal *tmp208 false
+  534 jump __start__ equal *tmp208 false
   535 control enabled switch1 false
   536 label *label131
   537 sensor *tmp211 switch1 @enabled
-    * jump *label133 notEqual *tmp211 false
+  538 jump __start__ notEqual *tmp211 false
   539 label *label137
   540 print "[salmon]Local or remote container became invalid."
   541 print "\n"

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-3 instructions):
 
    70 print "."
    71 print ".."
    72 jump *label24 always
-    * label *label23
-    * jump *label17 always
    73 label *label24
    74 label *label22
    75 printflush message1
    76 label *label19
    77 jump *label18 always
-    * label *label20
    78 label *label17
    79 label *label6
    80 label *label4
 
   124 print "n"
   125 print "[salmon]Item dump must be a container or a vault!"
   126 jump *label36 always
-    * label *label35
-    * jump *label27 always
   127 label *label36
   128 label *label34
   129 printflush message1
 
   303 print "."
   304 print ".."
   305 jump *label78 always
-    * label *label77
-    * jump *label71 always
   306 label *label78
   307 label *label76
   308 printflush message1
   309 label *label73
   310 jump *label72 always
-    * label *label74
   311 label *label71
   312 ucontrol flag 1
   313 set :state 1

Modifications by Final phase, Single Step Elimination, iteration 1 (-4 instructions):
 
    69 print UNIT
    70 print "."
    71 print ".."
-    * jump *label24 always
    72 label *label24
    73 label *label22
    74 printflush message1
 
   122 print "\"
   123 print "n"
   124 print "[salmon]Item dump must be a container or a vault!"
-    * jump *label36 always
   125 label *label36
   126 label *label34
   127 printflush message1
 
   300 print UNIT
   301 print "."
   302 print ".."
-    * jump *label78 always
   303 label *label78
   304 label *label76
   305 printflush message1
 
   538 label *label133
   539 label *label129
   540 label *label130
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-50 instructions):
 
     9 sensor *tmp2 switch1 @enabled
    10 jump *label2 notEqual *tmp2 false
    11 label *label136
-    * print "Unit Transport - Single"
-    * print "\n"
-    * print "Activate switch to start."
-    * print "\n"
+   12 print "Unit Transport - Single\nActivate switch to start.\n"
    13 printflush message1
    14 label *label1
    15 sensor *tmp2 switch1 @enabled
 
    28 jump *label9 always
    29 label *label10
    30 label *label11
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 1"
+   31 print "[salmon]No unit of type {0} found. 1"
+   32 format UNIT
    33 printflush message1
    34 label *label8
    35 jump *label7 always
 
    52 label *label18
    53 ubind UNIT
    54 jump *label21 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+   55 print "[salmon]No unit of type {0} found. 2"
+   56 format UNIT
    57 jump *label22 always
    58 label *label21
    59 sensor *tmp21 @unit @controlled
    60 jump *label17 equal *tmp21 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+   61 print "[salmon]Looking for a free {0}..."
+   62 format UNIT
    63 label *label24
    64 label *label22
    65 printflush message1
 
    95 jump *label134 greaterThan :n 0
    96 label *label30
    97 jump *label33 notEqual .CONTAINER null
-    * print "[salmon]No destination."
-    * print "\n"
+   98 print "[salmon]No destination.\n"
    99 jump *label34 always
   100 label *label33
   101 op notEqual *tmp36 .DROP_TARGET null
 
   103 op lessThan *tmp38 *tmp37 300
   104 op land *tmp39 *tmp36 *tmp38
   105 jump *label27 equal *tmp39 false
-    * print "Destination: "
-    * print .CONTAINER
-    * print "\"
-    * print "n"
-    * print "Item dump: "
-    * print .DROP_TARGET
-    * print "\"
-    * print "n"
-    * print "[salmon]Item dump must be a container or a vault!"
+  106 print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
+  107 format .CONTAINER
+  108 format .DROP_TARGET
   109 label *label36
   110 label *label34
   111 printflush message1
 
   121 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   122 jump *label38 always
   123 label *label37
-    * print "[gold]Locating vault #"
-    * print LINK_ID
-    * print "."
-    * print ".."
+  124 print "[gold]Locating vault #{0}..."
+  125 format LINK_ID
   126 printflush message1
   127 op add .QUERY_FLAG 99999900 LINK_ID
   128 set :flag .QUERY_FLAG
 
   183 op land *tmp70 *tmp68 *tmp69
   184 jump *label53 equal *tmp70 false
   185 label *label140
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  186 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   187 jump *label54 equal .SORTER null
   188 print "Block found: "
   189 print .SORTER
 
   269 label *label72
   270 ubind UNIT
   271 jump *label75 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+  272 print "[salmon]No unit of type {0} found. 2"
+  273 format UNIT
   274 jump *label76 always
   275 label *label75
   276 sensor *tmp118 @unit @controlled
   277 jump *label71 equal *tmp118 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+  278 print "[salmon]Looking for a free {0}..."
+  279 format UNIT
   280 label *label78
   281 label *label76
   282 printflush message1
 
   372 label *label99
   373 jump *label104 lessThanEq :iter 3
   374 set :iter 0
-    * print "Moving [green]"
-    * print .ITEM
-    * print .DIRECTION
-    * print *tmp99
-    * print "\"
-    * print "n"
+  375 print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
+  376 format .ITEM
+  377 format .DIRECTION
+  378 format *tmp99
   379 sensor *tmp158 .CONTAINER .ITEM
-    * print "Local items: [gold]"
-    * print *tmp158
-    * print "["
-    * print "]"
+  380 format *tmp158
   381 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
-    * print " (limit [orange]"
-    * print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  382 print " (limit [orange]{0}[])"
+  383 format .LOCAL_MARGIN
   384 label *label106
   385 label *label107
   386 jump *label108 equal .SHOW_REMOTE_LEVEL false
   387 sensor *tmp162 .CORE .ITEM
-    * print "\n"
-    * print "Remote items: [gold]"
-    * print *tmp162
-    * print "["
-    * print "]"
+  388 print "\nRemote items: [gold]{0}[]"
+  389 format *tmp162
   390 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
-    * print " (limit [orange]"
-    * print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  391 print " (limit [orange]{0}[])"
+  392 format .REMOTE_MARGIN
   393 label *label110
   394 label *label111
   395 label *label108
 
   397 sensor *tmp165 @unit @totalItems
   398 print .MSG
   399 print *tmp165
-    * print "[]"
-    * print "\n"
+  400 print "[]\n"
   401 jump *label114 notEqual :show_state 2
   402 sensor *tmp169 @unit @x
   403 op sub *tmp170 .SRC_X *tmp169
 
   406 op len *tmp173 *tmp170 *tmp172
   407 op idiv *tmp174 *tmp173 .SPEED_SEC
   408 op div *tmp175 *tmp174 10
-    * print "[]  arriving in [gold]"
-    * print *tmp175
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  409 print "[]  arriving in [gold]{0} sec[]\n"
+  410 format *tmp175
   411 jump *label115 always
   412 label *label114
   413 jump *label116 notEqual :show_state 3
 
   418 op len *tmp182 *tmp179 *tmp181
   419 op idiv *tmp183 *tmp182 .SPEED_SEC
   420 op div *tmp184 *tmp183 10
-    * print "[]  arriving in [gold]"
-    * print *tmp184
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  421 print "[]  arriving in [gold]{0} sec[]\n"
+  422 format *tmp184
   423 label *label116
   424 label *label117
   425 label *label115
   426 label *label112
   427 label *label113
   428 op floor *tmp185 :loop_time
-    * print "[lightgray]Loop time: "
-    * print *tmp185
-    * print " ms[]"
-    * print "\n"
+  429 print "[lightgray]Loop time: {0} ms[]\n"
+  430 format *tmp185
   431 printflush message1
   432 sensor *tmp186 switch1 @enabled
   433 jump *label68 equal *tmp186 0
 
   458 op strictEqual *tmp200 *tmp199 0
   459 jump *label128 notEqual *tmp200 false
   460 label *label139
-    * print "[salmon]sorter1 is missing!"
-    * print "\n"
-    * print "[gold]Please place and link sorter or inverted sorter to the processor."
-    * print "\n"
+  461 print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
   462 printflush message1
   463 printflush message2
   464 label *label127
 
   479 sensor *tmp211 switch1 @enabled
   480 jump __start__ notEqual *tmp211 false
   481 label *label137
-    * print "[salmon]Local or remote container became invalid."
-    * print "\n"
-    * print "[gold]Please fix and press button to reinitialize."
-    * print "\n"
+  482 print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
   483 printflush message1
   484 printflush message2
   485 label *label132

Final code before resolving virtual instructions:

label __start__
set UNIT @mega
set LINK_ID 0
set LOCAL_LIMIT 100
set REMOTE_LIMIT 100
op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
set .MSG null
sensor *tmp2 switch1 @enabled
jump *label2 notEqual *tmp2 false
label *label136
print "Unit Transport - Single\nActivate switch to start.\n"
printflush message1
sensor *tmp2 switch1 @enabled
jump *label136 equal *tmp2 false
label *label2
sensor *tmp4 @unit @dead
op strictEqual *tmp6 *tmp4 0
jump *label5 notEqual *tmp6 false
label *label138
set :fn0:first_unit null
label *label7
ubind UNIT
jump *label10 equal @unit null
set :fn0:first_unit @unit
jump *label9 always 0 0
label *label10
print "[salmon]No unit of type {0} found. 1"
format UNIT
printflush message1
jump *label7 always 0 0
label *label9
label *label12
sensor *tmp11 @unit @controller
jump *label6 equal *tmp11 @this
ubind UNIT
print "[gold]Looking for old unit..."
printflush message1
op notEqual *tmp14 @unit :fn0:first_unit
sensor *tmp15 :fn0:first_unit @dead
op strictEqual *tmp16 *tmp15 0
op land *tmp17 *tmp14 *tmp16
jump *label12 notEqual *tmp17 false
label *label18
ubind UNIT
jump *label21 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label22 always 0 0
label *label21
sensor *tmp21 @unit @controlled
jump *label17 equal *tmp21 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label22
printflush message1
jump *label18 always 0 0
label *label17
label *label6
sensor *tmp4 @unit @dead
op strictEqual *tmp6 *tmp4 0
jump *label138 equal *tmp6 false
label *label5
sensor .UNIT_CAPACITY @unit @itemCapacity
sensor *tmp25 @unit @speed
op div .SPEED_SEC *tmp25 10
ucontrol flag 1 0 0 0 0
label *label25
set .CONTAINER null
set .DROP_TARGET null
set :n @links
jump *label30 lessThanEq :n 0
label *label134
op sub :n :n 1
getlink :block :n
sensor *tmp31 :block @itemCapacity
jump *label31 lessThanEq *tmp31 0
set .DROP_TARGET .CONTAINER
set .CONTAINER :block
label *label31
jump *label134 greaterThan :n 0
label *label30
jump *label33 notEqual .CONTAINER null
print "[salmon]No destination.\n"
jump *label34 always 0 0
label *label33
op notEqual *tmp36 .DROP_TARGET null
sensor *tmp37 .DROP_TARGET @itemCapacity
op lessThan *tmp38 *tmp37 300
op land *tmp39 *tmp36 *tmp38
jump *label27 equal *tmp39 false
print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
format .CONTAINER
format .DROP_TARGET
label *label34
printflush message1
jump *label25 always 0 0
label *label27
set .CORE_Y null
set .CORE_X null
set .CORE null
jump *label37 notEqual LINK_ID 0
print "[gold]Locating core..."
printflush message1
ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
jump *label38 always 0 0
label *label37
print "[gold]Locating vault #{0}..."
format LINK_ID
printflush message1
op add .QUERY_FLAG 99999900 LINK_ID
set :flag .QUERY_FLAG
ucontrol flag .QUERY_FLAG 0 0 0 0
sensor *tmp47 @unit @dead
op strictEqual *tmp48 *tmp47 0
op land *tmp49 true *tmp48
jump *label41 equal *tmp49 false
label *label141
ucontrol stop 0 0 0 0 0
sensor :flag @unit @flag
op equal *tmp46 :flag .QUERY_FLAG
sensor *tmp47 @unit @dead
op strictEqual *tmp48 *tmp47 0
op land *tmp49 *tmp46 *tmp48
jump *label141 notEqual *tmp49 false
label *label41
jump *label42 equal :flag .QUERY_FLAG
op idiv :position :flag 100
op mod .CORE_X :position @mapw
op idiv .CORE_Y :position @mapw
ucontrol within .CORE_X .CORE_Y 8 *tmp56 0
op equal *tmp57 *tmp56 false
sensor *tmp58 @unit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label46 equal *tmp60 false
label *label142
ucontrol approach .CORE_X .CORE_Y 6 0 0
ucontrol within .CORE_X .CORE_Y 8 *tmp56 0
op equal *tmp57 *tmp56 false
sensor *tmp58 @unit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label142 notEqual *tmp60 false
label *label46
ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
jump *label47 equal :b_type @vault
set .CORE null
label *label47
label *label42
label *label38
jump *label49 notEqual .CORE null
end
label *label49
set .SORTER sorter1
sensor :sorter_type sorter1 @type
op notEqual *tmp68 :sorter_type @sorter
op notEqual *tmp69 :sorter_type @inverted-sorter
op land *tmp70 *tmp68 *tmp69
jump *label53 equal *tmp70 false
label *label140
print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
jump *label54 equal .SORTER null
print "Block found: "
print .SORTER
label *label54
printflush message1
set .SORTER sorter1
sensor :sorter_type sorter1 @type
op notEqual *tmp68 :sorter_type @sorter
op notEqual *tmp69 :sorter_type @inverted-sorter
op land *tmp70 *tmp68 *tmp69
jump *label140 notEqual *tmp70 false
label *label53
jump *label56 notEqual :sorter_type @sorter
set .SHOW_REMOTE_LEVEL true
set .SRC .CORE
set .DST .CONTAINER
sensor :src_capacity .CORE @itemCapacity
sensor :dst_capacity .CONTAINER @itemCapacity
op sub *tmp78 100 .EFF_REMOTE_LIMIT
op mul *tmp79 :src_capacity *tmp78
op idiv .LOAD_LEVEL *tmp79 100
op mul *tmp81 :dst_capacity .EFF_LOCAL_LIMIT
op idiv .DROP_LEVEL *tmp81 100
set .LOCAL_MARGIN .DROP_LEVEL
set .REMOTE_MARGIN .LOAD_LEVEL
set .DIRECTION "[] from vault #"
jump *label57 notEqual LINK_ID 0
set .DIRECTION "[] from core"
jump *label57 always 0 0
label *label56
op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
set .SRC .CONTAINER
set .DST .CORE
sensor :src_capacity .CONTAINER @itemCapacity
sensor :dst_capacity .CORE @itemCapacity
op sub *tmp88 100 .EFF_LOCAL_LIMIT
op mul *tmp89 :src_capacity *tmp88
op idiv .LOAD_LEVEL *tmp89 100
op mul *tmp91 :dst_capacity .EFF_REMOTE_LIMIT
op idiv *tmp92 *tmp91 100
op equal *tmp93 LINK_ID 0
op mul *tmp94 *tmp93 .UNIT_CAPACITY
op add .DROP_LEVEL *tmp92 *tmp94
set .LOCAL_MARGIN .LOAD_LEVEL
set .REMOTE_MARGIN .DROP_LEVEL
set .DIRECTION "[] to vault #"
jump *label61 notEqual LINK_ID 0
set .DIRECTION "[] to core"
label *label61
label *label57
set *tmp99 LINK_ID
jump *label63 notEqual LINK_ID 0
set *tmp99 ""
label *label63
sensor .SRC_X .SRC @x
sensor .SRC_Y .SRC @y
sensor .DST_X .DST @x
sensor .DST_Y .DST @y
jump *label64 notEqual .DROP_TARGET null
set .DROP_TARGET .CORE
set .DROP_X .CORE_X
set .DROP_Y .CORE_Y
jump *label65 always 0 0
label *label64
sensor .DROP_X .DROP_TARGET @x
sensor .DROP_Y .DROP_TARGET @y
label *label65
set .LAST_ITEM @mono
set :iter 0
set :loop_time 0
set :state 1
ucontrol stop 0 0 0 0 0
label *label66
set :start @time
sensor *tmp109 @unit @dead
op strictEqual *tmp110 *tmp109 0
sensor *tmp111 @unit @controller
op notEqual *tmp112 *tmp111 @this
jump *label69 greaterThan *tmp110 *tmp112
label *label72
ubind UNIT
jump *label75 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label76 always 0 0
label *label75
sensor *tmp118 @unit @controlled
jump *label71 equal *tmp118 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label76
printflush message1
jump *label72 always 0 0
label *label71
ucontrol flag 1 0 0 0 0
set :state 1
label *label69
sensor .ITEM .SORTER @config
jump *label79 equal .ITEM .LAST_ITEM
jump *label83 notEqual .ITEM null
label *label135
print "[salmon]No item type selected for transport."
printflush message1
sensor .ITEM .SORTER @config
jump *label135 equal .ITEM null
label *label83
set .LAST_ITEM .ITEM
set :state 1
label *label79
set :show_state 0
jump *label84 notEqual :state 1
sensor *tmp128 @unit @firstItem
jump *label86 notEqual *tmp128 .ITEM
set :state 3
jump *label87 always 0 0
label *label86
sensor *tmp131 @unit @totalItems
jump *label88 notEqual *tmp131 0
set :state 2
jump *label89 always 0 0
label *label88
set .MSG "\nUnloading previous items: [green]"
ucontrol approach .DROP_X .DROP_Y 6 0 0
ucontrol within .DROP_X .DROP_Y 8 *tmp134 0
jump *label90 equal *tmp134 false
ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY 0 0 0
label *label90
label *label89
label *label87
label *label84
jump *label92 notEqual :state 2
ucontrol within .SRC_X .SRC_Y 8 *tmp138 0
jump *label94 equal *tmp138 false
sensor *tmp140 .SRC .ITEM
op sub *tmp141 *tmp140 .LOAD_LEVEL
op max :max_load *tmp141 0
ucontrol itemTake .SRC .ITEM :max_load 0 0
sensor *tmp143 @unit @totalItems
jump *label96 lessThan *tmp143 .UNIT_CAPACITY
set :state 3
jump *label95 always 0 0
label *label96
set .MSG "\nLoading items: [green]"
jump *label95 always 0 0
label *label94
ucontrol approach .SRC_X .SRC_Y 6 0 0
set .MSG "\nGoing to source: [green]"
set :show_state 2
label *label95
label *label92
jump *label98 notEqual :state 3
ucontrol within .DST_X .DST_Y 8 *tmp148 0
jump *label100 equal *tmp148 false
sensor *tmp150 .DST .ITEM
op sub *tmp151 .DROP_LEVEL *tmp150
op max :max_drop *tmp151 0
ucontrol itemDrop .DST :max_drop 0 0 0
sensor *tmp153 @unit @totalItems
jump *label102 greaterThan *tmp153 0
set :state 2
ucontrol approach .SRC_X .SRC_Y 6 0 0
jump *label101 always 0 0
label *label102
set .MSG "\nDropping items: [green]"
jump *label101 always 0 0
label *label100
ucontrol approach .DST_X .DST_Y 6 0 0
set .MSG "\nGoing to destination: [green]"
set :show_state 3
label *label101
label *label98
jump *label104 lessThanEq :iter 3
set :iter 0
print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
format .ITEM
format .DIRECTION
format *tmp99
sensor *tmp158 .CONTAINER .ITEM
format *tmp158
jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
print " (limit [orange]{0}[])"
format .LOCAL_MARGIN
label *label106
jump *label108 equal .SHOW_REMOTE_LEVEL false
sensor *tmp162 .CORE .ITEM
print "\nRemote items: [gold]{0}[]"
format *tmp162
jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
print " (limit [orange]{0}[])"
format .REMOTE_MARGIN
label *label110
label *label108
sensor *tmp165 @unit @totalItems
print .MSG
print *tmp165
print "[]\n"
jump *label114 notEqual :show_state 2
sensor *tmp169 @unit @x
op sub *tmp170 .SRC_X *tmp169
sensor *tmp171 @unit @y
op sub *tmp172 .SRC_Y *tmp171
op len *tmp173 *tmp170 *tmp172
op idiv *tmp174 *tmp173 .SPEED_SEC
op div *tmp175 *tmp174 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp175
jump *label115 always 0 0
label *label114
jump *label116 notEqual :show_state 3
sensor *tmp178 @unit @x
op sub *tmp179 .DST_X *tmp178
sensor *tmp180 @unit @y
op sub *tmp181 .DST_Y *tmp180
op len *tmp182 *tmp179 *tmp181
op idiv *tmp183 *tmp182 .SPEED_SEC
op div *tmp184 *tmp183 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp184
label *label116
label *label115
op floor *tmp185 :loop_time 0
print "[lightgray]Loop time: {0} ms[]\n"
format *tmp185
printflush message1
sensor *tmp186 switch1 @enabled
jump *label68 equal *tmp186 0
sensor *tmp189 .SRC @dead
jump *label68 notEqual *tmp189 0
sensor *tmp192 .DST @dead
jump *label68 notEqual *tmp192 0
sensor *tmp195 .SORTER @dead
jump *label68 notEqual *tmp195 0
jump *label105 always 0 0
label *label104
op add :iter :iter 1
label *label105
op sub :loop_time @time :start
jump *label66 always 0 0
label *label68
sensor *tmp199 .SORTER @dead
op strictEqual *tmp200 *tmp199 0
jump *label128 notEqual *tmp200 false
label *label139
print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
printflush message1
printflush message2
sensor *tmp199 sorter1 @dead
op strictEqual *tmp200 *tmp199 0
jump *label139 equal *tmp200 false
label *label128
sensor *tmp202 .SRC @dead
op strictEqual *tmp204 *tmp202 0
op equal *tmp203 *tmp204 false
sensor *tmp205 .DST @dead
op strictEqual *tmp207 *tmp205 0
op equal *tmp206 *tmp207 false
op or *tmp208 *tmp203 *tmp206
jump __start__ equal *tmp208 false
control enabled switch1 false 0 0 0
sensor *tmp211 switch1 @enabled
jump __start__ notEqual *tmp211 false
label *label137
print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
printflush message1
printflush message2
sensor *tmp211 switch1 @enabled
jump *label137 equal *tmp211 false
