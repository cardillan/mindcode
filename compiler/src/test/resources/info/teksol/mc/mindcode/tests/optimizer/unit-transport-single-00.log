   605 instructions before optimizations.
    40 instructions eliminated by Temp Variables Elimination (3 passes, 7 iterations).
    86 instructions eliminated by Dead Code Elimination (7 iterations).
     6 instructions eliminated by Jump Normalization (5 iterations).
    55 instructions eliminated by Condition Optimization (5 iterations).
    31 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
    12 instructions eliminated by Boolean Optimization (4 iterations).
       5 fully-evaluated conditions turned to a sequence of selects.
     2 instructions eliminated by Data Flow Optimization (2 passes, 11 iterations).
     4 instructions added by Loop Optimization (3 iterations).
     6 loops improved by Loop Optimization.
     7 instructions eliminated by Jump Straightening (2 passes, 5 iterations).
     7 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    50 instructions eliminated by Print Merging.
   317 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 622):
  * Replicate loop condition at line 43:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 51:1                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 304:1                       size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 621):
  * Replicate loop condition at line 51:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 304:1                       size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 620):
  * Replicate loop condition at line 304:1                       size    +1, benefit       25.0, efficiency     25.000 (+0 instructions)
    Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 620):
  * Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500 (+1 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-52 instructions):
 
    31 set *tmp9 @unit
    32 set :rebindUnit:first_unit *tmp9
    33 jump *label9 always
-    * set *tmp8 null
    34 jump *label11 always
    35 label *label10
-    * set *tmp8 null
    36 label *label11
    37 print "[salmon]No unit of type "
    38 print UNIT
 
    46 sensor *tmp10 @unit @controller
    47 op equal *tmp11 *tmp10 @this
    48 jump *label15 equal *tmp11 false
-    * set *tmp6 null
    49 jump *label6 always
-    * set *tmp12 null
    50 jump *label16 always
    51 label *label15
-    * set *tmp12 null
    52 label *label16
    53 ubind UNIT
    54 print "[gold]Looking for old unit..."
 
    71 print UNIT
    72 print " "
    73 print "found. 2"
-    * set *tmp18 null
    74 jump *label23 always
    75 label *label22
    76 sensor *tmp19 @unit @controlled
 
    87 jump *label18 always
    88 set *tmp21 null
    89 label *label25
-    * set *tmp18 *tmp21
    90 label *label23
    91 printflush message1
    92 label *label20
 
    94 label *label21
    95 set *tmp16 null
    96 label *label18
-    * set *tmp6 *tmp16
    97 label *label6
    98 label *label4
    99 jump *label3 always
 
   122 jump *label32 equal *tmp30 false
   123 set .DROP_TARGET .CONTAINER
   124 set .CONTAINER :block
-    * set *tmp31 .CONTAINER
   125 jump *label33 always
   126 label *label32
-    * set *tmp31 null
   127 label *label33
   128 label *label30
   129 jump *label29 always
 
   132 jump *label34 equal *tmp32 false
   133 print "[salmon]No destination."
   134 print "\n"
-    * set *tmp33 "[salmon]No destination."
   135 jump *label35 always
   136 label *label34
   137 op notEqual *tmp34 .DROP_TARGET null
 
   157 jump *label28 always
   158 set *tmp37 null
   159 label *label37
-    * set *tmp33 *tmp37
   160 label *label35
   161 printflush message1
   162 label *label27
 
   171 printflush message1
   172 ulocate building core false @copper .CORE_X .CORE_Y *tmp41 *tmp40
   173 set .CORE *tmp40
-    * set *tmp39 .CORE
   174 jump *label41 always
   175 label *label40
   176 print "[gold]Locating vault #"
 
   234 label *label47
   235 set *tmp48 null
   236 label *label48
-    * set *tmp39 *tmp48
   237 label *label41
   238 op equal *tmp60 .CORE null
   239 jump *label56 equal *tmp60 false
   240 end
-    * set *tmp61 null
   241 jump *label57 always
   242 label *label56
-    * set *tmp61 null
   243 label *label57
   244 set .SORTER sorter1
   245 sensor *tmp62 .SORTER @type
 
   258 jump *label63 equal *tmp65 false
   259 print "Block found: "
   260 print .SORTER
-    * set *tmp66 .SORTER
   261 jump *label64 always
   262 label *label63
-    * set *tmp66 null
   263 label *label64
   264 printflush message1
   265 set .SORTER sorter1
 
   294 set *tmp78 "[] from vault #"
   295 label *label68
   296 set .DIRECTION *tmp78
-    * set *tmp69 .DIRECTION
   297 jump *label66 always
   298 label *label65
   299 op greaterThan *tmp79 LINK_ID 0
 
   324 set *tmp91 "[] to vault #"
   325 label *label70
   326 set .DIRECTION *tmp91
-    * set *tmp69 .DIRECTION
   327 label *label66
   328 op equal *tmp92 LINK_ID 0
   329 jump *label71 equal *tmp92 false
 
   346 set .DROP_TARGET .CORE
   347 set .DROP_X .CORE_X
   348 set .DROP_Y .CORE_Y
-    * set *tmp99 .DROP_Y
   349 jump *label74 always
   350 label *label73
   351 sensor *tmp100 .DROP_TARGET @x
   352 set .DROP_X *tmp100
   353 sensor *tmp101 .DROP_TARGET @y
   354 set .DROP_Y *tmp101
-    * set *tmp99 .DROP_Y
   355 label *label74
   356 set .LAST_ITEM @mono
   357 set :iter 0
 
   377 print UNIT
   378 print " "
   379 print "found. 2"
-    * set *tmp111 null
   380 jump *label85 always
   381 label *label84
   382 sensor *tmp112 @unit @controlled
 
   389 set *tmp114 null
   390 jump *label87 always
   391 label *label86
-    * set *tmp109 null
   392 jump *label80 always
   393 set *tmp114 null
   394 label *label87
-    * set *tmp111 *tmp114
   395 label *label85
   396 printflush message1
   397 label *label82
   398 jump *label81 always
   399 label *label83
-    * set *tmp109 null
   400 label *label80
   401 ucontrol flag 1
   402 set :state 1
-    * set *tmp108 :state
   403 jump *label79 always
   404 label *label78
-    * set *tmp108 null
   405 label *label79
   406 sensor *tmp115 .SORTER @config
   407 set .ITEM *tmp115
 
   419 label *label92
   420 set .LAST_ITEM .ITEM
   421 set :state 1
-    * set *tmp117 :state
   422 jump *label89 always
   423 label *label88
-    * set *tmp117 null
   424 label *label89
   425 set :show_state 0
   426 op equal *tmp120 :state 1
 
   453 label *label98
   454 set *tmp124 *tmp127
   455 label *label96
-    * set *tmp121 *tmp124
   456 jump *label94 always
   457 label *label93
-    * set *tmp121 null
   458 label *label94
   459 op equal *tmp130 :state 2
   460 jump *label101 equal *tmp130 false
 
   483 set :show_state 2
   484 set *tmp133 :show_state
   485 label *label104
-    * set *tmp131 *tmp133
   486 jump *label102 always
   487 label *label101
-    * set *tmp131 null
   488 label *label102
   489 op equal *tmp140 :state 3
   490 jump *label107 equal *tmp140 false
 
   514 set :show_state 3
   515 set *tmp143 :show_state
   516 label *label110
-    * set *tmp141 *tmp143
   517 jump *label108 always
   518 label *label107
-    * set *tmp141 null
   519 label *label108
   520 op greaterThan *tmp150 :iter 3
   521 jump *label113 equal *tmp150 false
 
   537 print .LOCAL_MARGIN
   538 print "["
   539 print "])"
-    * set *tmp154 null
   540 jump *label116 always
   541 label *label115
-    * set *tmp154 null
   542 label *label116
   543 jump *label117 equal .SHOW_REMOTE_LEVEL false
   544 sensor *tmp156 .CORE .ITEM
 
   558 label *label119
   559 set *tmp158 null
   560 label *label120
-    * set *tmp155 *tmp158
   561 jump *label118 always
   562 label *label117
-    * set *tmp155 null
   563 label *label118
   564 sensor *tmp159 @unit @totalItems
   565 print .MSG
 
   605 label *label126
   606 set *tmp162 *tmp171
   607 label *label124
-    * set *tmp160 *tmp162
   608 jump *label122 always
   609 label *label121
-    * set *tmp160 null
   610 label *label122
   611 op floor *tmp179 :loop_time
   612 print "[lightgray]Loop time: "
 
   618 op equal *tmp181 *tmp180 0
   619 jump *label127 equal *tmp181 false
   620 jump *label77 always
-    * set *tmp182 null
   621 jump *label128 always
   622 label *label127
-    * set *tmp182 null
   623 label *label128
   624 sensor *tmp183 .SRC @dead
   625 op notEqual *tmp184 *tmp183 0
   626 jump *label129 equal *tmp184 false
   627 jump *label77 always
-    * set *tmp185 null
   628 jump *label130 always
   629 label *label129
-    * set *tmp185 null
   630 label *label130
   631 sensor *tmp186 .DST @dead
   632 op notEqual *tmp187 *tmp186 0
   633 jump *label131 equal *tmp187 false
   634 jump *label77 always
-    * set *tmp188 null
   635 jump *label132 always
   636 label *label131
-    * set *tmp188 null
   637 label *label132
   638 sensor *tmp189 .SORTER @dead
   639 op notEqual *tmp190 *tmp189 0
 
   644 label *label133
   645 set *tmp191 null
   646 label *label134
-    * set *tmp151 *tmp191
   647 jump *label114 always
   648 label *label113
   649 op add :iter :iter 1
-    * set *tmp151 :iter
   650 label *label114
   651 op sub *tmp192 @time :start
   652 set :loop_time *tmp192
 
   691 label *label143
   692 jump *label142 always
   693 label *label144
-    * set *tmp200 null
   694 jump *label139 always
   695 label *label138
-    * set *tmp200 null
   696 label *label139
   697 end

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-22 instructions):
 
    80 print UNIT
    81 print "."
    82 print ".."
-    * set *tmp21 null
    83 jump *label25 always
    84 label *label24
-    * set *tmp16 null
    85 jump *label18 always
-    * set *tmp21 null
    86 label *label25
    87 label *label23
    88 printflush message1
    89 label *label20
    90 jump *label19 always
    91 label *label21
-    * set *tmp16 null
    92 label *label18
    93 label *label6
    94 label *label4
 
   147 print "\"
   148 print "n"
   149 print "[salmon]Item dump must be a container or a vault!"
-    * set *tmp37 null
   150 jump *label37 always
   151 label *label36
   152 jump *label28 always
-    * set *tmp37 null
   153 label *label37
   154 label *label35
   155 printflush message1
 
   223 label *label54
   224 set *tmp59 null
   225 label *label55
-    * set *tmp48 *tmp59
   226 jump *label48 always
   227 label *label47
-    * set *tmp48 null
   228 label *label48
   229 label *label41
   230 op equal *tmp60 .CORE null
 
   378 print UNIT
   379 print "."
   380 print ".."
-    * set *tmp114 null
   381 jump *label87 always
   382 label *label86
   383 jump *label80 always
-    * set *tmp114 null
   384 label *label87
   385 label *label85
   386 printflush message1
 
   419 op equal *tmp123 *tmp122 .ITEM
   420 jump *label95 equal *tmp123 false
   421 set :state 3
-    * set *tmp124 :state
   422 jump *label96 always
   423 label *label95
   424 sensor *tmp125 @unit @totalItems
 
   440 label *label100
   441 set *tmp127 *tmp129
   442 label *label98
-    * set *tmp124 *tmp127
   443 label *label96
   444 jump *label94 always
   445 label *label93
 
   463 set .MSG "\nLoading items: [green]"
   464 set *tmp139 .MSG
   465 label *label106
-    * set *tmp133 *tmp139
   466 jump *label104 always
   467 label *label103
   468 ucontrol approach .SRC_X .SRC_Y 6
   469 set .MSG "\nGoing to source: [green]"
   470 set :show_state 2
-    * set *tmp133 :show_state
   471 label *label104
   472 jump *label102 always
   473 label *label101
 
   492 set .MSG "\nDropping items: [green]"
   493 set *tmp149 .MSG
   494 label *label112
-    * set *tmp143 *tmp149
   495 jump *label110 always
   496 label *label109
   497 ucontrol approach .DST_X .DST_Y 6
   498 set .MSG "\nGoing to destination: [green]"
   499 set :show_state 3
-    * set *tmp143 :show_state
   500 label *label110
   501 jump *label108 always
   502 label *label107
 
   537 print .REMOTE_MARGIN
   538 print "["
   539 print "])"
-    * set *tmp158 null
   540 jump *label120 always
   541 label *label119
-    * set *tmp158 null
   542 label *label120
   543 jump *label118 always
   544 label *label117
 
   563 print " "
   564 print "sec[]"
   565 print "\n"
-    * set *tmp162 null
   566 jump *label124 always
   567 label *label123
   568 op equal *tmp170 :show_state 3
 
   584 label *label125
   585 set *tmp171 null
   586 label *label126
-    * set *tmp162 *tmp171
   587 label *label124
   588 jump *label122 always
   589 label *label121
 
   619 op notEqual *tmp190 *tmp189 0
   620 jump *label133 equal *tmp190 false
   621 jump *label77 always
-    * set *tmp191 null
   622 jump *label134 always
   623 label *label133
-    * set *tmp191 null
   624 label *label134
   625 jump *label114 always
   626 label *label113

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   218 op notEqual *tmp58 :b_type @vault
   219 jump *label54 equal *tmp58 false
   220 set .CORE null
-    * set *tmp59 .CORE
   221 jump *label55 always
   222 label *label54
-    * set *tmp59 null
   223 label *label55
   224 jump *label48 always
   225 label *label47
 
   423 op equal *tmp126 *tmp125 0
   424 jump *label97 equal *tmp126 false
   425 set :state 2
-    * set *tmp127 :state
   426 jump *label98 always
   427 label *label97
   428 set .MSG "\nUnloading previous items: [green]"
 
   435 label *label99
   436 set *tmp129 null
   437 label *label100
-    * set *tmp127 *tmp129
   438 label *label98
   439 label *label96
   440 jump *label94 always
 
   453 op greaterThanEq *tmp138 *tmp137 .UNIT_CAPACITY
   454 jump *label105 equal *tmp138 false
   455 set :state 3
-    * set *tmp139 :state
   456 jump *label106 always
   457 label *label105
   458 set .MSG "\nLoading items: [green]"
-    * set *tmp139 .MSG
   459 label *label106
   460 jump *label104 always
   461 label *label103
 
   480 jump *label111 equal *tmp148 false
   481 set :state 2
   482 ucontrol approach .SRC_X .SRC_Y 6
-    * set *tmp149 null
   483 jump *label112 always
   484 label *label111
   485 set .MSG "\nDropping items: [green]"
-    * set *tmp149 .MSG
   486 label *label112
   487 jump *label110 always
   488 label *label109
 
   571 print " "
   572 print "sec[]"
   573 print "\n"
-    * set *tmp171 null
   574 jump *label126 always
   575 label *label125
-    * set *tmp171 null
   576 label *label126
   577 label *label124
   578 jump *label122 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   430 ucontrol within .DROP_X .DROP_Y 8 *tmp128
   431 jump *label99 equal *tmp128 false
   432 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * set *tmp129 null
   433 jump *label100 always
   434 label *label99
-    * set *tmp129 null
   435 label *label100
   436 label *label98
   437 label *label96

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-38 instructions):
 
     1 set LINK_ID 0
     2 set LOCAL_LIMIT 100
     3 set REMOTE_LIMIT 100
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+    4 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+    5 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
 
    26 ubind UNIT
    27 op notEqual *tmp7 @unit null
    28 jump *label10 equal *tmp7 false
-    * set *tmp9 @unit
-    * set :rebindUnit:first_unit *tmp9
+   29 set :rebindUnit:first_unit @unit
    30 jump *label9 always
    31 jump *label11 always
    32 label *label10
 
    91 label *label4
    92 jump *label3 always
    93 label *label5
-    * sensor *tmp22 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp22
+   94 sensor .UNIT_CAPACITY @unit @itemCapacity
    95 sensor *tmp23 @unit @speed
-    * op div *tmp24 *tmp23 10
-    * set .SPEED_SEC *tmp24
+   96 op div .SPEED_SEC *tmp23 10
    97 ucontrol flag 1
    98 label *label26
    99 jump *label28 equal true false
   100 set .CONTAINER null
   101 set .DROP_TARGET null
-    * set *tmp25 @links
-    * set :n *tmp25
+  102 set :n @links
   103 label *label29
   104 op greaterThan *tmp26 :n 0
   105 jump *label31 equal *tmp26 false
-    * op sub *tmp27 :n 1
-    * set :n *tmp27
-    * getlink *tmp28 :n
-    * set :block *tmp28
+  106 op sub :n :n 1
+  107 getlink :block :n
   108 sensor *tmp29 :block @itemCapacity
   109 op greaterThan *tmp30 *tmp29 0
   110 jump *label32 equal *tmp30 false
 
   155 jump *label40 equal *tmp38 false
   156 print "[gold]Locating core..."
   157 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp41 *tmp40
-    * set .CORE *tmp40
+  158 ulocate building core false @copper .CORE_X .CORE_Y *tmp41 .CORE
   159 jump *label41 always
   160 label *label40
   161 print "[gold]Locating vault #"
 
   163 print "."
   164 print ".."
   165 printflush message1
-    * op add *tmp42 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp42
+  166 op add .QUERY_FLAG 99999900 LINK_ID
   167 set :flag .QUERY_FLAG
   168 ucontrol flag :flag
   169 label *label42
 
   176 jump *label45 always
   177 label *label45
   178 ucontrol stop
-    * sensor *tmp46 @unit @flag
-    * set :flag *tmp46
+  179 sensor :flag @unit @flag
   180 label *label43
   181 jump *label42 always
   182 label *label44
   183 op notEqual *tmp47 :flag .QUERY_FLAG
   184 jump *label47 equal *tmp47 false
-    * op idiv *tmp49 :flag 100
-    * set :position *tmp49
-    * op mod *tmp50 :position @mapw
-    * set .CORE_X *tmp50
-    * op idiv *tmp51 :position @mapw
-    * set .CORE_Y *tmp51
+  185 op idiv :position :flag 100
+  186 op mod .CORE_X :position @mapw
+  187 op idiv .CORE_Y :position @mapw
   188 label *label49
   189 ucontrol within .CORE_X .CORE_Y 8 *tmp52
   190 op equal *tmp53 *tmp52 false
 
   199 label *label50
   200 jump *label49 always
   201 label *label51
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp56 *tmp57
-    * set .CORE *tmp56
+  202 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp57
   203 op notEqual *tmp58 :b_type @vault
   204 jump *label54 equal *tmp58 false
   205 set .CORE null
 
   217 label *label56
   218 label *label57
   219 set .SORTER sorter1
-    * sensor *tmp62 .SORTER @type
-    * set :sorter_type *tmp62
+  220 sensor :sorter_type .SORTER @type
   221 label *label58
   222 op notEqual *tmp63 :sorter_type @sorter
   223 jump *label60 equal *tmp63 false
 
   237 label *label64
   238 printflush message1
   239 set .SORTER sorter1
-    * sensor *tmp67 .SORTER @type
-    * set :sorter_type *tmp67
+  240 sensor :sorter_type .SORTER @type
   241 label *label59
   242 jump *label58 always
   243 label *label60
 
   246 set .SHOW_REMOTE_LEVEL true
   247 set .SRC .CORE
   248 set .DST .CONTAINER
-    * sensor *tmp70 .SRC @itemCapacity
-    * set :src_capacity *tmp70
-    * sensor *tmp71 .DST @itemCapacity
-    * set :dst_capacity *tmp71
+  249 sensor :src_capacity .SRC @itemCapacity
+  250 sensor :dst_capacity .DST @itemCapacity
   251 op sub *tmp72 100 .EFF_REMOTE_LIMIT
   252 op mul *tmp73 :src_capacity *tmp72
-    * op idiv *tmp74 *tmp73 100
-    * set .LOAD_LEVEL *tmp74
+  253 op idiv .LOAD_LEVEL *tmp73 100
   254 op mul *tmp75 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp76 *tmp75 100
-    * set .DROP_LEVEL *tmp76
+  255 op idiv .DROP_LEVEL *tmp75 100
   256 set .LOCAL_MARGIN .DROP_LEVEL
   257 set .REMOTE_MARGIN .LOAD_LEVEL
   258 op equal *tmp77 LINK_ID 0
 
   265 set .DIRECTION *tmp78
   266 jump *label66 always
   267 label *label65
-    * op greaterThan *tmp79 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp79
+  268 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   269 set .SRC .CONTAINER
   270 set .DST .CORE
-    * sensor *tmp80 .SRC @itemCapacity
-    * set :src_capacity *tmp80
-    * sensor *tmp81 .DST @itemCapacity
-    * set :dst_capacity *tmp81
+  271 sensor :src_capacity .SRC @itemCapacity
+  272 sensor :dst_capacity .DST @itemCapacity
   273 op sub *tmp82 100 .EFF_LOCAL_LIMIT
   274 op mul *tmp83 :src_capacity *tmp82
-    * op idiv *tmp84 *tmp83 100
-    * set .LOAD_LEVEL *tmp84
+  275 op idiv .LOAD_LEVEL *tmp83 100
   276 op mul *tmp85 :dst_capacity .EFF_REMOTE_LIMIT
   277 op idiv *tmp86 *tmp85 100
   278 op equal *tmp87 LINK_ID 0
   279 op mul *tmp88 *tmp87 .UNIT_CAPACITY
-    * op add *tmp89 *tmp86 *tmp88
-    * set .DROP_LEVEL *tmp89
+  280 op add .DROP_LEVEL *tmp86 *tmp88
   281 set .LOCAL_MARGIN .LOAD_LEVEL
   282 set .REMOTE_MARGIN .DROP_LEVEL
   283 op equal *tmp90 LINK_ID 0
 
   297 set *tmp93 LINK_ID
   298 label *label72
   299 set .LINK_TXT *tmp93
-    * sensor *tmp94 .SRC @x
-    * set .SRC_X *tmp94
-    * sensor *tmp95 .SRC @y
-    * set .SRC_Y *tmp95
-    * sensor *tmp96 .DST @x
-    * set .DST_X *tmp96
-    * sensor *tmp97 .DST @y
-    * set .DST_Y *tmp97
+  300 sensor .SRC_X .SRC @x
+  301 sensor .SRC_Y .SRC @y
+  302 sensor .DST_X .DST @x
+  303 sensor .DST_Y .DST @y
   304 op equal *tmp98 .DROP_TARGET null
   305 jump *label73 equal *tmp98 false
   306 set .DROP_TARGET .CORE
 
   308 set .DROP_Y .CORE_Y
   309 jump *label74 always
   310 label *label73
-    * sensor *tmp100 .DROP_TARGET @x
-    * set .DROP_X *tmp100
-    * sensor *tmp101 .DROP_TARGET @y
-    * set .DROP_Y *tmp101
+  311 sensor .DROP_X .DROP_TARGET @x
+  312 sensor .DROP_Y .DROP_TARGET @y
   313 label *label74
   314 set .LAST_ITEM @mono
   315 set :iter 0
 
   318 ucontrol stop
   319 label *label75
   320 jump *label77 equal true false
-    * set *tmp102 @time
-    * set :start *tmp102
+  321 set :start @time
   322 sensor *tmp103 @unit @dead
   323 op strictEqual *tmp104 *tmp103 0
   324 sensor *tmp105 @unit @controller
 
   358 jump *label79 always
   359 label *label78
   360 label *label79
-    * sensor *tmp115 .SORTER @config
-    * set .ITEM *tmp115
+  361 sensor .ITEM .SORTER @config
   362 op notEqual *tmp116 .ITEM .LAST_ITEM
   363 jump *label88 equal *tmp116 false
   364 label *label90
 
   366 jump *label92 equal *tmp118 false
   367 print "[salmon]No item type selected for transport."
   368 printflush message1
-    * sensor *tmp119 .SORTER @config
-    * set .ITEM *tmp119
+  369 sensor .ITEM .SORTER @config
   370 label *label91
   371 jump *label90 always
   372 label *label92
 
   409 jump *label103 equal *tmp132 false
   410 sensor *tmp134 .SRC .ITEM
   411 op sub *tmp135 *tmp134 .LOAD_LEVEL
-    * op max *tmp136 *tmp135 0
-    * set :max_load *tmp136
+  412 op max :max_load *tmp135 0
   413 ucontrol itemTake .SRC .ITEM :max_load
   414 sensor *tmp137 @unit @totalItems
   415 op greaterThanEq *tmp138 *tmp137 .UNIT_CAPACITY
 
   434 jump *label109 equal *tmp142 false
   435 sensor *tmp144 .DST .ITEM
   436 op sub *tmp145 .DROP_LEVEL *tmp144
-    * op max *tmp146 *tmp145 0
-    * set :max_drop *tmp146
+  437 op max :max_drop *tmp145 0
   438 ucontrol itemDrop .DST :max_drop
   439 sensor *tmp147 @unit @totalItems
   440 op lessThanEq *tmp148 *tmp147 0
 
   577 label *label113
   578 op add :iter :iter 1
   579 label *label114
-    * op sub *tmp192 @time :start
-    * set :loop_time *tmp192
+  580 op sub :loop_time @time :start
   581 label *label76
   582 jump *label75 always
   583 label *label77

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-6 instructions):
 
    22 jump *label5 equal *tmp5 false
    23 set :rebindUnit:first_unit null
    24 label *label7
-    * jump *label9 equal true false
    25 ubind UNIT
    26 op notEqual *tmp7 @unit null
    27 jump *label10 equal *tmp7 false
 
    59 jump *label12 always
    60 label *label14
    61 label *label19
-    * jump *label21 equal true false
    62 ubind UNIT
    63 op equal *tmp17 @unit null
    64 jump *label22 equal *tmp17 false
 
    94 op div .SPEED_SEC *tmp23 10
    95 ucontrol flag 1
    96 label *label26
-    * jump *label28 equal true false
    97 set .CONTAINER null
    98 set .DROP_TARGET null
    99 set :n @links
 
   314 set :state 1
   315 ucontrol stop
   316 label *label75
-    * jump *label77 equal true false
   317 set :start @time
   318 sensor *tmp103 @unit @dead
   319 op strictEqual *tmp104 *tmp103 0
 
   322 op lessThanEq *tmp107 *tmp104 *tmp106
   323 jump *label78 equal *tmp107 false
   324 label *label81
-    * jump *label83 equal true false
   325 ubind UNIT
   326 op equal *tmp110 @unit null
   327 jump *label84 equal *tmp110 false
 
   496 print *tmp159
   497 print "[]"
   498 print "\n"
-    * jump *label121 equal true false
   499 op equal *tmp161 :show_state 2
   500 jump *label123 equal *tmp161 false
   501 sensor *tmp163 @unit @x

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-2 instructions):
 
    55 label *label17
    56 sensor *tmp14 :rebindUnit:first_unit @dead
    57 op strictEqual *tmp15 *tmp14 0
-    * jump *label14 equal *tmp15 false
-    * jump *label12 always
+   58 jump *label12 notEqual *tmp15 false
    59 label *label14
    60 label *label19
    61 ubind UNIT
 
   595 label *label141
   596 sensor *tmp198 .DST @dead
   597 op strictNotEqual *tmp199 *tmp198 0
-    * jump *label140 notEqual *tmp199 false
-    * jump *label138 always
+  598 jump *label138 equal *tmp199 false
   599 label *label140
   600 control enabled switch1 false
   601 label *label142

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-55 instructions):
 
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
-    * op equal *tmp3 *tmp2 false
-    * jump *label2 equal *tmp3 false
+    9 jump *label2 notEqual *tmp2 false
    10 print "Unit Transport - Single"
    11 print "\n"
    12 print "Activate switch to start."
 
    17 label *label2
    18 label *label3
    19 sensor *tmp4 @unit @dead
-    * op strictNotEqual *tmp5 *tmp4 0
-    * jump *label5 equal *tmp5 false
+   20 jump *label5 strictEqual *tmp4 0
    21 set :rebindUnit:first_unit null
    22 label *label7
    23 ubind UNIT
-    * op notEqual *tmp7 @unit null
-    * jump *label10 equal *tmp7 false
+   24 jump *label10 equal @unit null
    25 set :rebindUnit:first_unit @unit
    26 jump *label9 always
    27 jump *label11 always
 
    37 label *label9
    38 label *label12
    39 sensor *tmp10 @unit @controller
-    * op equal *tmp11 *tmp10 @this
-    * jump *label15 equal *tmp11 false
+   40 jump *label15 notEqual *tmp10 @this
    41 jump *label6 always
    42 jump *label16 always
    43 label *label15
 
    46 print "[gold]Looking for old unit..."
    47 printflush message1
    48 label *label13
-    * op notEqual *tmp13 @unit :rebindUnit:first_unit
-    * jump *label14 equal *tmp13 false
+   49 jump *label14 equal @unit :rebindUnit:first_unit
    50 label *label17
    51 sensor *tmp14 :rebindUnit:first_unit @dead
-    * op strictEqual *tmp15 *tmp14 0
-    * jump *label12 notEqual *tmp15 false
+   52 jump *label12 strictEqual *tmp14 0
    53 label *label14
    54 label *label19
    55 ubind UNIT
-    * op equal *tmp17 @unit null
-    * jump *label22 equal *tmp17 false
+   56 jump *label22 notEqual @unit null
    57 print "[salmon]No unit of type "
    58 print UNIT
    59 print " "
 
    61 jump *label23 always
    62 label *label22
    63 sensor *tmp19 @unit @controlled
-    * op notEqual *tmp20 *tmp19 0
-    * jump *label24 equal *tmp20 false
+   64 jump *label24 equal *tmp19 0
    65 print "[salmon]Looking for a free "
    66 print UNIT
    67 print "."
 
    89 set .DROP_TARGET null
    90 set :n @links
    91 label *label29
-    * op greaterThan *tmp26 :n 0
-    * jump *label31 equal *tmp26 false
+   92 jump *label31 lessThanEq :n 0
    93 op sub :n :n 1
    94 getlink :block :n
    95 sensor *tmp29 :block @itemCapacity
-    * op greaterThan *tmp30 *tmp29 0
-    * jump *label32 equal *tmp30 false
+   96 jump *label32 lessThanEq *tmp29 0
    97 set .DROP_TARGET .CONTAINER
    98 set .CONTAINER :block
    99 jump *label33 always
 
   102 label *label30
   103 jump *label29 always
   104 label *label31
-    * op equal *tmp32 .CONTAINER null
-    * jump *label34 equal *tmp32 false
+  105 jump *label34 notEqual .CONTAINER null
   106 print "[salmon]No destination."
   107 print "\n"
   108 jump *label35 always
   109 label *label34
-    * op notEqual *tmp34 .DROP_TARGET null
-    * jump *label36 equal *tmp34 false
+  110 jump *label36 equal .DROP_TARGET null
   111 label *label39
   112 sensor *tmp35 .DROP_TARGET @itemCapacity
-    * op lessThan *tmp36 *tmp35 300
-    * jump *label36 equal *tmp36 false
+  113 jump *label36 greaterThanEq *tmp35 300
   114 jump *label38 always
   115 label *label38
   116 print "Destination: "
 
   134 set .CORE_Y null
   135 set .CORE_X .CORE_Y
   136 set .CORE .CORE_X
-    * op equal *tmp38 LINK_ID 0
-    * jump *label40 equal *tmp38 false
+  137 jump *label40 notEqual LINK_ID 0
   138 print "[gold]Locating core..."
   139 printflush message1
   140 ulocate building core false @copper .CORE_X .CORE_Y *tmp41 .CORE
 
   149 set :flag .QUERY_FLAG
   150 ucontrol flag :flag
   151 label *label42
-    * op equal *tmp43 :flag .QUERY_FLAG
-    * jump *label44 equal *tmp43 false
+  152 jump *label44 notEqual :flag .QUERY_FLAG
   153 label *label46
   154 sensor *tmp44 @unit @dead
-    * op strictEqual *tmp45 *tmp44 0
-    * jump *label44 equal *tmp45 false
+  155 jump *label44 strictNotEqual *tmp44 0
   156 jump *label45 always
   157 label *label45
   158 ucontrol stop
 
   160 label *label43
   161 jump *label42 always
   162 label *label44
-    * op notEqual *tmp47 :flag .QUERY_FLAG
-    * jump *label47 equal *tmp47 false
+  163 jump *label47 equal :flag .QUERY_FLAG
   164 op idiv :position :flag 100
   165 op mod .CORE_X :position @mapw
   166 op idiv .CORE_Y :position @mapw
   167 label *label49
   168 ucontrol within .CORE_X .CORE_Y 8 *tmp52
-    * op equal *tmp53 *tmp52 false
-    * jump *label51 equal *tmp53 false
+  169 jump *label51 notEqual *tmp52 false
   170 label *label53
   171 sensor *tmp54 @unit @dead
-    * op equal *tmp55 *tmp54 0
-    * jump *label51 equal *tmp55 false
+  172 jump *label51 notEqual *tmp54 0
   173 jump *label52 always
   174 label *label52
   175 ucontrol approach .CORE_X .CORE_Y 6
 
   177 jump *label49 always
   178 label *label51
   179 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp57
-    * op notEqual *tmp58 :b_type @vault
-    * jump *label54 equal *tmp58 false
+  180 jump *label54 equal :b_type @vault
   181 set .CORE null
   182 jump *label55 always
   183 label *label54
 
   186 label *label47
   187 label *label48
   188 label *label41
-    * op equal *tmp60 .CORE null
-    * jump *label56 equal *tmp60 false
+  189 jump *label56 notEqual .CORE null
   190 end
   191 jump *label57 always
   192 label *label56
 
   194 set .SORTER sorter1
   195 sensor :sorter_type .SORTER @type
   196 label *label58
-    * op notEqual *tmp63 :sorter_type @sorter
-    * jump *label60 equal *tmp63 false
+  197 jump *label60 equal :sorter_type @sorter
   198 label *label62
-    * op notEqual *tmp64 :sorter_type @inverted-sorter
-    * jump *label60 equal *tmp64 false
+  199 jump *label60 equal :sorter_type @inverted-sorter
   200 jump *label61 always
   201 label *label61
   202 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   203 print "\n"
-    * op notEqual *tmp65 .SORTER null
-    * jump *label63 equal *tmp65 false
+  204 jump *label63 equal .SORTER null
   205 print "Block found: "
   206 print .SORTER
   207 jump *label64 always
 
   213 label *label59
   214 jump *label58 always
   215 label *label60
-    * op equal *tmp68 :sorter_type @sorter
-    * jump *label65 equal *tmp68 false
+  216 jump *label65 notEqual :sorter_type @sorter
   217 set .SHOW_REMOTE_LEVEL true
   218 set .SRC .CORE
   219 set .DST .CONTAINER
 
   226 op idiv .DROP_LEVEL *tmp75 100
   227 set .LOCAL_MARGIN .DROP_LEVEL
   228 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op equal *tmp77 LINK_ID 0
-    * jump *label67 equal *tmp77 false
+  229 jump *label67 notEqual LINK_ID 0
   230 set *tmp78 "[] from core"
   231 jump *label68 always
   232 label *label67
 
   250 op add .DROP_LEVEL *tmp86 *tmp88
   251 set .LOCAL_MARGIN .LOAD_LEVEL
   252 set .REMOTE_MARGIN .DROP_LEVEL
-    * op equal *tmp90 LINK_ID 0
-    * jump *label69 equal *tmp90 false
+  253 jump *label69 notEqual LINK_ID 0
   254 set *tmp91 "[] to core"
   255 jump *label70 always
   256 label *label69
 
   258 label *label70
   259 set .DIRECTION *tmp91
   260 label *label66
-    * op equal *tmp92 LINK_ID 0
-    * jump *label71 equal *tmp92 false
+  261 jump *label71 notEqual LINK_ID 0
   262 set *tmp93 ""
   263 jump *label72 always
   264 label *label71
 
   269 sensor .SRC_Y .SRC @y
   270 sensor .DST_X .DST @x
   271 sensor .DST_Y .DST @y
-    * op equal *tmp98 .DROP_TARGET null
-    * jump *label73 equal *tmp98 false
+  272 jump *label73 notEqual .DROP_TARGET null
   273 set .DROP_TARGET .CORE
   274 set .DROP_X .CORE_X
   275 set .DROP_Y .CORE_Y
 
   289 op strictEqual *tmp104 *tmp103 0
   290 sensor *tmp105 @unit @controller
   291 op notEqual *tmp106 *tmp105 @this
-    * op lessThanEq *tmp107 *tmp104 *tmp106
-    * jump *label78 equal *tmp107 false
+  292 jump *label78 greaterThan *tmp104 *tmp106
   293 label *label81
   294 ubind UNIT
-    * op equal *tmp110 @unit null
-    * jump *label84 equal *tmp110 false
+  295 jump *label84 notEqual @unit null
   296 print "[salmon]No unit of type "
   297 print UNIT
   298 print " "
 
   300 jump *label85 always
   301 label *label84
   302 sensor *tmp112 @unit @controlled
-    * op notEqual *tmp113 *tmp112 0
-    * jump *label86 equal *tmp113 false
+  303 jump *label86 equal *tmp112 0
   304 print "[salmon]Looking for a free "
   305 print UNIT
   306 print "."
 
   321 label *label78
   322 label *label79
   323 sensor .ITEM .SORTER @config
-    * op notEqual *tmp116 .ITEM .LAST_ITEM
-    * jump *label88 equal *tmp116 false
+  324 jump *label88 equal .ITEM .LAST_ITEM
   325 label *label90
-    * op equal *tmp118 .ITEM null
-    * jump *label92 equal *tmp118 false
+  326 jump *label92 notEqual .ITEM null
   327 print "[salmon]No item type selected for transport."
   328 printflush message1
   329 sensor .ITEM .SORTER @config
 
   336 label *label88
   337 label *label89
   338 set :show_state 0
-    * op equal *tmp120 :state 1
-    * jump *label93 equal *tmp120 false
+  339 jump *label93 notEqual :state 1
   340 sensor *tmp122 @unit @firstItem
-    * op equal *tmp123 *tmp122 .ITEM
-    * jump *label95 equal *tmp123 false
+  341 jump *label95 notEqual *tmp122 .ITEM
   342 set :state 3
   343 jump *label96 always
   344 label *label95
   345 sensor *tmp125 @unit @totalItems
-    * op equal *tmp126 *tmp125 0
-    * jump *label97 equal *tmp126 false
+  346 jump *label97 notEqual *tmp125 0
   347 set :state 2
   348 jump *label98 always
   349 label *label97
 
   360 jump *label94 always
   361 label *label93
   362 label *label94
-    * op equal *tmp130 :state 2
-    * jump *label101 equal *tmp130 false
+  363 jump *label101 notEqual :state 2
   364 ucontrol within .SRC_X .SRC_Y 8 *tmp132
   365 jump *label103 equal *tmp132 false
   366 sensor *tmp134 .SRC .ITEM
 
   368 op max :max_load *tmp135 0
   369 ucontrol itemTake .SRC .ITEM :max_load
   370 sensor *tmp137 @unit @totalItems
-    * op greaterThanEq *tmp138 *tmp137 .UNIT_CAPACITY
-    * jump *label105 equal *tmp138 false
+  371 jump *label105 lessThan *tmp137 .UNIT_CAPACITY
   372 set :state 3
   373 jump *label106 always
   374 label *label105
 
   383 jump *label102 always
   384 label *label101
   385 label *label102
-    * op equal *tmp140 :state 3
-    * jump *label107 equal *tmp140 false
+  386 jump *label107 notEqual :state 3
   387 ucontrol within .DST_X .DST_Y 8 *tmp142
   388 jump *label109 equal *tmp142 false
   389 sensor *tmp144 .DST .ITEM
 
   391 op max :max_drop *tmp145 0
   392 ucontrol itemDrop .DST :max_drop
   393 sensor *tmp147 @unit @totalItems
-    * op lessThanEq *tmp148 *tmp147 0
-    * jump *label111 equal *tmp148 false
+  394 jump *label111 greaterThan *tmp147 0
   395 set :state 2
   396 ucontrol approach .SRC_X .SRC_Y 6
   397 jump *label112 always
 
   407 jump *label108 always
   408 label *label107
   409 label *label108
-    * op greaterThan *tmp150 :iter 3
-    * jump *label113 equal *tmp150 false
+  410 jump *label113 lessThanEq :iter 3
   411 set :iter 0
   412 print "Moving [green]"
   413 print .ITEM
 
   420 print *tmp152
   421 print "["
   422 print "]"
-    * op lessThan *tmp153 .EFF_LOCAL_LIMIT 100
-    * jump *label115 equal *tmp153 false
+  423 jump *label115 greaterThanEq .EFF_LOCAL_LIMIT 100
   424 print " (limit [orange]"
   425 print .LOCAL_MARGIN
   426 print "["
 
   435 print *tmp156
   436 print "["
   437 print "]"
-    * op lessThan *tmp157 .EFF_REMOTE_LIMIT 100
-    * jump *label119 equal *tmp157 false
+  438 jump *label119 greaterThanEq .EFF_REMOTE_LIMIT 100
   439 print " (limit [orange]"
   440 print .REMOTE_MARGIN
   441 print "["
 
   451 print *tmp159
   452 print "[]"
   453 print "\n"
-    * op equal *tmp161 :show_state 2
-    * jump *label123 equal *tmp161 false
+  454 jump *label123 notEqual :show_state 2
   455 sensor *tmp163 @unit @x
   456 op sub *tmp164 .SRC_X *tmp163
   457 sensor *tmp165 @unit @y
 
   466 print "\n"
   467 jump *label124 always
   468 label *label123
-    * op equal *tmp170 :show_state 3
-    * jump *label125 equal *tmp170 false
+  469 jump *label125 notEqual :show_state 3
   470 sensor *tmp172 @unit @x
   471 op sub *tmp173 .DST_X *tmp172
   472 sensor *tmp174 @unit @y
 
   493 print "\n"
   494 printflush message1
   495 sensor *tmp180 switch1 @enabled
-    * op equal *tmp181 *tmp180 0
-    * jump *label127 equal *tmp181 false
+  496 jump *label127 notEqual *tmp180 0
   497 jump *label77 always
   498 jump *label128 always
   499 label *label127
   500 label *label128
   501 sensor *tmp183 .SRC @dead
-    * op notEqual *tmp184 *tmp183 0
-    * jump *label129 equal *tmp184 false
+  502 jump *label129 equal *tmp183 0
   503 jump *label77 always
   504 jump *label130 always
   505 label *label129
   506 label *label130
   507 sensor *tmp186 .DST @dead
-    * op notEqual *tmp187 *tmp186 0
-    * jump *label131 equal *tmp187 false
+  508 jump *label131 equal *tmp186 0
   509 jump *label77 always
   510 jump *label132 always
   511 label *label131
   512 label *label132
   513 sensor *tmp189 .SORTER @dead
-    * op notEqual *tmp190 *tmp189 0
-    * jump *label133 equal *tmp190 false
+  514 jump *label133 equal *tmp189 0
   515 jump *label77 always
   516 jump *label134 always
   517 label *label133
 
   526 label *label77
   527 label *label135
   528 sensor *tmp193 .SORTER @dead
-    * op strictEqual *tmp194 *tmp193 0
-    * op equal *tmp195 *tmp194 false
-    * jump *label137 equal *tmp195 false
+  529 jump *label137 strictEqual *tmp193 0
   530 print "[salmon]sorter1 is missing!"
   531 print "\n"
   532 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   538 jump *label135 always
   539 label *label137
   540 sensor *tmp196 .SRC @dead
-    * op strictNotEqual *tmp197 *tmp196 0
-    * jump *label140 notEqual *tmp197 false
+  541 jump *label140 strictNotEqual *tmp196 0
   542 label *label141
   543 sensor *tmp198 .DST @dead
-    * op strictNotEqual *tmp199 *tmp198 0
-    * jump *label138 equal *tmp199 false
+  544 jump *label138 strictEqual *tmp198 0
   545 label *label140
   546 control enabled switch1 false
   547 label *label142
   548 sensor *tmp202 switch1 @enabled
-    * op equal *tmp203 *tmp202 false
-    * jump *label144 equal *tmp203 false
+  549 jump *label144 notEqual *tmp202 false
   550 print "[salmon]Local or remote container became invalid."
   551 print "\n"
   552 print "[gold]Please fix and press button to reinitialize."

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-27 instructions):
 
    24 jump *label10 equal @unit null
    25 set :rebindUnit:first_unit @unit
    26 jump *label9 always
-    * jump *label11 always
    27 label *label10
    28 label *label11
    29 print "[salmon]No unit of type "
 
    38 sensor *tmp10 @unit @controller
    39 jump *label15 notEqual *tmp10 @this
    40 jump *label6 always
-    * jump *label16 always
    41 label *label15
    42 label *label16
    43 ubind UNIT
 
    94 jump *label32 lessThanEq *tmp29 0
    95 set .DROP_TARGET .CONTAINER
    96 set .CONTAINER :block
-    * jump *label33 always
    97 label *label32
    98 label *label33
    99 label *label30
 
   108 label *label39
   109 sensor *tmp35 .DROP_TARGET @itemCapacity
   110 jump *label36 greaterThanEq *tmp35 300
-    * jump *label38 always
   111 label *label38
   112 print "Destination: "
   113 print .CONTAINER
 
   149 label *label46
   150 sensor *tmp44 @unit @dead
   151 jump *label44 strictNotEqual *tmp44 0
-    * jump *label45 always
   152 label *label45
   153 ucontrol stop
   154 sensor :flag @unit @flag
 
   165 label *label53
   166 sensor *tmp54 @unit @dead
   167 jump *label51 notEqual *tmp54 0
-    * jump *label52 always
   168 label *label52
   169 ucontrol approach .CORE_X .CORE_Y 6
   170 label *label50
 
   173 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp57
   174 jump *label54 equal :b_type @vault
   175 set .CORE null
-    * jump *label55 always
   176 label *label54
   177 label *label55
-    * jump *label48 always
   178 label *label47
   179 label *label48
   180 label *label41
   181 jump *label56 notEqual .CORE null
   182 end
-    * jump *label57 always
   183 label *label56
   184 label *label57
   185 set .SORTER sorter1
 
   188 jump *label60 equal :sorter_type @sorter
   189 label *label62
   190 jump *label60 equal :sorter_type @inverted-sorter
-    * jump *label61 always
   191 label *label61
   192 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   193 print "\n"
   194 jump *label63 equal .SORTER null
   195 print "Block found: "
   196 print .SORTER
-    * jump *label64 always
   197 label *label63
   198 label *label64
   199 printflush message1
 
   306 label *label80
   307 ucontrol flag 1
   308 set :state 1
-    * jump *label79 always
   309 label *label78
   310 label *label79
   311 sensor .ITEM .SORTER @config
 
   320 label *label92
   321 set .LAST_ITEM .ITEM
   322 set :state 1
-    * jump *label89 always
   323 label *label88
   324 label *label89
   325 set :show_state 0
 
   339 ucontrol within .DROP_X .DROP_Y 8 *tmp128
   340 jump *label99 equal *tmp128 false
   341 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * jump *label100 always
   342 label *label99
   343 label *label100
   344 label *label98
   345 label *label96
-    * jump *label94 always
   346 label *label93
   347 label *label94
   348 jump *label101 notEqual :state 2
 
   365 set .MSG "\nGoing to source: [green]"
   366 set :show_state 2
   367 label *label104
-    * jump *label102 always
   368 label *label101
   369 label *label102
   370 jump *label107 notEqual :state 3
 
   388 set .MSG "\nGoing to destination: [green]"
   389 set :show_state 3
   390 label *label110
-    * jump *label108 always
   391 label *label107
   392 label *label108
   393 jump *label113 lessThanEq :iter 3
 
   408 print .LOCAL_MARGIN
   409 print "["
   410 print "])"
-    * jump *label116 always
   411 label *label115
   412 label *label116
   413 jump *label117 equal .SHOW_REMOTE_LEVEL false
 
   422 print .REMOTE_MARGIN
   423 print "["
   424 print "])"
-    * jump *label120 always
   425 label *label119
   426 label *label120
-    * jump *label118 always
   427 label *label117
   428 label *label118
   429 sensor *tmp159 @unit @totalItems
 
   459 print " "
   460 print "sec[]"
   461 print "\n"
-    * jump *label126 always
   462 label *label125
   463 label *label126
   464 label *label124
-    * jump *label122 always
   465 label *label121
   466 label *label122
   467 op floor *tmp179 :loop_time
 
   473 sensor *tmp180 switch1 @enabled
   474 jump *label127 notEqual *tmp180 0
   475 jump *label77 always
-    * jump *label128 always
   476 label *label127
   477 label *label128
   478 sensor *tmp183 .SRC @dead
   479 jump *label129 equal *tmp183 0
   480 jump *label77 always
-    * jump *label130 always
   481 label *label129
   482 label *label130
   483 sensor *tmp186 .DST @dead
   484 jump *label131 equal *tmp186 0
   485 jump *label77 always
-    * jump *label132 always
   486 label *label131
   487 label *label132
   488 sensor *tmp189 .SORTER @dead
   489 jump *label133 equal *tmp189 0
   490 jump *label77 always
-    * jump *label134 always
   491 label *label133
   492 label *label134
   493 jump *label114 always
 
   530 label *label143
   531 jump *label142 always
   532 label *label144
-    * jump *label139 always
   533 label *label138
   534 label *label139
   535 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   128 jump *label26 always
   129 label *label28
   130 set .CORE_Y null
-    * set .CORE_X .CORE_Y
-    * set .CORE .CORE_X
+  131 set .CORE_X null
+  132 set .CORE .CORE_Y
   133 jump *label40 notEqual LINK_ID 0
   134 print "[gold]Locating core..."
   135 printflush message1
 
   143 printflush message1
   144 op add .QUERY_FLAG 99999900 LINK_ID
   145 set :flag .QUERY_FLAG
-    * ucontrol flag :flag
+  146 ucontrol flag .QUERY_FLAG
   147 label *label42
   148 jump *label44 notEqual :flag .QUERY_FLAG
   149 label *label46
 
   183 label *label56
   184 label *label57
   185 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  186 sensor :sorter_type sorter1 @type
   187 label *label58
   188 jump *label60 equal :sorter_type @sorter
   189 label *label62
 
   198 label *label64
   199 printflush message1
   200 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  201 sensor :sorter_type sorter1 @type
   202 label *label59
   203 jump *label58 always
   204 label *label60
 
   206 set .SHOW_REMOTE_LEVEL true
   207 set .SRC .CORE
   208 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  209 sensor :src_capacity .CORE @itemCapacity
+  210 sensor :dst_capacity .CONTAINER @itemCapacity
   211 op sub *tmp72 100 .EFF_REMOTE_LIMIT
   212 op mul *tmp73 :src_capacity *tmp72
   213 op idiv .LOAD_LEVEL *tmp73 100
 
   227 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   228 set .SRC .CONTAINER
   229 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  230 sensor :src_capacity .CONTAINER @itemCapacity
+  231 sensor :dst_capacity .CORE @itemCapacity
   232 op sub *tmp82 100 .EFF_LOCAL_LIMIT
   233 op mul *tmp83 :src_capacity *tmp82
   234 op idiv .LOAD_LEVEL *tmp83 100
 
   395 print "Moving [green]"
   396 print .ITEM
   397 print .DIRECTION
-    * print .LINK_TXT
+  398 print *tmp93
   399 print "\"
   400 print "n"
   401 sensor *tmp152 .CONTAINER .ITEM

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   129 label *label28
   130 set .CORE_Y null
   131 set .CORE_X null
-    * set .CORE .CORE_Y
+  132 set .CORE null
   133 jump *label40 notEqual LINK_ID 0
   134 print "[gold]Locating core..."
   135 printflush message1
 
   253 label *label71
   254 set *tmp93 LINK_ID
   255 label *label72
-    * set .LINK_TXT *tmp93
   256 sensor .SRC_X .SRC @x
   257 sensor .SRC_Y .SRC @y
   258 sensor .DST_X .DST @x

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    88 set :n @links
    89 label *label29
    90 jump *label31 lessThanEq :n 0
+   91 label *label145
    92 op sub :n :n 1
    93 getlink :block :n
    94 sensor *tmp29 :block @itemCapacity
 
    98 label *label32
    99 label *label33
   100 label *label30
-    * jump *label29 always
+  101 jump *label145 greaterThan :n 0
   102 label *label31
   103 jump *label34 notEqual .CONTAINER null
   104 print "[salmon]No destination."
 
   312 jump *label88 equal .ITEM .LAST_ITEM
   313 label *label90
   314 jump *label92 notEqual .ITEM null
+  315 label *label146
   316 print "[salmon]No item type selected for transport."
   317 printflush message1
   318 sensor .ITEM .SORTER @config
   319 label *label91
-    * jump *label90 always
+  320 jump *label146 equal .ITEM null
   321 label *label92
   322 set .LAST_ITEM .ITEM
   323 set :state 1

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-12 instructions):
 
   172 jump *label49 always
   173 label *label51
   174 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp57
-    * jump *label54 equal :b_type @vault
-    * set .CORE null
-    * label *label54
-    * label *label55
+  175 select .CORE notEqual :b_type @vault null .CORE
   176 label *label47
   177 label *label48
   178 label *label41
 
   213 op idiv .DROP_LEVEL *tmp75 100
   214 set .LOCAL_MARGIN .DROP_LEVEL
   215 set .REMOTE_MARGIN .LOAD_LEVEL
-    * jump *label67 notEqual LINK_ID 0
-    * set *tmp78 "[] from core"
-    * jump *label68 always
-    * label *label67
-    * set *tmp78 "[] from vault #"
-    * label *label68
+  216 select *tmp78 equal LINK_ID 0 "[] from core" "[] from vault #"
   217 set .DIRECTION *tmp78
   218 jump *label66 always
   219 label *label65
 
   232 op add .DROP_LEVEL *tmp86 *tmp88
   233 set .LOCAL_MARGIN .LOAD_LEVEL
   234 set .REMOTE_MARGIN .DROP_LEVEL
-    * jump *label69 notEqual LINK_ID 0
-    * set *tmp91 "[] to core"
-    * jump *label70 always
-    * label *label69
-    * set *tmp91 "[] to vault #"
-    * label *label70
+  235 select *tmp91 equal LINK_ID 0 "[] to core" "[] to vault #"
   236 set .DIRECTION *tmp91
   237 label *label66
-    * jump *label71 notEqual LINK_ID 0
-    * set *tmp93 ""
-    * jump *label72 always
-    * label *label71
-    * set *tmp93 LINK_ID
-    * label *label72
+  238 select *tmp93 equal LINK_ID 0 "" LINK_ID
   239 sensor .SRC_X .SRC @x
   240 sensor .SRC_Y .SRC @y
   241 sensor .DST_X .DST @x
 
   335 op sub *tmp135 *tmp134 .LOAD_LEVEL
   336 op max :max_load *tmp135 0
   337 ucontrol itemTake .SRC .ITEM :max_load
-    * sensor *tmp137 @unit @totalItems
-    * jump *label105 lessThan *tmp137 .UNIT_CAPACITY
-    * set :state 3
-    * jump *label106 always
-    * label *label105
-    * set .MSG "\nLoading items: [green]"
-    * label *label106
+  338 sensor *tmp137 @unit @totalItems
+  339 select :state greaterThanEq *tmp137 .UNIT_CAPACITY 3 :state
+  340 select .MSG greaterThanEq *tmp137 .UNIT_CAPACITY .MSG "\nLoading items: [green]"
   341 jump *label104 always
   342 label *label103
   343 ucontrol approach .SRC_X .SRC_Y 6

Modifications by Replicate loop condition at line 43:1 (+1 instructions):
 
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
     9 jump *label2 notEqual *tmp2 false
+   10 label *label147
    11 print "Unit Transport - Single"
    12 print "\n"
    13 print "Activate switch to start."
    14 print "\n"
    15 printflush message1
    16 label *label1
-    * jump *label0 always
+   17 sensor *tmp2 switch1 @enabled
+   18 jump *label147 equal *tmp2 false
    19 label *label2
    20 label *label3
    21 sensor *tmp4 @unit @dead

Modifications by Replicate loop condition at line 51:1 (+1 instructions):
 
    20 label *label3
    21 sensor *tmp4 @unit @dead
    22 jump *label5 strictEqual *tmp4 0
+   23 label *label148
    24 set :rebindUnit:first_unit null
    25 label *label7
    26 ubind UNIT
 
    79 label *label18
    80 label *label6
    81 label *label4
-    * jump *label3 always
+   82 sensor *tmp4 @unit @dead
+   83 jump *label148 strictNotEqual *tmp4 0
    84 label *label5
    85 sensor .UNIT_CAPACITY @unit @itemCapacity
    86 sensor *tmp23 @unit @speed

Modifications by Replicate loop condition at line 304:1 (+1 instructions):
 
   484 label *label135
   485 sensor *tmp193 .SORTER @dead
   486 jump *label137 strictEqual *tmp193 0
+  487 label *label149
   488 print "[salmon]sorter1 is missing!"
   489 print "\n"
   490 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   493 printflush message2
   494 set .SORTER sorter1
   495 label *label136
-    * jump *label135 always
+  496 sensor *tmp193 .SORTER @dead
+  497 jump *label149 strictNotEqual *tmp193 0
   498 label *label137
   499 sensor *tmp196 .SRC @dead
   500 jump *label140 strictNotEqual *tmp196 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   493 printflush message2
   494 set .SORTER sorter1
   495 label *label136
-    * sensor *tmp193 .SORTER @dead
+  496 sensor *tmp193 sorter1 @dead
   497 jump *label149 strictNotEqual *tmp193 0
   498 label *label137
   499 sensor *tmp196 .SRC @dead

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   491 print "\n"
   492 printflush message1
   493 printflush message2
-    * set .SORTER sorter1
   494 label *label136
   495 sensor *tmp193 sorter1 @dead
   496 jump *label149 strictNotEqual *tmp193 0

Modifications by Replicate loop condition at line 314:5 (+1 instructions):
 
   505 label *label142
   506 sensor *tmp202 switch1 @enabled
   507 jump *label144 notEqual *tmp202 false
+  508 label *label150
   509 print "[salmon]Local or remote container became invalid."
   510 print "\n"
   511 print "[gold]Please fix and press button to reinitialize."
 
   513 printflush message1
   514 printflush message2
   515 label *label143
-    * jump *label142 always
+  516 sensor *tmp202 switch1 @enabled
+  517 jump *label150 equal *tmp202 false
   518 label *label144
   519 label *label138
   520 label *label139

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-2 instructions):
 
   217 op idiv .DROP_LEVEL *tmp75 100
   218 set .LOCAL_MARGIN .DROP_LEVEL
   219 set .REMOTE_MARGIN .LOAD_LEVEL
-    * select *tmp78 equal LINK_ID 0 "[] from core" "[] from vault #"
-    * set .DIRECTION *tmp78
+  220 select .DIRECTION equal LINK_ID 0 "[] from core" "[] from vault #"
   221 jump *label66 always
   222 label *label65
   223 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   235 op add .DROP_LEVEL *tmp86 *tmp88
   236 set .LOCAL_MARGIN .LOAD_LEVEL
   237 set .REMOTE_MARGIN .DROP_LEVEL
-    * select *tmp91 equal LINK_ID 0 "[] to core" "[] to vault #"
-    * set .DIRECTION *tmp91
+  238 select .DIRECTION equal LINK_ID 0 "[] to core" "[] to vault #"
   239 label *label66
   240 select *tmp93 equal LINK_ID 0 "" LINK_ID
   241 sensor .SRC_X .SRC @x

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     4 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
     5 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
     6 set .MSG null
-    * label *label0
     7 sensor *tmp2 switch1 @enabled
     8 jump *label2 notEqual *tmp2 false
     9 label *label147
 
    12 print "Activate switch to start."
    13 print "\n"
    14 printflush message1
-    * label *label1
    15 sensor *tmp2 switch1 @enabled
    16 jump *label147 equal *tmp2 false
    17 label *label2
-    * label *label3
    18 sensor *tmp4 @unit @dead
    19 jump *label5 strictEqual *tmp4 0
    20 label *label148
 
    25 set :rebindUnit:first_unit @unit
    26 jump *label9 always
    27 label *label10
-    * label *label11
    28 print "[salmon]No unit of type "
    29 print UNIT
    30 print " "
    31 print "found. 1"
    32 printflush message1
-    * label *label8
    33 jump *label7 always
    34 label *label9
    35 label *label12
 
    37 jump *label15 notEqual *tmp10 @this
    38 jump *label6 always
    39 label *label15
-    * label *label16
    40 ubind UNIT
    41 print "[gold]Looking for old unit..."
    42 printflush message1
-    * label *label13
    43 jump *label14 equal @unit :rebindUnit:first_unit
-    * label *label17
    44 sensor *tmp14 :rebindUnit:first_unit @dead
    45 jump *label12 strictEqual *tmp14 0
    46 label *label14
 
    65 label *label25
    66 label *label23
    67 printflush message1
-    * label *label20
    68 jump *label19 always
-    * label *label21
    69 label *label18
    70 label *label6
-    * label *label4
    71 sensor *tmp4 @unit @dead
    72 jump *label148 strictNotEqual *tmp4 0
    73 label *label5
 
    79 set .CONTAINER null
    80 set .DROP_TARGET null
    81 set :n @links
-    * label *label29
    82 jump *label31 lessThanEq :n 0
    83 label *label145
    84 op sub :n :n 1
 
    88 set .DROP_TARGET .CONTAINER
    89 set .CONTAINER :block
    90 label *label32
-    * label *label33
-    * label *label30
    91 jump *label145 greaterThan :n 0
    92 label *label31
    93 jump *label34 notEqual .CONTAINER null
 
    96 jump *label35 always
    97 label *label34
    98 jump *label36 equal .DROP_TARGET null
-    * label *label39
    99 sensor *tmp35 .DROP_TARGET @itemCapacity
   100 jump *label36 greaterThanEq *tmp35 300
-    * label *label38
   101 print "Destination: "
   102 print .CONTAINER
   103 print "\"
 
   113 label *label37
   114 label *label35
   115 printflush message1
-    * label *label27
   116 jump *label26 always
   117 label *label28
   118 set .CORE_Y null
 
   134 ucontrol flag .QUERY_FLAG
   135 label *label42
   136 jump *label44 notEqual :flag .QUERY_FLAG
-    * label *label46
   137 sensor *tmp44 @unit @dead
   138 jump *label44 strictNotEqual *tmp44 0
-    * label *label45
   139 ucontrol stop
   140 sensor :flag @unit @flag
-    * label *label43
   141 jump *label42 always
   142 label *label44
   143 jump *label47 equal :flag .QUERY_FLAG
 
   147 label *label49
   148 ucontrol within .CORE_X .CORE_Y 8 *tmp52
   149 jump *label51 notEqual *tmp52 false
-    * label *label53
   150 sensor *tmp54 @unit @dead
   151 jump *label51 notEqual *tmp54 0
-    * label *label52
   152 ucontrol approach .CORE_X .CORE_Y 6
-    * label *label50
   153 jump *label49 always
   154 label *label51
   155 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp57
   156 select .CORE notEqual :b_type @vault null .CORE
   157 label *label47
-    * label *label48
   158 label *label41
   159 jump *label56 notEqual .CORE null
   160 end
   161 label *label56
-    * label *label57
   162 set .SORTER sorter1
   163 sensor :sorter_type sorter1 @type
   164 label *label58
   165 jump *label60 equal :sorter_type @sorter
-    * label *label62
   166 jump *label60 equal :sorter_type @inverted-sorter
-    * label *label61
   167 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   168 print "\n"
   169 jump *label63 equal .SORTER null
   170 print "Block found: "
   171 print .SORTER
   172 label *label63
-    * label *label64
   173 printflush message1
   174 set .SORTER sorter1
   175 sensor :sorter_type sorter1 @type
-    * label *label59
   176 jump *label58 always
   177 label *label60
   178 jump *label65 notEqual :sorter_type @sorter
 
   255 label *label87
   256 label *label85
   257 printflush message1
-    * label *label82
   258 jump *label81 always
-    * label *label83
   259 label *label80
   260 ucontrol flag 1
   261 set :state 1
   262 label *label78
-    * label *label79
   263 sensor .ITEM .SORTER @config
   264 jump *label88 equal .ITEM .LAST_ITEM
-    * label *label90
   265 jump *label92 notEqual .ITEM null
   266 label *label146
   267 print "[salmon]No item type selected for transport."
   268 printflush message1
   269 sensor .ITEM .SORTER @config
-    * label *label91
   270 jump *label146 equal .ITEM null
   271 label *label92
   272 set .LAST_ITEM .ITEM
   273 set :state 1
   274 label *label88
-    * label *label89
   275 set :show_state 0
   276 jump *label93 notEqual :state 1
   277 sensor *tmp122 @unit @firstItem
 
   290 jump *label99 equal *tmp128 false
   291 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
   292 label *label99
-    * label *label100
   293 label *label98
   294 label *label96
   295 label *label93
-    * label *label94
   296 jump *label101 notEqual :state 2
   297 ucontrol within .SRC_X .SRC_Y 8 *tmp132
   298 jump *label103 equal *tmp132 false
 
   310 set :show_state 2
   311 label *label104
   312 label *label101
-    * label *label102
   313 jump *label107 notEqual :state 3
   314 ucontrol within .DST_X .DST_Y 8 *tmp142
   315 jump *label109 equal *tmp142 false
 
   332 set :show_state 3
   333 label *label110
   334 label *label107
-    * label *label108
   335 jump *label113 lessThanEq :iter 3
   336 set :iter 0
   337 print "Moving [green]"
 
   351 print "["
   352 print "])"
   353 label *label115
-    * label *label116
   354 jump *label117 equal .SHOW_REMOTE_LEVEL false
   355 sensor *tmp156 .CORE .ITEM
   356 print "\n"
 
   364 print "["
   365 print "])"
   366 label *label119
-    * label *label120
   367 label *label117
-    * label *label118
   368 sensor *tmp159 @unit @totalItems
   369 print .MSG
   370 print *tmp159
 
   399 print "sec[]"
   400 print "\n"
   401 label *label125
-    * label *label126
   402 label *label124
-    * label *label121
-    * label *label122
   403 op floor *tmp179 :loop_time
   404 print "[lightgray]Loop time: "
   405 print *tmp179
 
   410 jump *label127 notEqual *tmp180 0
   411 jump *label77 always
   412 label *label127
-    * label *label128
   413 sensor *tmp183 .SRC @dead
   414 jump *label129 equal *tmp183 0
   415 jump *label77 always
   416 label *label129
-    * label *label130
   417 sensor *tmp186 .DST @dead
   418 jump *label131 equal *tmp186 0
   419 jump *label77 always
   420 label *label131
-    * label *label132
   421 sensor *tmp189 .SORTER @dead
   422 jump *label133 equal *tmp189 0
   423 jump *label77 always
   424 label *label133
-    * label *label134
   425 jump *label114 always
   426 label *label113
   427 op add :iter :iter 1
   428 label *label114
   429 op sub :loop_time @time :start
-    * label *label76
   430 jump *label75 always
   431 label *label77
-    * label *label135
   432 sensor *tmp193 .SORTER @dead
   433 jump *label137 strictEqual *tmp193 0
   434 label *label149
 
   438 print "\n"
   439 printflush message1
   440 printflush message2
-    * label *label136
   441 sensor *tmp193 sorter1 @dead
   442 jump *label149 strictNotEqual *tmp193 0
   443 label *label137
   444 sensor *tmp196 .SRC @dead
   445 jump *label140 strictNotEqual *tmp196 0
-    * label *label141
   446 sensor *tmp198 .DST @dead
   447 jump *label138 strictEqual *tmp198 0
   448 label *label140
   449 control enabled switch1 false
-    * label *label142
   450 sensor *tmp202 switch1 @enabled
   451 jump *label144 notEqual *tmp202 false
   452 label *label150
 
   456 print "\n"
   457 printflush message1
   458 printflush message2
-    * label *label143
   459 sensor *tmp202 switch1 @enabled
   460 jump *label150 equal *tmp202 false
   461 label *label144
   462 label *label138
-    * label *label139
   463 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-5 instructions):
 
    34 label *label9
    35 label *label12
    36 sensor *tmp10 @unit @controller
-    * jump *label15 notEqual *tmp10 @this
-    * jump *label6 always
+   37 jump *label6 equal *tmp10 @this
    38 label *label15
    39 ubind UNIT
    40 print "[gold]Looking for old unit..."
 
   406 print "\n"
   407 printflush message1
   408 sensor *tmp180 switch1 @enabled
-    * jump *label127 notEqual *tmp180 0
-    * jump *label77 always
+  409 jump *label77 equal *tmp180 0
   410 label *label127
   411 sensor *tmp183 .SRC @dead
-    * jump *label129 equal *tmp183 0
-    * jump *label77 always
+  412 jump *label77 notEqual *tmp183 0
   413 label *label129
   414 sensor *tmp186 .DST @dead
-    * jump *label131 equal *tmp186 0
-    * jump *label77 always
+  415 jump *label77 notEqual *tmp186 0
   416 label *label131
   417 sensor *tmp189 .SORTER @dead
-    * jump *label133 equal *tmp189 0
-    * jump *label77 always
+  418 jump *label77 notEqual *tmp189 0
   419 label *label133
   420 jump *label114 always
   421 label *label113

Modifications by Jumps phase, Condition Optimization, pass 4, iteration 1:
 
    35 label *label12
    36 sensor *tmp10 @unit @controller
    37 jump *label6 equal *tmp10 @this
-    * label *label15
    38 ubind UNIT
    39 print "[gold]Looking for old unit..."
    40 printflush message1
 
   406 printflush message1
   407 sensor *tmp180 switch1 @enabled
   408 jump *label77 equal *tmp180 0
-    * label *label127
   409 sensor *tmp183 .SRC @dead
   410 jump *label77 notEqual *tmp183 0
-    * label *label129
   411 sensor *tmp186 .DST @dead
   412 jump *label77 notEqual *tmp186 0
-    * label *label131
   413 sensor *tmp189 .SORTER @dead
   414 jump *label77 notEqual *tmp189 0
-    * label *label133
   415 jump *label114 always
   416 label *label113
   417 op add :iter :iter 1

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 set UNIT @mega
     2 set LINK_ID 0
     3 set LOCAL_LIMIT 100
 
    53 jump *label23 always
    54 label *label22
    55 sensor *tmp19 @unit @controlled
-    * jump *label24 equal *tmp19 0
+   56 jump *label18 equal *tmp19 0
    57 print "[salmon]Looking for a free "
    58 print UNIT
    59 print "."
 
    94 print "\n"
    95 jump *label35 always
    96 label *label34
-    * jump *label36 equal .DROP_TARGET null
+   97 jump *label28 equal .DROP_TARGET null
    98 sensor *tmp35 .DROP_TARGET @itemCapacity
-    * jump *label36 greaterThanEq *tmp35 300
+   99 jump *label28 greaterThanEq *tmp35 300
   100 print "Destination: "
   101 print .CONTAINER
   102 print "\"
 
   243 jump *label85 always
   244 label *label84
   245 sensor *tmp112 @unit @controlled
-    * jump *label86 equal *tmp112 0
+  246 jump *label80 equal *tmp112 0
   247 print "[salmon]Looking for a free "
   248 print UNIT
   249 print "."
 
   320 jump *label111 greaterThan *tmp147 0
   321 set :state 2
   322 ucontrol approach .SRC_X .SRC_Y 6
-    * jump *label112 always
+  323 jump *label110 always
   324 label *label111
   325 set .MSG "\nDropping items: [green]"
   326 label *label112
 
   435 sensor *tmp196 .SRC @dead
   436 jump *label140 strictNotEqual *tmp196 0
   437 sensor *tmp198 .DST @dead
-    * jump *label138 strictEqual *tmp198 0
+  438 jump __start__ strictEqual *tmp198 0
   439 label *label140
   440 control enabled switch1 false
   441 sensor *tmp202 switch1 @enabled
-    * jump *label144 notEqual *tmp202 false
+  442 jump __start__ notEqual *tmp202 false
   443 label *label150
   444 print "[salmon]Local or remote container became invalid."
   445 print "\n"

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    59 print "."
    60 print ".."
    61 jump *label25 always
-    * label *label24
-    * jump *label18 always
    62 label *label25
    63 label *label23
    64 printflush message1
 
   105 print "n"
   106 print "[salmon]Item dump must be a container or a vault!"
   107 jump *label37 always
-    * label *label36
-    * jump *label28 always
   108 label *label37
   109 label *label35
   110 printflush message1
 
   245 print "."
   246 print ".."
   247 jump *label87 always
-    * label *label86
-    * jump *label80 always
   248 label *label87
   249 label *label85
   250 printflush message1
 
   317 jump *label110 always
   318 label *label111
   319 set .MSG "\nDropping items: [green]"
-    * label *label112
   320 jump *label110 always
   321 label *label109
   322 ucontrol approach .DST_X .DST_Y 6
 
   442 printflush message2
   443 sensor *tmp202 switch1 @enabled
   444 jump *label150 equal *tmp202 false
-    * label *label144
-    * label *label138
   445 end

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-4 instructions):
 
    58 print UNIT
    59 print "."
    60 print ".."
-    * jump *label25 always
    61 label *label25
    62 label *label23
    63 printflush message1
 
   103 print "\"
   104 print "n"
   105 print "[salmon]Item dump must be a container or a vault!"
-    * jump *label37 always
   106 label *label37
   107 label *label35
   108 printflush message1
 
   242 print UNIT
   243 print "."
   244 print ".."
-    * jump *label87 always
   245 label *label87
   246 label *label85
   247 printflush message1
 
   439 printflush message2
   440 sensor *tmp202 switch1 @enabled
   441 jump *label150 equal *tmp202 false
-    * end

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
    58 print UNIT
    59 print "."
    60 print ".."
-    * label *label25
    61 label *label23
    62 printflush message1
    63 jump *label19 always
 
   102 print "\"
   103 print "n"
   104 print "[salmon]Item dump must be a container or a vault!"
-    * label *label37
   105 label *label35
   106 printflush message1
   107 jump *label26 always
 
   240 print UNIT
   241 print "."
   242 print ".."
-    * label *label87
   243 label *label85
   244 printflush message1
   245 jump *label81 always

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
   112 jump *label40 notEqual LINK_ID 0
   113 print "[gold]Locating core..."
   114 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp41 .CORE
+  115 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   116 jump *label41 always
   117 label *label40
   118 print "[gold]Locating vault #"
 
   143 ucontrol approach .CORE_X .CORE_Y 6
   144 jump *label49 always
   145 label *label51
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp57
+  146 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   147 select .CORE notEqual :b_type @vault null .CORE
   148 label *label47
   149 label *label41

Modifications by Final phase, Print Merging, iteration 1 (-50 instructions):
 
     8 sensor *tmp2 switch1 @enabled
     9 jump *label2 notEqual *tmp2 false
    10 label *label147
-    * print "Unit Transport - Single"
-    * print "\n"
-    * print "Activate switch to start."
-    * print "\n"
+   11 print "Unit Transport - Single\nActivate switch to start.\n"
    12 printflush message1
    13 sensor *tmp2 switch1 @enabled
    14 jump *label147 equal *tmp2 false
 
    23 set :rebindUnit:first_unit @unit
    24 jump *label9 always
    25 label *label10
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 1"
+   26 print "[salmon]No unit of type {0} found. 1"
+   27 format UNIT
    28 printflush message1
    29 jump *label7 always
    30 label *label9
 
    41 label *label19
    42 ubind UNIT
    43 jump *label22 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+   44 print "[salmon]No unit of type {0} found. 2"
+   45 format UNIT
    46 jump *label23 always
    47 label *label22
    48 sensor *tmp19 @unit @controlled
    49 jump *label18 equal *tmp19 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+   50 print "[salmon]Looking for a free {0}..."
+   51 format UNIT
    52 label *label23
    53 printflush message1
    54 jump *label19 always
 
    77 jump *label145 greaterThan :n 0
    78 label *label31
    79 jump *label34 notEqual .CONTAINER null
-    * print "[salmon]No destination."
-    * print "\n"
+   80 print "[salmon]No destination.\n"
    81 jump *label35 always
    82 label *label34
    83 jump *label28 equal .DROP_TARGET null
    84 sensor *tmp35 .DROP_TARGET @itemCapacity
    85 jump *label28 greaterThanEq *tmp35 300
-    * print "Destination: "
-    * print .CONTAINER
-    * print "\"
-    * print "n"
-    * print "Item dump: "
-    * print .DROP_TARGET
-    * print "\"
-    * print "n"
-    * print "[salmon]Item dump must be a container or a vault!"
+   86 print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
+   87 format .CONTAINER
+   88 format .DROP_TARGET
    89 label *label35
    90 printflush message1
    91 jump *label26 always
 
    99 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   100 jump *label41 always
   101 label *label40
-    * print "[gold]Locating vault #"
-    * print LINK_ID
-    * print "."
-    * print ".."
+  102 print "[gold]Locating vault #{0}..."
+  103 format LINK_ID
   104 printflush message1
   105 op add .QUERY_FLAG 99999900 LINK_ID
   106 set :flag .QUERY_FLAG
 
   137 label *label58
   138 jump *label60 equal :sorter_type @sorter
   139 jump *label60 equal :sorter_type @inverted-sorter
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  140 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   141 jump *label63 equal .SORTER null
   142 print "Block found: "
   143 print .SORTER
 
   209 label *label81
   210 ubind UNIT
   211 jump *label84 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+  212 print "[salmon]No unit of type {0} found. 2"
+  213 format UNIT
   214 jump *label85 always
   215 label *label84
   216 sensor *tmp112 @unit @controlled
   217 jump *label80 equal *tmp112 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+  218 print "[salmon]Looking for a free {0}..."
+  219 format UNIT
   220 label *label85
   221 printflush message1
   222 jump *label81 always
 
   297 label *label107
   298 jump *label113 lessThanEq :iter 3
   299 set :iter 0
-    * print "Moving [green]"
-    * print .ITEM
-    * print .DIRECTION
-    * print *tmp93
-    * print "\"
-    * print "n"
+  300 print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
+  301 format .ITEM
+  302 format .DIRECTION
+  303 format *tmp93
   304 sensor *tmp152 .CONTAINER .ITEM
-    * print "Local items: [gold]"
-    * print *tmp152
-    * print "["
-    * print "]"
+  305 format *tmp152
   306 jump *label115 greaterThanEq .EFF_LOCAL_LIMIT 100
-    * print " (limit [orange]"
-    * print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  307 print " (limit [orange]{0}[])"
+  308 format .LOCAL_MARGIN
   309 label *label115
   310 jump *label117 equal .SHOW_REMOTE_LEVEL false
   311 sensor *tmp156 .CORE .ITEM
-    * print "\n"
-    * print "Remote items: [gold]"
-    * print *tmp156
-    * print "["
-    * print "]"
+  312 print "\nRemote items: [gold]{0}[]"
+  313 format *tmp156
   314 jump *label119 greaterThanEq .EFF_REMOTE_LIMIT 100
-    * print " (limit [orange]"
-    * print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  315 print " (limit [orange]{0}[])"
+  316 format .REMOTE_MARGIN
   317 label *label119
   318 label *label117
   319 sensor *tmp159 @unit @totalItems
   320 print .MSG
   321 print *tmp159
-    * print "[]"
-    * print "\n"
+  322 print "[]\n"
   323 jump *label123 notEqual :show_state 2
   324 sensor *tmp163 @unit @x
   325 op sub *tmp164 .SRC_X *tmp163
 
   328 op len *tmp167 *tmp164 *tmp166
   329 op idiv *tmp168 *tmp167 .SPEED_SEC
   330 op div *tmp169 *tmp168 10
-    * print "[]  arriving in [gold]"
-    * print *tmp169
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  331 print "[]  arriving in [gold]{0} sec[]\n"
+  332 format *tmp169
   333 jump *label124 always
   334 label *label123
   335 jump *label125 notEqual :show_state 3
 
   340 op len *tmp176 *tmp173 *tmp175
   341 op idiv *tmp177 *tmp176 .SPEED_SEC
   342 op div *tmp178 *tmp177 10
-    * print "[]  arriving in [gold]"
-    * print *tmp178
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  343 print "[]  arriving in [gold]{0} sec[]\n"
+  344 format *tmp178
   345 label *label125
   346 label *label124
   347 op floor *tmp179 :loop_time
-    * print "[lightgray]Loop time: "
-    * print *tmp179
-    * print " ms[]"
-    * print "\n"
+  348 print "[lightgray]Loop time: {0} ms[]\n"
+  349 format *tmp179
   350 printflush message1
   351 sensor *tmp180 switch1 @enabled
   352 jump *label77 equal *tmp180 0
 
   366 sensor *tmp193 .SORTER @dead
   367 jump *label137 strictEqual *tmp193 0
   368 label *label149
-    * print "[salmon]sorter1 is missing!"
-    * print "\n"
-    * print "[gold]Please place and link sorter or inverted sorter to the processor."
-    * print "\n"
+  369 print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
   370 printflush message1
   371 printflush message2
   372 sensor *tmp193 sorter1 @dead
 
   381 sensor *tmp202 switch1 @enabled
   382 jump __start__ notEqual *tmp202 false
   383 label *label150
-    * print "[salmon]Local or remote container became invalid."
-    * print "\n"
-    * print "[gold]Please fix and press button to reinitialize."
-    * print "\n"
+  384 print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
   385 printflush message1
   386 printflush message2
   387 sensor *tmp202 switch1 @enabled

Final code before resolving virtual instructions:

label __start__
set UNIT @mega
set LINK_ID 0
set LOCAL_LIMIT 100
set REMOTE_LIMIT 100
op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
set .MSG null
sensor *tmp2 switch1 @enabled
jump *label2 notEqual *tmp2 false
label *label147
print "Unit Transport - Single\nActivate switch to start.\n"
printflush message1
sensor *tmp2 switch1 @enabled
jump *label147 equal *tmp2 false
label *label2
sensor *tmp4 @unit @dead
jump *label5 strictEqual *tmp4 0
label *label148
set :rebindUnit:first_unit null
label *label7
ubind UNIT
jump *label10 equal @unit null
set :rebindUnit:first_unit @unit
jump *label9 always
label *label10
print "[salmon]No unit of type {0} found. 1"
format UNIT
printflush message1
jump *label7 always
label *label9
label *label12
sensor *tmp10 @unit @controller
jump *label6 equal *tmp10 @this
ubind UNIT
print "[gold]Looking for old unit..."
printflush message1
jump *label14 equal @unit :rebindUnit:first_unit
sensor *tmp14 :rebindUnit:first_unit @dead
jump *label12 strictEqual *tmp14 0
label *label14
label *label19
ubind UNIT
jump *label22 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label23 always
label *label22
sensor *tmp19 @unit @controlled
jump *label18 equal *tmp19 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label23
printflush message1
jump *label19 always
label *label18
label *label6
sensor *tmp4 @unit @dead
jump *label148 strictNotEqual *tmp4 0
label *label5
sensor .UNIT_CAPACITY @unit @itemCapacity
sensor *tmp23 @unit @speed
op div .SPEED_SEC *tmp23 10
ucontrol flag 1
label *label26
set .CONTAINER null
set .DROP_TARGET null
set :n @links
jump *label31 lessThanEq :n 0
label *label145
op sub :n :n 1
getlink :block :n
sensor *tmp29 :block @itemCapacity
jump *label32 lessThanEq *tmp29 0
set .DROP_TARGET .CONTAINER
set .CONTAINER :block
label *label32
jump *label145 greaterThan :n 0
label *label31
jump *label34 notEqual .CONTAINER null
print "[salmon]No destination.\n"
jump *label35 always
label *label34
jump *label28 equal .DROP_TARGET null
sensor *tmp35 .DROP_TARGET @itemCapacity
jump *label28 greaterThanEq *tmp35 300
print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
format .CONTAINER
format .DROP_TARGET
label *label35
printflush message1
jump *label26 always
label *label28
set .CORE_Y null
set .CORE_X null
set .CORE null
jump *label40 notEqual LINK_ID 0
print "[gold]Locating core..."
printflush message1
ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
jump *label41 always
label *label40
print "[gold]Locating vault #{0}..."
format LINK_ID
printflush message1
op add .QUERY_FLAG 99999900 LINK_ID
set :flag .QUERY_FLAG
ucontrol flag .QUERY_FLAG
label *label42
jump *label44 notEqual :flag .QUERY_FLAG
sensor *tmp44 @unit @dead
jump *label44 strictNotEqual *tmp44 0
ucontrol stop
sensor :flag @unit @flag
jump *label42 always
label *label44
jump *label47 equal :flag .QUERY_FLAG
op idiv :position :flag 100
op mod .CORE_X :position @mapw
op idiv .CORE_Y :position @mapw
label *label49
ucontrol within .CORE_X .CORE_Y 8 *tmp52
jump *label51 notEqual *tmp52 false
sensor *tmp54 @unit @dead
jump *label51 notEqual *tmp54 0
ucontrol approach .CORE_X .CORE_Y 6
jump *label49 always
label *label51
ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
select .CORE notEqual :b_type @vault null .CORE
label *label47
label *label41
jump *label56 notEqual .CORE null
end
label *label56
set .SORTER sorter1
sensor :sorter_type sorter1 @type
label *label58
jump *label60 equal :sorter_type @sorter
jump *label60 equal :sorter_type @inverted-sorter
print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
jump *label63 equal .SORTER null
print "Block found: "
print .SORTER
label *label63
printflush message1
set .SORTER sorter1
sensor :sorter_type sorter1 @type
jump *label58 always
label *label60
jump *label65 notEqual :sorter_type @sorter
set .SHOW_REMOTE_LEVEL true
set .SRC .CORE
set .DST .CONTAINER
sensor :src_capacity .CORE @itemCapacity
sensor :dst_capacity .CONTAINER @itemCapacity
op sub *tmp72 100 .EFF_REMOTE_LIMIT
op mul *tmp73 :src_capacity *tmp72
op idiv .LOAD_LEVEL *tmp73 100
op mul *tmp75 :dst_capacity .EFF_LOCAL_LIMIT
op idiv .DROP_LEVEL *tmp75 100
set .LOCAL_MARGIN .DROP_LEVEL
set .REMOTE_MARGIN .LOAD_LEVEL
select .DIRECTION equal LINK_ID 0 "[] from core" "[] from vault #"
jump *label66 always
label *label65
op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
set .SRC .CONTAINER
set .DST .CORE
sensor :src_capacity .CONTAINER @itemCapacity
sensor :dst_capacity .CORE @itemCapacity
op sub *tmp82 100 .EFF_LOCAL_LIMIT
op mul *tmp83 :src_capacity *tmp82
op idiv .LOAD_LEVEL *tmp83 100
op mul *tmp85 :dst_capacity .EFF_REMOTE_LIMIT
op idiv *tmp86 *tmp85 100
op equal *tmp87 LINK_ID 0
op mul *tmp88 *tmp87 .UNIT_CAPACITY
op add .DROP_LEVEL *tmp86 *tmp88
set .LOCAL_MARGIN .LOAD_LEVEL
set .REMOTE_MARGIN .DROP_LEVEL
select .DIRECTION equal LINK_ID 0 "[] to core" "[] to vault #"
label *label66
select *tmp93 equal LINK_ID 0 "" LINK_ID
sensor .SRC_X .SRC @x
sensor .SRC_Y .SRC @y
sensor .DST_X .DST @x
sensor .DST_Y .DST @y
jump *label73 notEqual .DROP_TARGET null
set .DROP_TARGET .CORE
set .DROP_X .CORE_X
set .DROP_Y .CORE_Y
jump *label74 always
label *label73
sensor .DROP_X .DROP_TARGET @x
sensor .DROP_Y .DROP_TARGET @y
label *label74
set .LAST_ITEM @mono
set :iter 0
set :loop_time 0
set :state 1
ucontrol stop
label *label75
set :start @time
sensor *tmp103 @unit @dead
op strictEqual *tmp104 *tmp103 0
sensor *tmp105 @unit @controller
op notEqual *tmp106 *tmp105 @this
jump *label78 greaterThan *tmp104 *tmp106
label *label81
ubind UNIT
jump *label84 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label85 always
label *label84
sensor *tmp112 @unit @controlled
jump *label80 equal *tmp112 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label85
printflush message1
jump *label81 always
label *label80
ucontrol flag 1
set :state 1
label *label78
sensor .ITEM .SORTER @config
jump *label88 equal .ITEM .LAST_ITEM
jump *label92 notEqual .ITEM null
label *label146
print "[salmon]No item type selected for transport."
printflush message1
sensor .ITEM .SORTER @config
jump *label146 equal .ITEM null
label *label92
set .LAST_ITEM .ITEM
set :state 1
label *label88
set :show_state 0
jump *label93 notEqual :state 1
sensor *tmp122 @unit @firstItem
jump *label95 notEqual *tmp122 .ITEM
set :state 3
jump *label96 always
label *label95
sensor *tmp125 @unit @totalItems
jump *label97 notEqual *tmp125 0
set :state 2
jump *label98 always
label *label97
set .MSG "\nUnloading previous items: [green]"
ucontrol approach .DROP_X .DROP_Y 6
ucontrol within .DROP_X .DROP_Y 8 *tmp128
jump *label99 equal *tmp128 false
ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
label *label99
label *label98
label *label96
label *label93
jump *label101 notEqual :state 2
ucontrol within .SRC_X .SRC_Y 8 *tmp132
jump *label103 equal *tmp132 false
sensor *tmp134 .SRC .ITEM
op sub *tmp135 *tmp134 .LOAD_LEVEL
op max :max_load *tmp135 0
ucontrol itemTake .SRC .ITEM :max_load
sensor *tmp137 @unit @totalItems
select :state greaterThanEq *tmp137 .UNIT_CAPACITY 3 :state
select .MSG greaterThanEq *tmp137 .UNIT_CAPACITY .MSG "\nLoading items: [green]"
jump *label104 always
label *label103
ucontrol approach .SRC_X .SRC_Y 6
set .MSG "\nGoing to source: [green]"
set :show_state 2
label *label104
label *label101
jump *label107 notEqual :state 3
ucontrol within .DST_X .DST_Y 8 *tmp142
jump *label109 equal *tmp142 false
sensor *tmp144 .DST .ITEM
op sub *tmp145 .DROP_LEVEL *tmp144
op max :max_drop *tmp145 0
ucontrol itemDrop .DST :max_drop
sensor *tmp147 @unit @totalItems
jump *label111 greaterThan *tmp147 0
set :state 2
ucontrol approach .SRC_X .SRC_Y 6
jump *label110 always
label *label111
set .MSG "\nDropping items: [green]"
jump *label110 always
label *label109
ucontrol approach .DST_X .DST_Y 6
set .MSG "\nGoing to destination: [green]"
set :show_state 3
label *label110
label *label107
jump *label113 lessThanEq :iter 3
set :iter 0
print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
format .ITEM
format .DIRECTION
format *tmp93
sensor *tmp152 .CONTAINER .ITEM
format *tmp152
jump *label115 greaterThanEq .EFF_LOCAL_LIMIT 100
print " (limit [orange]{0}[])"
format .LOCAL_MARGIN
label *label115
jump *label117 equal .SHOW_REMOTE_LEVEL false
sensor *tmp156 .CORE .ITEM
print "\nRemote items: [gold]{0}[]"
format *tmp156
jump *label119 greaterThanEq .EFF_REMOTE_LIMIT 100
print " (limit [orange]{0}[])"
format .REMOTE_MARGIN
label *label119
label *label117
sensor *tmp159 @unit @totalItems
print .MSG
print *tmp159
print "[]\n"
jump *label123 notEqual :show_state 2
sensor *tmp163 @unit @x
op sub *tmp164 .SRC_X *tmp163
sensor *tmp165 @unit @y
op sub *tmp166 .SRC_Y *tmp165
op len *tmp167 *tmp164 *tmp166
op idiv *tmp168 *tmp167 .SPEED_SEC
op div *tmp169 *tmp168 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp169
jump *label124 always
label *label123
jump *label125 notEqual :show_state 3
sensor *tmp172 @unit @x
op sub *tmp173 .DST_X *tmp172
sensor *tmp174 @unit @y
op sub *tmp175 .DST_Y *tmp174
op len *tmp176 *tmp173 *tmp175
op idiv *tmp177 *tmp176 .SPEED_SEC
op div *tmp178 *tmp177 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp178
label *label125
label *label124
op floor *tmp179 :loop_time
print "[lightgray]Loop time: {0} ms[]\n"
format *tmp179
printflush message1
sensor *tmp180 switch1 @enabled
jump *label77 equal *tmp180 0
sensor *tmp183 .SRC @dead
jump *label77 notEqual *tmp183 0
sensor *tmp186 .DST @dead
jump *label77 notEqual *tmp186 0
sensor *tmp189 .SORTER @dead
jump *label77 notEqual *tmp189 0
jump *label114 always
label *label113
op add :iter :iter 1
label *label114
op sub :loop_time @time :start
jump *label75 always
label *label77
sensor *tmp193 .SORTER @dead
jump *label137 strictEqual *tmp193 0
label *label149
print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
printflush message1
printflush message2
sensor *tmp193 sorter1 @dead
jump *label149 strictNotEqual *tmp193 0
label *label137
sensor *tmp196 .SRC @dead
jump *label140 strictNotEqual *tmp196 0
sensor *tmp198 .DST @dead
jump __start__ strictEqual *tmp198 0
label *label140
control enabled switch1 false
sensor *tmp202 switch1 @enabled
jump __start__ notEqual *tmp202 false
label *label150
print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
printflush message1
printflush message2
sensor *tmp202 switch1 @enabled
jump *label150 equal *tmp202 false
