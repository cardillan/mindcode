   599 instructions before optimizations.
    40 instructions eliminated by Temp Variables Elimination (3 passes, 8 iterations).
    86 instructions eliminated by Dead Code Elimination (7 iterations).
     6 instructions eliminated by Jump Normalization (6 iterations).
    44 instructions eliminated by Jump Optimization (3 passes, 6 iterations).
    27 instructions eliminated by Single Step Elimination (2 passes, 8 iterations).
     2 instructions modified by Expression Optimization (2 passes, 4 iterations).
    12 instructions eliminated by If Expression Optimization (5 iterations).
     4 instructions eliminated by Data Flow Optimization (5 passes, 19 iterations).
    17 instructions added by Loop Optimization (4 iterations).
     9 loops improved by Loop Optimization.
     5 instructions eliminated by Jump Straightening (6 iterations).
     6 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    50 instructions eliminated by Print Merging.
   339 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 609):
  * Replicate loop condition at line 43:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 51:1                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333
    Replicate loop condition at line 304:1                       size    +2, benefit       25.0, efficiency     12.500
    Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 608):
  * Replicate loop condition at line 51:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333
    Replicate loop condition at line 304:1                       size    +2, benefit       25.0, efficiency     12.500
    Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 607):
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333
  * Replicate loop condition at line 304:1                       size    +2, benefit       25.0, efficiency     12.500 (+1 instructions)
    Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 606):
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333
  * Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500 (+1 instructions)

Pass 1: speed optimization selection (cost limit 605):
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
  * Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333 (+3 instructions)

Pass 1: speed optimization selection (cost limit 602):
  * Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125 (+4 instructions)
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250

Pass 1: speed optimization selection (cost limit 598):
  * Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250 (+5 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-52 instructions):
 
    31 set *tmp9 @unit
    32 set :rebindUnit:first_unit *tmp9
    33 jump *label9 always
-    * set *tmp8 null
    34 jump *label11 always
    35 label *label10
-    * set *tmp8 null
    36 label *label11
    37 print "[salmon]No unit of type "
    38 print UNIT
 
    46 sensor *tmp10 @unit @controller
    47 op equal *tmp11 *tmp10 @this
    48 jump *label15 equal *tmp11 false
-    * set *tmp6 null
    49 jump *label6 always
-    * set *tmp12 null
    50 jump *label16 always
    51 label *label15
-    * set *tmp12 null
    52 label *label16
    53 ubind UNIT
    54 print "[gold]Looking for old unit..."
 
    69 print UNIT
    70 print " "
    71 print "found. 2"
-    * set *tmp19 null
    72 jump *label22 always
    73 label *label21
    74 sensor *tmp20 @unit @controlled
 
    85 jump *label17 always
    86 set *tmp22 null
    87 label *label24
-    * set *tmp19 *tmp22
    88 label *label22
    89 printflush message1
    90 label *label19
 
    92 label *label20
    93 set *tmp17 null
    94 label *label17
-    * set *tmp6 *tmp17
    95 label *label6
    96 label *label4
    97 jump *label3 always
 
   120 jump *label31 equal *tmp31 false
   121 set .DROP_TARGET .CONTAINER
   122 set .CONTAINER :block
-    * set *tmp32 .CONTAINER
   123 jump *label32 always
   124 label *label31
-    * set *tmp32 null
   125 label *label32
   126 label *label29
   127 jump *label28 always
 
   130 jump *label33 equal *tmp33 false
   131 print "[salmon]No destination."
   132 print "\n"
-    * set *tmp34 "[salmon]No destination."
   133 jump *label34 always
   134 label *label33
   135 op notEqual *tmp35 .DROP_TARGET null
 
   152 jump *label27 always
   153 set *tmp39 null
   154 label *label36
-    * set *tmp34 *tmp39
   155 label *label34
   156 printflush message1
   157 label *label26
 
   166 printflush message1
   167 ulocate building core false @copper .CORE_X .CORE_Y *tmp43 *tmp42
   168 set .CORE *tmp42
-    * set *tmp41 .CORE
   169 jump *label38 always
   170 label *label37
   171 print "[gold]Locating vault #"
 
   223 label *label42
   224 set *tmp51 null
   225 label *label43
-    * set *tmp41 *tmp51
   226 label *label38
   227 op equal *tmp64 .CORE null
   228 jump *label49 equal *tmp64 false
   229 end
-    * set *tmp65 null
   230 jump *label50 always
   231 label *label49
-    * set *tmp65 null
   232 label *label50
   233 set .SORTER sorter1
   234 sensor *tmp66 .SORTER @type
 
   244 jump *label54 equal *tmp70 false
   245 print "Block found: "
   246 print .SORTER
-    * set *tmp71 .SORTER
   247 jump *label55 always
   248 label *label54
-    * set *tmp71 null
   249 label *label55
   250 printflush message1
   251 set .SORTER sorter1
 
   280 set *tmp83 "[] from vault #"
   281 label *label59
   282 set .DIRECTION *tmp83
-    * set *tmp74 .DIRECTION
   283 jump *label57 always
   284 label *label56
   285 op greaterThan *tmp84 LINK_ID 0
 
   310 set *tmp96 "[] to vault #"
   311 label *label61
   312 set .DIRECTION *tmp96
-    * set *tmp74 .DIRECTION
   313 label *label57
   314 op equal *tmp97 LINK_ID 0
   315 jump *label62 equal *tmp97 false
 
   332 set .DROP_TARGET .CORE
   333 set .DROP_X .CORE_X
   334 set .DROP_Y .CORE_Y
-    * set *tmp104 .DROP_Y
   335 jump *label65 always
   336 label *label64
   337 sensor *tmp105 .DROP_TARGET @x
   338 set .DROP_X *tmp105
   339 sensor *tmp106 .DROP_TARGET @y
   340 set .DROP_Y *tmp106
-    * set *tmp104 .DROP_Y
   341 label *label65
   342 set .LAST_ITEM @mono
   343 set :iter 0
 
   363 print UNIT
   364 print " "
   365 print "found. 2"
-    * set *tmp116 null
   366 jump *label76 always
   367 label *label75
   368 sensor *tmp117 @unit @controlled
 
   375 set *tmp119 null
   376 jump *label78 always
   377 label *label77
-    * set *tmp114 null
   378 jump *label71 always
   379 set *tmp119 null
   380 label *label78
-    * set *tmp116 *tmp119
   381 label *label76
   382 printflush message1
   383 label *label73
   384 jump *label72 always
   385 label *label74
-    * set *tmp114 null
   386 label *label71
   387 ucontrol flag 1
   388 set :state 1
-    * set *tmp113 :state
   389 jump *label70 always
   390 label *label69
-    * set *tmp113 null
   391 label *label70
   392 sensor *tmp120 .SORTER @config
   393 set .ITEM *tmp120
 
   405 label *label83
   406 set .LAST_ITEM .ITEM
   407 set :state 1
-    * set *tmp122 :state
   408 jump *label80 always
   409 label *label79
-    * set *tmp122 null
   410 label *label80
   411 set :show_state 0
   412 op equal *tmp125 :state 1
 
   439 label *label89
   440 set *tmp129 *tmp132
   441 label *label87
-    * set *tmp126 *tmp129
   442 jump *label85 always
   443 label *label84
-    * set *tmp126 null
   444 label *label85
   445 op equal *tmp135 :state 2
   446 jump *label92 equal *tmp135 false
 
   469 set :show_state 2
   470 set *tmp138 :show_state
   471 label *label95
-    * set *tmp136 *tmp138
   472 jump *label93 always
   473 label *label92
-    * set *tmp136 null
   474 label *label93
   475 op equal *tmp145 :state 3
   476 jump *label98 equal *tmp145 false
 
   500 set :show_state 3
   501 set *tmp148 :show_state
   502 label *label101
-    * set *tmp146 *tmp148
   503 jump *label99 always
   504 label *label98
-    * set *tmp146 null
   505 label *label99
   506 op greaterThan *tmp155 :iter 3
   507 jump *label104 equal *tmp155 false
 
   523 print .LOCAL_MARGIN
   524 print "["
   525 print "])"
-    * set *tmp159 null
   526 jump *label107 always
   527 label *label106
-    * set *tmp159 null
   528 label *label107
   529 jump *label108 equal .SHOW_REMOTE_LEVEL false
   530 sensor *tmp161 .CORE .ITEM
 
   544 label *label110
   545 set *tmp163 null
   546 label *label111
-    * set *tmp160 *tmp163
   547 jump *label109 always
   548 label *label108
-    * set *tmp160 null
   549 label *label109
   550 sensor *tmp164 @unit @totalItems
   551 print .MSG
 
   591 label *label117
   592 set *tmp167 *tmp176
   593 label *label115
-    * set *tmp165 *tmp167
   594 jump *label113 always
   595 label *label112
-    * set *tmp165 null
   596 label *label113
   597 op floor *tmp184 :loop_time
   598 print "[lightgray]Loop time: "
 
   604 op equal *tmp186 *tmp185 0
   605 jump *label118 equal *tmp186 false
   606 jump *label68 always
-    * set *tmp187 null
   607 jump *label119 always
   608 label *label118
-    * set *tmp187 null
   609 label *label119
   610 sensor *tmp188 .SRC @dead
   611 op notEqual *tmp189 *tmp188 0
   612 jump *label120 equal *tmp189 false
   613 jump *label68 always
-    * set *tmp190 null
   614 jump *label121 always
   615 label *label120
-    * set *tmp190 null
   616 label *label121
   617 sensor *tmp191 .DST @dead
   618 op notEqual *tmp192 *tmp191 0
   619 jump *label122 equal *tmp192 false
   620 jump *label68 always
-    * set *tmp193 null
   621 jump *label123 always
   622 label *label122
-    * set *tmp193 null
   623 label *label123
   624 sensor *tmp194 .SORTER @dead
   625 op notEqual *tmp195 *tmp194 0
 
   630 label *label124
   631 set *tmp196 null
   632 label *label125
-    * set *tmp156 *tmp196
   633 jump *label105 always
   634 label *label104
   635 op add :iter :iter 1
-    * set *tmp156 :iter
   636 label *label105
   637 op sub *tmp197 @time :start
   638 set :loop_time *tmp197
 
   674 label *label132
   675 jump *label131 always
   676 label *label133
-    * set *tmp206 null
   677 jump *label130 always
   678 label *label129
-    * set *tmp206 null
   679 label *label130
   680 end

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-22 instructions):
 
    78 print UNIT
    79 print "."
    80 print ".."
-    * set *tmp22 null
    81 jump *label24 always
    82 label *label23
-    * set *tmp17 null
    83 jump *label17 always
-    * set *tmp22 null
    84 label *label24
    85 label *label22
    86 printflush message1
    87 label *label19
    88 jump *label18 always
    89 label *label20
-    * set *tmp17 null
    90 label *label17
    91 label *label6
    92 label *label4
 
   142 print "\"
   143 print "n"
   144 print "[salmon]Item dump must be a container or a vault!"
-    * set *tmp39 null
   145 jump *label36 always
   146 label *label35
   147 jump *label27 always
-    * set *tmp39 null
   148 label *label36
   149 label *label34
   150 printflush message1
 
   212 label *label47
   213 set *tmp63 null
   214 label *label48
-    * set *tmp51 *tmp63
   215 jump *label43 always
   216 label *label42
-    * set *tmp51 null
   217 label *label43
   218 label *label38
   219 op equal *tmp64 .CORE null
 
   364 print UNIT
   365 print "."
   366 print ".."
-    * set *tmp119 null
   367 jump *label78 always
   368 label *label77
   369 jump *label71 always
-    * set *tmp119 null
   370 label *label78
   371 label *label76
   372 printflush message1
 
   405 op equal *tmp128 *tmp127 .ITEM
   406 jump *label86 equal *tmp128 false
   407 set :state 3
-    * set *tmp129 :state
   408 jump *label87 always
   409 label *label86
   410 sensor *tmp130 @unit @totalItems
 
   426 label *label91
   427 set *tmp132 *tmp134
   428 label *label89
-    * set *tmp129 *tmp132
   429 label *label87
   430 jump *label85 always
   431 label *label84
 
   449 set .MSG "\nLoading items: [green]"
   450 set *tmp144 .MSG
   451 label *label97
-    * set *tmp138 *tmp144
   452 jump *label95 always
   453 label *label94
   454 ucontrol approach .SRC_X .SRC_Y 6
   455 set .MSG "\nGoing to source: [green]"
   456 set :show_state 2
-    * set *tmp138 :show_state
   457 label *label95
   458 jump *label93 always
   459 label *label92
 
   478 set .MSG "\nDropping items: [green]"
   479 set *tmp154 .MSG
   480 label *label103
-    * set *tmp148 *tmp154
   481 jump *label101 always
   482 label *label100
   483 ucontrol approach .DST_X .DST_Y 6
   484 set .MSG "\nGoing to destination: [green]"
   485 set :show_state 3
-    * set *tmp148 :show_state
   486 label *label101
   487 jump *label99 always
   488 label *label98
 
   523 print .REMOTE_MARGIN
   524 print "["
   525 print "])"
-    * set *tmp163 null
   526 jump *label111 always
   527 label *label110
-    * set *tmp163 null
   528 label *label111
   529 jump *label109 always
   530 label *label108
 
   549 print " "
   550 print "sec[]"
   551 print "\n"
-    * set *tmp167 null
   552 jump *label115 always
   553 label *label114
   554 op equal *tmp175 :show_state 3
 
   570 label *label116
   571 set *tmp176 null
   572 label *label117
-    * set *tmp167 *tmp176
   573 label *label115
   574 jump *label113 always
   575 label *label112
 
   605 op notEqual *tmp195 *tmp194 0
   606 jump *label124 equal *tmp195 false
   607 jump *label68 always
-    * set *tmp196 null
   608 jump *label125 always
   609 label *label124
-    * set *tmp196 null
   610 label *label125
   611 jump *label105 always
   612 label *label104

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   207 op notEqual *tmp62 :b_type @vault
   208 jump *label47 equal *tmp62 false
   209 set .CORE null
-    * set *tmp63 .CORE
   210 jump *label48 always
   211 label *label47
-    * set *tmp63 null
   212 label *label48
   213 jump *label43 always
   214 label *label42
 
   409 op equal *tmp131 *tmp130 0
   410 jump *label88 equal *tmp131 false
   411 set :state 2
-    * set *tmp132 :state
   412 jump *label89 always
   413 label *label88
   414 set .MSG "\nUnloading previous items: [green]"
 
   421 label *label90
   422 set *tmp134 null
   423 label *label91
-    * set *tmp132 *tmp134
   424 label *label89
   425 label *label87
   426 jump *label85 always
 
   439 op greaterThanEq *tmp143 *tmp142 .UNIT_CAPACITY
   440 jump *label96 equal *tmp143 false
   441 set :state 3
-    * set *tmp144 :state
   442 jump *label97 always
   443 label *label96
   444 set .MSG "\nLoading items: [green]"
-    * set *tmp144 .MSG
   445 label *label97
   446 jump *label95 always
   447 label *label94
 
   466 jump *label102 equal *tmp153 false
   467 set :state 2
   468 ucontrol approach .SRC_X .SRC_Y 6
-    * set *tmp154 null
   469 jump *label103 always
   470 label *label102
   471 set .MSG "\nDropping items: [green]"
-    * set *tmp154 .MSG
   472 label *label103
   473 jump *label101 always
   474 label *label100
 
   557 print " "
   558 print "sec[]"
   559 print "\n"
-    * set *tmp176 null
   560 jump *label117 always
   561 label *label116
-    * set *tmp176 null
   562 label *label117
   563 label *label115
   564 jump *label113 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   416 ucontrol within .DROP_X .DROP_Y 8 *tmp133
   417 jump *label90 equal *tmp133 false
   418 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * set *tmp134 null
   419 jump *label91 always
   420 label *label90
-    * set *tmp134 null
   421 label *label91
   422 label *label89
   423 label *label87

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-38 instructions):
 
     1 set LINK_ID 0
     2 set LOCAL_LIMIT 100
     3 set REMOTE_LIMIT 100
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+    4 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+    5 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
 
    26 ubind UNIT
    27 op notEqual *tmp7 @unit null
    28 jump *label10 equal *tmp7 false
-    * set *tmp9 @unit
-    * set :rebindUnit:first_unit *tmp9
+   29 set :rebindUnit:first_unit @unit
    30 jump *label9 always
    31 jump *label11 always
    32 label *label10
 
    89 label *label4
    90 jump *label3 always
    91 label *label5
-    * sensor *tmp23 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp23
+   92 sensor .UNIT_CAPACITY @unit @itemCapacity
    93 sensor *tmp24 @unit @speed
-    * op div *tmp25 *tmp24 10
-    * set .SPEED_SEC *tmp25
+   94 op div .SPEED_SEC *tmp24 10
    95 ucontrol flag 1
    96 label *label25
    97 jump *label27 equal true false
    98 set .CONTAINER null
    99 set .DROP_TARGET null
-    * set *tmp26 @links
-    * set :n *tmp26
+  100 set :n @links
   101 label *label28
   102 op greaterThan *tmp27 :n 0
   103 jump *label30 equal *tmp27 false
-    * op sub *tmp28 :n 1
-    * set :n *tmp28
-    * getlink *tmp29 :n
-    * set :block *tmp29
+  104 op sub :n :n 1
+  105 getlink :block :n
   106 sensor *tmp30 :block @itemCapacity
   107 op greaterThan *tmp31 *tmp30 0
   108 jump *label31 equal *tmp31 false
 
   150 jump *label37 equal *tmp40 false
   151 print "[gold]Locating core..."
   152 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp43 *tmp42
-    * set .CORE *tmp42
+  153 ulocate building core false @copper .CORE_X .CORE_Y *tmp43 .CORE
   154 jump *label38 always
   155 label *label37
   156 print "[gold]Locating vault #"
 
   158 print "."
   159 print ".."
   160 printflush message1
-    * op add *tmp44 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp44
+  161 op add .QUERY_FLAG 99999900 LINK_ID
   162 set :flag .QUERY_FLAG
   163 ucontrol flag :flag
   164 label *label39
 
   168 op land *tmp48 *tmp45 *tmp47
   169 jump *label41 equal *tmp48 false
   170 ucontrol stop
-    * sensor *tmp49 @unit @flag
-    * set :flag *tmp49
+  171 sensor :flag @unit @flag
   172 label *label40
   173 jump *label39 always
   174 label *label41
   175 op notEqual *tmp50 :flag .QUERY_FLAG
   176 jump *label42 equal *tmp50 false
-    * op idiv *tmp52 :flag 100
-    * set :position *tmp52
-    * op mod *tmp53 :position @mapw
-    * set .CORE_X *tmp53
-    * op idiv *tmp54 :position @mapw
-    * set .CORE_Y *tmp54
+  177 op idiv :position :flag 100
+  178 op mod .CORE_X :position @mapw
+  179 op idiv .CORE_Y :position @mapw
   180 label *label44
   181 ucontrol within .CORE_X .CORE_Y 8 *tmp55
   182 op equal *tmp56 *tmp55 false
 
   188 label *label45
   189 jump *label44 always
   190 label *label46
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp60 *tmp61
-    * set .CORE *tmp60
+  191 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp61
   192 op notEqual *tmp62 :b_type @vault
   193 jump *label47 equal *tmp62 false
   194 set .CORE null
 
   206 label *label49
   207 label *label50
   208 set .SORTER sorter1
-    * sensor *tmp66 .SORTER @type
-    * set :sorter_type *tmp66
+  209 sensor :sorter_type .SORTER @type
   210 label *label51
   211 op notEqual *tmp67 :sorter_type @sorter
   212 op notEqual *tmp68 :sorter_type @inverted-sorter
 
   223 label *label55
   224 printflush message1
   225 set .SORTER sorter1
-    * sensor *tmp72 .SORTER @type
-    * set :sorter_type *tmp72
+  226 sensor :sorter_type .SORTER @type
   227 label *label52
   228 jump *label51 always
   229 label *label53
 
   232 set .SHOW_REMOTE_LEVEL true
   233 set .SRC .CORE
   234 set .DST .CONTAINER
-    * sensor *tmp75 .SRC @itemCapacity
-    * set :src_capacity *tmp75
-    * sensor *tmp76 .DST @itemCapacity
-    * set :dst_capacity *tmp76
+  235 sensor :src_capacity .SRC @itemCapacity
+  236 sensor :dst_capacity .DST @itemCapacity
   237 op sub *tmp77 100 .EFF_REMOTE_LIMIT
   238 op mul *tmp78 :src_capacity *tmp77
-    * op idiv *tmp79 *tmp78 100
-    * set .LOAD_LEVEL *tmp79
+  239 op idiv .LOAD_LEVEL *tmp78 100
   240 op mul *tmp80 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp81 *tmp80 100
-    * set .DROP_LEVEL *tmp81
+  241 op idiv .DROP_LEVEL *tmp80 100
   242 set .LOCAL_MARGIN .DROP_LEVEL
   243 set .REMOTE_MARGIN .LOAD_LEVEL
   244 op equal *tmp82 LINK_ID 0
 
   251 set .DIRECTION *tmp83
   252 jump *label57 always
   253 label *label56
-    * op greaterThan *tmp84 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp84
+  254 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   255 set .SRC .CONTAINER
   256 set .DST .CORE
-    * sensor *tmp85 .SRC @itemCapacity
-    * set :src_capacity *tmp85
-    * sensor *tmp86 .DST @itemCapacity
-    * set :dst_capacity *tmp86
+  257 sensor :src_capacity .SRC @itemCapacity
+  258 sensor :dst_capacity .DST @itemCapacity
   259 op sub *tmp87 100 .EFF_LOCAL_LIMIT
   260 op mul *tmp88 :src_capacity *tmp87
-    * op idiv *tmp89 *tmp88 100
-    * set .LOAD_LEVEL *tmp89
+  261 op idiv .LOAD_LEVEL *tmp88 100
   262 op mul *tmp90 :dst_capacity .EFF_REMOTE_LIMIT
   263 op idiv *tmp91 *tmp90 100
   264 op equal *tmp92 LINK_ID 0
   265 op mul *tmp93 *tmp92 .UNIT_CAPACITY
-    * op add *tmp94 *tmp91 *tmp93
-    * set .DROP_LEVEL *tmp94
+  266 op add .DROP_LEVEL *tmp91 *tmp93
   267 set .LOCAL_MARGIN .LOAD_LEVEL
   268 set .REMOTE_MARGIN .DROP_LEVEL
   269 op equal *tmp95 LINK_ID 0
 
   283 set *tmp98 LINK_ID
   284 label *label63
   285 set .LINK_TXT *tmp98
-    * sensor *tmp99 .SRC @x
-    * set .SRC_X *tmp99
-    * sensor *tmp100 .SRC @y
-    * set .SRC_Y *tmp100
-    * sensor *tmp101 .DST @x
-    * set .DST_X *tmp101
-    * sensor *tmp102 .DST @y
-    * set .DST_Y *tmp102
+  286 sensor .SRC_X .SRC @x
+  287 sensor .SRC_Y .SRC @y
+  288 sensor .DST_X .DST @x
+  289 sensor .DST_Y .DST @y
   290 op equal *tmp103 .DROP_TARGET null
   291 jump *label64 equal *tmp103 false
   292 set .DROP_TARGET .CORE
 
   294 set .DROP_Y .CORE_Y
   295 jump *label65 always
   296 label *label64
-    * sensor *tmp105 .DROP_TARGET @x
-    * set .DROP_X *tmp105
-    * sensor *tmp106 .DROP_TARGET @y
-    * set .DROP_Y *tmp106
+  297 sensor .DROP_X .DROP_TARGET @x
+  298 sensor .DROP_Y .DROP_TARGET @y
   299 label *label65
   300 set .LAST_ITEM @mono
   301 set :iter 0
 
   304 ucontrol stop
   305 label *label66
   306 jump *label68 equal true false
-    * set *tmp107 @time
-    * set :start *tmp107
+  307 set :start @time
   308 sensor *tmp108 @unit @dead
   309 op strictEqual *tmp109 *tmp108 0
   310 sensor *tmp110 @unit @controller
 
   344 jump *label70 always
   345 label *label69
   346 label *label70
-    * sensor *tmp120 .SORTER @config
-    * set .ITEM *tmp120
+  347 sensor .ITEM .SORTER @config
   348 op notEqual *tmp121 .ITEM .LAST_ITEM
   349 jump *label79 equal *tmp121 false
   350 label *label81
 
   352 jump *label83 equal *tmp123 false
   353 print "[salmon]No item type selected for transport."
   354 printflush message1
-    * sensor *tmp124 .SORTER @config
-    * set .ITEM *tmp124
+  355 sensor .ITEM .SORTER @config
   356 label *label82
   357 jump *label81 always
   358 label *label83
 
   395 jump *label94 equal *tmp137 false
   396 sensor *tmp139 .SRC .ITEM
   397 op sub *tmp140 *tmp139 .LOAD_LEVEL
-    * op max *tmp141 *tmp140 0
-    * set :max_load *tmp141
+  398 op max :max_load *tmp140 0
   399 ucontrol itemTake .SRC .ITEM :max_load
   400 sensor *tmp142 @unit @totalItems
   401 op greaterThanEq *tmp143 *tmp142 .UNIT_CAPACITY
 
   420 jump *label100 equal *tmp147 false
   421 sensor *tmp149 .DST .ITEM
   422 op sub *tmp150 .DROP_LEVEL *tmp149
-    * op max *tmp151 *tmp150 0
-    * set :max_drop *tmp151
+  423 op max :max_drop *tmp150 0
   424 ucontrol itemDrop .DST :max_drop
   425 sensor *tmp152 @unit @totalItems
   426 op lessThanEq *tmp153 *tmp152 0
 
   563 label *label104
   564 op add :iter :iter 1
   565 label *label105
-    * op sub *tmp197 @time :start
-    * set :loop_time *tmp197
+  566 op sub :loop_time @time :start
   567 label *label67
   568 jump *label66 always
   569 label *label68

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-6 instructions):
 
    22 jump *label5 equal *tmp5 false
    23 set :rebindUnit:first_unit null
    24 label *label7
-    * jump *label9 equal true false
    25 ubind UNIT
    26 op notEqual *tmp7 @unit null
    27 jump *label10 equal *tmp7 false
 
    57 jump *label12 notEqual *tmp16 false
    58 label *label14
    59 label *label18
-    * jump *label20 equal true false
    60 ubind UNIT
    61 op equal *tmp18 @unit null
    62 jump *label21 equal *tmp18 false
 
    92 op div .SPEED_SEC *tmp24 10
    93 ucontrol flag 1
    94 label *label25
-    * jump *label27 equal true false
    95 set .CONTAINER null
    96 set .DROP_TARGET null
    97 set :n @links
 
   300 set :state 1
   301 ucontrol stop
   302 label *label66
-    * jump *label68 equal true false
   303 set :start @time
   304 sensor *tmp108 @unit @dead
   305 op strictEqual *tmp109 *tmp108 0
 
   308 op lessThanEq *tmp112 *tmp109 *tmp111
   309 jump *label69 equal *tmp112 false
   310 label *label72
-    * jump *label74 equal true false
   311 ubind UNIT
   312 op equal *tmp115 @unit null
   313 jump *label75 equal *tmp115 false
 
   482 print *tmp164
   483 print "[]"
   484 print "\n"
-    * jump *label112 equal true false
   485 op equal *tmp166 :show_state 2
   486 jump *label114 equal *tmp166 false
   487 sensor *tmp168 @unit @x

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-42 instructions):
 
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
-    * op equal *tmp3 *tmp2 false
-    * jump *label2 equal *tmp3 false
+    9 jump *label2 notEqual *tmp2 false
    10 print "Unit Transport - Single"
    11 print "\n"
    12 print "Activate switch to start."
 
    17 label *label2
    18 label *label3
    19 sensor *tmp4 @unit @dead
-    * op strictNotEqual *tmp5 *tmp4 0
-    * jump *label5 equal *tmp5 false
+   20 jump *label5 strictEqual *tmp4 0
    21 set :rebindUnit:first_unit null
    22 label *label7
    23 ubind UNIT
-    * op notEqual *tmp7 @unit null
-    * jump *label10 equal *tmp7 false
+   24 jump *label10 equal @unit null
    25 set :rebindUnit:first_unit @unit
    26 jump *label9 always
    27 jump *label11 always
 
    37 label *label9
    38 label *label12
    39 sensor *tmp10 @unit @controller
-    * op equal *tmp11 *tmp10 @this
-    * jump *label15 equal *tmp11 false
+   40 jump *label15 notEqual *tmp10 @this
    41 jump *label6 always
    42 jump *label16 always
    43 label *label15
 
    54 label *label14
    55 label *label18
    56 ubind UNIT
-    * op equal *tmp18 @unit null
-    * jump *label21 equal *tmp18 false
+   57 jump *label21 notEqual @unit null
    58 print "[salmon]No unit of type "
    59 print UNIT
    60 print " "
 
    62 jump *label22 always
    63 label *label21
    64 sensor *tmp20 @unit @controlled
-    * op notEqual *tmp21 *tmp20 0
-    * jump *label23 equal *tmp21 false
+   65 jump *label23 equal *tmp20 0
    66 print "[salmon]Looking for a free "
    67 print UNIT
    68 print "."
 
    90 set .DROP_TARGET null
    91 set :n @links
    92 label *label28
-    * op greaterThan *tmp27 :n 0
-    * jump *label30 equal *tmp27 false
+   93 jump *label30 lessThanEq :n 0
    94 op sub :n :n 1
    95 getlink :block :n
    96 sensor *tmp30 :block @itemCapacity
-    * op greaterThan *tmp31 *tmp30 0
-    * jump *label31 equal *tmp31 false
+   97 jump *label31 lessThanEq *tmp30 0
    98 set .DROP_TARGET .CONTAINER
    99 set .CONTAINER :block
   100 jump *label32 always
 
   103 label *label29
   104 jump *label28 always
   105 label *label30
-    * op equal *tmp33 .CONTAINER null
-    * jump *label33 equal *tmp33 false
+  106 jump *label33 notEqual .CONTAINER null
   107 print "[salmon]No destination."
   108 print "\n"
   109 jump *label34 always
 
   134 set .CORE_Y null
   135 set .CORE_X .CORE_Y
   136 set .CORE .CORE_X
-    * op equal *tmp40 LINK_ID 0
-    * jump *label37 equal *tmp40 false
+  137 jump *label37 notEqual LINK_ID 0
   138 print "[gold]Locating core..."
   139 printflush message1
   140 ulocate building core false @copper .CORE_X .CORE_Y *tmp43 .CORE
 
   159 label *label40
   160 jump *label39 always
   161 label *label41
-    * op notEqual *tmp50 :flag .QUERY_FLAG
-    * jump *label42 equal *tmp50 false
+  162 jump *label42 equal :flag .QUERY_FLAG
   163 op idiv :position :flag 100
   164 op mod .CORE_X :position @mapw
   165 op idiv .CORE_Y :position @mapw
 
   175 jump *label44 always
   176 label *label46
   177 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp61
-    * op notEqual *tmp62 :b_type @vault
-    * jump *label47 equal *tmp62 false
+  178 jump *label47 equal :b_type @vault
   179 set .CORE null
   180 jump *label48 always
   181 label *label47
 
   184 label *label42
   185 label *label43
   186 label *label38
-    * op equal *tmp64 .CORE null
-    * jump *label49 equal *tmp64 false
+  187 jump *label49 notEqual .CORE null
   188 end
   189 jump *label50 always
   190 label *label49
 
   198 jump *label53 equal *tmp69 false
   199 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   200 print "\n"
-    * op notEqual *tmp70 .SORTER null
-    * jump *label54 equal *tmp70 false
+  201 jump *label54 equal .SORTER null
   202 print "Block found: "
   203 print .SORTER
   204 jump *label55 always
 
   210 label *label52
   211 jump *label51 always
   212 label *label53
-    * op equal *tmp73 :sorter_type @sorter
-    * jump *label56 equal *tmp73 false
+  213 jump *label56 notEqual :sorter_type @sorter
   214 set .SHOW_REMOTE_LEVEL true
   215 set .SRC .CORE
   216 set .DST .CONTAINER
 
   223 op idiv .DROP_LEVEL *tmp80 100
   224 set .LOCAL_MARGIN .DROP_LEVEL
   225 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op equal *tmp82 LINK_ID 0
-    * jump *label58 equal *tmp82 false
+  226 jump *label58 notEqual LINK_ID 0
   227 set *tmp83 "[] from core"
   228 jump *label59 always
   229 label *label58
 
   247 op add .DROP_LEVEL *tmp91 *tmp93
   248 set .LOCAL_MARGIN .LOAD_LEVEL
   249 set .REMOTE_MARGIN .DROP_LEVEL
-    * op equal *tmp95 LINK_ID 0
-    * jump *label60 equal *tmp95 false
+  250 jump *label60 notEqual LINK_ID 0
   251 set *tmp96 "[] to core"
   252 jump *label61 always
   253 label *label60
 
   255 label *label61
   256 set .DIRECTION *tmp96
   257 label *label57
-    * op equal *tmp97 LINK_ID 0
-    * jump *label62 equal *tmp97 false
+  258 jump *label62 notEqual LINK_ID 0
   259 set *tmp98 ""
   260 jump *label63 always
   261 label *label62
 
   266 sensor .SRC_Y .SRC @y
   267 sensor .DST_X .DST @x
   268 sensor .DST_Y .DST @y
-    * op equal *tmp103 .DROP_TARGET null
-    * jump *label64 equal *tmp103 false
+  269 jump *label64 notEqual .DROP_TARGET null
   270 set .DROP_TARGET .CORE
   271 set .DROP_X .CORE_X
   272 set .DROP_Y .CORE_Y
 
   286 op strictEqual *tmp109 *tmp108 0
   287 sensor *tmp110 @unit @controller
   288 op notEqual *tmp111 *tmp110 @this
-    * op lessThanEq *tmp112 *tmp109 *tmp111
-    * jump *label69 equal *tmp112 false
+  289 jump *label69 greaterThan *tmp109 *tmp111
   290 label *label72
   291 ubind UNIT
-    * op equal *tmp115 @unit null
-    * jump *label75 equal *tmp115 false
+  292 jump *label75 notEqual @unit null
   293 print "[salmon]No unit of type "
   294 print UNIT
   295 print " "
 
   297 jump *label76 always
   298 label *label75
   299 sensor *tmp117 @unit @controlled
-    * op notEqual *tmp118 *tmp117 0
-    * jump *label77 equal *tmp118 false
+  300 jump *label77 equal *tmp117 0
   301 print "[salmon]Looking for a free "
   302 print UNIT
   303 print "."
 
   318 label *label69
   319 label *label70
   320 sensor .ITEM .SORTER @config
-    * op notEqual *tmp121 .ITEM .LAST_ITEM
-    * jump *label79 equal *tmp121 false
+  321 jump *label79 equal .ITEM .LAST_ITEM
   322 label *label81
-    * op equal *tmp123 .ITEM null
-    * jump *label83 equal *tmp123 false
+  323 jump *label83 notEqual .ITEM null
   324 print "[salmon]No item type selected for transport."
   325 printflush message1
   326 sensor .ITEM .SORTER @config
 
   333 label *label79
   334 label *label80
   335 set :show_state 0
-    * op equal *tmp125 :state 1
-    * jump *label84 equal *tmp125 false
+  336 jump *label84 notEqual :state 1
   337 sensor *tmp127 @unit @firstItem
-    * op equal *tmp128 *tmp127 .ITEM
-    * jump *label86 equal *tmp128 false
+  338 jump *label86 notEqual *tmp127 .ITEM
   339 set :state 3
   340 jump *label87 always
   341 label *label86
   342 sensor *tmp130 @unit @totalItems
-    * op equal *tmp131 *tmp130 0
-    * jump *label88 equal *tmp131 false
+  343 jump *label88 notEqual *tmp130 0
   344 set :state 2
   345 jump *label89 always
   346 label *label88
 
   357 jump *label85 always
   358 label *label84
   359 label *label85
-    * op equal *tmp135 :state 2
-    * jump *label92 equal *tmp135 false
+  360 jump *label92 notEqual :state 2
   361 ucontrol within .SRC_X .SRC_Y 8 *tmp137
   362 jump *label94 equal *tmp137 false
   363 sensor *tmp139 .SRC .ITEM
 
   365 op max :max_load *tmp140 0
   366 ucontrol itemTake .SRC .ITEM :max_load
   367 sensor *tmp142 @unit @totalItems
-    * op greaterThanEq *tmp143 *tmp142 .UNIT_CAPACITY
-    * jump *label96 equal *tmp143 false
+  368 jump *label96 lessThan *tmp142 .UNIT_CAPACITY
   369 set :state 3
   370 jump *label97 always
   371 label *label96
 
   380 jump *label93 always
   381 label *label92
   382 label *label93
-    * op equal *tmp145 :state 3
-    * jump *label98 equal *tmp145 false
+  383 jump *label98 notEqual :state 3
   384 ucontrol within .DST_X .DST_Y 8 *tmp147
   385 jump *label100 equal *tmp147 false
   386 sensor *tmp149 .DST .ITEM
 
   388 op max :max_drop *tmp150 0
   389 ucontrol itemDrop .DST :max_drop
   390 sensor *tmp152 @unit @totalItems
-    * op lessThanEq *tmp153 *tmp152 0
-    * jump *label102 equal *tmp153 false
+  391 jump *label102 greaterThan *tmp152 0
   392 set :state 2
   393 ucontrol approach .SRC_X .SRC_Y 6
   394 jump *label103 always
 
   404 jump *label99 always
   405 label *label98
   406 label *label99
-    * op greaterThan *tmp155 :iter 3
-    * jump *label104 equal *tmp155 false
+  407 jump *label104 lessThanEq :iter 3
   408 set :iter 0
   409 print "Moving [green]"
   410 print .ITEM
 
   417 print *tmp157
   418 print "["
   419 print "]"
-    * op lessThan *tmp158 .EFF_LOCAL_LIMIT 100
-    * jump *label106 equal *tmp158 false
+  420 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
   421 print " (limit [orange]"
   422 print .LOCAL_MARGIN
   423 print "["
 
   432 print *tmp161
   433 print "["
   434 print "]"
-    * op lessThan *tmp162 .EFF_REMOTE_LIMIT 100
-    * jump *label110 equal *tmp162 false
+  435 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
   436 print " (limit [orange]"
   437 print .REMOTE_MARGIN
   438 print "["
 
   448 print *tmp164
   449 print "[]"
   450 print "\n"
-    * op equal *tmp166 :show_state 2
-    * jump *label114 equal *tmp166 false
+  451 jump *label114 notEqual :show_state 2
   452 sensor *tmp168 @unit @x
   453 op sub *tmp169 .SRC_X *tmp168
   454 sensor *tmp170 @unit @y
 
   463 print "\n"
   464 jump *label115 always
   465 label *label114
-    * op equal *tmp175 :show_state 3
-    * jump *label116 equal *tmp175 false
+  466 jump *label116 notEqual :show_state 3
   467 sensor *tmp177 @unit @x
   468 op sub *tmp178 .DST_X *tmp177
   469 sensor *tmp179 @unit @y
 
   490 print "\n"
   491 printflush message1
   492 sensor *tmp185 switch1 @enabled
-    * op equal *tmp186 *tmp185 0
-    * jump *label118 equal *tmp186 false
+  493 jump *label118 notEqual *tmp185 0
   494 jump *label68 always
   495 jump *label119 always
   496 label *label118
   497 label *label119
   498 sensor *tmp188 .SRC @dead
-    * op notEqual *tmp189 *tmp188 0
-    * jump *label120 equal *tmp189 false
+  499 jump *label120 equal *tmp188 0
   500 jump *label68 always
   501 jump *label121 always
   502 label *label120
   503 label *label121
   504 sensor *tmp191 .DST @dead
-    * op notEqual *tmp192 *tmp191 0
-    * jump *label122 equal *tmp192 false
+  505 jump *label122 equal *tmp191 0
   506 jump *label68 always
   507 jump *label123 always
   508 label *label122
   509 label *label123
   510 sensor *tmp194 .SORTER @dead
-    * op notEqual *tmp195 *tmp194 0
-    * jump *label124 equal *tmp195 false
+  511 jump *label124 equal *tmp194 0
   512 jump *label68 always
   513 jump *label125 always
   514 label *label124
 
   524 label *label126
   525 sensor *tmp198 .SORTER @dead
   526 op strictEqual *tmp199 *tmp198 0
-    * op equal *tmp200 *tmp199 false
-    * jump *label128 equal *tmp200 false
+  527 jump *label128 notEqual *tmp199 false
   528 print "[salmon]sorter1 is missing!"
   529 print "\n"
   530 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   544 control enabled switch1 false
   545 label *label131
   546 sensor *tmp208 switch1 @enabled
-    * op equal *tmp209 *tmp208 false
-    * jump *label133 equal *tmp209 false
+  547 jump *label133 notEqual *tmp208 false
   548 print "[salmon]Local or remote container became invalid."
   549 print "\n"
   550 print "[gold]Please fix and press button to reinitialize."

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-23 instructions):
 
    24 jump *label10 equal @unit null
    25 set :rebindUnit:first_unit @unit
    26 jump *label9 always
-    * jump *label11 always
    27 label *label10
    28 label *label11
    29 print "[salmon]No unit of type "
 
    38 sensor *tmp10 @unit @controller
    39 jump *label15 notEqual *tmp10 @this
    40 jump *label6 always
-    * jump *label16 always
    41 label *label15
    42 label *label16
    43 ubind UNIT
 
    95 jump *label31 lessThanEq *tmp30 0
    96 set .DROP_TARGET .CONTAINER
    97 set .CONTAINER :block
-    * jump *label32 always
    98 label *label31
    99 label *label32
   100 label *label29
 
   174 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp61
   175 jump *label47 equal :b_type @vault
   176 set .CORE null
-    * jump *label48 always
   177 label *label47
   178 label *label48
-    * jump *label43 always
   179 label *label42
   180 label *label43
   181 label *label38
   182 jump *label49 notEqual .CORE null
   183 end
-    * jump *label50 always
   184 label *label49
   185 label *label50
   186 set .SORTER sorter1
 
   195 jump *label54 equal .SORTER null
   196 print "Block found: "
   197 print .SORTER
-    * jump *label55 always
   198 label *label54
   199 label *label55
   200 printflush message1
 
   307 label *label71
   308 ucontrol flag 1
   309 set :state 1
-    * jump *label70 always
   310 label *label69
   311 label *label70
   312 sensor .ITEM .SORTER @config
 
   321 label *label83
   322 set .LAST_ITEM .ITEM
   323 set :state 1
-    * jump *label80 always
   324 label *label79
   325 label *label80
   326 set :show_state 0
 
   340 ucontrol within .DROP_X .DROP_Y 8 *tmp133
   341 jump *label90 equal *tmp133 false
   342 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * jump *label91 always
   343 label *label90
   344 label *label91
   345 label *label89
   346 label *label87
-    * jump *label85 always
   347 label *label84
   348 label *label85
   349 jump *label92 notEqual :state 2
 
   366 set .MSG "\nGoing to source: [green]"
   367 set :show_state 2
   368 label *label95
-    * jump *label93 always
   369 label *label92
   370 label *label93
   371 jump *label98 notEqual :state 3
 
   389 set .MSG "\nGoing to destination: [green]"
   390 set :show_state 3
   391 label *label101
-    * jump *label99 always
   392 label *label98
   393 label *label99
   394 jump *label104 lessThanEq :iter 3
 
   409 print .LOCAL_MARGIN
   410 print "["
   411 print "])"
-    * jump *label107 always
   412 label *label106
   413 label *label107
   414 jump *label108 equal .SHOW_REMOTE_LEVEL false
 
   423 print .REMOTE_MARGIN
   424 print "["
   425 print "])"
-    * jump *label111 always
   426 label *label110
   427 label *label111
-    * jump *label109 always
   428 label *label108
   429 label *label109
   430 sensor *tmp164 @unit @totalItems
 
   460 print " "
   461 print "sec[]"
   462 print "\n"
-    * jump *label117 always
   463 label *label116
   464 label *label117
   465 label *label115
-    * jump *label113 always
   466 label *label112
   467 label *label113
   468 op floor *tmp184 :loop_time
 
   474 sensor *tmp185 switch1 @enabled
   475 jump *label118 notEqual *tmp185 0
   476 jump *label68 always
-    * jump *label119 always
   477 label *label118
   478 label *label119
   479 sensor *tmp188 .SRC @dead
   480 jump *label120 equal *tmp188 0
   481 jump *label68 always
-    * jump *label121 always
   482 label *label120
   483 label *label121
   484 sensor *tmp191 .DST @dead
   485 jump *label122 equal *tmp191 0
   486 jump *label68 always
-    * jump *label123 always
   487 label *label122
   488 label *label123
   489 sensor *tmp194 .SORTER @dead
   490 jump *label124 equal *tmp194 0
   491 jump *label68 always
-    * jump *label125 always
   492 label *label124
   493 label *label125
   494 jump *label105 always
 
   532 label *label132
   533 jump *label131 always
   534 label *label133
-    * jump *label130 always
   535 label *label129
   536 label *label130
   537 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   129 jump *label25 always
   130 label *label27
   131 set .CORE_Y null
-    * set .CORE_X .CORE_Y
-    * set .CORE .CORE_X
+  132 set .CORE_X null
+  133 set .CORE .CORE_Y
   134 jump *label37 notEqual LINK_ID 0
   135 print "[gold]Locating core..."
   136 printflush message1
 
   144 printflush message1
   145 op add .QUERY_FLAG 99999900 LINK_ID
   146 set :flag .QUERY_FLAG
-    * ucontrol flag :flag
+  147 ucontrol flag .QUERY_FLAG
   148 label *label39
   149 op equal *tmp45 :flag .QUERY_FLAG
   150 sensor *tmp46 @unit @dead
 
   184 label *label49
   185 label *label50
   186 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  187 sensor :sorter_type sorter1 @type
   188 label *label51
   189 op notEqual *tmp67 :sorter_type @sorter
   190 op notEqual *tmp68 :sorter_type @inverted-sorter
 
   199 label *label55
   200 printflush message1
   201 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  202 sensor :sorter_type sorter1 @type
   203 label *label52
   204 jump *label51 always
   205 label *label53
 
   207 set .SHOW_REMOTE_LEVEL true
   208 set .SRC .CORE
   209 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  210 sensor :src_capacity .CORE @itemCapacity
+  211 sensor :dst_capacity .CONTAINER @itemCapacity
   212 op sub *tmp77 100 .EFF_REMOTE_LIMIT
   213 op mul *tmp78 :src_capacity *tmp77
   214 op idiv .LOAD_LEVEL *tmp78 100
 
   228 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   229 set .SRC .CONTAINER
   230 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  231 sensor :src_capacity .CONTAINER @itemCapacity
+  232 sensor :dst_capacity .CORE @itemCapacity
   233 op sub *tmp87 100 .EFF_LOCAL_LIMIT
   234 op mul *tmp88 :src_capacity *tmp87
   235 op idiv .LOAD_LEVEL *tmp88 100
 
   396 print "Moving [green]"
   397 print .ITEM
   398 print .DIRECTION
-    * print .LINK_TXT
+  399 print *tmp98
   400 print "\"
   401 print "n"
   402 sensor *tmp157 .CONTAINER .ITEM

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   130 label *label27
   131 set .CORE_Y null
   132 set .CORE_X null
-    * set .CORE .CORE_Y
+  133 set .CORE null
   134 jump *label37 notEqual LINK_ID 0
   135 print "[gold]Locating core..."
   136 printflush message1
 
   254 label *label62
   255 set *tmp98 LINK_ID
   256 label *label63
-    * set .LINK_TXT *tmp98
   257 sensor .SRC_X .SRC @x
   258 sensor .SRC_Y .SRC @y
   259 sensor .DST_X .DST @x

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    89 set :n @links
    90 label *label28
    91 jump *label30 lessThanEq :n 0
+   92 label *label134
    93 op sub :n :n 1
    94 getlink :block :n
    95 sensor *tmp30 :block @itemCapacity
 
    99 label *label31
   100 label *label32
   101 label *label29
-    * jump *label28 always
+  102 jump *label134 greaterThan :n 0
   103 label *label30
   104 jump *label33 notEqual .CONTAINER null
   105 print "[salmon]No destination."
 
   313 jump *label79 equal .ITEM .LAST_ITEM
   314 label *label81
   315 jump *label83 notEqual .ITEM null
+  316 label *label135
   317 print "[salmon]No item type selected for transport."
   318 printflush message1
   319 sensor .ITEM .SORTER @config
   320 label *label82
-    * jump *label81 always
+  321 jump *label135 equal .ITEM null
   322 label *label83
   323 set .LAST_ITEM .ITEM
   324 set :state 1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-12 instructions):
 
   173 jump *label44 always
   174 label *label46
   175 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp61
-    * jump *label47 equal :b_type @vault
-    * set .CORE null
-    * label *label47
-    * label *label48
+  176 select .CORE notEqual :b_type @vault null .CORE
   177 label *label42
   178 label *label43
   179 label *label38
 
   214 op idiv .DROP_LEVEL *tmp80 100
   215 set .LOCAL_MARGIN .DROP_LEVEL
   216 set .REMOTE_MARGIN .LOAD_LEVEL
-    * jump *label58 notEqual LINK_ID 0
-    * set *tmp83 "[] from core"
-    * jump *label59 always
-    * label *label58
-    * set *tmp83 "[] from vault #"
-    * label *label59
+  217 select *tmp83 equal LINK_ID 0 "[] from core" "[] from vault #"
   218 set .DIRECTION *tmp83
   219 jump *label57 always
   220 label *label56
 
   233 op add .DROP_LEVEL *tmp91 *tmp93
   234 set .LOCAL_MARGIN .LOAD_LEVEL
   235 set .REMOTE_MARGIN .DROP_LEVEL
-    * jump *label60 notEqual LINK_ID 0
-    * set *tmp96 "[] to core"
-    * jump *label61 always
-    * label *label60
-    * set *tmp96 "[] to vault #"
-    * label *label61
+  236 select *tmp96 equal LINK_ID 0 "[] to core" "[] to vault #"
   237 set .DIRECTION *tmp96
   238 label *label57
-    * jump *label62 notEqual LINK_ID 0
-    * set *tmp98 ""
-    * jump *label63 always
-    * label *label62
-    * set *tmp98 LINK_ID
-    * label *label63
+  239 select *tmp98 equal LINK_ID 0 "" LINK_ID
   240 sensor .SRC_X .SRC @x
   241 sensor .SRC_Y .SRC @y
   242 sensor .DST_X .DST @x
 
   336 op sub *tmp140 *tmp139 .LOAD_LEVEL
   337 op max :max_load *tmp140 0
   338 ucontrol itemTake .SRC .ITEM :max_load
-    * sensor *tmp142 @unit @totalItems
-    * jump *label96 lessThan *tmp142 .UNIT_CAPACITY
-    * set :state 3
-    * jump *label97 always
-    * label *label96
-    * set .MSG "\nLoading items: [green]"
-    * label *label97
+  339 sensor *tmp142 @unit @totalItems
+  340 select :state greaterThanEq *tmp142 .UNIT_CAPACITY 3 :state
+  341 select .MSG greaterThanEq *tmp142 .UNIT_CAPACITY .MSG "\nLoading items: [green]"
   342 jump *label95 always
   343 label *label94
   344 ucontrol approach .SRC_X .SRC_Y 6

Modifications by Replicate loop condition at line 43:1 (+1 instructions):
 
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
     9 jump *label2 notEqual *tmp2 false
+   10 label *label136
    11 print "Unit Transport - Single"
    12 print "\n"
    13 print "Activate switch to start."
    14 print "\n"
    15 printflush message1
    16 label *label1
-    * jump *label0 always
+   17 sensor *tmp2 switch1 @enabled
+   18 jump *label136 equal *tmp2 false
    19 label *label2
    20 label *label3
    21 sensor *tmp4 @unit @dead

Modifications by Replicate loop condition at line 51:1 (+1 instructions):
 
    20 label *label3
    21 sensor *tmp4 @unit @dead
    22 jump *label5 strictEqual *tmp4 0
+   23 label *label137
    24 set :rebindUnit:first_unit null
    25 label *label7
    26 ubind UNIT
 
    80 label *label17
    81 label *label6
    82 label *label4
-    * jump *label3 always
+   83 sensor *tmp4 @unit @dead
+   84 jump *label137 strictNotEqual *tmp4 0
    85 label *label5
    86 sensor .UNIT_CAPACITY @unit @itemCapacity
    87 sensor *tmp24 @unit @speed

Modifications by Replicate loop condition at line 304:1 (+2 instructions):
 
   486 sensor *tmp198 .SORTER @dead
   487 op strictEqual *tmp199 *tmp198 0
   488 jump *label128 notEqual *tmp199 false
+  489 label *label138
   490 print "[salmon]sorter1 is missing!"
   491 print "\n"
   492 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   495 printflush message2
   496 set .SORTER sorter1
   497 label *label127
-    * jump *label126 always
+  498 sensor *tmp198 .SORTER @dead
+  499 op strictEqual *tmp199 *tmp198 0
+  500 jump *label138 equal *tmp199 false
   501 label *label128
   502 sensor *tmp201 .SRC @dead
   503 op strictNotEqual *tmp202 *tmp201 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   495 printflush message2
   496 set .SORTER sorter1
   497 label *label127
-    * sensor *tmp198 .SORTER @dead
+  498 sensor *tmp198 sorter1 @dead
   499 op strictEqual *tmp199 *tmp198 0
   500 jump *label138 equal *tmp199 false
   501 label *label128

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   493 print "\n"
   494 printflush message1
   495 printflush message2
-    * set .SORTER sorter1
   496 label *label127
   497 sensor *tmp198 sorter1 @dead
   498 op strictEqual *tmp199 *tmp198 0

Modifications by Replicate loop condition at line 314:5 (+1 instructions):
 
   508 label *label131
   509 sensor *tmp208 switch1 @enabled
   510 jump *label133 notEqual *tmp208 false
+  511 label *label139
   512 print "[salmon]Local or remote container became invalid."
   513 print "\n"
   514 print "[gold]Please fix and press button to reinitialize."
 
   516 printflush message1
   517 printflush message2
   518 label *label132
-    * jump *label131 always
+  519 sensor *tmp208 switch1 @enabled
+  520 jump *label139 equal *tmp208 false
   521 label *label133
   522 label *label129
   523 label *label130

Modifications by Replicate loop condition at line 129:1 (+3 instructions):
 
   192 op notEqual *tmp68 :sorter_type @inverted-sorter
   193 op land *tmp69 *tmp67 *tmp68
   194 jump *label53 equal *tmp69 false
+  195 label *label140
   196 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   197 print "\n"
   198 jump *label54 equal .SORTER null
 
   204 set .SORTER sorter1
   205 sensor :sorter_type sorter1 @type
   206 label *label52
-    * jump *label51 always
+  207 op notEqual *tmp67 :sorter_type @sorter
+  208 op notEqual *tmp68 :sorter_type @inverted-sorter
+  209 op land *tmp69 *tmp67 *tmp68
+  210 jump *label140 notEqual *tmp69 false
   211 label *label53
   212 jump *label56 notEqual :sorter_type @sorter
   213 set .SHOW_REMOTE_LEVEL true

Modifications by Replicate loop condition at line 102:5 (+4 instructions):
 
   156 op strictEqual *tmp47 *tmp46 0
   157 op land *tmp48 *tmp45 *tmp47
   158 jump *label41 equal *tmp48 false
+  159 label *label141
   160 ucontrol stop
   161 sensor :flag @unit @flag
   162 label *label40
-    * jump *label39 always
+  163 op equal *tmp45 :flag .QUERY_FLAG
+  164 sensor *tmp46 @unit @dead
+  165 op strictEqual *tmp47 *tmp46 0
+  166 op land *tmp48 *tmp45 *tmp47
+  167 jump *label141 notEqual *tmp48 false
   168 label *label41
   169 jump *label42 equal :flag .QUERY_FLAG
   170 op idiv :position :flag 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   151 set :flag .QUERY_FLAG
   152 ucontrol flag .QUERY_FLAG
   153 label *label39
-    * op equal *tmp45 :flag .QUERY_FLAG
+  154 op equal *tmp45 .QUERY_FLAG .QUERY_FLAG
   155 sensor *tmp46 @unit @dead
   156 op strictEqual *tmp47 *tmp46 0
   157 op land *tmp48 *tmp45 *tmp47

Modifications by Replicate loop condition at line 110:9 (+5 instructions):
 
   177 op equal *tmp58 *tmp57 0
   178 op land *tmp59 *tmp56 *tmp58
   179 jump *label46 equal *tmp59 false
+  180 label *label142
   181 ucontrol approach .CORE_X .CORE_Y 6
   182 label *label45
-    * jump *label44 always
+  183 ucontrol within .CORE_X .CORE_Y 8 *tmp55
+  184 op equal *tmp56 *tmp55 false
+  185 sensor *tmp57 @unit @dead
+  186 op equal *tmp58 *tmp57 0
+  187 op land *tmp59 *tmp56 *tmp58
+  188 jump *label142 notEqual *tmp59 false
   189 label *label46
   190 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp61
   191 select .CORE notEqual :b_type @vault null .CORE

Modifications by Iterated phase, Jump Optimization, pass 2, iteration 1 (-1 instructions):
 
   510 printflush message2
   511 label *label127
   512 sensor *tmp198 sorter1 @dead
-    * op strictEqual *tmp199 *tmp198 0
-    * jump *label138 equal *tmp199 false
+  513 jump *label138 strictNotEqual *tmp198 0
   514 label *label128
   515 sensor *tmp201 .SRC @dead
   516 op strictNotEqual *tmp202 *tmp201 0

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   151 set :flag .QUERY_FLAG
   152 ucontrol flag .QUERY_FLAG
   153 label *label39
-    * op equal *tmp45 .QUERY_FLAG .QUERY_FLAG
+  154 set *tmp45 true
   155 sensor *tmp46 @unit @dead
   156 op strictEqual *tmp47 *tmp46 0
   157 op land *tmp48 *tmp45 *tmp47

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   154 set *tmp45 true
   155 sensor *tmp46 @unit @dead
   156 op strictEqual *tmp47 *tmp46 0
-    * op land *tmp48 *tmp45 *tmp47
+  157 op land *tmp48 true *tmp47
   158 jump *label41 equal *tmp48 false
   159 label *label141
   160 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
   151 set :flag .QUERY_FLAG
   152 ucontrol flag .QUERY_FLAG
   153 label *label39
-    * set *tmp45 true
   154 sensor *tmp46 @unit @dead
   155 op strictEqual *tmp47 *tmp46 0
   156 op land *tmp48 true *tmp47

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-2 instructions):
 
   232 op idiv .DROP_LEVEL *tmp80 100
   233 set .LOCAL_MARGIN .DROP_LEVEL
   234 set .REMOTE_MARGIN .LOAD_LEVEL
-    * select *tmp83 equal LINK_ID 0 "[] from core" "[] from vault #"
-    * set .DIRECTION *tmp83
+  235 select .DIRECTION equal LINK_ID 0 "[] from core" "[] from vault #"
   236 jump *label57 always
   237 label *label56
   238 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
 
   250 op add .DROP_LEVEL *tmp91 *tmp93
   251 set .LOCAL_MARGIN .LOAD_LEVEL
   252 set .REMOTE_MARGIN .DROP_LEVEL
-    * select *tmp96 equal LINK_ID 0 "[] to core" "[] to vault #"
-    * set .DIRECTION *tmp96
+  253 select .DIRECTION equal LINK_ID 0 "[] to core" "[] to vault #"
   254 label *label57
   255 select *tmp98 equal LINK_ID 0 "" LINK_ID
   256 sensor .SRC_X .SRC @x

Modifications by Iterated phase, Jump Optimization, pass 3, iteration 1 (-1 instructions):
 
   496 label *label68
   497 label *label126
   498 sensor *tmp198 .SORTER @dead
-    * op strictEqual *tmp199 *tmp198 0
-    * jump *label128 notEqual *tmp199 false
+  499 jump *label128 strictEqual *tmp198 0
   500 label *label138
   501 print "[salmon]sorter1 is missing!"
   502 print "\n"

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1:
 
   153 label *label39
   154 sensor *tmp46 @unit @dead
   155 op strictEqual *tmp47 *tmp46 0
-    * op land *tmp48 true *tmp47
+  156 set *tmp48 *tmp47
   157 jump *label41 equal *tmp48 false
   158 label *label141
   159 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1 (-1 instructions):
 
   152 ucontrol flag .QUERY_FLAG
   153 label *label39
   154 sensor *tmp46 @unit @dead
-    * op strictEqual *tmp47 *tmp46 0
-    * set *tmp48 *tmp47
+  155 op strictEqual *tmp48 *tmp46 0
   156 jump *label41 equal *tmp48 false
   157 label *label141
   158 ucontrol stop

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
     4 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
     5 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
     6 set .MSG null
-    * label *label0
     7 sensor *tmp2 switch1 @enabled
     8 jump *label2 notEqual *tmp2 false
     9 label *label136
 
    12 print "Activate switch to start."
    13 print "\n"
    14 printflush message1
-    * label *label1
    15 sensor *tmp2 switch1 @enabled
    16 jump *label136 equal *tmp2 false
    17 label *label2
-    * label *label3
    18 sensor *tmp4 @unit @dead
    19 jump *label5 strictEqual *tmp4 0
    20 label *label137
 
    25 set :rebindUnit:first_unit @unit
    26 jump *label9 always
    27 label *label10
-    * label *label11
    28 print "[salmon]No unit of type "
    29 print UNIT
    30 print " "
    31 print "found. 1"
    32 printflush message1
-    * label *label8
    33 jump *label7 always
    34 label *label9
    35 label *label12
 
    37 jump *label15 notEqual *tmp10 @this
    38 jump *label6 always
    39 label *label15
-    * label *label16
    40 ubind UNIT
    41 print "[gold]Looking for old unit..."
    42 printflush message1
-    * label *label13
    43 op notEqual *tmp13 @unit :rebindUnit:first_unit
    44 sensor *tmp14 :rebindUnit:first_unit @dead
    45 op strictEqual *tmp15 *tmp14 0
    46 op land *tmp16 *tmp13 *tmp15
    47 jump *label12 notEqual *tmp16 false
-    * label *label14
    48 label *label18
    49 ubind UNIT
    50 jump *label21 notEqual @unit null
 
    66 label *label24
    67 label *label22
    68 printflush message1
-    * label *label19
    69 jump *label18 always
-    * label *label20
    70 label *label17
    71 label *label6
-    * label *label4
    72 sensor *tmp4 @unit @dead
    73 jump *label137 strictNotEqual *tmp4 0
    74 label *label5
 
    80 set .CONTAINER null
    81 set .DROP_TARGET null
    82 set :n @links
-    * label *label28
    83 jump *label30 lessThanEq :n 0
    84 label *label134
    85 op sub :n :n 1
 
    89 set .DROP_TARGET .CONTAINER
    90 set .CONTAINER :block
    91 label *label31
-    * label *label32
-    * label *label29
    92 jump *label134 greaterThan :n 0
    93 label *label30
    94 jump *label33 notEqual .CONTAINER null
 
   116 label *label36
   117 label *label34
   118 printflush message1
-    * label *label26
   119 jump *label25 always
   120 label *label27
   121 set .CORE_Y null
 
   135 op add .QUERY_FLAG 99999900 LINK_ID
   136 set :flag .QUERY_FLAG
   137 ucontrol flag .QUERY_FLAG
-    * label *label39
   138 sensor *tmp46 @unit @dead
   139 op strictEqual *tmp48 *tmp46 0
   140 jump *label41 equal *tmp48 false
   141 label *label141
   142 ucontrol stop
   143 sensor :flag @unit @flag
-    * label *label40
   144 op equal *tmp45 :flag .QUERY_FLAG
   145 sensor *tmp46 @unit @dead
   146 op strictEqual *tmp47 *tmp46 0
 
   151 op idiv :position :flag 100
   152 op mod .CORE_X :position @mapw
   153 op idiv .CORE_Y :position @mapw
-    * label *label44
   154 ucontrol within .CORE_X .CORE_Y 8 *tmp55
   155 op equal *tmp56 *tmp55 false
   156 sensor *tmp57 @unit @dead
 
   159 jump *label46 equal *tmp59 false
   160 label *label142
   161 ucontrol approach .CORE_X .CORE_Y 6
-    * label *label45
   162 ucontrol within .CORE_X .CORE_Y 8 *tmp55
   163 op equal *tmp56 *tmp55 false
   164 sensor *tmp57 @unit @dead
 
   169 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp61
   170 select .CORE notEqual :b_type @vault null .CORE
   171 label *label42
-    * label *label43
   172 label *label38
   173 jump *label49 notEqual .CORE null
   174 end
   175 label *label49
-    * label *label50
   176 set .SORTER sorter1
   177 sensor :sorter_type sorter1 @type
-    * label *label51
   178 op notEqual *tmp67 :sorter_type @sorter
   179 op notEqual *tmp68 :sorter_type @inverted-sorter
   180 op land *tmp69 *tmp67 *tmp68
 
   186 print "Block found: "
   187 print .SORTER
   188 label *label54
-    * label *label55
   189 printflush message1
   190 set .SORTER sorter1
   191 sensor :sorter_type sorter1 @type
-    * label *label52
   192 op notEqual *tmp67 :sorter_type @sorter
   193 op notEqual *tmp68 :sorter_type @inverted-sorter
   194 op land *tmp69 *tmp67 *tmp68
 
   274 label *label78
   275 label *label76
   276 printflush message1
-    * label *label73
   277 jump *label72 always
-    * label *label74
   278 label *label71
   279 ucontrol flag 1
   280 set :state 1
   281 label *label69
-    * label *label70
   282 sensor .ITEM .SORTER @config
   283 jump *label79 equal .ITEM .LAST_ITEM
-    * label *label81
   284 jump *label83 notEqual .ITEM null
   285 label *label135
   286 print "[salmon]No item type selected for transport."
   287 printflush message1
   288 sensor .ITEM .SORTER @config
-    * label *label82
   289 jump *label135 equal .ITEM null
   290 label *label83
   291 set .LAST_ITEM .ITEM
   292 set :state 1
   293 label *label79
-    * label *label80
   294 set :show_state 0
   295 jump *label84 notEqual :state 1
   296 sensor *tmp127 @unit @firstItem
 
   309 jump *label90 equal *tmp133 false
   310 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
   311 label *label90
-    * label *label91
   312 label *label89
   313 label *label87
   314 label *label84
-    * label *label85
   315 jump *label92 notEqual :state 2
   316 ucontrol within .SRC_X .SRC_Y 8 *tmp137
   317 jump *label94 equal *tmp137 false
 
   329 set :show_state 2
   330 label *label95
   331 label *label92
-    * label *label93
   332 jump *label98 notEqual :state 3
   333 ucontrol within .DST_X .DST_Y 8 *tmp147
   334 jump *label100 equal *tmp147 false
 
   351 set :show_state 3
   352 label *label101
   353 label *label98
-    * label *label99
   354 jump *label104 lessThanEq :iter 3
   355 set :iter 0
   356 print "Moving [green]"
 
   370 print "["
   371 print "])"
   372 label *label106
-    * label *label107
   373 jump *label108 equal .SHOW_REMOTE_LEVEL false
   374 sensor *tmp161 .CORE .ITEM
   375 print "\n"
 
   383 print "["
   384 print "])"
   385 label *label110
-    * label *label111
   386 label *label108
-    * label *label109
   387 sensor *tmp164 @unit @totalItems
   388 print .MSG
   389 print *tmp164
 
   418 print "sec[]"
   419 print "\n"
   420 label *label116
-    * label *label117
   421 label *label115
-    * label *label112
-    * label *label113
   422 op floor *tmp184 :loop_time
   423 print "[lightgray]Loop time: "
   424 print *tmp184
 
   429 jump *label118 notEqual *tmp185 0
   430 jump *label68 always
   431 label *label118
-    * label *label119
   432 sensor *tmp188 .SRC @dead
   433 jump *label120 equal *tmp188 0
   434 jump *label68 always
   435 label *label120
-    * label *label121
   436 sensor *tmp191 .DST @dead
   437 jump *label122 equal *tmp191 0
   438 jump *label68 always
   439 label *label122
-    * label *label123
   440 sensor *tmp194 .SORTER @dead
   441 jump *label124 equal *tmp194 0
   442 jump *label68 always
   443 label *label124
-    * label *label125
   444 jump *label105 always
   445 label *label104
   446 op add :iter :iter 1
   447 label *label105
   448 op sub :loop_time @time :start
-    * label *label67
   449 jump *label66 always
   450 label *label68
-    * label *label126
   451 sensor *tmp198 .SORTER @dead
   452 jump *label128 strictEqual *tmp198 0
   453 label *label138
 
   457 print "\n"
   458 printflush message1
   459 printflush message2
-    * label *label127
   460 sensor *tmp198 sorter1 @dead
   461 jump *label138 strictNotEqual *tmp198 0
   462 label *label128
 
   467 op or *tmp205 *tmp202 *tmp204
   468 jump *label129 equal *tmp205 false
   469 control enabled switch1 false
-    * label *label131
   470 sensor *tmp208 switch1 @enabled
   471 jump *label133 notEqual *tmp208 false
   472 label *label139
 
   476 print "\n"
   477 printflush message1
   478 printflush message2
-    * label *label132
   479 sensor *tmp208 switch1 @enabled
   480 jump *label139 equal *tmp208 false
   481 label *label133
   482 label *label129
-    * label *label130
   483 end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-5 instructions):
 
    34 label *label9
    35 label *label12
    36 sensor *tmp10 @unit @controller
-    * jump *label15 notEqual *tmp10 @this
-    * jump *label6 always
+   37 jump *label6 equal *tmp10 @this
    38 label *label15
    39 ubind UNIT
    40 print "[gold]Looking for old unit..."
 
   425 print "\n"
   426 printflush message1
   427 sensor *tmp185 switch1 @enabled
-    * jump *label118 notEqual *tmp185 0
-    * jump *label68 always
+  428 jump *label68 equal *tmp185 0
   429 label *label118
   430 sensor *tmp188 .SRC @dead
-    * jump *label120 equal *tmp188 0
-    * jump *label68 always
+  431 jump *label68 notEqual *tmp188 0
   432 label *label120
   433 sensor *tmp191 .DST @dead
-    * jump *label122 equal *tmp191 0
-    * jump *label68 always
+  434 jump *label68 notEqual *tmp191 0
   435 label *label122
   436 sensor *tmp194 .SORTER @dead
-    * jump *label124 equal *tmp194 0
-    * jump *label68 always
+  437 jump *label68 notEqual *tmp194 0
   438 label *label124
   439 jump *label105 always
   440 label *label104

Modifications by Jumps phase, Jump Optimization, pass 5, iteration 1:
 
    35 label *label12
    36 sensor *tmp10 @unit @controller
    37 jump *label6 equal *tmp10 @this
-    * label *label15
    38 ubind UNIT
    39 print "[gold]Looking for old unit..."
    40 printflush message1
 
   425 printflush message1
   426 sensor *tmp185 switch1 @enabled
   427 jump *label68 equal *tmp185 0
-    * label *label118
   428 sensor *tmp188 .SRC @dead
   429 jump *label68 notEqual *tmp188 0
-    * label *label120
   430 sensor *tmp191 .DST @dead
   431 jump *label68 notEqual *tmp191 0
-    * label *label122
   432 sensor *tmp194 .SORTER @dead
   433 jump *label68 notEqual *tmp194 0
-    * label *label124
   434 jump *label105 always
   435 label *label104
   436 op add :iter :iter 1

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
+    0 label __start__
     1 set UNIT @mega
     2 set LINK_ID 0
     3 set LOCAL_LIMIT 100
 
    54 jump *label22 always
    55 label *label21
    56 sensor *tmp20 @unit @controlled
-    * jump *label23 equal *tmp20 0
+   57 jump *label17 equal *tmp20 0
    58 print "[salmon]Looking for a free "
    59 print UNIT
    60 print "."
 
    99 sensor *tmp36 .DROP_TARGET @itemCapacity
   100 op lessThan *tmp37 *tmp36 300
   101 op land *tmp38 *tmp35 *tmp37
-    * jump *label35 equal *tmp38 false
+  102 jump *label27 equal *tmp38 false
   103 print "Destination: "
   104 print .CONTAINER
   105 print "\"
 
   262 jump *label76 always
   263 label *label75
   264 sensor *tmp117 @unit @controlled
-    * jump *label77 equal *tmp117 0
+  265 jump *label71 equal *tmp117 0
   266 print "[salmon]Looking for a free "
   267 print UNIT
   268 print "."
 
   339 jump *label102 greaterThan *tmp152 0
   340 set :state 2
   341 ucontrol approach .SRC_X .SRC_Y 6
-    * jump *label103 always
+  342 jump *label101 always
   343 label *label102
   344 set .MSG "\nDropping items: [green]"
   345 label *label103
 
   456 sensor *tmp203 .DST @dead
   457 op strictNotEqual *tmp204 *tmp203 0
   458 op or *tmp205 *tmp202 *tmp204
-    * jump *label129 equal *tmp205 false
+  459 jump __start__ equal *tmp205 false
   460 control enabled switch1 false
   461 sensor *tmp208 switch1 @enabled
-    * jump *label133 notEqual *tmp208 false
+  462 jump __start__ notEqual *tmp208 false
   463 label *label139
   464 print "[salmon]Local or remote container became invalid."
   465 print "\n"

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-3 instructions):
 
    60 print "."
    61 print ".."
    62 jump *label24 always
-    * label *label23
-    * jump *label17 always
    63 label *label24
    64 label *label22
    65 printflush message1
 
   108 print "n"
   109 print "[salmon]Item dump must be a container or a vault!"
   110 jump *label36 always
-    * label *label35
-    * jump *label27 always
   111 label *label36
   112 label *label34
   113 printflush message1
 
   264 print "."
   265 print ".."
   266 jump *label78 always
-    * label *label77
-    * jump *label71 always
   267 label *label78
   268 label *label76
   269 printflush message1
 
   336 jump *label101 always
   337 label *label102
   338 set .MSG "\nDropping items: [green]"
-    * label *label103
   339 jump *label101 always
   340 label *label100
   341 ucontrol approach .DST_X .DST_Y 6
 
   462 printflush message2
   463 sensor *tmp208 switch1 @enabled
   464 jump *label139 equal *tmp208 false
-    * label *label133
-    * label *label129
   465 end

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-4 instructions):
 
    59 print UNIT
    60 print "."
    61 print ".."
-    * jump *label24 always
    62 label *label24
    63 label *label22
    64 printflush message1
 
   106 print "\"
   107 print "n"
   108 print "[salmon]Item dump must be a container or a vault!"
-    * jump *label36 always
   109 label *label36
   110 label *label34
   111 printflush message1
 
   261 print UNIT
   262 print "."
   263 print ".."
-    * jump *label78 always
   264 label *label78
   265 label *label76
   266 printflush message1
 
   459 printflush message2
   460 sensor *tmp208 switch1 @enabled
   461 jump *label139 equal *tmp208 false
-    * end

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
    59 print UNIT
    60 print "."
    61 print ".."
-    * label *label24
    62 label *label22
    63 printflush message1
    64 jump *label18 always
 
   105 print "\"
   106 print "n"
   107 print "[salmon]Item dump must be a container or a vault!"
-    * label *label36
   108 label *label34
   109 printflush message1
   110 jump *label25 always
 
   259 print UNIT
   260 print "."
   261 print ".."
-    * label *label78
   262 label *label76
   263 printflush message1
   264 jump *label72 always

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
   115 jump *label37 notEqual LINK_ID 0
   116 print "[gold]Locating core..."
   117 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp43 .CORE
+  118 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   119 jump *label38 always
   120 label *label37
   121 print "[gold]Locating vault #"
 
   157 op land *tmp59 *tmp56 *tmp58
   158 jump *label142 notEqual *tmp59 false
   159 label *label46
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE *tmp61
+  160 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   161 select .CORE notEqual :b_type @vault null .CORE
   162 label *label42
   163 label *label38

Modifications by Final phase, Print Merging, iteration 1 (-50 instructions):
 
     8 sensor *tmp2 switch1 @enabled
     9 jump *label2 notEqual *tmp2 false
    10 label *label136
-    * print "Unit Transport - Single"
-    * print "\n"
-    * print "Activate switch to start."
-    * print "\n"
+   11 print "Unit Transport - Single\nActivate switch to start.\n"
    12 printflush message1
    13 sensor *tmp2 switch1 @enabled
    14 jump *label136 equal *tmp2 false
 
    23 set :rebindUnit:first_unit @unit
    24 jump *label9 always
    25 label *label10
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 1"
+   26 print "[salmon]No unit of type {0} found. 1"
+   27 format UNIT
    28 printflush message1
    29 jump *label7 always
    30 label *label9
 
    42 label *label18
    43 ubind UNIT
    44 jump *label21 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+   45 print "[salmon]No unit of type {0} found. 2"
+   46 format UNIT
    47 jump *label22 always
    48 label *label21
    49 sensor *tmp20 @unit @controlled
    50 jump *label17 equal *tmp20 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+   51 print "[salmon]Looking for a free {0}..."
+   52 format UNIT
    53 label *label22
    54 printflush message1
    55 jump *label18 always
 
    78 jump *label134 greaterThan :n 0
    79 label *label30
    80 jump *label33 notEqual .CONTAINER null
-    * print "[salmon]No destination."
-    * print "\n"
+   81 print "[salmon]No destination.\n"
    82 jump *label34 always
    83 label *label33
    84 op notEqual *tmp35 .DROP_TARGET null
 
    86 op lessThan *tmp37 *tmp36 300
    87 op land *tmp38 *tmp35 *tmp37
    88 jump *label27 equal *tmp38 false
-    * print "Destination: "
-    * print .CONTAINER
-    * print "\"
-    * print "n"
-    * print "Item dump: "
-    * print .DROP_TARGET
-    * print "\"
-    * print "n"
-    * print "[salmon]Item dump must be a container or a vault!"
+   89 print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
+   90 format .CONTAINER
+   91 format .DROP_TARGET
    92 label *label34
    93 printflush message1
    94 jump *label25 always
 
   102 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   103 jump *label38 always
   104 label *label37
-    * print "[gold]Locating vault #"
-    * print LINK_ID
-    * print "."
-    * print ".."
+  105 print "[gold]Locating vault #{0}..."
+  106 format LINK_ID
   107 printflush message1
   108 op add .QUERY_FLAG 99999900 LINK_ID
   109 set :flag .QUERY_FLAG
 
   153 op land *tmp69 *tmp67 *tmp68
   154 jump *label53 equal *tmp69 false
   155 label *label140
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  156 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   157 jump *label54 equal .SORTER null
   158 print "Block found: "
   159 print .SORTER
 
   228 label *label72
   229 ubind UNIT
   230 jump *label75 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+  231 print "[salmon]No unit of type {0} found. 2"
+  232 format UNIT
   233 jump *label76 always
   234 label *label75
   235 sensor *tmp117 @unit @controlled
   236 jump *label71 equal *tmp117 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+  237 print "[salmon]Looking for a free {0}..."
+  238 format UNIT
   239 label *label76
   240 printflush message1
   241 jump *label72 always
 
   316 label *label98
   317 jump *label104 lessThanEq :iter 3
   318 set :iter 0
-    * print "Moving [green]"
-    * print .ITEM
-    * print .DIRECTION
-    * print *tmp98
-    * print "\"
-    * print "n"
+  319 print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
+  320 format .ITEM
+  321 format .DIRECTION
+  322 format *tmp98
   323 sensor *tmp157 .CONTAINER .ITEM
-    * print "Local items: [gold]"
-    * print *tmp157
-    * print "["
-    * print "]"
+  324 format *tmp157
   325 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
-    * print " (limit [orange]"
-    * print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  326 print " (limit [orange]{0}[])"
+  327 format .LOCAL_MARGIN
   328 label *label106
   329 jump *label108 equal .SHOW_REMOTE_LEVEL false
   330 sensor *tmp161 .CORE .ITEM
-    * print "\n"
-    * print "Remote items: [gold]"
-    * print *tmp161
-    * print "["
-    * print "]"
+  331 print "\nRemote items: [gold]{0}[]"
+  332 format *tmp161
   333 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
-    * print " (limit [orange]"
-    * print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  334 print " (limit [orange]{0}[])"
+  335 format .REMOTE_MARGIN
   336 label *label110
   337 label *label108
   338 sensor *tmp164 @unit @totalItems
   339 print .MSG
   340 print *tmp164
-    * print "[]"
-    * print "\n"
+  341 print "[]\n"
   342 jump *label114 notEqual :show_state 2
   343 sensor *tmp168 @unit @x
   344 op sub *tmp169 .SRC_X *tmp168
 
   347 op len *tmp172 *tmp169 *tmp171
   348 op idiv *tmp173 *tmp172 .SPEED_SEC
   349 op div *tmp174 *tmp173 10
-    * print "[]  arriving in [gold]"
-    * print *tmp174
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  350 print "[]  arriving in [gold]{0} sec[]\n"
+  351 format *tmp174
   352 jump *label115 always
   353 label *label114
   354 jump *label116 notEqual :show_state 3
 
   359 op len *tmp181 *tmp178 *tmp180
   360 op idiv *tmp182 *tmp181 .SPEED_SEC
   361 op div *tmp183 *tmp182 10
-    * print "[]  arriving in [gold]"
-    * print *tmp183
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  362 print "[]  arriving in [gold]{0} sec[]\n"
+  363 format *tmp183
   364 label *label116
   365 label *label115
   366 op floor *tmp184 :loop_time
-    * print "[lightgray]Loop time: "
-    * print *tmp184
-    * print " ms[]"
-    * print "\n"
+  367 print "[lightgray]Loop time: {0} ms[]\n"
+  368 format *tmp184
   369 printflush message1
   370 sensor *tmp185 switch1 @enabled
   371 jump *label68 equal *tmp185 0
 
   385 sensor *tmp198 .SORTER @dead
   386 jump *label128 strictEqual *tmp198 0
   387 label *label138
-    * print "[salmon]sorter1 is missing!"
-    * print "\n"
-    * print "[gold]Please place and link sorter or inverted sorter to the processor."
-    * print "\n"
+  388 print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
   389 printflush message1
   390 printflush message2
   391 sensor *tmp198 sorter1 @dead
 
   401 sensor *tmp208 switch1 @enabled
   402 jump __start__ notEqual *tmp208 false
   403 label *label139
-    * print "[salmon]Local or remote container became invalid."
-    * print "\n"
-    * print "[gold]Please fix and press button to reinitialize."
-    * print "\n"
+  404 print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
   405 printflush message1
   406 printflush message2
   407 sensor *tmp208 switch1 @enabled

Final code before resolving virtual instructions:

label __start__
set UNIT @mega
set LINK_ID 0
set LOCAL_LIMIT 100
set REMOTE_LIMIT 100
op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
set .MSG null
sensor *tmp2 switch1 @enabled
jump *label2 notEqual *tmp2 false
label *label136
print "Unit Transport - Single\nActivate switch to start.\n"
printflush message1
sensor *tmp2 switch1 @enabled
jump *label136 equal *tmp2 false
label *label2
sensor *tmp4 @unit @dead
jump *label5 strictEqual *tmp4 0
label *label137
set :rebindUnit:first_unit null
label *label7
ubind UNIT
jump *label10 equal @unit null
set :rebindUnit:first_unit @unit
jump *label9 always
label *label10
print "[salmon]No unit of type {0} found. 1"
format UNIT
printflush message1
jump *label7 always
label *label9
label *label12
sensor *tmp10 @unit @controller
jump *label6 equal *tmp10 @this
ubind UNIT
print "[gold]Looking for old unit..."
printflush message1
op notEqual *tmp13 @unit :rebindUnit:first_unit
sensor *tmp14 :rebindUnit:first_unit @dead
op strictEqual *tmp15 *tmp14 0
op land *tmp16 *tmp13 *tmp15
jump *label12 notEqual *tmp16 false
label *label18
ubind UNIT
jump *label21 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label22 always
label *label21
sensor *tmp20 @unit @controlled
jump *label17 equal *tmp20 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label22
printflush message1
jump *label18 always
label *label17
label *label6
sensor *tmp4 @unit @dead
jump *label137 strictNotEqual *tmp4 0
label *label5
sensor .UNIT_CAPACITY @unit @itemCapacity
sensor *tmp24 @unit @speed
op div .SPEED_SEC *tmp24 10
ucontrol flag 1
label *label25
set .CONTAINER null
set .DROP_TARGET null
set :n @links
jump *label30 lessThanEq :n 0
label *label134
op sub :n :n 1
getlink :block :n
sensor *tmp30 :block @itemCapacity
jump *label31 lessThanEq *tmp30 0
set .DROP_TARGET .CONTAINER
set .CONTAINER :block
label *label31
jump *label134 greaterThan :n 0
label *label30
jump *label33 notEqual .CONTAINER null
print "[salmon]No destination.\n"
jump *label34 always
label *label33
op notEqual *tmp35 .DROP_TARGET null
sensor *tmp36 .DROP_TARGET @itemCapacity
op lessThan *tmp37 *tmp36 300
op land *tmp38 *tmp35 *tmp37
jump *label27 equal *tmp38 false
print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
format .CONTAINER
format .DROP_TARGET
label *label34
printflush message1
jump *label25 always
label *label27
set .CORE_Y null
set .CORE_X null
set .CORE null
jump *label37 notEqual LINK_ID 0
print "[gold]Locating core..."
printflush message1
ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
jump *label38 always
label *label37
print "[gold]Locating vault #{0}..."
format LINK_ID
printflush message1
op add .QUERY_FLAG 99999900 LINK_ID
set :flag .QUERY_FLAG
ucontrol flag .QUERY_FLAG
sensor *tmp46 @unit @dead
op strictEqual *tmp48 *tmp46 0
jump *label41 equal *tmp48 false
label *label141
ucontrol stop
sensor :flag @unit @flag
op equal *tmp45 :flag .QUERY_FLAG
sensor *tmp46 @unit @dead
op strictEqual *tmp47 *tmp46 0
op land *tmp48 *tmp45 *tmp47
jump *label141 notEqual *tmp48 false
label *label41
jump *label42 equal :flag .QUERY_FLAG
op idiv :position :flag 100
op mod .CORE_X :position @mapw
op idiv .CORE_Y :position @mapw
ucontrol within .CORE_X .CORE_Y 8 *tmp55
op equal *tmp56 *tmp55 false
sensor *tmp57 @unit @dead
op equal *tmp58 *tmp57 0
op land *tmp59 *tmp56 *tmp58
jump *label46 equal *tmp59 false
label *label142
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp55
op equal *tmp56 *tmp55 false
sensor *tmp57 @unit @dead
op equal *tmp58 *tmp57 0
op land *tmp59 *tmp56 *tmp58
jump *label142 notEqual *tmp59 false
label *label46
ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
select .CORE notEqual :b_type @vault null .CORE
label *label42
label *label38
jump *label49 notEqual .CORE null
end
label *label49
set .SORTER sorter1
sensor :sorter_type sorter1 @type
op notEqual *tmp67 :sorter_type @sorter
op notEqual *tmp68 :sorter_type @inverted-sorter
op land *tmp69 *tmp67 *tmp68
jump *label53 equal *tmp69 false
label *label140
print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
jump *label54 equal .SORTER null
print "Block found: "
print .SORTER
label *label54
printflush message1
set .SORTER sorter1
sensor :sorter_type sorter1 @type
op notEqual *tmp67 :sorter_type @sorter
op notEqual *tmp68 :sorter_type @inverted-sorter
op land *tmp69 *tmp67 *tmp68
jump *label140 notEqual *tmp69 false
label *label53
jump *label56 notEqual :sorter_type @sorter
set .SHOW_REMOTE_LEVEL true
set .SRC .CORE
set .DST .CONTAINER
sensor :src_capacity .CORE @itemCapacity
sensor :dst_capacity .CONTAINER @itemCapacity
op sub *tmp77 100 .EFF_REMOTE_LIMIT
op mul *tmp78 :src_capacity *tmp77
op idiv .LOAD_LEVEL *tmp78 100
op mul *tmp80 :dst_capacity .EFF_LOCAL_LIMIT
op idiv .DROP_LEVEL *tmp80 100
set .LOCAL_MARGIN .DROP_LEVEL
set .REMOTE_MARGIN .LOAD_LEVEL
select .DIRECTION equal LINK_ID 0 "[] from core" "[] from vault #"
jump *label57 always
label *label56
op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
set .SRC .CONTAINER
set .DST .CORE
sensor :src_capacity .CONTAINER @itemCapacity
sensor :dst_capacity .CORE @itemCapacity
op sub *tmp87 100 .EFF_LOCAL_LIMIT
op mul *tmp88 :src_capacity *tmp87
op idiv .LOAD_LEVEL *tmp88 100
op mul *tmp90 :dst_capacity .EFF_REMOTE_LIMIT
op idiv *tmp91 *tmp90 100
op equal *tmp92 LINK_ID 0
op mul *tmp93 *tmp92 .UNIT_CAPACITY
op add .DROP_LEVEL *tmp91 *tmp93
set .LOCAL_MARGIN .LOAD_LEVEL
set .REMOTE_MARGIN .DROP_LEVEL
select .DIRECTION equal LINK_ID 0 "[] to core" "[] to vault #"
label *label57
select *tmp98 equal LINK_ID 0 "" LINK_ID
sensor .SRC_X .SRC @x
sensor .SRC_Y .SRC @y
sensor .DST_X .DST @x
sensor .DST_Y .DST @y
jump *label64 notEqual .DROP_TARGET null
set .DROP_TARGET .CORE
set .DROP_X .CORE_X
set .DROP_Y .CORE_Y
jump *label65 always
label *label64
sensor .DROP_X .DROP_TARGET @x
sensor .DROP_Y .DROP_TARGET @y
label *label65
set .LAST_ITEM @mono
set :iter 0
set :loop_time 0
set :state 1
ucontrol stop
label *label66
set :start @time
sensor *tmp108 @unit @dead
op strictEqual *tmp109 *tmp108 0
sensor *tmp110 @unit @controller
op notEqual *tmp111 *tmp110 @this
jump *label69 greaterThan *tmp109 *tmp111
label *label72
ubind UNIT
jump *label75 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label76 always
label *label75
sensor *tmp117 @unit @controlled
jump *label71 equal *tmp117 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label76
printflush message1
jump *label72 always
label *label71
ucontrol flag 1
set :state 1
label *label69
sensor .ITEM .SORTER @config
jump *label79 equal .ITEM .LAST_ITEM
jump *label83 notEqual .ITEM null
label *label135
print "[salmon]No item type selected for transport."
printflush message1
sensor .ITEM .SORTER @config
jump *label135 equal .ITEM null
label *label83
set .LAST_ITEM .ITEM
set :state 1
label *label79
set :show_state 0
jump *label84 notEqual :state 1
sensor *tmp127 @unit @firstItem
jump *label86 notEqual *tmp127 .ITEM
set :state 3
jump *label87 always
label *label86
sensor *tmp130 @unit @totalItems
jump *label88 notEqual *tmp130 0
set :state 2
jump *label89 always
label *label88
set .MSG "\nUnloading previous items: [green]"
ucontrol approach .DROP_X .DROP_Y 6
ucontrol within .DROP_X .DROP_Y 8 *tmp133
jump *label90 equal *tmp133 false
ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
label *label90
label *label89
label *label87
label *label84
jump *label92 notEqual :state 2
ucontrol within .SRC_X .SRC_Y 8 *tmp137
jump *label94 equal *tmp137 false
sensor *tmp139 .SRC .ITEM
op sub *tmp140 *tmp139 .LOAD_LEVEL
op max :max_load *tmp140 0
ucontrol itemTake .SRC .ITEM :max_load
sensor *tmp142 @unit @totalItems
select :state greaterThanEq *tmp142 .UNIT_CAPACITY 3 :state
select .MSG greaterThanEq *tmp142 .UNIT_CAPACITY .MSG "\nLoading items: [green]"
jump *label95 always
label *label94
ucontrol approach .SRC_X .SRC_Y 6
set .MSG "\nGoing to source: [green]"
set :show_state 2
label *label95
label *label92
jump *label98 notEqual :state 3
ucontrol within .DST_X .DST_Y 8 *tmp147
jump *label100 equal *tmp147 false
sensor *tmp149 .DST .ITEM
op sub *tmp150 .DROP_LEVEL *tmp149
op max :max_drop *tmp150 0
ucontrol itemDrop .DST :max_drop
sensor *tmp152 @unit @totalItems
jump *label102 greaterThan *tmp152 0
set :state 2
ucontrol approach .SRC_X .SRC_Y 6
jump *label101 always
label *label102
set .MSG "\nDropping items: [green]"
jump *label101 always
label *label100
ucontrol approach .DST_X .DST_Y 6
set .MSG "\nGoing to destination: [green]"
set :show_state 3
label *label101
label *label98
jump *label104 lessThanEq :iter 3
set :iter 0
print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
format .ITEM
format .DIRECTION
format *tmp98
sensor *tmp157 .CONTAINER .ITEM
format *tmp157
jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
print " (limit [orange]{0}[])"
format .LOCAL_MARGIN
label *label106
jump *label108 equal .SHOW_REMOTE_LEVEL false
sensor *tmp161 .CORE .ITEM
print "\nRemote items: [gold]{0}[]"
format *tmp161
jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
print " (limit [orange]{0}[])"
format .REMOTE_MARGIN
label *label110
label *label108
sensor *tmp164 @unit @totalItems
print .MSG
print *tmp164
print "[]\n"
jump *label114 notEqual :show_state 2
sensor *tmp168 @unit @x
op sub *tmp169 .SRC_X *tmp168
sensor *tmp170 @unit @y
op sub *tmp171 .SRC_Y *tmp170
op len *tmp172 *tmp169 *tmp171
op idiv *tmp173 *tmp172 .SPEED_SEC
op div *tmp174 *tmp173 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp174
jump *label115 always
label *label114
jump *label116 notEqual :show_state 3
sensor *tmp177 @unit @x
op sub *tmp178 .DST_X *tmp177
sensor *tmp179 @unit @y
op sub *tmp180 .DST_Y *tmp179
op len *tmp181 *tmp178 *tmp180
op idiv *tmp182 *tmp181 .SPEED_SEC
op div *tmp183 *tmp182 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp183
label *label116
label *label115
op floor *tmp184 :loop_time
print "[lightgray]Loop time: {0} ms[]\n"
format *tmp184
printflush message1
sensor *tmp185 switch1 @enabled
jump *label68 equal *tmp185 0
sensor *tmp188 .SRC @dead
jump *label68 notEqual *tmp188 0
sensor *tmp191 .DST @dead
jump *label68 notEqual *tmp191 0
sensor *tmp194 .SORTER @dead
jump *label68 notEqual *tmp194 0
jump *label105 always
label *label104
op add :iter :iter 1
label *label105
op sub :loop_time @time :start
jump *label66 always
label *label68
sensor *tmp198 .SORTER @dead
jump *label128 strictEqual *tmp198 0
label *label138
print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
printflush message1
printflush message2
sensor *tmp198 sorter1 @dead
jump *label138 strictNotEqual *tmp198 0
label *label128
sensor *tmp201 .SRC @dead
op strictNotEqual *tmp202 *tmp201 0
sensor *tmp203 .DST @dead
op strictNotEqual *tmp204 *tmp203 0
op or *tmp205 *tmp202 *tmp204
jump __start__ equal *tmp205 false
control enabled switch1 false
sensor *tmp208 switch1 @enabled
jump __start__ notEqual *tmp208 false
label *label139
print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
printflush message1
printflush message2
sensor *tmp208 switch1 @enabled
jump *label139 equal *tmp208 false
