   602 instructions before optimizations.
    38 instructions eliminated by Temp Variables Elimination (2 iterations).
    86 instructions eliminated by Dead Code Elimination (7 iterations).
     6 instructions eliminated by Jump Normalization (6 iterations).
    42 instructions eliminated by Jump Optimization (6 iterations).
    27 instructions eliminated by Single Step Elimination (2 passes, 8 iterations).
     2 instructions modified by Expression Optimization (2 passes, 4 iterations).
    10 instructions eliminated by If Expression Optimization (5 iterations).
     4 instructions eliminated by Data Flow Optimization (5 passes, 19 iterations).
    18 instructions added by Loop Optimization (4 iterations).
     9 loops improved by Loop Optimization.
     5 instructions eliminated by Jump Straightening (6 iterations).
     7 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    50 instructions eliminated by Print Merging.
   349 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 604):
  * Replicate loop condition at line 43:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 51:1                        size    +2, benefit       25.0, efficiency     12.500
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333
    Replicate loop condition at line 304:1                       size    +2, benefit       25.0, efficiency     12.500
    Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500

Pass 1: speed optimization selection (cost limit 603):
    Replicate loop condition at line 51:1                        size    +2, benefit       25.0, efficiency     12.500
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333
    Replicate loop condition at line 304:1                       size    +2, benefit       25.0, efficiency     12.500
  * Replicate loop condition at line 314:5                       size    +1, benefit       12.5, efficiency     12.500 (+1 instructions)

Pass 1: speed optimization selection (cost limit 602):
  * Replicate loop condition at line 51:1                        size    +2, benefit       25.0, efficiency     12.500 (+2 instructions)
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333
    Replicate loop condition at line 304:1                       size    +2, benefit       25.0, efficiency     12.500

Pass 1: speed optimization selection (cost limit 600):
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
    Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333
  * Replicate loop condition at line 304:1                       size    +2, benefit       25.0, efficiency     12.500 (+1 instructions)

Pass 1: speed optimization selection (cost limit 599):
    Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250
  * Replicate loop condition at line 129:1                       size    +3, benefit       25.0, efficiency      8.333 (+3 instructions)

Pass 1: speed optimization selection (cost limit 596):
  * Replicate loop condition at line 102:5                       size    +4, benefit       12.5, efficiency      3.125 (+4 instructions)
    Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250

Pass 1: speed optimization selection (cost limit 592):
  * Replicate loop condition at line 110:9                       size    +5, benefit        6.3, efficiency      1.250 (+5 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-52 instructions):
 
    32 set *tmp10 @unit
    33 set :rebindUnit:first_unit *tmp10
    34 jump *label9 always
-    * set *tmp9 null
    35 jump *label11 always
    36 label *label10
-    * set *tmp9 null
    37 label *label11
    38 print "[salmon]No unit of type "
    39 print UNIT
 
    47 sensor *tmp11 @unit @controller
    48 op equal *tmp12 *tmp11 @this
    49 jump *label15 equal *tmp12 false
-    * set *tmp7 null
    50 jump *label6 always
-    * set *tmp13 null
    51 jump *label16 always
    52 label *label15
-    * set *tmp13 null
    53 label *label16
    54 ubind UNIT
    55 print "[gold]Looking for old unit..."
 
    70 print UNIT
    71 print " "
    72 print "found. 2"
-    * set *tmp20 null
    73 jump *label22 always
    74 label *label21
    75 sensor *tmp21 @unit @controlled
 
    86 jump *label17 always
    87 set *tmp23 null
    88 label *label24
-    * set *tmp20 *tmp23
    89 label *label22
    90 printflush message1
    91 label *label19
 
    93 label *label20
    94 set *tmp18 null
    95 label *label17
-    * set *tmp7 *tmp18
    96 label *label6
    97 label *label4
    98 jump *label3 always
 
   121 jump *label31 equal *tmp32 false
   122 set .DROP_TARGET .CONTAINER
   123 set .CONTAINER :block
-    * set *tmp33 .CONTAINER
   124 jump *label32 always
   125 label *label31
-    * set *tmp33 null
   126 label *label32
   127 label *label29
   128 jump *label28 always
 
   131 jump *label33 equal *tmp34 false
   132 print "[salmon]No destination."
   133 print "\n"
-    * set *tmp35 "[salmon]No destination."
   134 jump *label34 always
   135 label *label33
   136 op notEqual *tmp36 .DROP_TARGET null
 
   153 jump *label27 always
   154 set *tmp40 null
   155 label *label36
-    * set *tmp35 *tmp40
   156 label *label34
   157 printflush message1
   158 label *label26
 
   167 printflush message1
   168 ulocate building core false @copper .CORE_X .CORE_Y *tmp44 *tmp43
   169 set .CORE *tmp43
-    * set *tmp42 .CORE
   170 jump *label38 always
   171 label *label37
   172 print "[gold]Locating vault #"
 
   224 label *label42
   225 set *tmp52 null
   226 label *label43
-    * set *tmp42 *tmp52
   227 label *label38
   228 op equal *tmp65 .CORE null
   229 jump *label49 equal *tmp65 false
   230 end
-    * set *tmp66 null
   231 jump *label50 always
   232 label *label49
-    * set *tmp66 null
   233 label *label50
   234 set .SORTER sorter1
   235 sensor *tmp67 .SORTER @type
 
   245 jump *label54 equal *tmp71 false
   246 print "Block found: "
   247 print .SORTER
-    * set *tmp72 .SORTER
   248 jump *label55 always
   249 label *label54
-    * set *tmp72 null
   250 label *label55
   251 printflush message1
   252 set .SORTER sorter1
 
   281 set *tmp84 "[] from vault #"
   282 label *label59
   283 set .DIRECTION *tmp84
-    * set *tmp75 .DIRECTION
   284 jump *label57 always
   285 label *label56
   286 op greaterThan *tmp85 LINK_ID 0
 
   311 set *tmp97 "[] to vault #"
   312 label *label61
   313 set .DIRECTION *tmp97
-    * set *tmp75 .DIRECTION
   314 label *label57
   315 op equal *tmp98 LINK_ID 0
   316 jump *label62 equal *tmp98 false
 
   333 set .DROP_TARGET .CORE
   334 set .DROP_X .CORE_X
   335 set .DROP_Y .CORE_Y
-    * set *tmp105 .DROP_Y
   336 jump *label65 always
   337 label *label64
   338 sensor *tmp106 .DROP_TARGET @x
   339 set .DROP_X *tmp106
   340 sensor *tmp107 .DROP_TARGET @y
   341 set .DROP_Y *tmp107
-    * set *tmp105 .DROP_Y
   342 label *label65
   343 set .LAST_ITEM @mono
   344 set :iter 0
 
   364 print UNIT
   365 print " "
   366 print "found. 2"
-    * set *tmp117 null
   367 jump *label76 always
   368 label *label75
   369 sensor *tmp118 @unit @controlled
 
   376 set *tmp120 null
   377 jump *label78 always
   378 label *label77
-    * set *tmp115 null
   379 jump *label71 always
   380 set *tmp120 null
   381 label *label78
-    * set *tmp117 *tmp120
   382 label *label76
   383 printflush message1
   384 label *label73
   385 jump *label72 always
   386 label *label74
-    * set *tmp115 null
   387 label *label71
   388 ucontrol flag 1
   389 set :state 1
-    * set *tmp114 :state
   390 jump *label70 always
   391 label *label69
-    * set *tmp114 null
   392 label *label70
   393 sensor *tmp121 .SORTER @config
   394 set .ITEM *tmp121
 
   406 label *label83
   407 set .LAST_ITEM .ITEM
   408 set :state 1
-    * set *tmp123 :state
   409 jump *label80 always
   410 label *label79
-    * set *tmp123 null
   411 label *label80
   412 set :show_state 0
   413 op equal *tmp126 :state 1
 
   440 label *label89
   441 set *tmp130 *tmp133
   442 label *label87
-    * set *tmp127 *tmp130
   443 jump *label85 always
   444 label *label84
-    * set *tmp127 null
   445 label *label85
   446 op equal *tmp136 :state 2
   447 jump *label92 equal *tmp136 false
 
   470 set :show_state 2
   471 set *tmp139 :show_state
   472 label *label95
-    * set *tmp137 *tmp139
   473 jump *label93 always
   474 label *label92
-    * set *tmp137 null
   475 label *label93
   476 op equal *tmp146 :state 3
   477 jump *label98 equal *tmp146 false
 
   501 set :show_state 3
   502 set *tmp149 :show_state
   503 label *label101
-    * set *tmp147 *tmp149
   504 jump *label99 always
   505 label *label98
-    * set *tmp147 null
   506 label *label99
   507 op greaterThan *tmp156 :iter 3
   508 jump *label104 equal *tmp156 false
 
   524 print .LOCAL_MARGIN
   525 print "["
   526 print "])"
-    * set *tmp160 null
   527 jump *label107 always
   528 label *label106
-    * set *tmp160 null
   529 label *label107
   530 jump *label108 equal .SHOW_REMOTE_LEVEL false
   531 sensor *tmp162 .CORE .ITEM
 
   545 label *label110
   546 set *tmp164 null
   547 label *label111
-    * set *tmp161 *tmp164
   548 jump *label109 always
   549 label *label108
-    * set *tmp161 null
   550 label *label109
   551 sensor *tmp165 @unit @totalItems
   552 print .MSG
 
   592 label *label117
   593 set *tmp168 *tmp177
   594 label *label115
-    * set *tmp166 *tmp168
   595 jump *label113 always
   596 label *label112
-    * set *tmp166 null
   597 label *label113
   598 op floor *tmp185 :loop_time
   599 print "[lightgray]Loop time: "
 
   605 op equal *tmp187 *tmp186 0
   606 jump *label118 equal *tmp187 false
   607 jump *label68 always
-    * set *tmp188 null
   608 jump *label119 always
   609 label *label118
-    * set *tmp188 null
   610 label *label119
   611 sensor *tmp189 .SRC @dead
   612 op notEqual *tmp190 *tmp189 0
   613 jump *label120 equal *tmp190 false
   614 jump *label68 always
-    * set *tmp191 null
   615 jump *label121 always
   616 label *label120
-    * set *tmp191 null
   617 label *label121
   618 sensor *tmp192 .DST @dead
   619 op notEqual *tmp193 *tmp192 0
   620 jump *label122 equal *tmp193 false
   621 jump *label68 always
-    * set *tmp194 null
   622 jump *label123 always
   623 label *label122
-    * set *tmp194 null
   624 label *label123
   625 sensor *tmp195 .SORTER @dead
   626 op notEqual *tmp196 *tmp195 0
 
   631 label *label124
   632 set *tmp197 null
   633 label *label125
-    * set *tmp157 *tmp197
   634 jump *label105 always
   635 label *label104
   636 op add :iter :iter 1
-    * set *tmp157 :iter
   637 label *label105
   638 op sub *tmp198 @time :start
   639 set :loop_time *tmp198
 
   677 label *label132
   678 jump *label131 always
   679 label *label133
-    * set *tmp209 null
   680 jump *label130 always
   681 label *label129
-    * set *tmp209 null
   682 label *label130
   683 end

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-22 instructions):
 
    79 print UNIT
    80 print "."
    81 print ".."
-    * set *tmp23 null
    82 jump *label24 always
    83 label *label23
-    * set *tmp18 null
    84 jump *label17 always
-    * set *tmp23 null
    85 label *label24
    86 label *label22
    87 printflush message1
    88 label *label19
    89 jump *label18 always
    90 label *label20
-    * set *tmp18 null
    91 label *label17
    92 label *label6
    93 label *label4
 
   143 print "\"
   144 print "n"
   145 print "[salmon]Item dump must be a container or a vault!"
-    * set *tmp40 null
   146 jump *label36 always
   147 label *label35
   148 jump *label27 always
-    * set *tmp40 null
   149 label *label36
   150 label *label34
   151 printflush message1
 
   213 label *label47
   214 set *tmp64 null
   215 label *label48
-    * set *tmp52 *tmp64
   216 jump *label43 always
   217 label *label42
-    * set *tmp52 null
   218 label *label43
   219 label *label38
   220 op equal *tmp65 .CORE null
 
   365 print UNIT
   366 print "."
   367 print ".."
-    * set *tmp120 null
   368 jump *label78 always
   369 label *label77
   370 jump *label71 always
-    * set *tmp120 null
   371 label *label78
   372 label *label76
   373 printflush message1
 
   406 op equal *tmp129 *tmp128 .ITEM
   407 jump *label86 equal *tmp129 false
   408 set :state 3
-    * set *tmp130 :state
   409 jump *label87 always
   410 label *label86
   411 sensor *tmp131 @unit @totalItems
 
   427 label *label91
   428 set *tmp133 *tmp135
   429 label *label89
-    * set *tmp130 *tmp133
   430 label *label87
   431 jump *label85 always
   432 label *label84
 
   450 set .MSG "\nLoading items: [green]"
   451 set *tmp145 .MSG
   452 label *label97
-    * set *tmp139 *tmp145
   453 jump *label95 always
   454 label *label94
   455 ucontrol approach .SRC_X .SRC_Y 6
   456 set .MSG "\nGoing to source: [green]"
   457 set :show_state 2
-    * set *tmp139 :show_state
   458 label *label95
   459 jump *label93 always
   460 label *label92
 
   479 set .MSG "\nDropping items: [green]"
   480 set *tmp155 .MSG
   481 label *label103
-    * set *tmp149 *tmp155
   482 jump *label101 always
   483 label *label100
   484 ucontrol approach .DST_X .DST_Y 6
   485 set .MSG "\nGoing to destination: [green]"
   486 set :show_state 3
-    * set *tmp149 :show_state
   487 label *label101
   488 jump *label99 always
   489 label *label98
 
   524 print .REMOTE_MARGIN
   525 print "["
   526 print "])"
-    * set *tmp164 null
   527 jump *label111 always
   528 label *label110
-    * set *tmp164 null
   529 label *label111
   530 jump *label109 always
   531 label *label108
 
   550 print " "
   551 print "sec[]"
   552 print "\n"
-    * set *tmp168 null
   553 jump *label115 always
   554 label *label114
   555 op equal *tmp176 :show_state 3
 
   571 label *label116
   572 set *tmp177 null
   573 label *label117
-    * set *tmp168 *tmp177
   574 label *label115
   575 jump *label113 always
   576 label *label112
 
   606 op notEqual *tmp196 *tmp195 0
   607 jump *label124 equal *tmp196 false
   608 jump *label68 always
-    * set *tmp197 null
   609 jump *label125 always
   610 label *label124
-    * set *tmp197 null
   611 label *label125
   612 jump *label105 always
   613 label *label104

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-10 instructions):
 
   208 op notEqual *tmp63 :b_type @vault
   209 jump *label47 equal *tmp63 false
   210 set .CORE null
-    * set *tmp64 .CORE
   211 jump *label48 always
   212 label *label47
-    * set *tmp64 null
   213 label *label48
   214 jump *label43 always
   215 label *label42
 
   410 op equal *tmp132 *tmp131 0
   411 jump *label88 equal *tmp132 false
   412 set :state 2
-    * set *tmp133 :state
   413 jump *label89 always
   414 label *label88
   415 set .MSG "\nUnloading previous items: [green]"
 
   422 label *label90
   423 set *tmp135 null
   424 label *label91
-    * set *tmp133 *tmp135
   425 label *label89
   426 label *label87
   427 jump *label85 always
 
   440 op greaterThanEq *tmp144 *tmp143 .UNIT_CAPACITY
   441 jump *label96 equal *tmp144 false
   442 set :state 3
-    * set *tmp145 :state
   443 jump *label97 always
   444 label *label96
   445 set .MSG "\nLoading items: [green]"
-    * set *tmp145 .MSG
   446 label *label97
   447 jump *label95 always
   448 label *label94
 
   467 jump *label102 equal *tmp154 false
   468 set :state 2
   469 ucontrol approach .SRC_X .SRC_Y 6
-    * set *tmp155 null
   470 jump *label103 always
   471 label *label102
   472 set .MSG "\nDropping items: [green]"
-    * set *tmp155 .MSG
   473 label *label103
   474 jump *label101 always
   475 label *label100
 
   558 print " "
   559 print "sec[]"
   560 print "\n"
-    * set *tmp177 null
   561 jump *label117 always
   562 label *label116
-    * set *tmp177 null
   563 label *label117
   564 label *label115
   565 jump *label113 always

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   417 ucontrol within .DROP_X .DROP_Y 8 *tmp134
   418 jump *label90 equal *tmp134 false
   419 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * set *tmp135 null
   420 jump *label91 always
   421 label *label90
-    * set *tmp135 null
   422 label *label91
   423 label *label89
   424 label *label87

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-38 instructions):
 
     1 set LINK_ID 0
     2 set LOCAL_LIMIT 100
     3 set REMOTE_LIMIT 100
-    * op max *tmp0 LOCAL_LIMIT 20
-    * set .EFF_LOCAL_LIMIT *tmp0
-    * op max *tmp1 REMOTE_LIMIT 20
-    * set .EFF_REMOTE_LIMIT *tmp1
+    4 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
+    5 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
 
    27 ubind UNIT
    28 op notEqual *tmp8 @unit null
    29 jump *label10 equal *tmp8 false
-    * set *tmp10 @unit
-    * set :rebindUnit:first_unit *tmp10
+   30 set :rebindUnit:first_unit @unit
    31 jump *label9 always
    32 jump *label11 always
    33 label *label10
 
    90 label *label4
    91 jump *label3 always
    92 label *label5
-    * sensor *tmp24 @unit @itemCapacity
-    * set .UNIT_CAPACITY *tmp24
+   93 sensor .UNIT_CAPACITY @unit @itemCapacity
    94 sensor *tmp25 @unit @speed
-    * op div *tmp26 *tmp25 10
-    * set .SPEED_SEC *tmp26
+   95 op div .SPEED_SEC *tmp25 10
    96 ucontrol flag 1
    97 label *label25
    98 jump *label27 equal true false
    99 set .CONTAINER null
   100 set .DROP_TARGET null
-    * set *tmp27 @links
-    * set :n *tmp27
+  101 set :n @links
   102 label *label28
   103 op greaterThan *tmp28 :n 0
   104 jump *label30 equal *tmp28 false
-    * op sub *tmp29 :n 1
-    * set :n *tmp29
-    * getlink *tmp30 :n
-    * set :block *tmp30
+  105 op sub :n :n 1
+  106 getlink :block :n
   107 sensor *tmp31 :block @itemCapacity
   108 op greaterThan *tmp32 *tmp31 0
   109 jump *label31 equal *tmp32 false
 
   151 jump *label37 equal *tmp41 false
   152 print "[gold]Locating core..."
   153 printflush message1
-    * ulocate building core false @copper .CORE_X .CORE_Y *tmp44 *tmp43
-    * set .CORE *tmp43
+  154 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   155 jump *label38 always
   156 label *label37
   157 print "[gold]Locating vault #"
 
   159 print "."
   160 print ".."
   161 printflush message1
-    * op add *tmp45 99999900 LINK_ID
-    * set .QUERY_FLAG *tmp45
+  162 op add .QUERY_FLAG 99999900 LINK_ID
   163 set :flag .QUERY_FLAG
   164 ucontrol flag :flag
   165 label *label39
 
   169 op land *tmp49 *tmp46 *tmp48
   170 jump *label41 equal *tmp49 false
   171 ucontrol stop
-    * sensor *tmp50 @unit @flag
-    * set :flag *tmp50
+  172 sensor :flag @unit @flag
   173 label *label40
   174 jump *label39 always
   175 label *label41
   176 op notEqual *tmp51 :flag .QUERY_FLAG
   177 jump *label42 equal *tmp51 false
-    * op idiv *tmp53 :flag 100
-    * set :position *tmp53
-    * op mod *tmp54 :position @mapw
-    * set .CORE_X *tmp54
-    * op idiv *tmp55 :position @mapw
-    * set .CORE_Y *tmp55
+  178 op idiv :position :flag 100
+  179 op mod .CORE_X :position @mapw
+  180 op idiv .CORE_Y :position @mapw
   181 label *label44
   182 ucontrol within .CORE_X .CORE_Y 8 *tmp56
   183 op equal *tmp57 *tmp56 false
 
   189 label *label45
   190 jump *label44 always
   191 label *label46
-    * ucontrol getBlock .CORE_X .CORE_Y :b_type *tmp61 *tmp62
-    * set .CORE *tmp61
+  192 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   193 op notEqual *tmp63 :b_type @vault
   194 jump *label47 equal *tmp63 false
   195 set .CORE null
 
   207 label *label49
   208 label *label50
   209 set .SORTER sorter1
-    * sensor *tmp67 .SORTER @type
-    * set :sorter_type *tmp67
+  210 sensor :sorter_type .SORTER @type
   211 label *label51
   212 op notEqual *tmp68 :sorter_type @sorter
   213 op notEqual *tmp69 :sorter_type @inverted-sorter
 
   224 label *label55
   225 printflush message1
   226 set .SORTER sorter1
-    * sensor *tmp73 .SORTER @type
-    * set :sorter_type *tmp73
+  227 sensor :sorter_type .SORTER @type
   228 label *label52
   229 jump *label51 always
   230 label *label53
 
   233 set .SHOW_REMOTE_LEVEL true
   234 set .SRC .CORE
   235 set .DST .CONTAINER
-    * sensor *tmp76 .SRC @itemCapacity
-    * set :src_capacity *tmp76
-    * sensor *tmp77 .DST @itemCapacity
-    * set :dst_capacity *tmp77
+  236 sensor :src_capacity .SRC @itemCapacity
+  237 sensor :dst_capacity .DST @itemCapacity
   238 op sub *tmp78 100 .EFF_REMOTE_LIMIT
   239 op mul *tmp79 :src_capacity *tmp78
-    * op idiv *tmp80 *tmp79 100
-    * set .LOAD_LEVEL *tmp80
+  240 op idiv .LOAD_LEVEL *tmp79 100
   241 op mul *tmp81 :dst_capacity .EFF_LOCAL_LIMIT
-    * op idiv *tmp82 *tmp81 100
-    * set .DROP_LEVEL *tmp82
+  242 op idiv .DROP_LEVEL *tmp81 100
   243 set .LOCAL_MARGIN .DROP_LEVEL
   244 set .REMOTE_MARGIN .LOAD_LEVEL
   245 op equal *tmp83 LINK_ID 0
 
   252 set .DIRECTION *tmp84
   253 jump *label57 always
   254 label *label56
-    * op greaterThan *tmp85 LINK_ID 0
-    * set .SHOW_REMOTE_LEVEL *tmp85
+  255 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   256 set .SRC .CONTAINER
   257 set .DST .CORE
-    * sensor *tmp86 .SRC @itemCapacity
-    * set :src_capacity *tmp86
-    * sensor *tmp87 .DST @itemCapacity
-    * set :dst_capacity *tmp87
+  258 sensor :src_capacity .SRC @itemCapacity
+  259 sensor :dst_capacity .DST @itemCapacity
   260 op sub *tmp88 100 .EFF_LOCAL_LIMIT
   261 op mul *tmp89 :src_capacity *tmp88
-    * op idiv *tmp90 *tmp89 100
-    * set .LOAD_LEVEL *tmp90
+  262 op idiv .LOAD_LEVEL *tmp89 100
   263 op mul *tmp91 :dst_capacity .EFF_REMOTE_LIMIT
   264 op idiv *tmp92 *tmp91 100
   265 op equal *tmp93 LINK_ID 0
   266 op mul *tmp94 *tmp93 .UNIT_CAPACITY
-    * op add *tmp95 *tmp92 *tmp94
-    * set .DROP_LEVEL *tmp95
+  267 op add .DROP_LEVEL *tmp92 *tmp94
   268 set .LOCAL_MARGIN .LOAD_LEVEL
   269 set .REMOTE_MARGIN .DROP_LEVEL
   270 op equal *tmp96 LINK_ID 0
 
   284 set *tmp99 LINK_ID
   285 label *label63
   286 set .LINK_TXT *tmp99
-    * sensor *tmp100 .SRC @x
-    * set .SRC_X *tmp100
-    * sensor *tmp101 .SRC @y
-    * set .SRC_Y *tmp101
-    * sensor *tmp102 .DST @x
-    * set .DST_X *tmp102
-    * sensor *tmp103 .DST @y
-    * set .DST_Y *tmp103
+  287 sensor .SRC_X .SRC @x
+  288 sensor .SRC_Y .SRC @y
+  289 sensor .DST_X .DST @x
+  290 sensor .DST_Y .DST @y
   291 op equal *tmp104 .DROP_TARGET null
   292 jump *label64 equal *tmp104 false
   293 set .DROP_TARGET .CORE
 
   295 set .DROP_Y .CORE_Y
   296 jump *label65 always
   297 label *label64
-    * sensor *tmp106 .DROP_TARGET @x
-    * set .DROP_X *tmp106
-    * sensor *tmp107 .DROP_TARGET @y
-    * set .DROP_Y *tmp107
+  298 sensor .DROP_X .DROP_TARGET @x
+  299 sensor .DROP_Y .DROP_TARGET @y
   300 label *label65
   301 set .LAST_ITEM @mono
   302 set :iter 0
 
   305 ucontrol stop
   306 label *label66
   307 jump *label68 equal true false
-    * set *tmp108 @time
-    * set :start *tmp108
+  308 set :start @time
   309 sensor *tmp109 @unit @dead
   310 op strictEqual *tmp110 *tmp109 0
   311 sensor *tmp111 @unit @controller
 
   345 jump *label70 always
   346 label *label69
   347 label *label70
-    * sensor *tmp121 .SORTER @config
-    * set .ITEM *tmp121
+  348 sensor .ITEM .SORTER @config
   349 op notEqual *tmp122 .ITEM .LAST_ITEM
   350 jump *label79 equal *tmp122 false
   351 label *label81
 
   353 jump *label83 equal *tmp124 false
   354 print "[salmon]No item type selected for transport."
   355 printflush message1
-    * sensor *tmp125 .SORTER @config
-    * set .ITEM *tmp125
+  356 sensor .ITEM .SORTER @config
   357 label *label82
   358 jump *label81 always
   359 label *label83
 
   396 jump *label94 equal *tmp138 false
   397 sensor *tmp140 .SRC .ITEM
   398 op sub *tmp141 *tmp140 .LOAD_LEVEL
-    * op max *tmp142 *tmp141 0
-    * set :max_load *tmp142
+  399 op max :max_load *tmp141 0
   400 ucontrol itemTake .SRC .ITEM :max_load
   401 sensor *tmp143 @unit @totalItems
   402 op greaterThanEq *tmp144 *tmp143 .UNIT_CAPACITY
 
   421 jump *label100 equal *tmp148 false
   422 sensor *tmp150 .DST .ITEM
   423 op sub *tmp151 .DROP_LEVEL *tmp150
-    * op max *tmp152 *tmp151 0
-    * set :max_drop *tmp152
+  424 op max :max_drop *tmp151 0
   425 ucontrol itemDrop .DST :max_drop
   426 sensor *tmp153 @unit @totalItems
   427 op lessThanEq *tmp154 *tmp153 0
 
   564 label *label104
   565 op add :iter :iter 1
   566 label *label105
-    * op sub *tmp198 @time :start
-    * set :loop_time *tmp198
+  567 op sub :loop_time @time :start
   568 label *label67
   569 jump *label66 always
   570 label *label68

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-6 instructions):
 
    23 jump *label5 equal *tmp5 false
    24 set :rebindUnit:first_unit null
    25 label *label7
-    * jump *label9 equal true false
    26 ubind UNIT
    27 op notEqual *tmp8 @unit null
    28 jump *label10 equal *tmp8 false
 
    58 jump *label12 notEqual *tmp17 false
    59 label *label14
    60 label *label18
-    * jump *label20 equal true false
    61 ubind UNIT
    62 op equal *tmp19 @unit null
    63 jump *label21 equal *tmp19 false
 
    93 op div .SPEED_SEC *tmp25 10
    94 ucontrol flag 1
    95 label *label25
-    * jump *label27 equal true false
    96 set .CONTAINER null
    97 set .DROP_TARGET null
    98 set :n @links
 
   301 set :state 1
   302 ucontrol stop
   303 label *label66
-    * jump *label68 equal true false
   304 set :start @time
   305 sensor *tmp109 @unit @dead
   306 op strictEqual *tmp110 *tmp109 0
 
   309 op lessThanEq *tmp113 *tmp110 *tmp112
   310 jump *label69 equal *tmp113 false
   311 label *label72
-    * jump *label74 equal true false
   312 ubind UNIT
   313 op equal *tmp116 @unit null
   314 jump *label75 equal *tmp116 false
 
   483 print *tmp165
   484 print "[]"
   485 print "\n"
-    * jump *label112 equal true false
   486 op equal *tmp167 :show_state 2
   487 jump *label114 equal *tmp167 false
   488 sensor *tmp169 @unit @x

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-42 instructions):
 
     6 set .MSG null
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
-    * op equal *tmp3 *tmp2 false
-    * jump *label2 equal *tmp3 false
+    9 jump *label2 notEqual *tmp2 false
    10 print "Unit Transport - Single"
    11 print "\n"
    12 print "Activate switch to start."
 
    18 label *label3
    19 sensor *tmp4 @unit @dead
    20 op strictEqual *tmp6 *tmp4 0
-    * op equal *tmp5 *tmp6 false
-    * jump *label5 equal *tmp5 false
+   21 jump *label5 notEqual *tmp6 false
    22 set :rebindUnit:first_unit null
    23 label *label7
    24 ubind UNIT
-    * op notEqual *tmp8 @unit null
-    * jump *label10 equal *tmp8 false
+   25 jump *label10 equal @unit null
    26 set :rebindUnit:first_unit @unit
    27 jump *label9 always
    28 jump *label11 always
 
    38 label *label9
    39 label *label12
    40 sensor *tmp11 @unit @controller
-    * op equal *tmp12 *tmp11 @this
-    * jump *label15 equal *tmp12 false
+   41 jump *label15 notEqual *tmp11 @this
    42 jump *label6 always
    43 jump *label16 always
    44 label *label15
 
    55 label *label14
    56 label *label18
    57 ubind UNIT
-    * op equal *tmp19 @unit null
-    * jump *label21 equal *tmp19 false
+   58 jump *label21 notEqual @unit null
    59 print "[salmon]No unit of type "
    60 print UNIT
    61 print " "
 
    63 jump *label22 always
    64 label *label21
    65 sensor *tmp21 @unit @controlled
-    * op notEqual *tmp22 *tmp21 0
-    * jump *label23 equal *tmp22 false
+   66 jump *label23 equal *tmp21 0
    67 print "[salmon]Looking for a free "
    68 print UNIT
    69 print "."
 
    91 set .DROP_TARGET null
    92 set :n @links
    93 label *label28
-    * op greaterThan *tmp28 :n 0
-    * jump *label30 equal *tmp28 false
+   94 jump *label30 lessThanEq :n 0
    95 op sub :n :n 1
    96 getlink :block :n
    97 sensor *tmp31 :block @itemCapacity
-    * op greaterThan *tmp32 *tmp31 0
-    * jump *label31 equal *tmp32 false
+   98 jump *label31 lessThanEq *tmp31 0
    99 set .DROP_TARGET .CONTAINER
   100 set .CONTAINER :block
   101 jump *label32 always
 
   104 label *label29
   105 jump *label28 always
   106 label *label30
-    * op equal *tmp34 .CONTAINER null
-    * jump *label33 equal *tmp34 false
+  107 jump *label33 notEqual .CONTAINER null
   108 print "[salmon]No destination."
   109 print "\n"
   110 jump *label34 always
 
   135 set .CORE_Y null
   136 set .CORE_X .CORE_Y
   137 set .CORE .CORE_X
-    * op equal *tmp41 LINK_ID 0
-    * jump *label37 equal *tmp41 false
+  138 jump *label37 notEqual LINK_ID 0
   139 print "[gold]Locating core..."
   140 printflush message1
   141 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
 
   160 label *label40
   161 jump *label39 always
   162 label *label41
-    * op notEqual *tmp51 :flag .QUERY_FLAG
-    * jump *label42 equal *tmp51 false
+  163 jump *label42 equal :flag .QUERY_FLAG
   164 op idiv :position :flag 100
   165 op mod .CORE_X :position @mapw
   166 op idiv .CORE_Y :position @mapw
 
   176 jump *label44 always
   177 label *label46
   178 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
-    * op notEqual *tmp63 :b_type @vault
-    * jump *label47 equal *tmp63 false
+  179 jump *label47 equal :b_type @vault
   180 set .CORE null
   181 jump *label48 always
   182 label *label47
 
   185 label *label42
   186 label *label43
   187 label *label38
-    * op equal *tmp65 .CORE null
-    * jump *label49 equal *tmp65 false
+  188 jump *label49 notEqual .CORE null
   189 end
   190 jump *label50 always
   191 label *label49
 
   199 jump *label53 equal *tmp70 false
   200 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   201 print "\n"
-    * op notEqual *tmp71 .SORTER null
-    * jump *label54 equal *tmp71 false
+  202 jump *label54 equal .SORTER null
   203 print "Block found: "
   204 print .SORTER
   205 jump *label55 always
 
   211 label *label52
   212 jump *label51 always
   213 label *label53
-    * op equal *tmp74 :sorter_type @sorter
-    * jump *label56 equal *tmp74 false
+  214 jump *label56 notEqual :sorter_type @sorter
   215 set .SHOW_REMOTE_LEVEL true
   216 set .SRC .CORE
   217 set .DST .CONTAINER
 
   224 op idiv .DROP_LEVEL *tmp81 100
   225 set .LOCAL_MARGIN .DROP_LEVEL
   226 set .REMOTE_MARGIN .LOAD_LEVEL
-    * op equal *tmp83 LINK_ID 0
-    * jump *label58 equal *tmp83 false
+  227 jump *label58 notEqual LINK_ID 0
   228 set *tmp84 "[] from core"
   229 jump *label59 always
   230 label *label58
 
   248 op add .DROP_LEVEL *tmp92 *tmp94
   249 set .LOCAL_MARGIN .LOAD_LEVEL
   250 set .REMOTE_MARGIN .DROP_LEVEL
-    * op equal *tmp96 LINK_ID 0
-    * jump *label60 equal *tmp96 false
+  251 jump *label60 notEqual LINK_ID 0
   252 set *tmp97 "[] to core"
   253 jump *label61 always
   254 label *label60
 
   256 label *label61
   257 set .DIRECTION *tmp97
   258 label *label57
-    * op equal *tmp98 LINK_ID 0
-    * jump *label62 equal *tmp98 false
+  259 jump *label62 notEqual LINK_ID 0
   260 set *tmp99 ""
   261 jump *label63 always
   262 label *label62
 
   267 sensor .SRC_Y .SRC @y
   268 sensor .DST_X .DST @x
   269 sensor .DST_Y .DST @y
-    * op equal *tmp104 .DROP_TARGET null
-    * jump *label64 equal *tmp104 false
+  270 jump *label64 notEqual .DROP_TARGET null
   271 set .DROP_TARGET .CORE
   272 set .DROP_X .CORE_X
   273 set .DROP_Y .CORE_Y
 
   287 op strictEqual *tmp110 *tmp109 0
   288 sensor *tmp111 @unit @controller
   289 op notEqual *tmp112 *tmp111 @this
-    * op lessThanEq *tmp113 *tmp110 *tmp112
-    * jump *label69 equal *tmp113 false
+  290 jump *label69 greaterThan *tmp110 *tmp112
   291 label *label72
   292 ubind UNIT
-    * op equal *tmp116 @unit null
-    * jump *label75 equal *tmp116 false
+  293 jump *label75 notEqual @unit null
   294 print "[salmon]No unit of type "
   295 print UNIT
   296 print " "
 
   298 jump *label76 always
   299 label *label75
   300 sensor *tmp118 @unit @controlled
-    * op notEqual *tmp119 *tmp118 0
-    * jump *label77 equal *tmp119 false
+  301 jump *label77 equal *tmp118 0
   302 print "[salmon]Looking for a free "
   303 print UNIT
   304 print "."
 
   319 label *label69
   320 label *label70
   321 sensor .ITEM .SORTER @config
-    * op notEqual *tmp122 .ITEM .LAST_ITEM
-    * jump *label79 equal *tmp122 false
+  322 jump *label79 equal .ITEM .LAST_ITEM
   323 label *label81
-    * op equal *tmp124 .ITEM null
-    * jump *label83 equal *tmp124 false
+  324 jump *label83 notEqual .ITEM null
   325 print "[salmon]No item type selected for transport."
   326 printflush message1
   327 sensor .ITEM .SORTER @config
 
   334 label *label79
   335 label *label80
   336 set :show_state 0
-    * op equal *tmp126 :state 1
-    * jump *label84 equal *tmp126 false
+  337 jump *label84 notEqual :state 1
   338 sensor *tmp128 @unit @firstItem
-    * op equal *tmp129 *tmp128 .ITEM
-    * jump *label86 equal *tmp129 false
+  339 jump *label86 notEqual *tmp128 .ITEM
   340 set :state 3
   341 jump *label87 always
   342 label *label86
   343 sensor *tmp131 @unit @totalItems
-    * op equal *tmp132 *tmp131 0
-    * jump *label88 equal *tmp132 false
+  344 jump *label88 notEqual *tmp131 0
   345 set :state 2
   346 jump *label89 always
   347 label *label88
 
   358 jump *label85 always
   359 label *label84
   360 label *label85
-    * op equal *tmp136 :state 2
-    * jump *label92 equal *tmp136 false
+  361 jump *label92 notEqual :state 2
   362 ucontrol within .SRC_X .SRC_Y 8 *tmp138
   363 jump *label94 equal *tmp138 false
   364 sensor *tmp140 .SRC .ITEM
 
   366 op max :max_load *tmp141 0
   367 ucontrol itemTake .SRC .ITEM :max_load
   368 sensor *tmp143 @unit @totalItems
-    * op greaterThanEq *tmp144 *tmp143 .UNIT_CAPACITY
-    * jump *label96 equal *tmp144 false
+  369 jump *label96 lessThan *tmp143 .UNIT_CAPACITY
   370 set :state 3
   371 jump *label97 always
   372 label *label96
 
   381 jump *label93 always
   382 label *label92
   383 label *label93
-    * op equal *tmp146 :state 3
-    * jump *label98 equal *tmp146 false
+  384 jump *label98 notEqual :state 3
   385 ucontrol within .DST_X .DST_Y 8 *tmp148
   386 jump *label100 equal *tmp148 false
   387 sensor *tmp150 .DST .ITEM
 
   389 op max :max_drop *tmp151 0
   390 ucontrol itemDrop .DST :max_drop
   391 sensor *tmp153 @unit @totalItems
-    * op lessThanEq *tmp154 *tmp153 0
-    * jump *label102 equal *tmp154 false
+  392 jump *label102 greaterThan *tmp153 0
   393 set :state 2
   394 ucontrol approach .SRC_X .SRC_Y 6
   395 jump *label103 always
 
   405 jump *label99 always
   406 label *label98
   407 label *label99
-    * op greaterThan *tmp156 :iter 3
-    * jump *label104 equal *tmp156 false
+  408 jump *label104 lessThanEq :iter 3
   409 set :iter 0
   410 print "Moving [green]"
   411 print .ITEM
 
   418 print *tmp158
   419 print "["
   420 print "]"
-    * op lessThan *tmp159 .EFF_LOCAL_LIMIT 100
-    * jump *label106 equal *tmp159 false
+  421 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
   422 print " (limit [orange]"
   423 print .LOCAL_MARGIN
   424 print "["
 
   433 print *tmp162
   434 print "["
   435 print "]"
-    * op lessThan *tmp163 .EFF_REMOTE_LIMIT 100
-    * jump *label110 equal *tmp163 false
+  436 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
   437 print " (limit [orange]"
   438 print .REMOTE_MARGIN
   439 print "["
 
   449 print *tmp165
   450 print "[]"
   451 print "\n"
-    * op equal *tmp167 :show_state 2
-    * jump *label114 equal *tmp167 false
+  452 jump *label114 notEqual :show_state 2
   453 sensor *tmp169 @unit @x
   454 op sub *tmp170 .SRC_X *tmp169
   455 sensor *tmp171 @unit @y
 
   464 print "\n"
   465 jump *label115 always
   466 label *label114
-    * op equal *tmp176 :show_state 3
-    * jump *label116 equal *tmp176 false
+  467 jump *label116 notEqual :show_state 3
   468 sensor *tmp178 @unit @x
   469 op sub *tmp179 .DST_X *tmp178
   470 sensor *tmp180 @unit @y
 
   491 print "\n"
   492 printflush message1
   493 sensor *tmp186 switch1 @enabled
-    * op equal *tmp187 *tmp186 0
-    * jump *label118 equal *tmp187 false
+  494 jump *label118 notEqual *tmp186 0
   495 jump *label68 always
   496 jump *label119 always
   497 label *label118
   498 label *label119
   499 sensor *tmp189 .SRC @dead
-    * op notEqual *tmp190 *tmp189 0
-    * jump *label120 equal *tmp190 false
+  500 jump *label120 equal *tmp189 0
   501 jump *label68 always
   502 jump *label121 always
   503 label *label120
   504 label *label121
   505 sensor *tmp192 .DST @dead
-    * op notEqual *tmp193 *tmp192 0
-    * jump *label122 equal *tmp193 false
+  506 jump *label122 equal *tmp192 0
   507 jump *label68 always
   508 jump *label123 always
   509 label *label122
   510 label *label123
   511 sensor *tmp195 .SORTER @dead
-    * op notEqual *tmp196 *tmp195 0
-    * jump *label124 equal *tmp196 false
+  512 jump *label124 equal *tmp195 0
   513 jump *label68 always
   514 jump *label125 always
   515 label *label124
 
   525 label *label126
   526 sensor *tmp199 .SORTER @dead
   527 op strictEqual *tmp200 *tmp199 0
-    * op equal *tmp201 *tmp200 false
-    * jump *label128 equal *tmp201 false
+  528 jump *label128 notEqual *tmp200 false
   529 print "[salmon]sorter1 is missing!"
   530 print "\n"
   531 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   547 control enabled switch1 false
   548 label *label131
   549 sensor *tmp211 switch1 @enabled
-    * op equal *tmp212 *tmp211 false
-    * jump *label133 equal *tmp212 false
+  550 jump *label133 notEqual *tmp211 false
   551 print "[salmon]Local or remote container became invalid."
   552 print "\n"
   553 print "[gold]Please fix and press button to reinitialize."

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-23 instructions):
 
    25 jump *label10 equal @unit null
    26 set :rebindUnit:first_unit @unit
    27 jump *label9 always
-    * jump *label11 always
    28 label *label10
    29 label *label11
    30 print "[salmon]No unit of type "
 
    39 sensor *tmp11 @unit @controller
    40 jump *label15 notEqual *tmp11 @this
    41 jump *label6 always
-    * jump *label16 always
    42 label *label15
    43 label *label16
    44 ubind UNIT
 
    96 jump *label31 lessThanEq *tmp31 0
    97 set .DROP_TARGET .CONTAINER
    98 set .CONTAINER :block
-    * jump *label32 always
    99 label *label31
   100 label *label32
   101 label *label29
 
   175 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   176 jump *label47 equal :b_type @vault
   177 set .CORE null
-    * jump *label48 always
   178 label *label47
   179 label *label48
-    * jump *label43 always
   180 label *label42
   181 label *label43
   182 label *label38
   183 jump *label49 notEqual .CORE null
   184 end
-    * jump *label50 always
   185 label *label49
   186 label *label50
   187 set .SORTER sorter1
 
   196 jump *label54 equal .SORTER null
   197 print "Block found: "
   198 print .SORTER
-    * jump *label55 always
   199 label *label54
   200 label *label55
   201 printflush message1
 
   308 label *label71
   309 ucontrol flag 1
   310 set :state 1
-    * jump *label70 always
   311 label *label69
   312 label *label70
   313 sensor .ITEM .SORTER @config
 
   322 label *label83
   323 set .LAST_ITEM .ITEM
   324 set :state 1
-    * jump *label80 always
   325 label *label79
   326 label *label80
   327 set :show_state 0
 
   341 ucontrol within .DROP_X .DROP_Y 8 *tmp134
   342 jump *label90 equal *tmp134 false
   343 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
-    * jump *label91 always
   344 label *label90
   345 label *label91
   346 label *label89
   347 label *label87
-    * jump *label85 always
   348 label *label84
   349 label *label85
   350 jump *label92 notEqual :state 2
 
   367 set .MSG "\nGoing to source: [green]"
   368 set :show_state 2
   369 label *label95
-    * jump *label93 always
   370 label *label92
   371 label *label93
   372 jump *label98 notEqual :state 3
 
   390 set .MSG "\nGoing to destination: [green]"
   391 set :show_state 3
   392 label *label101
-    * jump *label99 always
   393 label *label98
   394 label *label99
   395 jump *label104 lessThanEq :iter 3
 
   410 print .LOCAL_MARGIN
   411 print "["
   412 print "])"
-    * jump *label107 always
   413 label *label106
   414 label *label107
   415 jump *label108 equal .SHOW_REMOTE_LEVEL false
 
   424 print .REMOTE_MARGIN
   425 print "["
   426 print "])"
-    * jump *label111 always
   427 label *label110
   428 label *label111
-    * jump *label109 always
   429 label *label108
   430 label *label109
   431 sensor *tmp165 @unit @totalItems
 
   461 print " "
   462 print "sec[]"
   463 print "\n"
-    * jump *label117 always
   464 label *label116
   465 label *label117
   466 label *label115
-    * jump *label113 always
   467 label *label112
   468 label *label113
   469 op floor *tmp185 :loop_time
 
   475 sensor *tmp186 switch1 @enabled
   476 jump *label118 notEqual *tmp186 0
   477 jump *label68 always
-    * jump *label119 always
   478 label *label118
   479 label *label119
   480 sensor *tmp189 .SRC @dead
   481 jump *label120 equal *tmp189 0
   482 jump *label68 always
-    * jump *label121 always
   483 label *label120
   484 label *label121
   485 sensor *tmp192 .DST @dead
   486 jump *label122 equal *tmp192 0
   487 jump *label68 always
-    * jump *label123 always
   488 label *label122
   489 label *label123
   490 sensor *tmp195 .SORTER @dead
   491 jump *label124 equal *tmp195 0
   492 jump *label68 always
-    * jump *label125 always
   493 label *label124
   494 label *label125
   495 jump *label105 always
 
   535 label *label132
   536 jump *label131 always
   537 label *label133
-    * jump *label130 always
   538 label *label129
   539 label *label130
   540 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   130 jump *label25 always
   131 label *label27
   132 set .CORE_Y null
-    * set .CORE_X .CORE_Y
-    * set .CORE .CORE_X
+  133 set .CORE_X null
+  134 set .CORE .CORE_Y
   135 jump *label37 notEqual LINK_ID 0
   136 print "[gold]Locating core..."
   137 printflush message1
 
   145 printflush message1
   146 op add .QUERY_FLAG 99999900 LINK_ID
   147 set :flag .QUERY_FLAG
-    * ucontrol flag :flag
+  148 ucontrol flag .QUERY_FLAG
   149 label *label39
   150 op equal *tmp46 :flag .QUERY_FLAG
   151 sensor *tmp47 @unit @dead
 
   185 label *label49
   186 label *label50
   187 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  188 sensor :sorter_type sorter1 @type
   189 label *label51
   190 op notEqual *tmp68 :sorter_type @sorter
   191 op notEqual *tmp69 :sorter_type @inverted-sorter
 
   200 label *label55
   201 printflush message1
   202 set .SORTER sorter1
-    * sensor :sorter_type .SORTER @type
+  203 sensor :sorter_type sorter1 @type
   204 label *label52
   205 jump *label51 always
   206 label *label53
 
   208 set .SHOW_REMOTE_LEVEL true
   209 set .SRC .CORE
   210 set .DST .CONTAINER
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  211 sensor :src_capacity .CORE @itemCapacity
+  212 sensor :dst_capacity .CONTAINER @itemCapacity
   213 op sub *tmp78 100 .EFF_REMOTE_LIMIT
   214 op mul *tmp79 :src_capacity *tmp78
   215 op idiv .LOAD_LEVEL *tmp79 100
 
   229 op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
   230 set .SRC .CONTAINER
   231 set .DST .CORE
-    * sensor :src_capacity .SRC @itemCapacity
-    * sensor :dst_capacity .DST @itemCapacity
+  232 sensor :src_capacity .CONTAINER @itemCapacity
+  233 sensor :dst_capacity .CORE @itemCapacity
   234 op sub *tmp88 100 .EFF_LOCAL_LIMIT
   235 op mul *tmp89 :src_capacity *tmp88
   236 op idiv .LOAD_LEVEL *tmp89 100
 
   397 print "Moving [green]"
   398 print .ITEM
   399 print .DIRECTION
-    * print .LINK_TXT
+  400 print *tmp99
   401 print "\"
   402 print "n"
   403 sensor *tmp158 .CONTAINER .ITEM

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   131 label *label27
   132 set .CORE_Y null
   133 set .CORE_X null
-    * set .CORE .CORE_Y
+  134 set .CORE null
   135 jump *label37 notEqual LINK_ID 0
   136 print "[gold]Locating core..."
   137 printflush message1
 
   255 label *label62
   256 set *tmp99 LINK_ID
   257 label *label63
-    * set .LINK_TXT *tmp99
   258 sensor .SRC_X .SRC @x
   259 sensor .SRC_Y .SRC @y
   260 sensor .DST_X .DST @x

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    90 set :n @links
    91 label *label28
    92 jump *label30 lessThanEq :n 0
+   93 label *label134
    94 op sub :n :n 1
    95 getlink :block :n
    96 sensor *tmp31 :block @itemCapacity
 
   100 label *label31
   101 label *label32
   102 label *label29
-    * jump *label28 always
+  103 jump *label134 greaterThan :n 0
   104 label *label30
   105 jump *label33 notEqual .CONTAINER null
   106 print "[salmon]No destination."
 
   314 jump *label79 equal .ITEM .LAST_ITEM
   315 label *label81
   316 jump *label83 notEqual .ITEM null
+  317 label *label135
   318 print "[salmon]No item type selected for transport."
   319 printflush message1
   320 sensor .ITEM .SORTER @config
   321 label *label82
-    * jump *label81 always
+  322 jump *label135 equal .ITEM null
   323 label *label83
   324 set .LAST_ITEM .ITEM
   325 set :state 1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-10 instructions):
 
   174 jump *label44 always
   175 label *label46
   176 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
-    * jump *label47 equal :b_type @vault
-    * set .CORE null
-    * label *label47
-    * label *label48
+  177 select .CORE notEqual :b_type @vault null .CORE
   178 label *label42
   179 label *label43
   180 label *label38
 
   215 op idiv .DROP_LEVEL *tmp81 100
   216 set .LOCAL_MARGIN .DROP_LEVEL
   217 set .REMOTE_MARGIN .LOAD_LEVEL
-    * jump *label58 notEqual LINK_ID 0
-    * set *tmp84 "[] from core"
-    * jump *label59 always
-    * label *label58
-    * set *tmp84 "[] from vault #"
-    * label *label59
+  218 select *tmp84 equal LINK_ID 0 "[] from core" "[] from vault #"
   219 set .DIRECTION *tmp84
   220 jump *label57 always
   221 label *label56
 
   234 op add .DROP_LEVEL *tmp92 *tmp94
   235 set .LOCAL_MARGIN .LOAD_LEVEL
   236 set .REMOTE_MARGIN .DROP_LEVEL
-    * jump *label60 notEqual LINK_ID 0
-    * set *tmp97 "[] to core"
-    * jump *label61 always
-    * label *label60
-    * set *tmp97 "[] to vault #"
-    * label *label61
+  237 select *tmp97 equal LINK_ID 0 "[] to core" "[] to vault #"
   238 set .DIRECTION *tmp97
   239 label *label57
-    * jump *label62 notEqual LINK_ID 0
-    * set *tmp99 ""
-    * jump *label63 always
-    * label *label62
-    * set *tmp99 LINK_ID
-    * label *label63
+  240 select *tmp99 equal LINK_ID 0 "" LINK_ID
   241 sensor .SRC_X .SRC @x
   242 sensor .SRC_Y .SRC @y
   243 sensor .DST_X .DST @x

Modifications by Replicate loop condition at line 43:1 (+1 instructions):
 
     7 label *label0
     8 sensor *tmp2 switch1 @enabled
     9 jump *label2 notEqual *tmp2 false
+   10 label *label136
    11 print "Unit Transport - Single"
    12 print "\n"
    13 print "Activate switch to start."
    14 print "\n"
    15 printflush message1
    16 label *label1
-    * jump *label0 always
+   17 sensor *tmp2 switch1 @enabled
+   18 jump *label136 equal *tmp2 false
    19 label *label2
    20 label *label3
    21 sensor *tmp4 @unit @dead

Modifications by Replicate loop condition at line 314:5 (+1 instructions):
 
   511 label *label131
   512 sensor *tmp211 switch1 @enabled
   513 jump *label133 notEqual *tmp211 false
+  514 label *label137
   515 print "[salmon]Local or remote container became invalid."
   516 print "\n"
   517 print "[gold]Please fix and press button to reinitialize."
 
   519 printflush message1
   520 printflush message2
   521 label *label132
-    * jump *label131 always
+  522 sensor *tmp211 switch1 @enabled
+  523 jump *label137 equal *tmp211 false
   524 label *label133
   525 label *label129
   526 label *label130

Modifications by Replicate loop condition at line 51:1 (+2 instructions):
 
    21 sensor *tmp4 @unit @dead
    22 op strictEqual *tmp6 *tmp4 0
    23 jump *label5 notEqual *tmp6 false
+   24 label *label138
    25 set :rebindUnit:first_unit null
    26 label *label7
    27 ubind UNIT
 
    81 label *label17
    82 label *label6
    83 label *label4
-    * jump *label3 always
+   84 sensor *tmp4 @unit @dead
+   85 op strictEqual *tmp6 *tmp4 0
+   86 jump *label138 equal *tmp6 false
    87 label *label5
    88 sensor .UNIT_CAPACITY @unit @itemCapacity
    89 sensor *tmp25 @unit @speed

Modifications by Replicate loop condition at line 304:1 (+2 instructions):
 
   492 sensor *tmp199 .SORTER @dead
   493 op strictEqual *tmp200 *tmp199 0
   494 jump *label128 notEqual *tmp200 false
+  495 label *label139
   496 print "[salmon]sorter1 is missing!"
   497 print "\n"
   498 print "[gold]Please place and link sorter or inverted sorter to the processor."
 
   501 printflush message2
   502 set .SORTER sorter1
   503 label *label127
-    * jump *label126 always
+  504 sensor *tmp199 .SORTER @dead
+  505 op strictEqual *tmp200 *tmp199 0
+  506 jump *label139 equal *tmp200 false
   507 label *label128
   508 sensor *tmp202 .SRC @dead
   509 op strictEqual *tmp204 *tmp202 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   501 printflush message2
   502 set .SORTER sorter1
   503 label *label127
-    * sensor *tmp199 .SORTER @dead
+  504 sensor *tmp199 sorter1 @dead
   505 op strictEqual *tmp200 *tmp199 0
   506 jump *label139 equal *tmp200 false
   507 label *label128

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
   499 print "\n"
   500 printflush message1
   501 printflush message2
-    * set .SORTER sorter1
   502 label *label127
   503 sensor *tmp199 sorter1 @dead
   504 op strictEqual *tmp200 *tmp199 0

Modifications by Replicate loop condition at line 129:1 (+3 instructions):
 
   194 op notEqual *tmp69 :sorter_type @inverted-sorter
   195 op land *tmp70 *tmp68 *tmp69
   196 jump *label53 equal *tmp70 false
+  197 label *label140
   198 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
   199 print "\n"
   200 jump *label54 equal .SORTER null
 
   206 set .SORTER sorter1
   207 sensor :sorter_type sorter1 @type
   208 label *label52
-    * jump *label51 always
+  209 op notEqual *tmp68 :sorter_type @sorter
+  210 op notEqual *tmp69 :sorter_type @inverted-sorter
+  211 op land *tmp70 *tmp68 *tmp69
+  212 jump *label140 notEqual *tmp70 false
   213 label *label53
   214 jump *label56 notEqual :sorter_type @sorter
   215 set .SHOW_REMOTE_LEVEL true

Modifications by Replicate loop condition at line 102:5 (+4 instructions):
 
   158 op strictEqual *tmp48 *tmp47 0
   159 op land *tmp49 *tmp46 *tmp48
   160 jump *label41 equal *tmp49 false
+  161 label *label141
   162 ucontrol stop
   163 sensor :flag @unit @flag
   164 label *label40
-    * jump *label39 always
+  165 op equal *tmp46 :flag .QUERY_FLAG
+  166 sensor *tmp47 @unit @dead
+  167 op strictEqual *tmp48 *tmp47 0
+  168 op land *tmp49 *tmp46 *tmp48
+  169 jump *label141 notEqual *tmp49 false
   170 label *label41
   171 jump *label42 equal :flag .QUERY_FLAG
   172 op idiv :position :flag 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   153 set :flag .QUERY_FLAG
   154 ucontrol flag .QUERY_FLAG
   155 label *label39
-    * op equal *tmp46 :flag .QUERY_FLAG
+  156 op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
   157 sensor *tmp47 @unit @dead
   158 op strictEqual *tmp48 *tmp47 0
   159 op land *tmp49 *tmp46 *tmp48

Modifications by Replicate loop condition at line 110:9 (+5 instructions):
 
   179 op equal *tmp59 *tmp58 0
   180 op land *tmp60 *tmp57 *tmp59
   181 jump *label46 equal *tmp60 false
+  182 label *label142
   183 ucontrol approach .CORE_X .CORE_Y 6
   184 label *label45
-    * jump *label44 always
+  185 ucontrol within .CORE_X .CORE_Y 8 *tmp56
+  186 op equal *tmp57 *tmp56 false
+  187 sensor *tmp58 @unit @dead
+  188 op equal *tmp59 *tmp58 0
+  189 op land *tmp60 *tmp57 *tmp59
+  190 jump *label142 notEqual *tmp60 false
   191 label *label46
   192 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   193 select .CORE notEqual :b_type @vault null .CORE

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   153 set :flag .QUERY_FLAG
   154 ucontrol flag .QUERY_FLAG
   155 label *label39
-    * op equal *tmp46 .QUERY_FLAG .QUERY_FLAG
+  156 set *tmp46 true
   157 sensor *tmp47 @unit @dead
   158 op strictEqual *tmp48 *tmp47 0
   159 op land *tmp49 *tmp46 *tmp48

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   156 set *tmp46 true
   157 sensor *tmp47 @unit @dead
   158 op strictEqual *tmp48 *tmp47 0
-    * op land *tmp49 *tmp46 *tmp48
+  159 op land *tmp49 true *tmp48
   160 jump *label41 equal *tmp49 false
   161 label *label141
   162 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
   153 set :flag .QUERY_FLAG
   154 ucontrol flag .QUERY_FLAG
   155 label *label39
-    * set *tmp46 true
   156 sensor *tmp47 @unit @dead
   157 op strictEqual *tmp48 *tmp47 0
   158 op land *tmp49 true *tmp48

Modifications by Iterated phase, Expression Optimization, pass 3, iteration 1:
 
   155 label *label39
   156 sensor *tmp47 @unit @dead
   157 op strictEqual *tmp48 *tmp47 0
-    * op land *tmp49 true *tmp48
+  158 set *tmp49 *tmp48
   159 jump *label41 equal *tmp49 false
   160 label *label141
   161 ucontrol stop

Modifications by Iterated phase, Data Flow Optimization, pass 3, iteration 1 (-1 instructions):
 
   154 ucontrol flag .QUERY_FLAG
   155 label *label39
   156 sensor *tmp47 @unit @dead
-    * op strictEqual *tmp48 *tmp47 0
-    * set *tmp49 *tmp48
+  157 op strictEqual *tmp49 *tmp47 0
   158 jump *label41 equal *tmp49 false
   159 label *label141
   160 ucontrol stop

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
     4 op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
     5 op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
     6 set .MSG null
-    * label *label0
     7 sensor *tmp2 switch1 @enabled
     8 jump *label2 notEqual *tmp2 false
     9 label *label136
 
    12 print "Activate switch to start."
    13 print "\n"
    14 printflush message1
-    * label *label1
    15 sensor *tmp2 switch1 @enabled
    16 jump *label136 equal *tmp2 false
    17 label *label2
-    * label *label3
    18 sensor *tmp4 @unit @dead
    19 op strictEqual *tmp6 *tmp4 0
    20 jump *label5 notEqual *tmp6 false
 
    26 set :rebindUnit:first_unit @unit
    27 jump *label9 always
    28 label *label10
-    * label *label11
    29 print "[salmon]No unit of type "
    30 print UNIT
    31 print " "
    32 print "found. 1"
    33 printflush message1
-    * label *label8
    34 jump *label7 always
    35 label *label9
    36 label *label12
 
    38 jump *label15 notEqual *tmp11 @this
    39 jump *label6 always
    40 label *label15
-    * label *label16
    41 ubind UNIT
    42 print "[gold]Looking for old unit..."
    43 printflush message1
-    * label *label13
    44 op notEqual *tmp14 @unit :rebindUnit:first_unit
    45 sensor *tmp15 :rebindUnit:first_unit @dead
    46 op strictEqual *tmp16 *tmp15 0
    47 op land *tmp17 *tmp14 *tmp16
    48 jump *label12 notEqual *tmp17 false
-    * label *label14
    49 label *label18
    50 ubind UNIT
    51 jump *label21 notEqual @unit null
 
    67 label *label24
    68 label *label22
    69 printflush message1
-    * label *label19
    70 jump *label18 always
-    * label *label20
    71 label *label17
    72 label *label6
-    * label *label4
    73 sensor *tmp4 @unit @dead
    74 op strictEqual *tmp6 *tmp4 0
    75 jump *label138 equal *tmp6 false
 
    82 set .CONTAINER null
    83 set .DROP_TARGET null
    84 set :n @links
-    * label *label28
    85 jump *label30 lessThanEq :n 0
    86 label *label134
    87 op sub :n :n 1
 
    91 set .DROP_TARGET .CONTAINER
    92 set .CONTAINER :block
    93 label *label31
-    * label *label32
-    * label *label29
    94 jump *label134 greaterThan :n 0
    95 label *label30
    96 jump *label33 notEqual .CONTAINER null
 
   118 label *label36
   119 label *label34
   120 printflush message1
-    * label *label26
   121 jump *label25 always
   122 label *label27
   123 set .CORE_Y null
 
   137 op add .QUERY_FLAG 99999900 LINK_ID
   138 set :flag .QUERY_FLAG
   139 ucontrol flag .QUERY_FLAG
-    * label *label39
   140 sensor *tmp47 @unit @dead
   141 op strictEqual *tmp49 *tmp47 0
   142 jump *label41 equal *tmp49 false
   143 label *label141
   144 ucontrol stop
   145 sensor :flag @unit @flag
-    * label *label40
   146 op equal *tmp46 :flag .QUERY_FLAG
   147 sensor *tmp47 @unit @dead
   148 op strictEqual *tmp48 *tmp47 0
 
   153 op idiv :position :flag 100
   154 op mod .CORE_X :position @mapw
   155 op idiv .CORE_Y :position @mapw
-    * label *label44
   156 ucontrol within .CORE_X .CORE_Y 8 *tmp56
   157 op equal *tmp57 *tmp56 false
   158 sensor *tmp58 @unit @dead
 
   161 jump *label46 equal *tmp60 false
   162 label *label142
   163 ucontrol approach .CORE_X .CORE_Y 6
-    * label *label45
   164 ucontrol within .CORE_X .CORE_Y 8 *tmp56
   165 op equal *tmp57 *tmp56 false
   166 sensor *tmp58 @unit @dead
 
   171 ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
   172 select .CORE notEqual :b_type @vault null .CORE
   173 label *label42
-    * label *label43
   174 label *label38
   175 jump *label49 notEqual .CORE null
   176 end
   177 label *label49
-    * label *label50
   178 set .SORTER sorter1
   179 sensor :sorter_type sorter1 @type
-    * label *label51
   180 op notEqual *tmp68 :sorter_type @sorter
   181 op notEqual *tmp69 :sorter_type @inverted-sorter
   182 op land *tmp70 *tmp68 *tmp69
 
   188 print "Block found: "
   189 print .SORTER
   190 label *label54
-    * label *label55
   191 printflush message1
   192 set .SORTER sorter1
   193 sensor :sorter_type sorter1 @type
-    * label *label52
   194 op notEqual *tmp68 :sorter_type @sorter
   195 op notEqual *tmp69 :sorter_type @inverted-sorter
   196 op land *tmp70 *tmp68 *tmp69
 
   278 label *label78
   279 label *label76
   280 printflush message1
-    * label *label73
   281 jump *label72 always
-    * label *label74
   282 label *label71
   283 ucontrol flag 1
   284 set :state 1
   285 label *label69
-    * label *label70
   286 sensor .ITEM .SORTER @config
   287 jump *label79 equal .ITEM .LAST_ITEM
-    * label *label81
   288 jump *label83 notEqual .ITEM null
   289 label *label135
   290 print "[salmon]No item type selected for transport."
   291 printflush message1
   292 sensor .ITEM .SORTER @config
-    * label *label82
   293 jump *label135 equal .ITEM null
   294 label *label83
   295 set .LAST_ITEM .ITEM
   296 set :state 1
   297 label *label79
-    * label *label80
   298 set :show_state 0
   299 jump *label84 notEqual :state 1
   300 sensor *tmp128 @unit @firstItem
 
   313 jump *label90 equal *tmp134 false
   314 ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
   315 label *label90
-    * label *label91
   316 label *label89
   317 label *label87
   318 label *label84
-    * label *label85
   319 jump *label92 notEqual :state 2
   320 ucontrol within .SRC_X .SRC_Y 8 *tmp138
   321 jump *label94 equal *tmp138 false
 
   337 set :show_state 2
   338 label *label95
   339 label *label92
-    * label *label93
   340 jump *label98 notEqual :state 3
   341 ucontrol within .DST_X .DST_Y 8 *tmp148
   342 jump *label100 equal *tmp148 false
 
   359 set :show_state 3
   360 label *label101
   361 label *label98
-    * label *label99
   362 jump *label104 lessThanEq :iter 3
   363 set :iter 0
   364 print "Moving [green]"
 
   378 print "["
   379 print "])"
   380 label *label106
-    * label *label107
   381 jump *label108 equal .SHOW_REMOTE_LEVEL false
   382 sensor *tmp162 .CORE .ITEM
   383 print "\n"
 
   391 print "["
   392 print "])"
   393 label *label110
-    * label *label111
   394 label *label108
-    * label *label109
   395 sensor *tmp165 @unit @totalItems
   396 print .MSG
   397 print *tmp165
 
   426 print "sec[]"
   427 print "\n"
   428 label *label116
-    * label *label117
   429 label *label115
-    * label *label112
-    * label *label113
   430 op floor *tmp185 :loop_time
   431 print "[lightgray]Loop time: "
   432 print *tmp185
 
   437 jump *label118 notEqual *tmp186 0
   438 jump *label68 always
   439 label *label118
-    * label *label119
   440 sensor *tmp189 .SRC @dead
   441 jump *label120 equal *tmp189 0
   442 jump *label68 always
   443 label *label120
-    * label *label121
   444 sensor *tmp192 .DST @dead
   445 jump *label122 equal *tmp192 0
   446 jump *label68 always
   447 label *label122
-    * label *label123
   448 sensor *tmp195 .SORTER @dead
   449 jump *label124 equal *tmp195 0
   450 jump *label68 always
   451 label *label124
-    * label *label125
   452 jump *label105 always
   453 label *label104
   454 op add :iter :iter 1
   455 label *label105
   456 op sub :loop_time @time :start
-    * label *label67
   457 jump *label66 always
   458 label *label68
-    * label *label126
   459 sensor *tmp199 .SORTER @dead
   460 op strictEqual *tmp200 *tmp199 0
   461 jump *label128 notEqual *tmp200 false
 
   466 print "\n"
   467 printflush message1
   468 printflush message2
-    * label *label127
   469 sensor *tmp199 sorter1 @dead
   470 op strictEqual *tmp200 *tmp199 0
   471 jump *label139 equal *tmp200 false
 
   479 op or *tmp208 *tmp203 *tmp206
   480 jump *label129 equal *tmp208 false
   481 control enabled switch1 false
-    * label *label131
   482 sensor *tmp211 switch1 @enabled
   483 jump *label133 notEqual *tmp211 false
   484 label *label137
 
   488 print "\n"
   489 printflush message1
   490 printflush message2
-    * label *label132
   491 sensor *tmp211 switch1 @enabled
   492 jump *label137 equal *tmp211 false
   493 label *label133
   494 label *label129
-    * label *label130
   495 end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-5 instructions):
 
    35 label *label9
    36 label *label12
    37 sensor *tmp11 @unit @controller
-    * jump *label15 notEqual *tmp11 @this
-    * jump *label6 always
+   38 jump *label6 equal *tmp11 @this
    39 label *label15
    40 ubind UNIT
    41 print "[gold]Looking for old unit..."
 
   433 print "\n"
   434 printflush message1
   435 sensor *tmp186 switch1 @enabled
-    * jump *label118 notEqual *tmp186 0
-    * jump *label68 always
+  436 jump *label68 equal *tmp186 0
   437 label *label118
   438 sensor *tmp189 .SRC @dead
-    * jump *label120 equal *tmp189 0
-    * jump *label68 always
+  439 jump *label68 notEqual *tmp189 0
   440 label *label120
   441 sensor *tmp192 .DST @dead
-    * jump *label122 equal *tmp192 0
-    * jump *label68 always
+  442 jump *label68 notEqual *tmp192 0
   443 label *label122
   444 sensor *tmp195 .SORTER @dead
-    * jump *label124 equal *tmp195 0
-    * jump *label68 always
+  445 jump *label68 notEqual *tmp195 0
   446 label *label124
   447 jump *label105 always
   448 label *label104

Modifications by Jumps phase, Jump Optimization, pass 5, iteration 1:
 
    36 label *label12
    37 sensor *tmp11 @unit @controller
    38 jump *label6 equal *tmp11 @this
-    * label *label15
    39 ubind UNIT
    40 print "[gold]Looking for old unit..."
    41 printflush message1
 
   433 printflush message1
   434 sensor *tmp186 switch1 @enabled
   435 jump *label68 equal *tmp186 0
-    * label *label118
   436 sensor *tmp189 .SRC @dead
   437 jump *label68 notEqual *tmp189 0
-    * label *label120
   438 sensor *tmp192 .DST @dead
   439 jump *label68 notEqual *tmp192 0
-    * label *label122
   440 sensor *tmp195 .SORTER @dead
   441 jump *label68 notEqual *tmp195 0
-    * label *label124
   442 jump *label105 always
   443 label *label104
   444 op add :iter :iter 1

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
+    0 label __start__
     1 set UNIT @mega
     2 set LINK_ID 0
     3 set LOCAL_LIMIT 100
 
    55 jump *label22 always
    56 label *label21
    57 sensor *tmp21 @unit @controlled
-    * jump *label23 equal *tmp21 0
+   58 jump *label17 equal *tmp21 0
    59 print "[salmon]Looking for a free "
    60 print UNIT
    61 print "."
 
   101 sensor *tmp37 .DROP_TARGET @itemCapacity
   102 op lessThan *tmp38 *tmp37 300
   103 op land *tmp39 *tmp36 *tmp38
-    * jump *label35 equal *tmp39 false
+  104 jump *label27 equal *tmp39 false
   105 print "Destination: "
   106 print .CONTAINER
   107 print "\"
 
   266 jump *label76 always
   267 label *label75
   268 sensor *tmp118 @unit @controlled
-    * jump *label77 equal *tmp118 0
+  269 jump *label71 equal *tmp118 0
   270 print "[salmon]Looking for a free "
   271 print UNIT
   272 print "."
 
   325 sensor *tmp143 @unit @totalItems
   326 jump *label96 lessThan *tmp143 .UNIT_CAPACITY
   327 set :state 3
-    * jump *label97 always
+  328 jump *label95 always
   329 label *label96
   330 set .MSG "\nLoading items: [green]"
   331 label *label97
 
   347 jump *label102 greaterThan *tmp153 0
   348 set :state 2
   349 ucontrol approach .SRC_X .SRC_Y 6
-    * jump *label103 always
+  350 jump *label101 always
   351 label *label102
   352 set .MSG "\nDropping items: [green]"
   353 label *label103
 
   468 op strictEqual *tmp207 *tmp205 0
   469 op equal *tmp206 *tmp207 false
   470 op or *tmp208 *tmp203 *tmp206
-    * jump *label129 equal *tmp208 false
+  471 jump __start__ equal *tmp208 false
   472 control enabled switch1 false
   473 sensor *tmp211 switch1 @enabled
-    * jump *label133 notEqual *tmp211 false
+  474 jump __start__ notEqual *tmp211 false
   475 label *label137
   476 print "[salmon]Local or remote container became invalid."
   477 print "\n"

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-3 instructions):
 
    61 print "."
    62 print ".."
    63 jump *label24 always
-    * label *label23
-    * jump *label17 always
    64 label *label24
    65 label *label22
    66 printflush message1
 
   110 print "n"
   111 print "[salmon]Item dump must be a container or a vault!"
   112 jump *label36 always
-    * label *label35
-    * jump *label27 always
   113 label *label36
   114 label *label34
   115 printflush message1
 
   268 print "."
   269 print ".."
   270 jump *label78 always
-    * label *label77
-    * jump *label71 always
   271 label *label78
   272 label *label76
   273 printflush message1
 
   322 jump *label95 always
   323 label *label96
   324 set .MSG "\nLoading items: [green]"
-    * label *label97
   325 jump *label95 always
   326 label *label94
   327 ucontrol approach .SRC_X .SRC_Y 6
 
   343 jump *label101 always
   344 label *label102
   345 set .MSG "\nDropping items: [green]"
-    * label *label103
   346 jump *label101 always
   347 label *label100
   348 ucontrol approach .DST_X .DST_Y 6
 
   473 printflush message2
   474 sensor *tmp211 switch1 @enabled
   475 jump *label137 equal *tmp211 false
-    * label *label133
-    * label *label129
   476 end

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-4 instructions):
 
    60 print UNIT
    61 print "."
    62 print ".."
-    * jump *label24 always
    63 label *label24
    64 label *label22
    65 printflush message1
 
   108 print "\"
   109 print "n"
   110 print "[salmon]Item dump must be a container or a vault!"
-    * jump *label36 always
   111 label *label36
   112 label *label34
   113 printflush message1
 
   265 print UNIT
   266 print "."
   267 print ".."
-    * jump *label78 always
   268 label *label78
   269 label *label76
   270 printflush message1
 
   470 printflush message2
   471 sensor *tmp211 switch1 @enabled
   472 jump *label137 equal *tmp211 false
-    * end

Modifications by Jumps phase, Jump Normalization, pass 6, iteration 1:
 
    60 print UNIT
    61 print "."
    62 print ".."
-    * label *label24
    63 label *label22
    64 printflush message1
    65 jump *label18 always
 
   107 print "\"
   108 print "n"
   109 print "[salmon]Item dump must be a container or a vault!"
-    * label *label36
   110 label *label34
   111 printflush message1
   112 jump *label25 always
 
   263 print UNIT
   264 print "."
   265 print ".."
-    * label *label78
   266 label *label76
   267 printflush message1
   268 jump *label72 always

Modifications by Final phase, Print Merging, iteration 1 (-50 instructions):
 
     8 sensor *tmp2 switch1 @enabled
     9 jump *label2 notEqual *tmp2 false
    10 label *label136
-    * print "Unit Transport - Single"
-    * print "\n"
-    * print "Activate switch to start."
-    * print "\n"
+   11 print "Unit Transport - Single\nActivate switch to start.\n"
    12 printflush message1
    13 sensor *tmp2 switch1 @enabled
    14 jump *label136 equal *tmp2 false
 
    24 set :rebindUnit:first_unit @unit
    25 jump *label9 always
    26 label *label10
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 1"
+   27 print "[salmon]No unit of type {0} found. 1"
+   28 format UNIT
    29 printflush message1
    30 jump *label7 always
    31 label *label9
 
    43 label *label18
    44 ubind UNIT
    45 jump *label21 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+   46 print "[salmon]No unit of type {0} found. 2"
+   47 format UNIT
    48 jump *label22 always
    49 label *label21
    50 sensor *tmp21 @unit @controlled
    51 jump *label17 equal *tmp21 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+   52 print "[salmon]Looking for a free {0}..."
+   53 format UNIT
    54 label *label22
    55 printflush message1
    56 jump *label18 always
 
    80 jump *label134 greaterThan :n 0
    81 label *label30
    82 jump *label33 notEqual .CONTAINER null
-    * print "[salmon]No destination."
-    * print "\n"
+   83 print "[salmon]No destination.\n"
    84 jump *label34 always
    85 label *label33
    86 op notEqual *tmp36 .DROP_TARGET null
 
    88 op lessThan *tmp38 *tmp37 300
    89 op land *tmp39 *tmp36 *tmp38
    90 jump *label27 equal *tmp39 false
-    * print "Destination: "
-    * print .CONTAINER
-    * print "\"
-    * print "n"
-    * print "Item dump: "
-    * print .DROP_TARGET
-    * print "\"
-    * print "n"
-    * print "[salmon]Item dump must be a container or a vault!"
+   91 print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
+   92 format .CONTAINER
+   93 format .DROP_TARGET
    94 label *label34
    95 printflush message1
    96 jump *label25 always
 
   104 ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
   105 jump *label38 always
   106 label *label37
-    * print "[gold]Locating vault #"
-    * print LINK_ID
-    * print "."
-    * print ".."
+  107 print "[gold]Locating vault #{0}..."
+  108 format LINK_ID
   109 printflush message1
   110 op add .QUERY_FLAG 99999900 LINK_ID
   111 set :flag .QUERY_FLAG
 
   155 op land *tmp70 *tmp68 *tmp69
   156 jump *label53 equal *tmp70 false
   157 label *label140
-    * print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter."
-    * print "\n"
+  158 print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
   159 jump *label54 equal .SORTER null
   160 print "Block found: "
   161 print .SORTER
 
   232 label *label72
   233 ubind UNIT
   234 jump *label75 notEqual @unit null
-    * print "[salmon]No unit of type "
-    * print UNIT
-    * print " "
-    * print "found. 2"
+  235 print "[salmon]No unit of type {0} found. 2"
+  236 format UNIT
   237 jump *label76 always
   238 label *label75
   239 sensor *tmp118 @unit @controlled
   240 jump *label71 equal *tmp118 0
-    * print "[salmon]Looking for a free "
-    * print UNIT
-    * print "."
-    * print ".."
+  241 print "[salmon]Looking for a free {0}..."
+  242 format UNIT
   243 label *label76
   244 printflush message1
   245 jump *label72 always
 
   323 label *label98
   324 jump *label104 lessThanEq :iter 3
   325 set :iter 0
-    * print "Moving [green]"
-    * print .ITEM
-    * print .DIRECTION
-    * print *tmp99
-    * print "\"
-    * print "n"
+  326 print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
+  327 format .ITEM
+  328 format .DIRECTION
+  329 format *tmp99
   330 sensor *tmp158 .CONTAINER .ITEM
-    * print "Local items: [gold]"
-    * print *tmp158
-    * print "["
-    * print "]"
+  331 format *tmp158
   332 jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
-    * print " (limit [orange]"
-    * print .LOCAL_MARGIN
-    * print "["
-    * print "])"
+  333 print " (limit [orange]{0}[])"
+  334 format .LOCAL_MARGIN
   335 label *label106
   336 jump *label108 equal .SHOW_REMOTE_LEVEL false
   337 sensor *tmp162 .CORE .ITEM
-    * print "\n"
-    * print "Remote items: [gold]"
-    * print *tmp162
-    * print "["
-    * print "]"
+  338 print "\nRemote items: [gold]{0}[]"
+  339 format *tmp162
   340 jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
-    * print " (limit [orange]"
-    * print .REMOTE_MARGIN
-    * print "["
-    * print "])"
+  341 print " (limit [orange]{0}[])"
+  342 format .REMOTE_MARGIN
   343 label *label110
   344 label *label108
   345 sensor *tmp165 @unit @totalItems
   346 print .MSG
   347 print *tmp165
-    * print "[]"
-    * print "\n"
+  348 print "[]\n"
   349 jump *label114 notEqual :show_state 2
   350 sensor *tmp169 @unit @x
   351 op sub *tmp170 .SRC_X *tmp169
 
   354 op len *tmp173 *tmp170 *tmp172
   355 op idiv *tmp174 *tmp173 .SPEED_SEC
   356 op div *tmp175 *tmp174 10
-    * print "[]  arriving in [gold]"
-    * print *tmp175
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  357 print "[]  arriving in [gold]{0} sec[]\n"
+  358 format *tmp175
   359 jump *label115 always
   360 label *label114
   361 jump *label116 notEqual :show_state 3
 
   366 op len *tmp182 *tmp179 *tmp181
   367 op idiv *tmp183 *tmp182 .SPEED_SEC
   368 op div *tmp184 *tmp183 10
-    * print "[]  arriving in [gold]"
-    * print *tmp184
-    * print " "
-    * print "sec[]"
-    * print "\n"
+  369 print "[]  arriving in [gold]{0} sec[]\n"
+  370 format *tmp184
   371 label *label116
   372 label *label115
   373 op floor *tmp185 :loop_time
-    * print "[lightgray]Loop time: "
-    * print *tmp185
-    * print " ms[]"
-    * print "\n"
+  374 print "[lightgray]Loop time: {0} ms[]\n"
+  375 format *tmp185
   376 printflush message1
   377 sensor *tmp186 switch1 @enabled
   378 jump *label68 equal *tmp186 0
 
   393 op strictEqual *tmp200 *tmp199 0
   394 jump *label128 notEqual *tmp200 false
   395 label *label139
-    * print "[salmon]sorter1 is missing!"
-    * print "\n"
-    * print "[gold]Please place and link sorter or inverted sorter to the processor."
-    * print "\n"
+  396 print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
   397 printflush message1
   398 printflush message2
   399 sensor *tmp199 sorter1 @dead
 
   412 sensor *tmp211 switch1 @enabled
   413 jump __start__ notEqual *tmp211 false
   414 label *label137
-    * print "[salmon]Local or remote container became invalid."
-    * print "\n"
-    * print "[gold]Please fix and press button to reinitialize."
-    * print "\n"
+  415 print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
   416 printflush message1
   417 printflush message2
   418 sensor *tmp211 switch1 @enabled

Final code before resolving virtual instructions:

label __start__
set UNIT @mega
set LINK_ID 0
set LOCAL_LIMIT 100
set REMOTE_LIMIT 100
op max .EFF_LOCAL_LIMIT LOCAL_LIMIT 20
op max .EFF_REMOTE_LIMIT REMOTE_LIMIT 20
set .MSG null
sensor *tmp2 switch1 @enabled
jump *label2 notEqual *tmp2 false
label *label136
print "Unit Transport - Single\nActivate switch to start.\n"
printflush message1
sensor *tmp2 switch1 @enabled
jump *label136 equal *tmp2 false
label *label2
sensor *tmp4 @unit @dead
op strictEqual *tmp6 *tmp4 0
jump *label5 notEqual *tmp6 false
label *label138
set :rebindUnit:first_unit null
label *label7
ubind UNIT
jump *label10 equal @unit null
set :rebindUnit:first_unit @unit
jump *label9 always
label *label10
print "[salmon]No unit of type {0} found. 1"
format UNIT
printflush message1
jump *label7 always
label *label9
label *label12
sensor *tmp11 @unit @controller
jump *label6 equal *tmp11 @this
ubind UNIT
print "[gold]Looking for old unit..."
printflush message1
op notEqual *tmp14 @unit :rebindUnit:first_unit
sensor *tmp15 :rebindUnit:first_unit @dead
op strictEqual *tmp16 *tmp15 0
op land *tmp17 *tmp14 *tmp16
jump *label12 notEqual *tmp17 false
label *label18
ubind UNIT
jump *label21 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label22 always
label *label21
sensor *tmp21 @unit @controlled
jump *label17 equal *tmp21 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label22
printflush message1
jump *label18 always
label *label17
label *label6
sensor *tmp4 @unit @dead
op strictEqual *tmp6 *tmp4 0
jump *label138 equal *tmp6 false
label *label5
sensor .UNIT_CAPACITY @unit @itemCapacity
sensor *tmp25 @unit @speed
op div .SPEED_SEC *tmp25 10
ucontrol flag 1
label *label25
set .CONTAINER null
set .DROP_TARGET null
set :n @links
jump *label30 lessThanEq :n 0
label *label134
op sub :n :n 1
getlink :block :n
sensor *tmp31 :block @itemCapacity
jump *label31 lessThanEq *tmp31 0
set .DROP_TARGET .CONTAINER
set .CONTAINER :block
label *label31
jump *label134 greaterThan :n 0
label *label30
jump *label33 notEqual .CONTAINER null
print "[salmon]No destination.\n"
jump *label34 always
label *label33
op notEqual *tmp36 .DROP_TARGET null
sensor *tmp37 .DROP_TARGET @itemCapacity
op lessThan *tmp38 *tmp37 300
op land *tmp39 *tmp36 *tmp38
jump *label27 equal *tmp39 false
print "Destination: {0}\nItem dump: {0}\n[salmon]Item dump must be a container or a vault!"
format .CONTAINER
format .DROP_TARGET
label *label34
printflush message1
jump *label25 always
label *label27
set .CORE_Y null
set .CORE_X null
set .CORE null
jump *label37 notEqual LINK_ID 0
print "[gold]Locating core..."
printflush message1
ulocate building core false @copper .CORE_X .CORE_Y 0 .CORE
jump *label38 always
label *label37
print "[gold]Locating vault #{0}..."
format LINK_ID
printflush message1
op add .QUERY_FLAG 99999900 LINK_ID
set :flag .QUERY_FLAG
ucontrol flag .QUERY_FLAG
sensor *tmp47 @unit @dead
op strictEqual *tmp49 *tmp47 0
jump *label41 equal *tmp49 false
label *label141
ucontrol stop
sensor :flag @unit @flag
op equal *tmp46 :flag .QUERY_FLAG
sensor *tmp47 @unit @dead
op strictEqual *tmp48 *tmp47 0
op land *tmp49 *tmp46 *tmp48
jump *label141 notEqual *tmp49 false
label *label41
jump *label42 equal :flag .QUERY_FLAG
op idiv :position :flag 100
op mod .CORE_X :position @mapw
op idiv .CORE_Y :position @mapw
ucontrol within .CORE_X .CORE_Y 8 *tmp56
op equal *tmp57 *tmp56 false
sensor *tmp58 @unit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label46 equal *tmp60 false
label *label142
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp56
op equal *tmp57 *tmp56 false
sensor *tmp58 @unit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label142 notEqual *tmp60 false
label *label46
ucontrol getBlock .CORE_X .CORE_Y :b_type .CORE 0
select .CORE notEqual :b_type @vault null .CORE
label *label42
label *label38
jump *label49 notEqual .CORE null
end
label *label49
set .SORTER sorter1
sensor :sorter_type sorter1 @type
op notEqual *tmp68 :sorter_type @sorter
op notEqual *tmp69 :sorter_type @inverted-sorter
op land *tmp70 *tmp68 *tmp69
jump *label53 equal *tmp70 false
label *label140
print "[salmon]Block sorter1 is neither a sorter, nor an inverted sorter.\n"
jump *label54 equal .SORTER null
print "Block found: "
print .SORTER
label *label54
printflush message1
set .SORTER sorter1
sensor :sorter_type sorter1 @type
op notEqual *tmp68 :sorter_type @sorter
op notEqual *tmp69 :sorter_type @inverted-sorter
op land *tmp70 *tmp68 *tmp69
jump *label140 notEqual *tmp70 false
label *label53
jump *label56 notEqual :sorter_type @sorter
set .SHOW_REMOTE_LEVEL true
set .SRC .CORE
set .DST .CONTAINER
sensor :src_capacity .CORE @itemCapacity
sensor :dst_capacity .CONTAINER @itemCapacity
op sub *tmp78 100 .EFF_REMOTE_LIMIT
op mul *tmp79 :src_capacity *tmp78
op idiv .LOAD_LEVEL *tmp79 100
op mul *tmp81 :dst_capacity .EFF_LOCAL_LIMIT
op idiv .DROP_LEVEL *tmp81 100
set .LOCAL_MARGIN .DROP_LEVEL
set .REMOTE_MARGIN .LOAD_LEVEL
select *tmp84 equal LINK_ID 0 "[] from core" "[] from vault #"
set .DIRECTION *tmp84
jump *label57 always
label *label56
op greaterThan .SHOW_REMOTE_LEVEL LINK_ID 0
set .SRC .CONTAINER
set .DST .CORE
sensor :src_capacity .CONTAINER @itemCapacity
sensor :dst_capacity .CORE @itemCapacity
op sub *tmp88 100 .EFF_LOCAL_LIMIT
op mul *tmp89 :src_capacity *tmp88
op idiv .LOAD_LEVEL *tmp89 100
op mul *tmp91 :dst_capacity .EFF_REMOTE_LIMIT
op idiv *tmp92 *tmp91 100
op equal *tmp93 LINK_ID 0
op mul *tmp94 *tmp93 .UNIT_CAPACITY
op add .DROP_LEVEL *tmp92 *tmp94
set .LOCAL_MARGIN .LOAD_LEVEL
set .REMOTE_MARGIN .DROP_LEVEL
select *tmp97 equal LINK_ID 0 "[] to core" "[] to vault #"
set .DIRECTION *tmp97
label *label57
select *tmp99 equal LINK_ID 0 "" LINK_ID
sensor .SRC_X .SRC @x
sensor .SRC_Y .SRC @y
sensor .DST_X .DST @x
sensor .DST_Y .DST @y
jump *label64 notEqual .DROP_TARGET null
set .DROP_TARGET .CORE
set .DROP_X .CORE_X
set .DROP_Y .CORE_Y
jump *label65 always
label *label64
sensor .DROP_X .DROP_TARGET @x
sensor .DROP_Y .DROP_TARGET @y
label *label65
set .LAST_ITEM @mono
set :iter 0
set :loop_time 0
set :state 1
ucontrol stop
label *label66
set :start @time
sensor *tmp109 @unit @dead
op strictEqual *tmp110 *tmp109 0
sensor *tmp111 @unit @controller
op notEqual *tmp112 *tmp111 @this
jump *label69 greaterThan *tmp110 *tmp112
label *label72
ubind UNIT
jump *label75 notEqual @unit null
print "[salmon]No unit of type {0} found. 2"
format UNIT
jump *label76 always
label *label75
sensor *tmp118 @unit @controlled
jump *label71 equal *tmp118 0
print "[salmon]Looking for a free {0}..."
format UNIT
label *label76
printflush message1
jump *label72 always
label *label71
ucontrol flag 1
set :state 1
label *label69
sensor .ITEM .SORTER @config
jump *label79 equal .ITEM .LAST_ITEM
jump *label83 notEqual .ITEM null
label *label135
print "[salmon]No item type selected for transport."
printflush message1
sensor .ITEM .SORTER @config
jump *label135 equal .ITEM null
label *label83
set .LAST_ITEM .ITEM
set :state 1
label *label79
set :show_state 0
jump *label84 notEqual :state 1
sensor *tmp128 @unit @firstItem
jump *label86 notEqual *tmp128 .ITEM
set :state 3
jump *label87 always
label *label86
sensor *tmp131 @unit @totalItems
jump *label88 notEqual *tmp131 0
set :state 2
jump *label89 always
label *label88
set .MSG "\nUnloading previous items: [green]"
ucontrol approach .DROP_X .DROP_Y 6
ucontrol within .DROP_X .DROP_Y 8 *tmp134
jump *label90 equal *tmp134 false
ucontrol itemDrop .DROP_TARGET .UNIT_CAPACITY
label *label90
label *label89
label *label87
label *label84
jump *label92 notEqual :state 2
ucontrol within .SRC_X .SRC_Y 8 *tmp138
jump *label94 equal *tmp138 false
sensor *tmp140 .SRC .ITEM
op sub *tmp141 *tmp140 .LOAD_LEVEL
op max :max_load *tmp141 0
ucontrol itemTake .SRC .ITEM :max_load
sensor *tmp143 @unit @totalItems
jump *label96 lessThan *tmp143 .UNIT_CAPACITY
set :state 3
jump *label95 always
label *label96
set .MSG "\nLoading items: [green]"
jump *label95 always
label *label94
ucontrol approach .SRC_X .SRC_Y 6
set .MSG "\nGoing to source: [green]"
set :show_state 2
label *label95
label *label92
jump *label98 notEqual :state 3
ucontrol within .DST_X .DST_Y 8 *tmp148
jump *label100 equal *tmp148 false
sensor *tmp150 .DST .ITEM
op sub *tmp151 .DROP_LEVEL *tmp150
op max :max_drop *tmp151 0
ucontrol itemDrop .DST :max_drop
sensor *tmp153 @unit @totalItems
jump *label102 greaterThan *tmp153 0
set :state 2
ucontrol approach .SRC_X .SRC_Y 6
jump *label101 always
label *label102
set .MSG "\nDropping items: [green]"
jump *label101 always
label *label100
ucontrol approach .DST_X .DST_Y 6
set .MSG "\nGoing to destination: [green]"
set :show_state 3
label *label101
label *label98
jump *label104 lessThanEq :iter 3
set :iter 0
print "Moving [green]{0}{0}{0}\nLocal items: [gold]{0}[]"
format .ITEM
format .DIRECTION
format *tmp99
sensor *tmp158 .CONTAINER .ITEM
format *tmp158
jump *label106 greaterThanEq .EFF_LOCAL_LIMIT 100
print " (limit [orange]{0}[])"
format .LOCAL_MARGIN
label *label106
jump *label108 equal .SHOW_REMOTE_LEVEL false
sensor *tmp162 .CORE .ITEM
print "\nRemote items: [gold]{0}[]"
format *tmp162
jump *label110 greaterThanEq .EFF_REMOTE_LIMIT 100
print " (limit [orange]{0}[])"
format .REMOTE_MARGIN
label *label110
label *label108
sensor *tmp165 @unit @totalItems
print .MSG
print *tmp165
print "[]\n"
jump *label114 notEqual :show_state 2
sensor *tmp169 @unit @x
op sub *tmp170 .SRC_X *tmp169
sensor *tmp171 @unit @y
op sub *tmp172 .SRC_Y *tmp171
op len *tmp173 *tmp170 *tmp172
op idiv *tmp174 *tmp173 .SPEED_SEC
op div *tmp175 *tmp174 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp175
jump *label115 always
label *label114
jump *label116 notEqual :show_state 3
sensor *tmp178 @unit @x
op sub *tmp179 .DST_X *tmp178
sensor *tmp180 @unit @y
op sub *tmp181 .DST_Y *tmp180
op len *tmp182 *tmp179 *tmp181
op idiv *tmp183 *tmp182 .SPEED_SEC
op div *tmp184 *tmp183 10
print "[]  arriving in [gold]{0} sec[]\n"
format *tmp184
label *label116
label *label115
op floor *tmp185 :loop_time
print "[lightgray]Loop time: {0} ms[]\n"
format *tmp185
printflush message1
sensor *tmp186 switch1 @enabled
jump *label68 equal *tmp186 0
sensor *tmp189 .SRC @dead
jump *label68 notEqual *tmp189 0
sensor *tmp192 .DST @dead
jump *label68 notEqual *tmp192 0
sensor *tmp195 .SORTER @dead
jump *label68 notEqual *tmp195 0
jump *label105 always
label *label104
op add :iter :iter 1
label *label105
op sub :loop_time @time :start
jump *label66 always
label *label68
sensor *tmp199 .SORTER @dead
op strictEqual *tmp200 *tmp199 0
jump *label128 notEqual *tmp200 false
label *label139
print "[salmon]sorter1 is missing!\n[gold]Please place and link sorter or inverted sorter to the processor.\n"
printflush message1
printflush message2
sensor *tmp199 sorter1 @dead
op strictEqual *tmp200 *tmp199 0
jump *label139 equal *tmp200 false
label *label128
sensor *tmp202 .SRC @dead
op strictEqual *tmp204 *tmp202 0
op equal *tmp203 *tmp204 false
sensor *tmp205 .DST @dead
op strictEqual *tmp207 *tmp205 0
op equal *tmp206 *tmp207 false
op or *tmp208 *tmp203 *tmp206
jump __start__ equal *tmp208 false
control enabled switch1 false
sensor *tmp211 switch1 @enabled
jump __start__ notEqual *tmp211 false
label *label137
print "[salmon]Local or remote container became invalid.\n[gold]Please fix and press button to reinitialize.\n"
printflush message1
printflush message2
sensor *tmp211 switch1 @enabled
jump *label137 equal *tmp211 false
