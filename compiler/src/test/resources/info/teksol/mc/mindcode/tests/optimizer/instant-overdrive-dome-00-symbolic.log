  1434 instructions before optimizations.
    52 instructions eliminated by Temp Variables Elimination.
   263 instructions eliminated by Dead Code Elimination (2 passes, 8 iterations).
     3 instructions eliminated by Jump Normalization (3 passes, 5 iterations).
    71 instructions eliminated by Jump Optimization (2 passes, 5 iterations).
   104 instructions eliminated by Single Step Elimination (4 passes, 9 iterations).
     2 instructions modified by Expression Optimization (4 iterations).
     2 instructions eliminated by If Expression Optimization (4 iterations).
    98 instructions eliminated by Data Flow Optimization (4 passes, 17 iterations).
     2 instructions added by Loop Optimization (4 iterations).
     3 loops improved by Loop Optimization.
   141 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
    17 instructions eliminated by Jump Straightening (5 iterations).
    24 instructions updated by JumpThreading.
    18 instructions eliminated by Unreachable Code Elimination.
    83 instructions eliminated by Print Merging.
   866 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 201):
  * Replicate loop condition at line 44:1                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
    Replicate loop condition at line 127:1                       cost     1, benefit       25.0, efficiency       25.0
  ! Unroll iteration loop at line 177:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 1: speed optimization selection (cost limit 200):
  * Replicate loop condition at line 127:1                       cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
  ! Unroll iteration loop at line 177:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 1: speed optimization selection (cost limit 199):
  ! Unroll iteration loop at line 177:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 2: speed optimization selection (cost limit 230):
  * Unroll iteration loop at line 177:9                          cost   181, benefit      375.0, efficiency        2.1 (+133 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-166 instructions):
 
    82 label *label21
    83 set *tmp24 null
    84 label *label22
-    * set *tmp22 *tmp24
    85 jump *label20 always
    86 label *label19
    87 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
-    * set *tmp22 :areUnitsAvailable.0:occupied
    88 label *label20
    89 ubind :areUnitsAvailable.0:type
    90 label *label17
 
    94 op land *tmp28 *tmp25 *tmp27
    95 jump *label16 notEqual *tmp28 false
    96 label *label18
-    * set *tmp7 null
    97 jump *label12 always
    98 label *label11
-    * set *tmp7 null
    99 label *label12
   100 jump *label23 equal :areUnitsAvailable.0:output false
   101 print :areUnitsAvailable.0:type
 
   109 jump *label25 equal *tmp30 false
   110 print ", needed: "
   111 print :areUnitsAvailable.0:needed
-    * set *tmp31 null
   112 jump *label26 always
   113 label *label25
-    * set *tmp31 null
   114 label *label26
   115 print "\n"
-    * set *tmp29 null
   116 jump *label24 always
   117 label *label23
-    * set *tmp29 null
   118 label *label24
   119 set *tmp4 false
   120 jump *label10 always
 
   123 jump *label27 equal *tmp4 false
   124 set *tmp3 UNIT_TYPE
   125 jump *label6 always
-    * set *tmp32 null
   126 jump *label28 always
   127 label *label27
-    * set *tmp32 null
   128 label *label28
   129 set :chooseUnitType.0:type @flare
   130 op add *tmp33 @counter 1
 
   197 label *label51
   198 set *tmp56 null
   199 label *label52
-    * set *tmp54 *tmp56
   200 jump *label50 always
   201 label *label49
   202 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp54 :areUnitsAvailable.1:occupied
   203 label *label50
   204 ubind :areUnitsAvailable.1:type
   205 label *label47
 
   209 op land *tmp60 *tmp57 *tmp59
   210 jump *label46 notEqual *tmp60 false
   211 label *label48
-    * set *tmp39 null
   212 jump *label42 always
   213 label *label41
-    * set *tmp39 null
   214 label *label42
   215 jump *label53 equal :areUnitsAvailable.1:output false
   216 print :areUnitsAvailable.1:type
 
   224 jump *label55 equal *tmp62 false
   225 print ", needed: "
   226 print :areUnitsAvailable.1:needed
-    * set *tmp63 null
   227 jump *label56 always
   228 label *label55
-    * set *tmp63 null
   229 label *label56
   230 print "\n"
-    * set *tmp61 null
   231 jump *label54 always
   232 label *label53
-    * set *tmp61 null
   233 label *label54
   234 set *tmp36 false
   235 jump *label40 always
 
   244 label *label57
   245 set *tmp64 null
   246 label *label58
-    * set *tmp35 *tmp64
   247 jump *label39 always
   248 label *label38
-    * set *tmp35 null
   249 label *label39
   250 label *label30
   251 multijump *tmp33 0 0
 
   273 op equal *tmp67 :rebindUnits.0:firstUnit null
   274 jump *label60 equal *tmp67 false
   275 end
-    * set *tmp68 null
   276 jump *label61 always
   277 label *label60
-    * set *tmp68 null
   278 label *label61
   279 label *label62
   280 sensor *tmp69 @unit @controller
 
   295 label *label67
   296 set *tmp74 null
   297 label *label68
-    * set *tmp71 *tmp74
   298 jump *label66 always
   299 label *label65
-    * set *tmp71 null
   300 label *label66
   301 ubind .TYPE
   302 label *label63
 
   306 op land *tmp78 *tmp75 *tmp77
   307 jump *label62 notEqual *tmp78 false
   308 label *label64
-    * set *tmp65 :rebindUnits.0:count
   309 jump *label59 always
-    * set *tmp65 null
   310 label *label59
   311 # "Function: inline def acquireUnit(in currentUnit)"
   312 set :acquireUnit.0:currentUnit .UNIT_S1
 
   321 op equal *tmp86 *tmp85 @this
   322 op land *tmp87 *tmp84 *tmp86
   323 jump *label73 equal *tmp87 false
-    * set *tmp80 :rebindUnit.0:currentUnit
   324 jump *label70 always
   325 set *tmp88 null
   326 jump *label74 always
   327 label *label73
   328 set *tmp88 null
   329 label *label74
-    * set *tmp82 *tmp88
   330 jump *label72 always
   331 label *label71
-    * set *tmp82 null
   332 label *label72
   333 ubind .TYPE
   334 set *tmp89 @unit
 
   339 sensor *tmp92 @unit @controlled
   340 op equal *tmp93 *tmp92 0
   341 jump *label80 equal *tmp93 false
-    * set *tmp80 @unit
   342 jump *label70 always
-    * set *tmp94 null
   343 jump *label81 always
   344 label *label80
-    * set *tmp94 null
   345 label *label81
   346 ubind .TYPE
   347 label *label78
 
   351 op land *tmp98 *tmp95 *tmp97
   352 jump *label77 notEqual *tmp98 false
   353 label *label79
-    * set *tmp91 null
   354 jump *label76 always
   355 label *label75
-    * set *tmp91 null
   356 label *label76
   357 end
-    * set *tmp80 null
   358 label *label70
   359 ucontrol flag 1
   360 set *tmp79 @unit
 
   375 op equal *tmp106 *tmp105 @this
   376 op land *tmp107 *tmp104 *tmp106
   377 jump *label86 equal *tmp107 false
-    * set *tmp100 :rebindUnit.1:currentUnit
   378 jump *label83 always
   379 set *tmp108 null
   380 jump *label87 always
   381 label *label86
   382 set *tmp108 null
   383 label *label87
-    * set *tmp102 *tmp108
   384 jump *label85 always
   385 label *label84
-    * set *tmp102 null
   386 label *label85
   387 ubind .TYPE
   388 set *tmp109 @unit
 
   393 sensor *tmp112 @unit @controlled
   394 op equal *tmp113 *tmp112 0
   395 jump *label93 equal *tmp113 false
-    * set *tmp100 @unit
   396 jump *label83 always
-    * set *tmp114 null
   397 jump *label94 always
   398 label *label93
-    * set *tmp114 null
   399 label *label94
   400 ubind .TYPE
   401 label *label91
 
   405 op land *tmp118 *tmp115 *tmp117
   406 jump *label90 notEqual *tmp118 false
   407 label *label92
-    * set *tmp111 null
   408 jump *label89 always
   409 label *label88
-    * set *tmp111 null
   410 label *label89
   411 end
-    * set *tmp100 null
   412 label *label83
   413 ucontrol flag 1
   414 set *tmp99 @unit
 
   425 set :u .UNIT_S1
   426 set .UNIT_S1 .UNIT_P1
   427 set .UNIT_P1 :u
-    * set *tmp124 .UNIT_P1
   428 jump *label96 always
   429 label *label95
-    * set *tmp124 null
   430 label *label96
   431 sensor *tmp125 .UNIT_S1 @itemCapacity
   432 set .UNIT_CAPACITY *tmp125
 
   437 op strictEqual *tmp128 .SPEED null
   438 jump *label97 equal *tmp128 false
   439 stop
-    * set *tmp129 null
   440 jump *label98 always
   441 label *label97
-    * set *tmp129 null
   442 label *label98
   443 print "[gold]Locating core..."
   444 printflush message1
 
   486 op equal *tmp155 *tmp154 @this
   487 op land *tmp156 *tmp153 *tmp155
   488 jump *label109 equal *tmp156 false
-    * set *tmp149 :rebindUnit.2:currentUnit
   489 jump *label106 always
   490 set *tmp157 null
   491 jump *label110 always
   492 label *label109
   493 set *tmp157 null
   494 label *label110
-    * set *tmp151 *tmp157
   495 jump *label108 always
   496 label *label107
-    * set *tmp151 null
   497 label *label108
   498 ubind .TYPE
   499 set *tmp158 @unit
 
   504 sensor *tmp161 @unit @controlled
   505 op equal *tmp162 *tmp161 0
   506 jump *label116 equal *tmp162 false
-    * set *tmp149 @unit
   507 jump *label106 always
-    * set *tmp163 null
   508 jump *label117 always
   509 label *label116
-    * set *tmp163 null
   510 label *label117
   511 ubind .TYPE
   512 label *label114
 
   516 op land *tmp167 *tmp164 *tmp166
   517 jump *label113 notEqual *tmp167 false
   518 label *label115
-    * set *tmp160 null
   519 jump *label112 always
   520 label *label111
-    * set *tmp160 null
   521 label *label112
   522 end
-    * set *tmp149 null
   523 label *label106
   524 ucontrol flag 1
   525 set *tmp148 @unit
 
   540 op equal *tmp175 *tmp174 @this
   541 op land *tmp176 *tmp173 *tmp175
   542 jump *label122 equal *tmp176 false
-    * set *tmp169 :rebindUnit.3:currentUnit
   543 jump *label119 always
   544 set *tmp177 null
   545 jump *label123 always
   546 label *label122
   547 set *tmp177 null
   548 label *label123
-    * set *tmp171 *tmp177
   549 jump *label121 always
   550 label *label120
-    * set *tmp171 null
   551 label *label121
   552 ubind .TYPE
   553 set *tmp178 @unit
 
   558 sensor *tmp181 @unit @controlled
   559 op equal *tmp182 *tmp181 0
   560 jump *label129 equal *tmp182 false
-    * set *tmp169 @unit
   561 jump *label119 always
-    * set *tmp183 null
   562 jump *label130 always
   563 label *label129
-    * set *tmp183 null
   564 label *label130
   565 ubind .TYPE
   566 label *label127
 
   570 op land *tmp187 *tmp184 *tmp186
   571 jump *label126 notEqual *tmp187 false
   572 label *label128
-    * set *tmp180 null
   573 jump *label125 always
   574 label *label124
-    * set *tmp180 null
   575 label *label125
   576 end
-    * set *tmp169 null
   577 label *label119
   578 ucontrol flag 1
   579 set *tmp168 @unit
 
   590 set :u .UNIT_S1
   591 set .UNIT_S1 .UNIT_P2
   592 set .UNIT_P2 :u
-    * set *tmp193 .UNIT_P2
   593 jump *label132 always
   594 label *label131
-    * set *tmp193 null
   595 label *label132
   596 sensor *tmp194 .UNIT_S2 @firstItem
   597 op equal *tmp195 *tmp194 @phase-fabric
 
   602 set :u .UNIT_S2
   603 set .UNIT_S2 .UNIT_P2
   604 set .UNIT_P2 :u
-    * set *tmp199 .UNIT_P2
   605 jump *label134 always
   606 label *label133
-    * set *tmp199 null
   607 label *label134
   608 set .GROUP1 "unit  1"
   609 set .GROUP2 "unit 2"
-    * set *tmp147 .GROUP2
   610 jump *label104 always
   611 label *label103
   612 ubind .UNIT_S2
 
   617 set .UNIT_P2 null
   618 set .GROUP1 "unit"
   619 set .GROUP2 ""
-    * set *tmp147 .GROUP2
   620 label *label104
   621 op equal *tmp200 .FOUR_UNITS false
   622 sensor *tmp201 .UNIT_S1 @totalItems
 
   668 print "\n"
   669 set *tmp216 null
   670 label *label140
-    * set *tmp213 *tmp216
   671 label *label138
   672 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
   673 set :processUnit.0:unit .UNIT_S1
 
   685 op equal *tmp224 *tmp223 @this
   686 op land *tmp225 *tmp222 *tmp224
   687 jump *label145 equal *tmp225 false
-    * set *tmp218 :rebindUnit.4:currentUnit
   688 jump *label142 always
   689 set *tmp226 null
   690 jump *label146 always
   691 label *label145
   692 set *tmp226 null
   693 label *label146
-    * set *tmp220 *tmp226
   694 jump *label144 always
   695 label *label143
-    * set *tmp220 null
   696 label *label144
   697 ubind .TYPE
   698 set *tmp227 @unit
 
   703 sensor *tmp230 @unit @controlled
   704 op equal *tmp231 *tmp230 0
   705 jump *label152 equal *tmp231 false
-    * set *tmp218 @unit
   706 jump *label142 always
-    * set *tmp232 null
   707 jump *label153 always
   708 label *label152
-    * set *tmp232 null
   709 label *label153
   710 ubind .TYPE
   711 label *label150
 
   715 op land *tmp236 *tmp233 *tmp235
   716 jump *label149 notEqual *tmp236 false
   717 label *label151
-    * set *tmp229 null
   718 jump *label148 always
   719 label *label147
-    * set *tmp229 null
   720 label *label148
   721 end
-    * set *tmp218 null
   722 label *label142
   723 set :processUnit.0:msg ""
   724 sensor *tmp237 @unit @flag
 
   757 label *label159
   758 set *tmp244 *tmp247
   759 label *label157
-    * set *tmp241 *tmp244
   760 jump *label155 always
   761 label *label154
-    * set *tmp241 null
   762 label *label155
   763 op equal *tmp250 :processUnit.0:state 2
   764 jump *label162 equal *tmp250 false
 
   791 set :processUnit.0:distance *tmp263
   792 set *tmp253 :processUnit.0:distance
   793 label *label165
-    * set *tmp251 *tmp253
   794 jump *label163 always
   795 label *label162
-    * set *tmp251 null
   796 label *label163
   797 op equal *tmp264 :processUnit.0:state 3
   798 jump *label168 equal *tmp264 false
 
   801 jump *label172 equal :processUnit.0:supply false
   802 ucontrol itemDrop .DOME .UNIT_CAPACITY
   803 set :processUnit.0:msg ", supplying\n"
-    * set *tmp268 :processUnit.0:msg
   804 jump *label173 always
   805 label *label172
   806 ucontrol approach .DOME_X .DOME_Y 6
   807 set :processUnit.0:msg ", waiting\n"
-    * set *tmp268 :processUnit.0:msg
   808 label *label173
   809 sensor *tmp269 @unit @totalItems
   810 op lessThanEq *tmp270 *tmp269 0
 
   831 set :processUnit.0:distance *tmp278
   832 set *tmp267 :processUnit.0:distance
   833 label *label171
-    * set *tmp265 *tmp267
   834 jump *label169 always
   835 label *label168
-    * set *tmp265 null
   836 label *label169
   837 ucontrol flag :processUnit.0:state
   838 sensor *tmp279 @unit @totalItems
 
   852 print "["
   853 print "] sec"
   854 print "\n"
-    * set *tmp281 null
   855 jump *label177 always
   856 label *label176
   857 print :processUnit.0:msg
-    * set *tmp281 :processUnit.0:msg
   858 label *label177
   859 set *tmp217 @unit
   860 jump *label141 always
 
   879 op equal *tmp291 *tmp290 @this
   880 op land *tmp292 *tmp289 *tmp291
   881 jump *label184 equal *tmp292 false
-    * set *tmp285 :rebindUnit.5:currentUnit
   882 jump *label181 always
   883 set *tmp293 null
   884 jump *label185 always
   885 label *label184
   886 set *tmp293 null
   887 label *label185
-    * set *tmp287 *tmp293
   888 jump *label183 always
   889 label *label182
-    * set *tmp287 null
   890 label *label183
   891 ubind .TYPE
   892 set *tmp294 @unit
 
   897 sensor *tmp297 @unit @controlled
   898 op equal *tmp298 *tmp297 0
   899 jump *label191 equal *tmp298 false
-    * set *tmp285 @unit
   900 jump *label181 always
-    * set *tmp299 null
   901 jump *label192 always
   902 label *label191
-    * set *tmp299 null
   903 label *label192
   904 ubind .TYPE
   905 label *label189
 
   909 op land *tmp303 *tmp300 *tmp302
   910 jump *label188 notEqual *tmp303 false
   911 label *label190
-    * set *tmp296 null
   912 jump *label187 always
   913 label *label186
-    * set *tmp296 null
   914 label *label187
   915 end
-    * set *tmp285 null
   916 label *label181
   917 set :processUnit.1:msg ""
   918 sensor *tmp304 @unit @flag
 
   951 label *label198
   952 set *tmp311 *tmp314
   953 label *label196
-    * set *tmp308 *tmp311
   954 jump *label194 always
   955 label *label193
-    * set *tmp308 null
   956 label *label194
   957 op equal *tmp317 :processUnit.1:state 2
   958 jump *label201 equal *tmp317 false
 
   985 set :processUnit.1:distance *tmp330
   986 set *tmp320 :processUnit.1:distance
   987 label *label204
-    * set *tmp318 *tmp320
   988 jump *label202 always
   989 label *label201
-    * set *tmp318 null
   990 label *label202
   991 op equal *tmp331 :processUnit.1:state 3
   992 jump *label207 equal *tmp331 false
 
   995 jump *label211 equal :processUnit.1:supply false
   996 ucontrol itemDrop .DOME .UNIT_CAPACITY
   997 set :processUnit.1:msg ", supplying\n"
-    * set *tmp335 :processUnit.1:msg
   998 jump *label212 always
   999 label *label211
  1000 ucontrol approach .DOME_X .DOME_Y 6
  1001 set :processUnit.1:msg ", waiting\n"
-    * set *tmp335 :processUnit.1:msg
  1002 label *label212
  1003 sensor *tmp336 @unit @totalItems
  1004 op lessThanEq *tmp337 *tmp336 0
 
  1025 set :processUnit.1:distance *tmp345
  1026 set *tmp334 :processUnit.1:distance
  1027 label *label210
-    * set *tmp332 *tmp334
  1028 jump *label208 always
  1029 label *label207
-    * set *tmp332 null
  1030 label *label208
  1031 ucontrol flag :processUnit.1:state
  1032 sensor *tmp346 @unit @totalItems
 
  1046 print "["
  1047 print "] sec"
  1048 print "\n"
-    * set *tmp348 null
  1049 jump *label216 always
  1050 label *label215
  1051 print :processUnit.1:msg
-    * set *tmp348 :processUnit.1:msg
  1052 label *label216
  1053 set *tmp284 @unit
  1054 jump *label180 always
 
  1066 set *tmp349 *tmp353
  1067 label *label218
  1068 set .SUPPLY_S_FIRST *tmp349
-    * set *tmp282 .SUPPLY_S_FIRST
  1069 jump *label179 always
  1070 label *label178
-    * set *tmp282 null
  1071 label *label179
  1072 # "Function: inline def printDomeStatus(in item, in text)"
  1073 set :printDomeStatus.1:item @phase-fabric
 
  1092 print "\n"
  1093 set *tmp357 null
  1094 label *label221
-    * set *tmp354 *tmp357
  1095 label *label219
  1096 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
  1097 set :processUnit.2:unit .UNIT_P1
 
  1109 op equal *tmp365 *tmp364 @this
  1110 op land *tmp366 *tmp363 *tmp365
  1111 jump *label226 equal *tmp366 false
-    * set *tmp359 :rebindUnit.6:currentUnit
  1112 jump *label223 always
  1113 set *tmp367 null
  1114 jump *label227 always
  1115 label *label226
  1116 set *tmp367 null
  1117 label *label227
-    * set *tmp361 *tmp367
  1118 jump *label225 always
  1119 label *label224
-    * set *tmp361 null
  1120 label *label225
  1121 ubind .TYPE
  1122 set *tmp368 @unit
 
  1127 sensor *tmp371 @unit @controlled
  1128 op equal *tmp372 *tmp371 0
  1129 jump *label233 equal *tmp372 false
-    * set *tmp359 @unit
  1130 jump *label223 always
-    * set *tmp373 null
  1131 jump *label234 always
  1132 label *label233
-    * set *tmp373 null
  1133 label *label234
  1134 ubind .TYPE
  1135 label *label231
 
  1139 op land *tmp377 *tmp374 *tmp376
  1140 jump *label230 notEqual *tmp377 false
  1141 label *label232
-    * set *tmp370 null
  1142 jump *label229 always
  1143 label *label228
-    * set *tmp370 null
  1144 label *label229
  1145 end
-    * set *tmp359 null
  1146 label *label223
  1147 set :processUnit.2:msg ""
  1148 sensor *tmp378 @unit @flag
 
  1181 label *label240
  1182 set *tmp385 *tmp388
  1183 label *label238
-    * set *tmp382 *tmp385
  1184 jump *label236 always
  1185 label *label235
-    * set *tmp382 null
  1186 label *label236
  1187 op equal *tmp391 :processUnit.2:state 2
  1188 jump *label243 equal *tmp391 false
 
  1215 set :processUnit.2:distance *tmp404
  1216 set *tmp394 :processUnit.2:distance
  1217 label *label246
-    * set *tmp392 *tmp394
  1218 jump *label244 always
  1219 label *label243
-    * set *tmp392 null
  1220 label *label244
  1221 op equal *tmp405 :processUnit.2:state 3
  1222 jump *label249 equal *tmp405 false
 
  1225 jump *label253 equal :processUnit.2:supply false
  1226 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1227 set :processUnit.2:msg ", supplying\n"
-    * set *tmp409 :processUnit.2:msg
  1228 jump *label254 always
  1229 label *label253
  1230 ucontrol approach .DOME_X .DOME_Y 6
  1231 set :processUnit.2:msg ", waiting\n"
-    * set *tmp409 :processUnit.2:msg
  1232 label *label254
  1233 sensor *tmp410 @unit @totalItems
  1234 op lessThanEq *tmp411 *tmp410 0
 
  1255 set :processUnit.2:distance *tmp419
  1256 set *tmp408 :processUnit.2:distance
  1257 label *label252
-    * set *tmp406 *tmp408
  1258 jump *label250 always
  1259 label *label249
-    * set *tmp406 null
  1260 label *label250
  1261 ucontrol flag :processUnit.2:state
  1262 sensor *tmp420 @unit @totalItems
 
  1276 print "["
  1277 print "] sec"
  1278 print "\n"
-    * set *tmp422 null
  1279 jump *label258 always
  1280 label *label257
  1281 print :processUnit.2:msg
-    * set *tmp422 :processUnit.2:msg
  1282 label *label258
  1283 set *tmp358 @unit
  1284 jump *label222 always
 
  1303 op equal *tmp432 *tmp431 @this
  1304 op land *tmp433 *tmp430 *tmp432
  1305 jump *label265 equal *tmp433 false
-    * set *tmp426 :rebindUnit.7:currentUnit
  1306 jump *label262 always
  1307 set *tmp434 null
  1308 jump *label266 always
  1309 label *label265
  1310 set *tmp434 null
  1311 label *label266
-    * set *tmp428 *tmp434
  1312 jump *label264 always
  1313 label *label263
-    * set *tmp428 null
  1314 label *label264
  1315 ubind .TYPE
  1316 set *tmp435 @unit
 
  1321 sensor *tmp438 @unit @controlled
  1322 op equal *tmp439 *tmp438 0
  1323 jump *label272 equal *tmp439 false
-    * set *tmp426 @unit
  1324 jump *label262 always
-    * set *tmp440 null
  1325 jump *label273 always
  1326 label *label272
-    * set *tmp440 null
  1327 label *label273
  1328 ubind .TYPE
  1329 label *label270
 
  1333 op land *tmp444 *tmp441 *tmp443
  1334 jump *label269 notEqual *tmp444 false
  1335 label *label271
-    * set *tmp437 null
  1336 jump *label268 always
  1337 label *label267
-    * set *tmp437 null
  1338 label *label268
  1339 end
-    * set *tmp426 null
  1340 label *label262
  1341 set :processUnit.3:msg ""
  1342 sensor *tmp445 @unit @flag
 
  1375 label *label279
  1376 set *tmp452 *tmp455
  1377 label *label277
-    * set *tmp449 *tmp452
  1378 jump *label275 always
  1379 label *label274
-    * set *tmp449 null
  1380 label *label275
  1381 op equal *tmp458 :processUnit.3:state 2
  1382 jump *label282 equal *tmp458 false
 
  1409 set :processUnit.3:distance *tmp471
  1410 set *tmp461 :processUnit.3:distance
  1411 label *label285
-    * set *tmp459 *tmp461
  1412 jump *label283 always
  1413 label *label282
-    * set *tmp459 null
  1414 label *label283
  1415 op equal *tmp472 :processUnit.3:state 3
  1416 jump *label288 equal *tmp472 false
 
  1419 jump *label292 equal :processUnit.3:supply false
  1420 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1421 set :processUnit.3:msg ", supplying\n"
-    * set *tmp476 :processUnit.3:msg
  1422 jump *label293 always
  1423 label *label292
  1424 ucontrol approach .DOME_X .DOME_Y 6
  1425 set :processUnit.3:msg ", waiting\n"
-    * set *tmp476 :processUnit.3:msg
  1426 label *label293
  1427 sensor *tmp477 @unit @totalItems
  1428 op lessThanEq *tmp478 *tmp477 0
 
  1449 set :processUnit.3:distance *tmp486
  1450 set *tmp475 :processUnit.3:distance
  1451 label *label291
-    * set *tmp473 *tmp475
  1452 jump *label289 always
  1453 label *label288
-    * set *tmp473 null
  1454 label *label289
  1455 ucontrol flag :processUnit.3:state
  1456 sensor *tmp487 @unit @totalItems
 
  1470 print "["
  1471 print "] sec"
  1472 print "\n"
-    * set *tmp489 null
  1473 jump *label297 always
  1474 label *label296
  1475 print :processUnit.3:msg
-    * set *tmp489 :processUnit.3:msg
  1476 label *label297
  1477 set *tmp425 @unit
  1478 jump *label261 always
 
  1490 set *tmp490 *tmp494
  1491 label *label299
  1492 set .SUPPLY_P_FIRST *tmp490
-    * set *tmp423 .SUPPLY_P_FIRST
  1493 jump *label260 always
  1494 label *label259
-    * set *tmp423 null
  1495 label *label260
  1496 op sub *tmp495 @time :start
  1497 op floor *tmp496 *tmp495
 
  1554 label *label313
  1555 set *tmp521 null
  1556 label *label314
-    * set *tmp519 *tmp521
  1557 jump *label312 always
  1558 label *label311
  1559 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp519 :areUnitsAvailable.2:occupied
  1560 label *label312
  1561 ubind :areUnitsAvailable.2:type
  1562 label *label309
 
  1566 op land *tmp525 *tmp522 *tmp524
  1567 jump *label308 notEqual *tmp525 false
  1568 label *label310
-    * set *tmp504 null
  1569 jump *label304 always
  1570 label *label303
-    * set *tmp504 null
  1571 label *label304
  1572 jump *label315 equal :areUnitsAvailable.2:output false
  1573 print :areUnitsAvailable.2:type
 
  1581 jump *label317 equal *tmp527 false
  1582 print ", needed: "
  1583 print :areUnitsAvailable.2:needed
-    * set *tmp528 null
  1584 jump *label318 always
  1585 label *label317
-    * set *tmp528 null
  1586 label *label318
  1587 print "\n"
-    * set *tmp526 null
  1588 jump *label316 always
  1589 label *label315
-    * set *tmp526 null
  1590 label *label316
  1591 set *tmp501 false
  1592 jump *label302 always
 
  1594 label *label302
  1595 jump *label319 equal *tmp501 false
  1596 end
-    * set *tmp529 null
  1597 jump *label320 always
  1598 label *label319
-    * set *tmp529 null
  1599 label *label320
  1600 op add *tmp530 @time 5000
  1601 set :unitCheck *tmp530
-    * set *tmp500 :unitCheck
  1602 jump *label301 always
  1603 label *label300
-    * set *tmp500 null
  1604 label *label301
  1605 label *label136
  1606 jump *label135 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-54 instructions):
 
    77 jump *label21 equal *tmp23 false
    78 set *tmp4 true
    79 jump *label10 always
-    * set *tmp24 null
    80 jump *label22 always
    81 label *label21
-    * set *tmp24 null
    82 label *label22
    83 jump *label20 always
    84 label *label19
 
   190 jump *label51 equal *tmp55 false
   191 set *tmp36 true
   192 jump *label40 always
-    * set *tmp56 null
   193 jump *label52 always
   194 label *label51
-    * set *tmp56 null
   195 label *label52
   196 jump *label50 always
   197 label *label49
 
   235 printflush null
   236 set *tmp3 :chooseUnitType.0:type
   237 jump *label6 always
-    * set *tmp64 null
   238 jump *label58 always
   239 label *label57
-    * set *tmp64 null
   240 label *label58
   241 jump *label39 always
   242 label *label38
 
   284 op notEqual *tmp73 .UNIT_S2 null
   285 jump *label67 equal *tmp73 false
   286 jump *label64 always
-    * set *tmp74 null
   287 jump *label68 always
   288 label *label67
-    * set *tmp74 null
   289 label *label68
   290 jump *label66 always
   291 label *label65
 
   314 op land *tmp87 *tmp84 *tmp86
   315 jump *label73 equal *tmp87 false
   316 jump *label70 always
-    * set *tmp88 null
   317 jump *label74 always
   318 label *label73
-    * set *tmp88 null
   319 label *label74
   320 jump *label72 always
   321 label *label71
 
   366 op land *tmp107 *tmp104 *tmp106
   367 jump *label86 equal *tmp107 false
   368 jump *label83 always
-    * set *tmp108 null
   369 jump *label87 always
   370 label *label86
-    * set *tmp108 null
   371 label *label87
   372 jump *label85 always
   373 label *label84
 
   475 op land *tmp156 *tmp153 *tmp155
   476 jump *label109 equal *tmp156 false
   477 jump *label106 always
-    * set *tmp157 null
   478 jump *label110 always
   479 label *label109
-    * set *tmp157 null
   480 label *label110
   481 jump *label108 always
   482 label *label107
 
   527 op land *tmp176 *tmp173 *tmp175
   528 jump *label122 equal *tmp176 false
   529 jump *label119 always
-    * set *tmp177 null
   530 jump *label123 always
   531 label *label122
-    * set *tmp177 null
   532 label *label123
   533 jump *label121 always
   534 label *label120
 
   642 print "["
   643 print "]"
   644 print "\n"
-    * set *tmp216 null
   645 jump *label140 always
   646 label *label139
   647 print "  dome:  [coral]"
 
   649 print "["
   650 print "]"
   651 print "\n"
-    * set *tmp216 null
   652 label *label140
   653 label *label138
   654 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
 
   668 op land *tmp225 *tmp222 *tmp224
   669 jump *label145 equal *tmp225 false
   670 jump *label142 always
-    * set *tmp226 null
   671 jump *label146 always
   672 label *label145
-    * set *tmp226 null
   673 label *label146
   674 jump *label144 always
   675 label *label143
 
   713 op equal *tmp243 *tmp242 :processUnit.0:item
   714 jump *label156 equal *tmp243 false
   715 set :processUnit.0:state 3
-    * set *tmp244 :processUnit.0:state
   716 jump *label157 always
   717 label *label156
   718 sensor *tmp245 @unit @totalItems
 
   734 label *label161
   735 set *tmp247 *tmp249
   736 label *label159
-    * set *tmp244 *tmp247
   737 label *label157
   738 jump *label155 always
   739 label *label154
 
   754 set :processUnit.0:msg ", loading\n"
   755 set *tmp256 :processUnit.0:msg
   756 label *label167
-    * set *tmp253 *tmp256
   757 jump *label165 always
   758 label *label164
   759 ucontrol approach .CORE_X .CORE_Y 6
 
   766 op idiv *tmp262 *tmp261 .SPEED_TENTHS
   767 op div *tmp263 *tmp262 10
   768 set :processUnit.0:distance *tmp263
-    * set *tmp253 :processUnit.0:distance
   769 label *label165
   770 jump *label163 always
   771 label *label162
 
   792 label *label174
   793 set *tmp271 null
   794 label *label175
-    * set *tmp267 *tmp271
   795 jump *label171 always
   796 label *label170
   797 ucontrol approach .DOME_X .DOME_Y 6
 
   804 op idiv *tmp277 *tmp276 .SPEED_TENTHS
   805 op div *tmp278 *tmp277 10
   806 set :processUnit.0:distance *tmp278
-    * set *tmp267 :processUnit.0:distance
   807 label *label171
   808 jump *label169 always
   809 label *label168
 
   854 op land *tmp292 *tmp289 *tmp291
   855 jump *label184 equal *tmp292 false
   856 jump *label181 always
-    * set *tmp293 null
   857 jump *label185 always
   858 label *label184
-    * set *tmp293 null
   859 label *label185
   860 jump *label183 always
   861 label *label182
 
   899 op equal *tmp310 *tmp309 :processUnit.1:item
   900 jump *label195 equal *tmp310 false
   901 set :processUnit.1:state 3
-    * set *tmp311 :processUnit.1:state
   902 jump *label196 always
   903 label *label195
   904 sensor *tmp312 @unit @totalItems
 
   920 label *label200
   921 set *tmp314 *tmp316
   922 label *label198
-    * set *tmp311 *tmp314
   923 label *label196
   924 jump *label194 always
   925 label *label193
 
   940 set :processUnit.1:msg ", loading\n"
   941 set *tmp323 :processUnit.1:msg
   942 label *label206
-    * set *tmp320 *tmp323
   943 jump *label204 always
   944 label *label203
   945 ucontrol approach .CORE_X .CORE_Y 6
 
   952 op idiv *tmp329 *tmp328 .SPEED_TENTHS
   953 op div *tmp330 *tmp329 10
   954 set :processUnit.1:distance *tmp330
-    * set *tmp320 :processUnit.1:distance
   955 label *label204
   956 jump *label202 always
   957 label *label201
 
   978 label *label213
   979 set *tmp338 null
   980 label *label214
-    * set *tmp334 *tmp338
   981 jump *label210 always
   982 label *label209
   983 ucontrol approach .DOME_X .DOME_Y 6
 
   990 op idiv *tmp344 *tmp343 .SPEED_TENTHS
   991 op div *tmp345 *tmp344 10
   992 set :processUnit.1:distance *tmp345
-    * set *tmp334 :processUnit.1:distance
   993 label *label210
   994 jump *label208 always
   995 label *label207
 
  1048 print "["
  1049 print "]"
  1050 print "\n"
-    * set *tmp357 null
  1051 jump *label221 always
  1052 label *label220
  1053 print "  dome:  [coral]"
 
  1055 print "["
  1056 print "]"
  1057 print "\n"
-    * set *tmp357 null
  1058 label *label221
  1059 label *label219
  1060 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
 
  1074 op land *tmp366 *tmp363 *tmp365
  1075 jump *label226 equal *tmp366 false
  1076 jump *label223 always
-    * set *tmp367 null
  1077 jump *label227 always
  1078 label *label226
-    * set *tmp367 null
  1079 label *label227
  1080 jump *label225 always
  1081 label *label224
 
  1119 op equal *tmp384 *tmp383 :processUnit.2:item
  1120 jump *label237 equal *tmp384 false
  1121 set :processUnit.2:state 3
-    * set *tmp385 :processUnit.2:state
  1122 jump *label238 always
  1123 label *label237
  1124 sensor *tmp386 @unit @totalItems
 
  1140 label *label242
  1141 set *tmp388 *tmp390
  1142 label *label240
-    * set *tmp385 *tmp388
  1143 label *label238
  1144 jump *label236 always
  1145 label *label235
 
  1160 set :processUnit.2:msg ", loading\n"
  1161 set *tmp397 :processUnit.2:msg
  1162 label *label248
-    * set *tmp394 *tmp397
  1163 jump *label246 always
  1164 label *label245
  1165 ucontrol approach .CORE_X .CORE_Y 6
 
  1172 op idiv *tmp403 *tmp402 .SPEED_TENTHS
  1173 op div *tmp404 *tmp403 10
  1174 set :processUnit.2:distance *tmp404
-    * set *tmp394 :processUnit.2:distance
  1175 label *label246
  1176 jump *label244 always
  1177 label *label243
 
  1198 label *label255
  1199 set *tmp412 null
  1200 label *label256
-    * set *tmp408 *tmp412
  1201 jump *label252 always
  1202 label *label251
  1203 ucontrol approach .DOME_X .DOME_Y 6
 
  1210 op idiv *tmp418 *tmp417 .SPEED_TENTHS
  1211 op div *tmp419 *tmp418 10
  1212 set :processUnit.2:distance *tmp419
-    * set *tmp408 :processUnit.2:distance
  1213 label *label252
  1214 jump *label250 always
  1215 label *label249
 
  1260 op land *tmp433 *tmp430 *tmp432
  1261 jump *label265 equal *tmp433 false
  1262 jump *label262 always
-    * set *tmp434 null
  1263 jump *label266 always
  1264 label *label265
-    * set *tmp434 null
  1265 label *label266
  1266 jump *label264 always
  1267 label *label263
 
  1305 op equal *tmp451 *tmp450 :processUnit.3:item
  1306 jump *label276 equal *tmp451 false
  1307 set :processUnit.3:state 3
-    * set *tmp452 :processUnit.3:state
  1308 jump *label277 always
  1309 label *label276
  1310 sensor *tmp453 @unit @totalItems
 
  1326 label *label281
  1327 set *tmp455 *tmp457
  1328 label *label279
-    * set *tmp452 *tmp455
  1329 label *label277
  1330 jump *label275 always
  1331 label *label274
 
  1346 set :processUnit.3:msg ", loading\n"
  1347 set *tmp464 :processUnit.3:msg
  1348 label *label287
-    * set *tmp461 *tmp464
  1349 jump *label285 always
  1350 label *label284
  1351 ucontrol approach .CORE_X .CORE_Y 6
 
  1358 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1359 op div *tmp471 *tmp470 10
  1360 set :processUnit.3:distance *tmp471
-    * set *tmp461 :processUnit.3:distance
  1361 label *label285
  1362 jump *label283 always
  1363 label *label282
 
  1384 label *label294
  1385 set *tmp479 null
  1386 label *label295
-    * set *tmp475 *tmp479
  1387 jump *label291 always
  1388 label *label290
  1389 ucontrol approach .DOME_X .DOME_Y 6
 
  1396 op idiv *tmp485 *tmp484 .SPEED_TENTHS
  1397 op div *tmp486 *tmp485 10
  1398 set :processUnit.3:distance *tmp486
-    * set *tmp475 :processUnit.3:distance
  1399 label *label291
  1400 jump *label289 always
  1401 label *label288
 
  1497 jump *label313 equal *tmp520 false
  1498 set *tmp501 true
  1499 jump *label302 always
-    * set *tmp521 null
  1500 jump *label314 always
  1501 label *label313
-    * set *tmp521 null
  1502 label *label314
  1503 jump *label312 always
  1504 label *label311

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-24 instructions):
 
   719 op equal *tmp246 *tmp245 0
   720 jump *label158 equal *tmp246 false
   721 set :processUnit.0:state 2
-    * set *tmp247 :processUnit.0:state
   722 jump *label159 always
   723 label *label158
   724 set :processUnit.0:msg ", initializing\n"
 
   731 label *label160
   732 set *tmp249 null
   733 label *label161
-    * set *tmp247 *tmp249
   734 label *label159
   735 label *label157
   736 jump *label155 always
 
   746 jump *label166 equal *tmp255 false
   747 ucontrol approach .DOME_X .DOME_Y 6
   748 set :processUnit.0:state 3
-    * set *tmp256 :processUnit.0:state
   749 jump *label167 always
   750 label *label166
   751 set :processUnit.0:msg ", loading\n"
-    * set *tmp256 :processUnit.0:msg
   752 label *label167
   753 jump *label165 always
   754 label *label164
 
   783 jump *label174 equal *tmp270 false
   784 ucontrol approach .CORE_X .CORE_Y 6
   785 set :processUnit.0:state 2
-    * set *tmp271 :processUnit.0:state
   786 jump *label175 always
   787 label *label174
-    * set *tmp271 null
   788 label *label175
   789 jump *label171 always
   790 label *label170
 
   899 op equal *tmp313 *tmp312 0
   900 jump *label197 equal *tmp313 false
   901 set :processUnit.1:state 2
-    * set *tmp314 :processUnit.1:state
   902 jump *label198 always
   903 label *label197
   904 set :processUnit.1:msg ", initializing\n"
 
   911 label *label199
   912 set *tmp316 null
   913 label *label200
-    * set *tmp314 *tmp316
   914 label *label198
   915 label *label196
   916 jump *label194 always
 
   926 jump *label205 equal *tmp322 false
   927 ucontrol approach .DOME_X .DOME_Y 6
   928 set :processUnit.1:state 3
-    * set *tmp323 :processUnit.1:state
   929 jump *label206 always
   930 label *label205
   931 set :processUnit.1:msg ", loading\n"
-    * set *tmp323 :processUnit.1:msg
   932 label *label206
   933 jump *label204 always
   934 label *label203
 
   963 jump *label213 equal *tmp337 false
   964 ucontrol approach .CORE_X .CORE_Y 6
   965 set :processUnit.1:state 2
-    * set *tmp338 :processUnit.1:state
   966 jump *label214 always
   967 label *label213
-    * set *tmp338 null
   968 label *label214
   969 jump *label210 always
   970 label *label209
 
  1113 op equal *tmp387 *tmp386 0
  1114 jump *label239 equal *tmp387 false
  1115 set :processUnit.2:state 2
-    * set *tmp388 :processUnit.2:state
  1116 jump *label240 always
  1117 label *label239
  1118 set :processUnit.2:msg ", initializing\n"
 
  1125 label *label241
  1126 set *tmp390 null
  1127 label *label242
-    * set *tmp388 *tmp390
  1128 label *label240
  1129 label *label238
  1130 jump *label236 always
 
  1140 jump *label247 equal *tmp396 false
  1141 ucontrol approach .DOME_X .DOME_Y 6
  1142 set :processUnit.2:state 3
-    * set *tmp397 :processUnit.2:state
  1143 jump *label248 always
  1144 label *label247
  1145 set :processUnit.2:msg ", loading\n"
-    * set *tmp397 :processUnit.2:msg
  1146 label *label248
  1147 jump *label246 always
  1148 label *label245
 
  1177 jump *label255 equal *tmp411 false
  1178 ucontrol approach .CORE_X .CORE_Y 6
  1179 set :processUnit.2:state 2
-    * set *tmp412 :processUnit.2:state
  1180 jump *label256 always
  1181 label *label255
-    * set *tmp412 null
  1182 label *label256
  1183 jump *label252 always
  1184 label *label251
 
  1293 op equal *tmp454 *tmp453 0
  1294 jump *label278 equal *tmp454 false
  1295 set :processUnit.3:state 2
-    * set *tmp455 :processUnit.3:state
  1296 jump *label279 always
  1297 label *label278
  1298 set :processUnit.3:msg ", initializing\n"
 
  1305 label *label280
  1306 set *tmp457 null
  1307 label *label281
-    * set *tmp455 *tmp457
  1308 label *label279
  1309 label *label277
  1310 jump *label275 always
 
  1320 jump *label286 equal *tmp463 false
  1321 ucontrol approach .DOME_X .DOME_Y 6
  1322 set :processUnit.3:state 3
-    * set *tmp464 :processUnit.3:state
  1323 jump *label287 always
  1324 label *label286
  1325 set :processUnit.3:msg ", loading\n"
-    * set *tmp464 :processUnit.3:msg
  1326 label *label287
  1327 jump *label285 always
  1328 label *label284
 
  1357 jump *label294 equal *tmp478 false
  1358 ucontrol approach .CORE_X .CORE_Y 6
  1359 set :processUnit.3:state 2
-    * set *tmp479 :processUnit.3:state
  1360 jump *label295 always
  1361 label *label294
-    * set *tmp479 null
  1362 label *label295
  1363 jump *label291 always
  1364 label *label290

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
   726 ucontrol within .CORE_X .CORE_Y 8 *tmp248
   727 jump *label160 equal *tmp248 false
   728 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp249 null
   729 jump *label161 always
   730 label *label160
-    * set *tmp249 null
   731 label *label161
   732 label *label159
   733 label *label157
 
   904 ucontrol within .CORE_X .CORE_Y 8 *tmp315
   905 jump *label199 equal *tmp315 false
   906 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp316 null
   907 jump *label200 always
   908 label *label199
-    * set *tmp316 null
   909 label *label200
   910 label *label198
   911 label *label196
 
  1116 ucontrol within .CORE_X .CORE_Y 8 *tmp389
  1117 jump *label241 equal *tmp389 false
  1118 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp390 null
  1119 jump *label242 always
  1120 label *label241
-    * set *tmp390 null
  1121 label *label242
  1122 label *label240
  1123 label *label238
 
  1294 ucontrol within .CORE_X .CORE_Y 8 *tmp456
  1295 jump *label280 equal *tmp456 false
  1296 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp457 null
  1297 jump *label281 always
  1298 label *label280
-    * set *tmp457 null
  1299 label *label281
  1300 label *label279
  1301 label *label277

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-52 instructions):
 
    40 set :areUnitsAvailable.0:occupied :areUnitsAvailable.0:needed
    41 set :areUnitsAvailable.0:free :areUnitsAvailable.0:occupied
    42 ubind :areUnitsAvailable.0:type
-    * set *tmp5 @unit
-    * set :areUnitsAvailable.0:firstUnit *tmp5
+   43 set :areUnitsAvailable.0:firstUnit @unit
    44 op notEqual *tmp6 :areUnitsAvailable.0:firstUnit null
    45 jump *label11 equal *tmp6 false
    46 # "Function: inline def needsFourUnits(in unit)"
 
    50 op len *tmp11 *tmp9 *tmp10
    51 op mul *tmp12 2 *tmp11
    52 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * op div *tmp14 *tmp12 *tmp13
-    * set :needsFourUnits.0:travel_time *tmp14
-    * op greaterThanEq *tmp15 :needsFourUnits.0:travel_time 47
-    * set *tmp8 *tmp15
+   53 op div :needsFourUnits.0:travel_time *tmp12 *tmp13
+   54 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    55 jump *label13 always
    56 set *tmp8 null
    57 label *label13
 
   150 set :areUnitsAvailable.1:occupied :areUnitsAvailable.1:needed
   151 set :areUnitsAvailable.1:free :areUnitsAvailable.1:occupied
   152 ubind :areUnitsAvailable.1:type
-    * set *tmp37 @unit
-    * set :areUnitsAvailable.1:firstUnit *tmp37
+  153 set :areUnitsAvailable.1:firstUnit @unit
   154 op notEqual *tmp38 :areUnitsAvailable.1:firstUnit null
   155 jump *label41 equal *tmp38 false
   156 # "Function: inline def needsFourUnits(in unit)"
 
   160 op len *tmp43 *tmp41 *tmp42
   161 op mul *tmp44 2 *tmp43
   162 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * op div *tmp46 *tmp44 *tmp45
-    * set :needsFourUnits.1:travel_time *tmp46
-    * op greaterThanEq *tmp47 :needsFourUnits.1:travel_time 47
-    * set *tmp40 *tmp47
+  163 op div :needsFourUnits.1:travel_time *tmp44 *tmp45
+  164 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   165 jump *label43 always
   166 set *tmp40 null
   167 label *label43
 
   256 set .UNIT_S1 .UNIT_P1
   257 set :rebindUnits.0:count 0
   258 ubind .TYPE
-    * set *tmp66 @unit
-    * set :rebindUnits.0:firstUnit *tmp66
+  259 set :rebindUnits.0:firstUnit @unit
   260 op equal *tmp67 :rebindUnits.0:firstUnit null
   261 jump *label60 equal *tmp67 false
   262 end
 
   272 set .UNIT_S2 .UNIT_P2
   273 set .UNIT_P2 .UNIT_S1
   274 set .UNIT_S1 .UNIT_P1
-    * set *tmp72 @unit
-    * set .UNIT_P1 *tmp72
+  275 set .UNIT_P1 @unit
   276 op notEqual *tmp73 .UNIT_S2 null
   277 jump *label67 equal *tmp73 false
   278 jump *label64 always
 
   313 label *label71
   314 label *label72
   315 ubind .TYPE
-    * set *tmp89 @unit
-    * set :rebindUnit.0:firstUnit *tmp89
+  316 set :rebindUnit.0:firstUnit @unit
   317 op notEqual *tmp90 :rebindUnit.0:firstUnit null
   318 jump *label75 equal *tmp90 false
   319 label *label77
 
   364 label *label84
   365 label *label85
   366 ubind .TYPE
-    * set *tmp109 @unit
-    * set :rebindUnit.1:firstUnit *tmp109
+  367 set :rebindUnit.1:firstUnit @unit
   368 op notEqual *tmp110 :rebindUnit.1:firstUnit null
   369 jump *label88 equal *tmp110 false
   370 label *label90
 
   406 jump *label96 always
   407 label *label95
   408 label *label96
-    * sensor *tmp125 .UNIT_S1 @itemCapacity
-    * set .UNIT_CAPACITY *tmp125
-    * sensor *tmp126 .UNIT_S1 @speed
-    * set .SPEED *tmp126
-    * op div *tmp127 .SPEED 10
-    * set .SPEED_TENTHS *tmp127
+  409 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
+  410 sensor .SPEED .UNIT_S1 @speed
+  411 op div .SPEED_TENTHS .SPEED 10
   412 op strictEqual *tmp128 .SPEED null
   413 jump *label97 equal *tmp128 false
   414 stop
 
   418 print "[gold]Locating core..."
   419 printflush message1
   420 label *label99
-    * ulocate building core false @copper *tmp131 *tmp132 *tmp133 *tmp130
-    * set .CORE *tmp130
+  421 ulocate building core false @copper 0 0 0 .CORE
   422 label *label100
   423 op equal *tmp134 .CORE null
   424 jump *label99 notEqual *tmp134 false
   425 label *label101
-    * sensor *tmp135 .CORE @x
-    * set .CORE_X *tmp135
-    * sensor *tmp136 .CORE @y
-    * set .CORE_Y *tmp136
-    * sensor *tmp137 .DOME @x
-    * set .DOME_X *tmp137
-    * sensor *tmp138 .DOME @y
-    * set .DOME_Y *tmp138
+  426 sensor .CORE_X .CORE @x
+  427 sensor .CORE_Y .CORE @y
+  428 sensor .DOME_X .DOME @x
+  429 sensor .DOME_Y .DOME @y
   430 # "Function: inline def needsFourUnits(in unit)"
   431 set :needsFourUnits.2:unit .UNIT_S1
   432 op sub *tmp140 .DOME_X .CORE_X
 
   434 op len *tmp142 *tmp140 *tmp141
   435 op mul *tmp143 2 *tmp142
   436 sensor *tmp144 :needsFourUnits.2:unit @speed
-    * op div *tmp145 *tmp143 *tmp144
-    * set :needsFourUnits.2:travel_time *tmp145
-    * op greaterThanEq *tmp146 :needsFourUnits.2:travel_time 47
-    * set *tmp139 *tmp146
+  437 op div :needsFourUnits.2:travel_time *tmp143 *tmp144
+  438 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   439 jump *label102 always
   440 set *tmp139 null
   441 label *label102
 
   462 label *label107
   463 label *label108
   464 ubind .TYPE
-    * set *tmp158 @unit
-    * set :rebindUnit.2:firstUnit *tmp158
+  465 set :rebindUnit.2:firstUnit @unit
   466 op notEqual *tmp159 :rebindUnit.2:firstUnit null
   467 jump *label111 equal *tmp159 false
   468 label *label113
 
   513 label *label120
   514 label *label121
   515 ubind .TYPE
-    * set *tmp178 @unit
-    * set :rebindUnit.3:firstUnit *tmp178
+  516 set :rebindUnit.3:firstUnit @unit
   517 op notEqual *tmp179 :rebindUnit.3:firstUnit null
   518 jump *label124 equal *tmp179 false
   519 label *label126
 
   584 sensor *tmp201 .UNIT_S1 @totalItems
   585 sensor *tmp202 .UNIT_S2 @totalItems
   586 op lessThan *tmp203 *tmp201 *tmp202
-    * op or *tmp204 *tmp200 *tmp203
-    * set .SUPPLY_S_FIRST *tmp204
+  587 op or .SUPPLY_S_FIRST *tmp200 *tmp203
   588 op equal *tmp205 .FOUR_UNITS false
   589 sensor *tmp206 .UNIT_P1 @totalItems
   590 sensor *tmp207 .UNIT_P2 @totalItems
   591 op lessThan *tmp208 *tmp206 *tmp207
-    * op or *tmp209 *tmp205 *tmp208
-    * set .SUPPLY_P_FIRST *tmp209
-    * op add *tmp210 @time 5000
-    * set :unitCheck *tmp210
+  592 op or .SUPPLY_P_FIRST *tmp205 *tmp208
+  593 op add :unitCheck @time 5000
   594 label *label135
   595 sensor *tmp211 switch1 @enabled
   596 jump *label137 equal *tmp211 false
-    * set *tmp212 @time
-    * set :start *tmp212
+  597 set :start @time
   598 print " === [gold]Supplying Overdrive Dome[] === "
   599 print "\n"
   600 print "\n"
 
   607 set :printDomeStatus.0:item @silicon
   608 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   609 print :printDomeStatus.0:text
-    * sensor *tmp214 .DOME :printDomeStatus.0:item
-    * set :printDomeStatus.0:level *tmp214
+  610 sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
   611 op greaterThan *tmp215 :printDomeStatus.0:level 3
   612 jump *label139 equal *tmp215 false
   613 print "  dome:  [green]"
 
   648 label *label143
   649 label *label144
   650 ubind .TYPE
-    * set *tmp227 @unit
-    * set :rebindUnit.4:firstUnit *tmp227
+  651 set :rebindUnit.4:firstUnit @unit
   652 op notEqual *tmp228 :rebindUnit.4:firstUnit null
   653 jump *label147 equal *tmp228 false
   654 label *label149
 
   673 end
   674 label *label142
   675 set :processUnit.0:msg ""
-    * sensor *tmp237 @unit @flag
-    * set :processUnit.0:state *tmp237
+  676 sensor :processUnit.0:state @unit @flag
   677 set :processUnit.0:distance -1
   678 set :processUnit.0:color "gold"
   679 op lessThan *tmp238 :processUnit.0:state 2
 
   729 op sub *tmp260 .CORE_Y *tmp259
   730 op len *tmp261 *tmp258 *tmp260
   731 op idiv *tmp262 *tmp261 .SPEED_TENTHS
-    * op div *tmp263 *tmp262 10
-    * set :processUnit.0:distance *tmp263
+  732 op div :processUnit.0:distance *tmp262 10
   733 label *label165
   734 jump *label163 always
   735 label *label162
 
   764 op sub *tmp275 .DOME_Y *tmp274
   765 op len *tmp276 *tmp273 *tmp275
   766 op idiv *tmp277 *tmp276 .SPEED_TENTHS
-    * op div *tmp278 *tmp277 10
-    * set :processUnit.0:distance *tmp278
+  767 op div :processUnit.0:distance *tmp277 10
   768 label *label171
   769 jump *label169 always
   770 label *label168
 
   822 label *label182
   823 label *label183
   824 ubind .TYPE
-    * set *tmp294 @unit
-    * set :rebindUnit.5:firstUnit *tmp294
+  825 set :rebindUnit.5:firstUnit @unit
   826 op notEqual *tmp295 :rebindUnit.5:firstUnit null
   827 jump *label186 equal *tmp295 false
   828 label *label188
 
   847 end
   848 label *label181
   849 set :processUnit.1:msg ""
-    * sensor *tmp304 @unit @flag
-    * set :processUnit.1:state *tmp304
+  850 sensor :processUnit.1:state @unit @flag
   851 set :processUnit.1:distance -1
   852 set :processUnit.1:color "gold"
   853 op lessThan *tmp305 :processUnit.1:state 2
 
   903 op sub *tmp327 .CORE_Y *tmp326
   904 op len *tmp328 *tmp325 *tmp327
   905 op idiv *tmp329 *tmp328 .SPEED_TENTHS
-    * op div *tmp330 *tmp329 10
-    * set :processUnit.1:distance *tmp330
+  906 op div :processUnit.1:distance *tmp329 10
   907 label *label204
   908 jump *label202 always
   909 label *label201
 
   938 op sub *tmp342 .DOME_Y *tmp341
   939 op len *tmp343 *tmp340 *tmp342
   940 op idiv *tmp344 *tmp343 .SPEED_TENTHS
-    * op div *tmp345 *tmp344 10
-    * set :processUnit.1:distance *tmp345
+  941 op div :processUnit.1:distance *tmp344 10
   942 label *label210
   943 jump *label208 always
   944 label *label207
 
   972 set .UNIT_S2 *tmp284
   973 jump *label217 equal .SUPPLY_S_FIRST false
   974 sensor *tmp350 .UNIT_S1 @totalItems
-    * op greaterThan *tmp351 *tmp350 0
-    * set *tmp349 *tmp351
+  975 op greaterThan *tmp349 *tmp350 0
   976 jump *label218 always
   977 label *label217
   978 sensor *tmp352 .UNIT_S2 @totalItems
-    * op equal *tmp353 *tmp352 0
-    * set *tmp349 *tmp353
+  979 op equal *tmp349 *tmp352 0
   980 label *label218
   981 set .SUPPLY_S_FIRST *tmp349
   982 jump *label179 always
 
   986 set :printDomeStatus.1:item @phase-fabric
   987 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   988 print :printDomeStatus.1:text
-    * sensor *tmp355 .DOME :printDomeStatus.1:item
-    * set :printDomeStatus.1:level *tmp355
+  989 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
   990 op greaterThan *tmp356 :printDomeStatus.1:level 3
   991 jump *label220 equal *tmp356 false
   992 print "  dome:  [green]"
 
  1027 label *label224
  1028 label *label225
  1029 ubind .TYPE
-    * set *tmp368 @unit
-    * set :rebindUnit.6:firstUnit *tmp368
+ 1030 set :rebindUnit.6:firstUnit @unit
  1031 op notEqual *tmp369 :rebindUnit.6:firstUnit null
  1032 jump *label228 equal *tmp369 false
  1033 label *label230
 
  1052 end
  1053 label *label223
  1054 set :processUnit.2:msg ""
-    * sensor *tmp378 @unit @flag
-    * set :processUnit.2:state *tmp378
+ 1055 sensor :processUnit.2:state @unit @flag
  1056 set :processUnit.2:distance -1
  1057 set :processUnit.2:color "gold"
  1058 op lessThan *tmp379 :processUnit.2:state 2
 
  1108 op sub *tmp401 .CORE_Y *tmp400
  1109 op len *tmp402 *tmp399 *tmp401
  1110 op idiv *tmp403 *tmp402 .SPEED_TENTHS
-    * op div *tmp404 *tmp403 10
-    * set :processUnit.2:distance *tmp404
+ 1111 op div :processUnit.2:distance *tmp403 10
  1112 label *label246
  1113 jump *label244 always
  1114 label *label243
 
  1143 op sub *tmp416 .DOME_Y *tmp415
  1144 op len *tmp417 *tmp414 *tmp416
  1145 op idiv *tmp418 *tmp417 .SPEED_TENTHS
-    * op div *tmp419 *tmp418 10
-    * set :processUnit.2:distance *tmp419
+ 1146 op div :processUnit.2:distance *tmp418 10
  1147 label *label252
  1148 jump *label250 always
  1149 label *label249
 
  1201 label *label263
  1202 label *label264
  1203 ubind .TYPE
-    * set *tmp435 @unit
-    * set :rebindUnit.7:firstUnit *tmp435
+ 1204 set :rebindUnit.7:firstUnit @unit
  1205 op notEqual *tmp436 :rebindUnit.7:firstUnit null
  1206 jump *label267 equal *tmp436 false
  1207 label *label269
 
  1226 end
  1227 label *label262
  1228 set :processUnit.3:msg ""
-    * sensor *tmp445 @unit @flag
-    * set :processUnit.3:state *tmp445
+ 1229 sensor :processUnit.3:state @unit @flag
  1230 set :processUnit.3:distance -1
  1231 set :processUnit.3:color "gold"
  1232 op lessThan *tmp446 :processUnit.3:state 2
 
  1282 op sub *tmp468 .CORE_Y *tmp467
  1283 op len *tmp469 *tmp466 *tmp468
  1284 op idiv *tmp470 *tmp469 .SPEED_TENTHS
-    * op div *tmp471 *tmp470 10
-    * set :processUnit.3:distance *tmp471
+ 1285 op div :processUnit.3:distance *tmp470 10
  1286 label *label285
  1287 jump *label283 always
  1288 label *label282
 
  1317 op sub *tmp483 .DOME_Y *tmp482
  1318 op len *tmp484 *tmp481 *tmp483
  1319 op idiv *tmp485 *tmp484 .SPEED_TENTHS
-    * op div *tmp486 *tmp485 10
-    * set :processUnit.3:distance *tmp486
+ 1320 op div :processUnit.3:distance *tmp485 10
  1321 label *label291
  1322 jump *label289 always
  1323 label *label288
 
  1351 set .UNIT_P2 *tmp425
  1352 jump *label298 equal .SUPPLY_P_FIRST false
  1353 sensor *tmp491 .UNIT_P1 @totalItems
-    * op greaterThan *tmp492 *tmp491 0
-    * set *tmp490 *tmp492
+ 1354 op greaterThan *tmp490 *tmp491 0
  1355 jump *label299 always
  1356 label *label298
  1357 sensor *tmp493 .UNIT_P2 @totalItems
-    * op equal *tmp494 *tmp493 0
-    * set *tmp490 *tmp494
+ 1358 op equal *tmp490 *tmp493 0
  1359 label *label299
  1360 set .SUPPLY_P_FIRST *tmp490
  1361 jump *label260 always
 
  1380 set :areUnitsAvailable.2:occupied :areUnitsAvailable.2:needed
  1381 set :areUnitsAvailable.2:free :areUnitsAvailable.2:occupied
  1382 ubind :areUnitsAvailable.2:type
-    * set *tmp502 @unit
-    * set :areUnitsAvailable.2:firstUnit *tmp502
+ 1383 set :areUnitsAvailable.2:firstUnit @unit
  1384 op notEqual *tmp503 :areUnitsAvailable.2:firstUnit null
  1385 jump *label303 equal *tmp503 false
  1386 # "Function: inline def needsFourUnits(in unit)"
 
  1390 op len *tmp508 *tmp506 *tmp507
  1391 op mul *tmp509 2 *tmp508
  1392 sensor *tmp510 :needsFourUnits.3:unit @speed
-    * op div *tmp511 *tmp509 *tmp510
-    * set :needsFourUnits.3:travel_time *tmp511
-    * op greaterThanEq *tmp512 :needsFourUnits.3:travel_time 47
-    * set *tmp505 *tmp512
+ 1393 op div :needsFourUnits.3:travel_time *tmp509 *tmp510
+ 1394 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1395 jump *label305 always
  1396 set *tmp505 null
  1397 label *label305
 
  1460 jump *label320 always
  1461 label *label319
  1462 label *label320
-    * op add *tmp530 @time 5000
-    * set :unitCheck *tmp530
+ 1463 op add :unitCheck @time 5000
  1464 jump *label301 always
  1465 label *label300
  1466 label *label301

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    27 label *label5
    28 # "Function: inline def chooseUnitType()"
    29 label *label7
-    * jump *label9 equal true false
    30 printflush null
    31 print "[gold]Looking for suitable unit type:[]"
    32 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-70 instructions):
 
     7 set .CORE_X .CORE_Y
     8 set .DOME dome1
     9 label *label0
-    * op equal *tmp0 .DOME null
-    * jump *label2 equal *tmp0 false
+   10 jump *label2 notEqual .DOME null
    11 print "[gold]Waiting for an overdrive dome to be connected..."
    12 printflush message1
    13 set .DOME dome1
 
    16 label *label2
    17 label *label3
    18 sensor *tmp1 switch1 @enabled
-    * op equal *tmp2 *tmp1 false
-    * jump *label5 equal *tmp2 false
+   19 jump *label5 notEqual *tmp1 false
    20 print "[coral]Activate switch to begin supplying overdrive dome..."
    21 print "\n"
    22 printflush message1
 
    38 set :areUnitsAvailable.0:free :areUnitsAvailable.0:occupied
    39 ubind :areUnitsAvailable.0:type
    40 set :areUnitsAvailable.0:firstUnit @unit
-    * op notEqual *tmp6 :areUnitsAvailable.0:firstUnit null
-    * jump *label11 equal *tmp6 false
+   41 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    42 # "Function: inline def needsFourUnits(in unit)"
    43 set :needsFourUnits.0:unit @unit
    44 op sub *tmp9 .DOME_X .CORE_X
 
    66 op or *tmp21 *tmp18 *tmp20
    67 jump *label19 equal *tmp21 false
    68 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * op greaterThanEq *tmp23 :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
-    * jump *label21 equal *tmp23 false
+   69 jump *label21 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
    70 set *tmp4 true
    71 jump *label10 always
    72 jump *label22 always
 
    95 print ","
    96 print " free: "
    97 print :areUnitsAvailable.0:free
-    * op greaterThan *tmp30 :areUnitsAvailable.0:needed 0
-    * jump *label25 equal *tmp30 false
+   98 jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
    99 print ", needed: "
   100 print :areUnitsAvailable.0:needed
   101 jump *label26 always
 
   133 multilabel *label36
   134 jump *label37 always
   135 label *label29
-    * op notEqual *tmp34 :chooseUnitType.0:type UNIT_TYPE
-    * jump *label38 equal *tmp34 false
+  136 jump *label38 equal :chooseUnitType.0:type UNIT_TYPE
   137 remark "chooseUnitType: "
   138 remark :chooseUnitType.0:type
   139 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   144 set :areUnitsAvailable.1:free :areUnitsAvailable.1:occupied
   145 ubind :areUnitsAvailable.1:type
   146 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp38 :areUnitsAvailable.1:firstUnit null
-    * jump *label41 equal *tmp38 false
+  147 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   148 # "Function: inline def needsFourUnits(in unit)"
   149 set :needsFourUnits.1:unit @unit
   150 op sub *tmp41 .DOME_X .CORE_X
 
   172 op or *tmp53 *tmp50 *tmp52
   173 jump *label49 equal *tmp53 false
   174 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * op greaterThanEq *tmp55 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
-    * jump *label51 equal *tmp55 false
+  175 jump *label51 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   176 set *tmp36 true
   177 jump *label40 always
   178 jump *label52 always
 
   201 print ","
   202 print " free: "
   203 print :areUnitsAvailable.1:free
-    * op greaterThan *tmp62 :areUnitsAvailable.1:needed 0
-    * jump *label55 equal *tmp62 false
+  204 jump *label55 lessThanEq :areUnitsAvailable.1:needed 0
   205 print ", needed: "
   206 print :areUnitsAvailable.1:needed
   207 jump *label56 always
 
   247 set :rebindUnits.0:count 0
   248 ubind .TYPE
   249 set :rebindUnits.0:firstUnit @unit
-    * op equal *tmp67 :rebindUnits.0:firstUnit null
-    * jump *label60 equal *tmp67 false
+  250 jump *label60 notEqual :rebindUnits.0:firstUnit null
   251 end
   252 jump *label61 always
   253 label *label60
   254 label *label61
   255 label *label62
   256 sensor *tmp69 @unit @controller
-    * op equal *tmp70 *tmp69 @this
-    * jump *label65 equal *tmp70 false
+  257 jump *label65 notEqual *tmp69 @this
   258 op add :rebindUnits.0:count :rebindUnits.0:count 1
   259 ucontrol flag 1
   260 set .UNIT_S2 .UNIT_P2
   261 set .UNIT_P2 .UNIT_S1
   262 set .UNIT_S1 .UNIT_P1
   263 set .UNIT_P1 @unit
-    * op notEqual *tmp73 .UNIT_S2 null
-    * jump *label67 equal *tmp73 false
+  264 jump *label67 equal .UNIT_S2 null
   265 jump *label64 always
   266 jump *label68 always
   267 label *label67
 
   283 set :acquireUnit.0:currentUnit .UNIT_S1
   284 # "Function: inline def rebindUnit(in currentUnit)"
   285 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * op notEqual *tmp81 :rebindUnit.0:currentUnit null
-    * jump *label71 equal *tmp81 false
+  286 jump *label71 equal :rebindUnit.0:currentUnit null
   287 ubind :rebindUnit.0:currentUnit
   288 sensor *tmp83 @unit @dead
   289 op strictEqual *tmp84 *tmp83 0
 
   300 label *label72
   301 ubind .TYPE
   302 set :rebindUnit.0:firstUnit @unit
-    * op notEqual *tmp90 :rebindUnit.0:firstUnit null
-    * jump *label75 equal *tmp90 false
+  303 jump *label75 equal :rebindUnit.0:firstUnit null
   304 label *label77
   305 sensor *tmp92 @unit @controlled
-    * op equal *tmp93 *tmp92 0
-    * jump *label80 equal *tmp93 false
+  306 jump *label80 notEqual *tmp92 0
   307 jump *label70 always
   308 jump *label81 always
   309 label *label80
 
   331 set :acquireUnit.1:currentUnit .UNIT_P1
   332 # "Function: inline def rebindUnit(in currentUnit)"
   333 set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * op notEqual *tmp101 :rebindUnit.1:currentUnit null
-    * jump *label84 equal *tmp101 false
+  334 jump *label84 equal :rebindUnit.1:currentUnit null
   335 ubind :rebindUnit.1:currentUnit
   336 sensor *tmp103 @unit @dead
   337 op strictEqual *tmp104 *tmp103 0
 
   348 label *label85
   349 ubind .TYPE
   350 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp110 :rebindUnit.1:firstUnit null
-    * jump *label88 equal *tmp110 false
+  351 jump *label88 equal :rebindUnit.1:firstUnit null
   352 label *label90
   353 sensor *tmp112 @unit @controlled
-    * op equal *tmp113 *tmp112 0
-    * jump *label93 equal *tmp113 false
+  354 jump *label93 notEqual *tmp112 0
   355 jump *label83 always
   356 jump *label94 always
   357 label *label93
 
   401 label *label99
   402 ulocate building core false @copper 0 0 0 .CORE
   403 label *label100
-    * op equal *tmp134 .CORE null
-    * jump *label99 notEqual *tmp134 false
+  404 jump *label99 equal .CORE null
   405 label *label101
   406 sensor .CORE_X .CORE @x
   407 sensor .CORE_Y .CORE @y
 
   425 set :acquireUnit.2:currentUnit .UNIT_S2
   426 # "Function: inline def rebindUnit(in currentUnit)"
   427 set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * op notEqual *tmp150 :rebindUnit.2:currentUnit null
-    * jump *label107 equal *tmp150 false
+  428 jump *label107 equal :rebindUnit.2:currentUnit null
   429 ubind :rebindUnit.2:currentUnit
   430 sensor *tmp152 @unit @dead
   431 op strictEqual *tmp153 *tmp152 0
 
   442 label *label108
   443 ubind .TYPE
   444 set :rebindUnit.2:firstUnit @unit
-    * op notEqual *tmp159 :rebindUnit.2:firstUnit null
-    * jump *label111 equal *tmp159 false
+  445 jump *label111 equal :rebindUnit.2:firstUnit null
   446 label *label113
   447 sensor *tmp161 @unit @controlled
-    * op equal *tmp162 *tmp161 0
-    * jump *label116 equal *tmp162 false
+  448 jump *label116 notEqual *tmp161 0
   449 jump *label106 always
   450 jump *label117 always
   451 label *label116
 
   473 set :acquireUnit.3:currentUnit .UNIT_P2
   474 # "Function: inline def rebindUnit(in currentUnit)"
   475 set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * op notEqual *tmp170 :rebindUnit.3:currentUnit null
-    * jump *label120 equal *tmp170 false
+  476 jump *label120 equal :rebindUnit.3:currentUnit null
   477 ubind :rebindUnit.3:currentUnit
   478 sensor *tmp172 @unit @dead
   479 op strictEqual *tmp173 *tmp172 0
 
   490 label *label121
   491 ubind .TYPE
   492 set :rebindUnit.3:firstUnit @unit
-    * op notEqual *tmp179 :rebindUnit.3:firstUnit null
-    * jump *label124 equal *tmp179 false
+  493 jump *label124 equal :rebindUnit.3:firstUnit null
   494 label *label126
   495 sensor *tmp181 @unit @controlled
-    * op equal *tmp182 *tmp181 0
-    * jump *label129 equal *tmp182 false
+  496 jump *label129 notEqual *tmp181 0
   497 jump *label119 always
   498 jump *label130 always
   499 label *label129
 
   582 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   583 print :printDomeStatus.0:text
   584 sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
-    * op greaterThan *tmp215 :printDomeStatus.0:level 3
-    * jump *label139 equal *tmp215 false
+  585 jump *label139 lessThanEq :printDomeStatus.0:level 3
   586 print "  dome:  [green]"
   587 print :printDomeStatus.0:level
   588 print "["
 
   604 set :processUnit.0:supply .SUPPLY_S_FIRST
   605 # "Function: inline def rebindUnit(in currentUnit)"
   606 set :rebindUnit.4:currentUnit :processUnit.0:unit
-    * op notEqual *tmp219 :rebindUnit.4:currentUnit null
-    * jump *label143 equal *tmp219 false
+  607 jump *label143 equal :rebindUnit.4:currentUnit null
   608 ubind :rebindUnit.4:currentUnit
   609 sensor *tmp221 @unit @dead
   610 op strictEqual *tmp222 *tmp221 0
 
   621 label *label144
   622 ubind .TYPE
   623 set :rebindUnit.4:firstUnit @unit
-    * op notEqual *tmp228 :rebindUnit.4:firstUnit null
-    * jump *label147 equal *tmp228 false
+  624 jump *label147 equal :rebindUnit.4:firstUnit null
   625 label *label149
   626 sensor *tmp230 @unit @controlled
-    * op equal *tmp231 *tmp230 0
-    * jump *label152 equal *tmp231 false
+  627 jump *label152 notEqual *tmp230 0
   628 jump *label142 always
   629 jump *label153 always
   630 label *label152
 
   651 op or *tmp240 *tmp238 *tmp239
   652 jump *label154 equal *tmp240 false
   653 sensor *tmp242 @unit @firstItem
-    * op equal *tmp243 *tmp242 :processUnit.0:item
-    * jump *label156 equal *tmp243 false
+  654 jump *label156 notEqual *tmp242 :processUnit.0:item
   655 set :processUnit.0:state 3
   656 jump *label157 always
   657 label *label156
   658 sensor *tmp245 @unit @totalItems
-    * op equal *tmp246 *tmp245 0
-    * jump *label158 equal *tmp246 false
+  659 jump *label158 notEqual *tmp245 0
   660 set :processUnit.0:state 2
   661 jump *label159 always
   662 label *label158
 
   673 jump *label155 always
   674 label *label154
   675 label *label155
-    * op equal *tmp250 :processUnit.0:state 2
-    * jump *label162 equal *tmp250 false
+  676 jump *label162 notEqual :processUnit.0:state 2
   677 ucontrol within .CORE_X .CORE_Y 8 *tmp252
   678 jump *label164 equal *tmp252 false
   679 ucontrol itemTake .CORE :processUnit.0:item .UNIT_CAPACITY
   680 sensor *tmp254 @unit @totalItems
-    * op greaterThanEq *tmp255 *tmp254 .UNIT_CAPACITY
-    * jump *label166 equal *tmp255 false
+  681 jump *label166 lessThan *tmp254 .UNIT_CAPACITY
   682 ucontrol approach .DOME_X .DOME_Y 6
   683 set :processUnit.0:state 3
   684 jump *label167 always
 
   700 jump *label163 always
   701 label *label162
   702 label *label163
-    * op equal *tmp264 :processUnit.0:state 3
-    * jump *label168 equal *tmp264 false
+  703 jump *label168 notEqual :processUnit.0:state 3
   704 ucontrol within .DOME_X .DOME_Y 8 *tmp266
   705 jump *label170 equal *tmp266 false
   706 jump *label172 equal :processUnit.0:supply false
 
   712 set :processUnit.0:msg ", waiting\n"
   713 label *label173
   714 sensor *tmp269 @unit @totalItems
-    * op lessThanEq *tmp270 *tmp269 0
-    * jump *label174 equal *tmp270 false
+  715 jump *label174 greaterThan *tmp269 0
   716 ucontrol approach .CORE_X .CORE_Y 6
   717 set :processUnit.0:state 2
   718 jump *label175 always
 
   744 print *tmp279
   745 print "["
   746 print "]"
-    * op greaterThanEq *tmp280 :processUnit.0:distance 0
-    * jump *label176 equal *tmp280 false
+  747 jump *label176 lessThan :processUnit.0:distance 0
   748 print :processUnit.0:msg
   749 print :processUnit.0:distance
   750 print "["
 
   768 set :processUnit.1:supply *tmp283
   769 # "Function: inline def rebindUnit(in currentUnit)"
   770 set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * op notEqual *tmp286 :rebindUnit.5:currentUnit null
-    * jump *label182 equal *tmp286 false
+  771 jump *label182 equal :rebindUnit.5:currentUnit null
   772 ubind :rebindUnit.5:currentUnit
   773 sensor *tmp288 @unit @dead
   774 op strictEqual *tmp289 *tmp288 0
 
   785 label *label183
   786 ubind .TYPE
   787 set :rebindUnit.5:firstUnit @unit
-    * op notEqual *tmp295 :rebindUnit.5:firstUnit null
-    * jump *label186 equal *tmp295 false
+  788 jump *label186 equal :rebindUnit.5:firstUnit null
   789 label *label188
   790 sensor *tmp297 @unit @controlled
-    * op equal *tmp298 *tmp297 0
-    * jump *label191 equal *tmp298 false
+  791 jump *label191 notEqual *tmp297 0
   792 jump *label181 always
   793 jump *label192 always
   794 label *label191
 
   815 op or *tmp307 *tmp305 *tmp306
   816 jump *label193 equal *tmp307 false
   817 sensor *tmp309 @unit @firstItem
-    * op equal *tmp310 *tmp309 :processUnit.1:item
-    * jump *label195 equal *tmp310 false
+  818 jump *label195 notEqual *tmp309 :processUnit.1:item
   819 set :processUnit.1:state 3
   820 jump *label196 always
   821 label *label195
   822 sensor *tmp312 @unit @totalItems
-    * op equal *tmp313 *tmp312 0
-    * jump *label197 equal *tmp313 false
+  823 jump *label197 notEqual *tmp312 0
   824 set :processUnit.1:state 2
   825 jump *label198 always
   826 label *label197
 
   837 jump *label194 always
   838 label *label193
   839 label *label194
-    * op equal *tmp317 :processUnit.1:state 2
-    * jump *label201 equal *tmp317 false
+  840 jump *label201 notEqual :processUnit.1:state 2
   841 ucontrol within .CORE_X .CORE_Y 8 *tmp319
   842 jump *label203 equal *tmp319 false
   843 ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
   844 sensor *tmp321 @unit @totalItems
-    * op greaterThanEq *tmp322 *tmp321 .UNIT_CAPACITY
-    * jump *label205 equal *tmp322 false
+  845 jump *label205 lessThan *tmp321 .UNIT_CAPACITY
   846 ucontrol approach .DOME_X .DOME_Y 6
   847 set :processUnit.1:state 3
   848 jump *label206 always
 
   864 jump *label202 always
   865 label *label201
   866 label *label202
-    * op equal *tmp331 :processUnit.1:state 3
-    * jump *label207 equal *tmp331 false
+  867 jump *label207 notEqual :processUnit.1:state 3
   868 ucontrol within .DOME_X .DOME_Y 8 *tmp333
   869 jump *label209 equal *tmp333 false
   870 jump *label211 equal :processUnit.1:supply false
 
   876 set :processUnit.1:msg ", waiting\n"
   877 label *label212
   878 sensor *tmp336 @unit @totalItems
-    * op lessThanEq *tmp337 *tmp336 0
-    * jump *label213 equal *tmp337 false
+  879 jump *label213 greaterThan *tmp336 0
   880 ucontrol approach .CORE_X .CORE_Y 6
   881 set :processUnit.1:state 2
   882 jump *label214 always
 
   908 print *tmp346
   909 print "["
   910 print "]"
-    * op greaterThanEq *tmp347 :processUnit.1:distance 0
-    * jump *label215 equal *tmp347 false
+  911 jump *label215 lessThan :processUnit.1:distance 0
   912 print :processUnit.1:msg
   913 print :processUnit.1:distance
   914 print "["
 
   940 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   941 print :printDomeStatus.1:text
   942 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
-    * op greaterThan *tmp356 :printDomeStatus.1:level 3
-    * jump *label220 equal *tmp356 false
+  943 jump *label220 lessThanEq :printDomeStatus.1:level 3
   944 print "  dome:  [green]"
   945 print :printDomeStatus.1:level
   946 print "["
 
   962 set :processUnit.2:supply .SUPPLY_P_FIRST
   963 # "Function: inline def rebindUnit(in currentUnit)"
   964 set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * op notEqual *tmp360 :rebindUnit.6:currentUnit null
-    * jump *label224 equal *tmp360 false
+  965 jump *label224 equal :rebindUnit.6:currentUnit null
   966 ubind :rebindUnit.6:currentUnit
   967 sensor *tmp362 @unit @dead
   968 op strictEqual *tmp363 *tmp362 0
 
   979 label *label225
   980 ubind .TYPE
   981 set :rebindUnit.6:firstUnit @unit
-    * op notEqual *tmp369 :rebindUnit.6:firstUnit null
-    * jump *label228 equal *tmp369 false
+  982 jump *label228 equal :rebindUnit.6:firstUnit null
   983 label *label230
   984 sensor *tmp371 @unit @controlled
-    * op equal *tmp372 *tmp371 0
-    * jump *label233 equal *tmp372 false
+  985 jump *label233 notEqual *tmp371 0
   986 jump *label223 always
   987 jump *label234 always
   988 label *label233
 
  1009 op or *tmp381 *tmp379 *tmp380
  1010 jump *label235 equal *tmp381 false
  1011 sensor *tmp383 @unit @firstItem
-    * op equal *tmp384 *tmp383 :processUnit.2:item
-    * jump *label237 equal *tmp384 false
+ 1012 jump *label237 notEqual *tmp383 :processUnit.2:item
  1013 set :processUnit.2:state 3
  1014 jump *label238 always
  1015 label *label237
  1016 sensor *tmp386 @unit @totalItems
-    * op equal *tmp387 *tmp386 0
-    * jump *label239 equal *tmp387 false
+ 1017 jump *label239 notEqual *tmp386 0
  1018 set :processUnit.2:state 2
  1019 jump *label240 always
  1020 label *label239
 
  1031 jump *label236 always
  1032 label *label235
  1033 label *label236
-    * op equal *tmp391 :processUnit.2:state 2
-    * jump *label243 equal *tmp391 false
+ 1034 jump *label243 notEqual :processUnit.2:state 2
  1035 ucontrol within .CORE_X .CORE_Y 8 *tmp393
  1036 jump *label245 equal *tmp393 false
  1037 ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
  1038 sensor *tmp395 @unit @totalItems
-    * op greaterThanEq *tmp396 *tmp395 .UNIT_CAPACITY
-    * jump *label247 equal *tmp396 false
+ 1039 jump *label247 lessThan *tmp395 .UNIT_CAPACITY
  1040 ucontrol approach .DOME_X .DOME_Y 6
  1041 set :processUnit.2:state 3
  1042 jump *label248 always
 
  1058 jump *label244 always
  1059 label *label243
  1060 label *label244
-    * op equal *tmp405 :processUnit.2:state 3
-    * jump *label249 equal *tmp405 false
+ 1061 jump *label249 notEqual :processUnit.2:state 3
  1062 ucontrol within .DOME_X .DOME_Y 8 *tmp407
  1063 jump *label251 equal *tmp407 false
  1064 jump *label253 equal :processUnit.2:supply false
 
  1070 set :processUnit.2:msg ", waiting\n"
  1071 label *label254
  1072 sensor *tmp410 @unit @totalItems
-    * op lessThanEq *tmp411 *tmp410 0
-    * jump *label255 equal *tmp411 false
+ 1073 jump *label255 greaterThan *tmp410 0
  1074 ucontrol approach .CORE_X .CORE_Y 6
  1075 set :processUnit.2:state 2
  1076 jump *label256 always
 
  1102 print *tmp420
  1103 print "["
  1104 print "]"
-    * op greaterThanEq *tmp421 :processUnit.2:distance 0
-    * jump *label257 equal *tmp421 false
+ 1105 jump *label257 lessThan :processUnit.2:distance 0
  1106 print :processUnit.2:msg
  1107 print :processUnit.2:distance
  1108 print "["
 
  1126 set :processUnit.3:supply *tmp424
  1127 # "Function: inline def rebindUnit(in currentUnit)"
  1128 set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * op notEqual *tmp427 :rebindUnit.7:currentUnit null
-    * jump *label263 equal *tmp427 false
+ 1129 jump *label263 equal :rebindUnit.7:currentUnit null
  1130 ubind :rebindUnit.7:currentUnit
  1131 sensor *tmp429 @unit @dead
  1132 op strictEqual *tmp430 *tmp429 0
 
  1143 label *label264
  1144 ubind .TYPE
  1145 set :rebindUnit.7:firstUnit @unit
-    * op notEqual *tmp436 :rebindUnit.7:firstUnit null
-    * jump *label267 equal *tmp436 false
+ 1146 jump *label267 equal :rebindUnit.7:firstUnit null
  1147 label *label269
  1148 sensor *tmp438 @unit @controlled
-    * op equal *tmp439 *tmp438 0
-    * jump *label272 equal *tmp439 false
+ 1149 jump *label272 notEqual *tmp438 0
  1150 jump *label262 always
  1151 jump *label273 always
  1152 label *label272
 
  1173 op or *tmp448 *tmp446 *tmp447
  1174 jump *label274 equal *tmp448 false
  1175 sensor *tmp450 @unit @firstItem
-    * op equal *tmp451 *tmp450 :processUnit.3:item
-    * jump *label276 equal *tmp451 false
+ 1176 jump *label276 notEqual *tmp450 :processUnit.3:item
  1177 set :processUnit.3:state 3
  1178 jump *label277 always
  1179 label *label276
  1180 sensor *tmp453 @unit @totalItems
-    * op equal *tmp454 *tmp453 0
-    * jump *label278 equal *tmp454 false
+ 1181 jump *label278 notEqual *tmp453 0
  1182 set :processUnit.3:state 2
  1183 jump *label279 always
  1184 label *label278
 
  1195 jump *label275 always
  1196 label *label274
  1197 label *label275
-    * op equal *tmp458 :processUnit.3:state 2
-    * jump *label282 equal *tmp458 false
+ 1198 jump *label282 notEqual :processUnit.3:state 2
  1199 ucontrol within .CORE_X .CORE_Y 8 *tmp460
  1200 jump *label284 equal *tmp460 false
  1201 ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
  1202 sensor *tmp462 @unit @totalItems
-    * op greaterThanEq *tmp463 *tmp462 .UNIT_CAPACITY
-    * jump *label286 equal *tmp463 false
+ 1203 jump *label286 lessThan *tmp462 .UNIT_CAPACITY
  1204 ucontrol approach .DOME_X .DOME_Y 6
  1205 set :processUnit.3:state 3
  1206 jump *label287 always
 
  1222 jump *label283 always
  1223 label *label282
  1224 label *label283
-    * op equal *tmp472 :processUnit.3:state 3
-    * jump *label288 equal *tmp472 false
+ 1225 jump *label288 notEqual :processUnit.3:state 3
  1226 ucontrol within .DOME_X .DOME_Y 8 *tmp474
  1227 jump *label290 equal *tmp474 false
  1228 jump *label292 equal :processUnit.3:supply false
 
  1234 set :processUnit.3:msg ", waiting\n"
  1235 label *label293
  1236 sensor *tmp477 @unit @totalItems
-    * op lessThanEq *tmp478 *tmp477 0
-    * jump *label294 equal *tmp478 false
+ 1237 jump *label294 greaterThan *tmp477 0
  1238 ucontrol approach .CORE_X .CORE_Y 6
  1239 set :processUnit.3:state 2
  1240 jump *label295 always
 
  1266 print *tmp487
  1267 print "["
  1268 print "]"
-    * op greaterThanEq *tmp488 :processUnit.3:distance 0
-    * jump *label296 equal *tmp488 false
+ 1269 jump *label296 lessThan :processUnit.3:distance 0
  1270 print :processUnit.3:msg
  1271 print :processUnit.3:distance
  1272 print "["
 
  1313 set :areUnitsAvailable.2:free :areUnitsAvailable.2:occupied
  1314 ubind :areUnitsAvailable.2:type
  1315 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp503 :areUnitsAvailable.2:firstUnit null
-    * jump *label303 equal *tmp503 false
+ 1316 jump *label303 equal :areUnitsAvailable.2:firstUnit null
  1317 # "Function: inline def needsFourUnits(in unit)"
  1318 set :needsFourUnits.3:unit @unit
  1319 op sub *tmp506 .DOME_X .CORE_X
 
  1341 op or *tmp518 *tmp515 *tmp517
  1342 jump *label311 equal *tmp518 false
  1343 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * op greaterThanEq *tmp520 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
-    * jump *label313 equal *tmp520 false
+ 1344 jump *label313 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1345 set *tmp501 true
  1346 jump *label302 always
  1347 jump *label314 always
 
  1370 print ","
  1371 print " free: "
  1372 print :areUnitsAvailable.2:free
-    * op greaterThan *tmp527 :areUnitsAvailable.2:needed 0
-    * jump *label317 equal *tmp527 false
+ 1373 jump *label317 lessThanEq :areUnitsAvailable.2:needed 0
  1374 print ", needed: "
  1375 print :areUnitsAvailable.2:needed
  1376 jump *label318 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-79 instructions):
 
    69 jump *label21 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
    70 set *tmp4 true
    71 jump *label10 always
-    * jump *label22 always
    72 label *label21
    73 label *label22
    74 jump *label20 always
 
    83 op land *tmp28 *tmp25 *tmp27
    84 jump *label16 notEqual *tmp28 false
    85 label *label18
-    * jump *label12 always
    86 label *label11
    87 label *label12
    88 jump *label23 equal :areUnitsAvailable.0:output false
 
    96 jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
    97 print ", needed: "
    98 print :areUnitsAvailable.0:needed
-    * jump *label26 always
    99 label *label25
   100 label *label26
   101 print "\n"
-    * jump *label24 always
   102 label *label23
   103 label *label24
   104 set *tmp4 false
 
   108 jump *label27 equal *tmp4 false
   109 set *tmp3 UNIT_TYPE
   110 jump *label6 always
-    * jump *label28 always
   111 label *label27
   112 label *label28
   113 set :chooseUnitType.0:type @flare
 
   170 jump *label51 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   171 set *tmp36 true
   172 jump *label40 always
-    * jump *label52 always
   173 label *label51
   174 label *label52
   175 jump *label50 always
 
   184 op land *tmp60 *tmp57 *tmp59
   185 jump *label46 notEqual *tmp60 false
   186 label *label48
-    * jump *label42 always
   187 label *label41
   188 label *label42
   189 jump *label53 equal :areUnitsAvailable.1:output false
 
   197 jump *label55 lessThanEq :areUnitsAvailable.1:needed 0
   198 print ", needed: "
   199 print :areUnitsAvailable.1:needed
-    * jump *label56 always
   200 label *label55
   201 label *label56
   202 print "\n"
-    * jump *label54 always
   203 label *label53
   204 label *label54
   205 set *tmp36 false
 
   210 printflush null
   211 set *tmp3 :chooseUnitType.0:type
   212 jump *label6 always
-    * jump *label58 always
   213 label *label57
   214 label *label58
-    * jump *label39 always
   215 label *label38
   216 label *label39
   217 label *label30
 
   238 set :rebindUnits.0:firstUnit @unit
   239 jump *label60 notEqual :rebindUnits.0:firstUnit null
   240 end
-    * jump *label61 always
   241 label *label60
   242 label *label61
   243 label *label62
 
   251 set .UNIT_P1 @unit
   252 jump *label67 equal .UNIT_S2 null
   253 jump *label64 always
-    * jump *label68 always
   254 label *label67
   255 label *label68
-    * jump *label66 always
   256 label *label65
   257 label *label66
   258 ubind .TYPE
 
   263 op land *tmp78 *tmp75 *tmp77
   264 jump *label62 notEqual *tmp78 false
   265 label *label64
-    * jump *label59 always
   266 label *label59
   267 # "Function: inline def acquireUnit(in currentUnit)"
   268 set :acquireUnit.0:currentUnit .UNIT_S1
 
   277 op land *tmp87 *tmp84 *tmp86
   278 jump *label73 equal *tmp87 false
   279 jump *label70 always
-    * jump *label74 always
   280 label *label73
   281 label *label74
-    * jump *label72 always
   282 label *label71
   283 label *label72
   284 ubind .TYPE
 
   288 sensor *tmp92 @unit @controlled
   289 jump *label80 notEqual *tmp92 0
   290 jump *label70 always
-    * jump *label81 always
   291 label *label80
   292 label *label81
   293 ubind .TYPE
 
   298 op land *tmp98 *tmp95 *tmp97
   299 jump *label77 notEqual *tmp98 false
   300 label *label79
-    * jump *label76 always
   301 label *label75
   302 label *label76
   303 end
 
   321 op land *tmp107 *tmp104 *tmp106
   322 jump *label86 equal *tmp107 false
   323 jump *label83 always
-    * jump *label87 always
   324 label *label86
   325 label *label87
-    * jump *label85 always
   326 label *label84
   327 label *label85
   328 ubind .TYPE
 
   332 sensor *tmp112 @unit @controlled
   333 jump *label93 notEqual *tmp112 0
   334 jump *label83 always
-    * jump *label94 always
   335 label *label93
   336 label *label94
   337 ubind .TYPE
 
   342 op land *tmp118 *tmp115 *tmp117
   343 jump *label90 notEqual *tmp118 false
   344 label *label92
-    * jump *label89 always
   345 label *label88
   346 label *label89
   347 end
 
   361 set :u .UNIT_S1
   362 set .UNIT_S1 .UNIT_P1
   363 set .UNIT_P1 :u
-    * jump *label96 always
   364 label *label95
   365 label *label96
   366 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   369 op strictEqual *tmp128 .SPEED null
   370 jump *label97 equal *tmp128 false
   371 stop
-    * jump *label98 always
   372 label *label97
   373 label *label98
   374 print "[gold]Locating core..."
 
   409 op land *tmp156 *tmp153 *tmp155
   410 jump *label109 equal *tmp156 false
   411 jump *label106 always
-    * jump *label110 always
   412 label *label109
   413 label *label110
-    * jump *label108 always
   414 label *label107
   415 label *label108
   416 ubind .TYPE
 
   420 sensor *tmp161 @unit @controlled
   421 jump *label116 notEqual *tmp161 0
   422 jump *label106 always
-    * jump *label117 always
   423 label *label116
   424 label *label117
   425 ubind .TYPE
 
   430 op land *tmp167 *tmp164 *tmp166
   431 jump *label113 notEqual *tmp167 false
   432 label *label115
-    * jump *label112 always
   433 label *label111
   434 label *label112
   435 end
 
   453 op land *tmp176 *tmp173 *tmp175
   454 jump *label122 equal *tmp176 false
   455 jump *label119 always
-    * jump *label123 always
   456 label *label122
   457 label *label123
-    * jump *label121 always
   458 label *label120
   459 label *label121
   460 ubind .TYPE
 
   464 sensor *tmp181 @unit @controlled
   465 jump *label129 notEqual *tmp181 0
   466 jump *label119 always
-    * jump *label130 always
   467 label *label129
   468 label *label130
   469 ubind .TYPE
 
   474 op land *tmp187 *tmp184 *tmp186
   475 jump *label126 notEqual *tmp187 false
   476 label *label128
-    * jump *label125 always
   477 label *label124
   478 label *label125
   479 end
 
   493 set :u .UNIT_S1
   494 set .UNIT_S1 .UNIT_P2
   495 set .UNIT_P2 :u
-    * jump *label132 always
   496 label *label131
   497 label *label132
   498 sensor *tmp194 .UNIT_S2 @firstItem
 
   504 set :u .UNIT_S2
   505 set .UNIT_S2 .UNIT_P2
   506 set .UNIT_P2 :u
-    * jump *label134 always
   507 label *label133
   508 label *label134
   509 set .GROUP1 "unit  1"
 
   578 op land *tmp225 *tmp222 *tmp224
   579 jump *label145 equal *tmp225 false
   580 jump *label142 always
-    * jump *label146 always
   581 label *label145
   582 label *label146
-    * jump *label144 always
   583 label *label143
   584 label *label144
   585 ubind .TYPE
 
   589 sensor *tmp230 @unit @controlled
   590 jump *label152 notEqual *tmp230 0
   591 jump *label142 always
-    * jump *label153 always
   592 label *label152
   593 label *label153
   594 ubind .TYPE
 
   599 op land *tmp236 *tmp233 *tmp235
   600 jump *label149 notEqual *tmp236 false
   601 label *label151
-    * jump *label148 always
   602 label *label147
   603 label *label148
   604 end
 
   626 ucontrol within .CORE_X .CORE_Y 8 *tmp248
   627 jump *label160 equal *tmp248 false
   628 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label161 always
   629 label *label160
   630 label *label161
   631 label *label159
   632 label *label157
-    * jump *label155 always
   633 label *label154
   634 label *label155
   635 jump *label162 notEqual :processUnit.0:state 2
 
   656 op idiv *tmp262 *tmp261 .SPEED_TENTHS
   657 op div :processUnit.0:distance *tmp262 10
   658 label *label165
-    * jump *label163 always
   659 label *label162
   660 label *label163
   661 jump *label168 notEqual :processUnit.0:state 3
 
   673 jump *label174 greaterThan *tmp269 0
   674 ucontrol approach .CORE_X .CORE_Y 6
   675 set :processUnit.0:state 2
-    * jump *label175 always
   676 label *label174
   677 label *label175
   678 jump *label171 always
 
   687 op idiv *tmp277 *tmp276 .SPEED_TENTHS
   688 op div :processUnit.0:distance *tmp277 10
   689 label *label171
-    * jump *label169 always
   690 label *label168
   691 label *label169
   692 ucontrol flag :processUnit.0:state
 
   733 op land *tmp292 *tmp289 *tmp291
   734 jump *label184 equal *tmp292 false
   735 jump *label181 always
-    * jump *label185 always
   736 label *label184
   737 label *label185
-    * jump *label183 always
   738 label *label182
   739 label *label183
   740 ubind .TYPE
 
   744 sensor *tmp297 @unit @controlled
   745 jump *label191 notEqual *tmp297 0
   746 jump *label181 always
-    * jump *label192 always
   747 label *label191
   748 label *label192
   749 ubind .TYPE
 
   754 op land *tmp303 *tmp300 *tmp302
   755 jump *label188 notEqual *tmp303 false
   756 label *label190
-    * jump *label187 always
   757 label *label186
   758 label *label187
   759 end
 
   781 ucontrol within .CORE_X .CORE_Y 8 *tmp315
   782 jump *label199 equal *tmp315 false
   783 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label200 always
   784 label *label199
   785 label *label200
   786 label *label198
   787 label *label196
-    * jump *label194 always
   788 label *label193
   789 label *label194
   790 jump *label201 notEqual :processUnit.1:state 2
 
   811 op idiv *tmp329 *tmp328 .SPEED_TENTHS
   812 op div :processUnit.1:distance *tmp329 10
   813 label *label204
-    * jump *label202 always
   814 label *label201
   815 label *label202
   816 jump *label207 notEqual :processUnit.1:state 3
 
   828 jump *label213 greaterThan *tmp336 0
   829 ucontrol approach .CORE_X .CORE_Y 6
   830 set :processUnit.1:state 2
-    * jump *label214 always
   831 label *label213
   832 label *label214
   833 jump *label210 always
 
   842 op idiv *tmp344 *tmp343 .SPEED_TENTHS
   843 op div :processUnit.1:distance *tmp344 10
   844 label *label210
-    * jump *label208 always
   845 label *label207
   846 label *label208
   847 ucontrol flag :processUnit.1:state
 
   879 op equal *tmp349 *tmp352 0
   880 label *label218
   881 set .SUPPLY_S_FIRST *tmp349
-    * jump *label179 always
   882 label *label178
   883 label *label179
   884 # "Function: inline def printDomeStatus(in item, in text)"
 
   917 op land *tmp366 *tmp363 *tmp365
   918 jump *label226 equal *tmp366 false
   919 jump *label223 always
-    * jump *label227 always
   920 label *label226
   921 label *label227
-    * jump *label225 always
   922 label *label224
   923 label *label225
   924 ubind .TYPE
 
   928 sensor *tmp371 @unit @controlled
   929 jump *label233 notEqual *tmp371 0
   930 jump *label223 always
-    * jump *label234 always
   931 label *label233
   932 label *label234
   933 ubind .TYPE
 
   938 op land *tmp377 *tmp374 *tmp376
   939 jump *label230 notEqual *tmp377 false
   940 label *label232
-    * jump *label229 always
   941 label *label228
   942 label *label229
   943 end
 
   965 ucontrol within .CORE_X .CORE_Y 8 *tmp389
   966 jump *label241 equal *tmp389 false
   967 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label242 always
   968 label *label241
   969 label *label242
   970 label *label240
   971 label *label238
-    * jump *label236 always
   972 label *label235
   973 label *label236
   974 jump *label243 notEqual :processUnit.2:state 2
 
   995 op idiv *tmp403 *tmp402 .SPEED_TENTHS
   996 op div :processUnit.2:distance *tmp403 10
   997 label *label246
-    * jump *label244 always
   998 label *label243
   999 label *label244
  1000 jump *label249 notEqual :processUnit.2:state 3
 
  1012 jump *label255 greaterThan *tmp410 0
  1013 ucontrol approach .CORE_X .CORE_Y 6
  1014 set :processUnit.2:state 2
-    * jump *label256 always
  1015 label *label255
  1016 label *label256
  1017 jump *label252 always
 
  1026 op idiv *tmp418 *tmp417 .SPEED_TENTHS
  1027 op div :processUnit.2:distance *tmp418 10
  1028 label *label252
-    * jump *label250 always
  1029 label *label249
  1030 label *label250
  1031 ucontrol flag :processUnit.2:state
 
  1072 op land *tmp433 *tmp430 *tmp432
  1073 jump *label265 equal *tmp433 false
  1074 jump *label262 always
-    * jump *label266 always
  1075 label *label265
  1076 label *label266
-    * jump *label264 always
  1077 label *label263
  1078 label *label264
  1079 ubind .TYPE
 
  1083 sensor *tmp438 @unit @controlled
  1084 jump *label272 notEqual *tmp438 0
  1085 jump *label262 always
-    * jump *label273 always
  1086 label *label272
  1087 label *label273
  1088 ubind .TYPE
 
  1093 op land *tmp444 *tmp441 *tmp443
  1094 jump *label269 notEqual *tmp444 false
  1095 label *label271
-    * jump *label268 always
  1096 label *label267
  1097 label *label268
  1098 end
 
  1120 ucontrol within .CORE_X .CORE_Y 8 *tmp456
  1121 jump *label280 equal *tmp456 false
  1122 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label281 always
  1123 label *label280
  1124 label *label281
  1125 label *label279
  1126 label *label277
-    * jump *label275 always
  1127 label *label274
  1128 label *label275
  1129 jump *label282 notEqual :processUnit.3:state 2
 
  1150 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1151 op div :processUnit.3:distance *tmp470 10
  1152 label *label285
-    * jump *label283 always
  1153 label *label282
  1154 label *label283
  1155 jump *label288 notEqual :processUnit.3:state 3
 
  1167 jump *label294 greaterThan *tmp477 0
  1168 ucontrol approach .CORE_X .CORE_Y 6
  1169 set :processUnit.3:state 2
-    * jump *label295 always
  1170 label *label294
  1171 label *label295
  1172 jump *label291 always
 
  1181 op idiv *tmp485 *tmp484 .SPEED_TENTHS
  1182 op div :processUnit.3:distance *tmp485 10
  1183 label *label291
-    * jump *label289 always
  1184 label *label288
  1185 label *label289
  1186 ucontrol flag :processUnit.3:state
 
  1218 op equal *tmp490 *tmp493 0
  1219 label *label299
  1220 set .SUPPLY_P_FIRST *tmp490
-    * jump *label260 always
  1221 label *label259
  1222 label *label260
  1223 op sub *tmp495 @time :start
 
  1271 jump *label313 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1272 set *tmp501 true
  1273 jump *label302 always
-    * jump *label314 always
  1274 label *label313
  1275 label *label314
  1276 jump *label312 always
 
  1285 op land *tmp525 *tmp522 *tmp524
  1286 jump *label308 notEqual *tmp525 false
  1287 label *label310
-    * jump *label304 always
  1288 label *label303
  1289 label *label304
  1290 jump *label315 equal :areUnitsAvailable.2:output false
 
  1298 jump *label317 lessThanEq :areUnitsAvailable.2:needed 0
  1299 print ", needed: "
  1300 print :areUnitsAvailable.2:needed
-    * jump *label318 always
  1301 label *label317
  1302 label *label318
  1303 print "\n"
-    * jump *label316 always
  1304 label *label315
  1305 label *label316
  1306 set *tmp501 false
 
  1309 label *label302
  1310 jump *label319 equal *tmp501 false
  1311 end
-    * jump *label320 always
  1312 label *label319
  1313 label *label320
  1314 op add :unitCheck @time 5000
-    * jump *label301 always
  1315 label *label300
  1316 label *label301
  1317 label *label136

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
     4 set .DOME_Y null
-    * set .DOME_X .DOME_Y
-    * set .CORE_Y .DOME_X
-    * set .CORE_X .CORE_Y
+    5 set .DOME_X null
+    6 set .CORE_Y .DOME_Y
+    7 set .CORE_X .DOME_X
     8 set .DOME dome1
     9 label *label0
    10 jump *label2 notEqual .DOME null
 
    34 set :areUnitsAvailable.0:type UNIT_TYPE
    35 set :areUnitsAvailable.0:output true
    36 set :areUnitsAvailable.0:needed 0
-    * set :areUnitsAvailable.0:occupied :areUnitsAvailable.0:needed
-    * set :areUnitsAvailable.0:free :areUnitsAvailable.0:occupied
-    * ubind :areUnitsAvailable.0:type
+   37 set :areUnitsAvailable.0:occupied 0
+   38 set :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   39 ubind UNIT_TYPE
    40 set :areUnitsAvailable.0:firstUnit @unit
    41 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    42 # "Function: inline def needsFourUnits(in unit)"
    43 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 .DOME_X .CORE_X
-    * op sub *tmp10 .DOME_Y .CORE_Y
+   44 op sub *tmp9 .DOME_Y .CORE_Y
+   45 op sub *tmp10 null .DOME_X
    46 op len *tmp11 *tmp9 *tmp10
    47 op mul *tmp12 2 *tmp11
    48 sensor *tmp13 :needsFourUnits.0:unit @speed
    49 op div :needsFourUnits.0:travel_time *tmp12 *tmp13
    50 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    51 jump *label13 always
-    * set *tmp8 null
    52 label *label13
    53 jump *label14 equal *tmp8 false
    54 set *tmp16 4
 
    65 op or *tmp21 *tmp18 *tmp20
    66 jump *label19 equal *tmp21 false
    67 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label21 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   68 jump *label21 lessThan :areUnitsAvailable.0:free *tmp16
    69 set *tmp4 true
    70 jump *label10 always
    71 label *label21
 
    74 label *label19
    75 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
    76 label *label20
-    * ubind :areUnitsAvailable.0:type
+   77 ubind UNIT_TYPE
    78 label *label17
    79 op notEqual *tmp25 @unit :areUnitsAvailable.0:firstUnit
    80 sensor *tmp26 :areUnitsAvailable.0:firstUnit @dead
 
    84 label *label18
    85 label *label11
    86 label *label12
-    * jump *label23 equal :areUnitsAvailable.0:output false
-    * print :areUnitsAvailable.0:type
+   87 jump *label23 equal true false
+   88 print UNIT_TYPE
    89 print ":"
    90 print " occupied: "
    91 print :areUnitsAvailable.0:occupied
 
   102 label *label24
   103 set *tmp4 false
   104 jump *label10 always
-    * set *tmp4 null
   105 label *label10
   106 jump *label27 equal *tmp4 false
   107 set *tmp3 UNIT_TYPE
 
   133 set :areUnitsAvailable.1:type :chooseUnitType.0:type
   134 set :areUnitsAvailable.1:output true
   135 set :areUnitsAvailable.1:needed 0
-    * set :areUnitsAvailable.1:occupied :areUnitsAvailable.1:needed
-    * set :areUnitsAvailable.1:free :areUnitsAvailable.1:occupied
-    * ubind :areUnitsAvailable.1:type
+  136 set :areUnitsAvailable.1:occupied 0
+  137 set :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  138 ubind :chooseUnitType.0:type
   139 set :areUnitsAvailable.1:firstUnit @unit
   140 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   141 # "Function: inline def needsFourUnits(in unit)"
   142 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 .DOME_X .CORE_X
-    * op sub *tmp42 .DOME_Y .CORE_Y
+  143 op sub *tmp41 .DOME_Y .CORE_Y
+  144 op sub *tmp42 null .DOME_X
   145 op len *tmp43 *tmp41 *tmp42
   146 op mul *tmp44 2 *tmp43
   147 sensor *tmp45 :needsFourUnits.1:unit @speed
   148 op div :needsFourUnits.1:travel_time *tmp44 *tmp45
   149 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   150 jump *label43 always
-    * set *tmp40 null
   151 label *label43
   152 jump *label44 equal *tmp40 false
   153 set *tmp48 4
 
   164 op or *tmp53 *tmp50 *tmp52
   165 jump *label49 equal *tmp53 false
   166 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label51 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  167 jump *label51 lessThan :areUnitsAvailable.1:free *tmp48
   168 set *tmp36 true
   169 jump *label40 always
   170 label *label51
 
   173 label *label49
   174 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   175 label *label50
-    * ubind :areUnitsAvailable.1:type
+  176 ubind :chooseUnitType.0:type
   177 label *label47
   178 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   179 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   183 label *label48
   184 label *label41
   185 label *label42
-    * jump *label53 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  186 jump *label53 equal true false
+  187 print :chooseUnitType.0:type
   188 print ":"
   189 print " occupied: "
   190 print :areUnitsAvailable.1:occupied
 
   201 label *label54
   202 set *tmp36 false
   203 jump *label40 always
-    * set *tmp36 null
   204 label *label40
   205 jump *label57 equal *tmp36 false
   206 printflush null
 
   226 printflush message1
   227 # "Function: inline def rebindUnits()"
   228 set .UNIT_P2 null
-    * set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P1 .UNIT_S2
-    * set .UNIT_S1 .UNIT_P1
+  229 set .UNIT_S2 null
+  230 set .UNIT_P1 .UNIT_P2
+  231 set .UNIT_S1 .UNIT_S2
   232 set :rebindUnits.0:count 0
-    * ubind .TYPE
+  233 ubind *tmp3
   234 set :rebindUnits.0:firstUnit @unit
   235 jump *label60 notEqual :rebindUnits.0:firstUnit null
   236 end
 
   251 label *label68
   252 label *label65
   253 label *label66
-    * ubind .TYPE
+  254 ubind *tmp3
   255 label *label63
   256 op notEqual *tmp75 @unit :rebindUnits.0:firstUnit
   257 sensor *tmp76 :rebindUnits.0:firstUnit @dead
 
   263 # "Function: inline def acquireUnit(in currentUnit)"
   264 set :acquireUnit.0:currentUnit .UNIT_S1
   265 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * jump *label71 equal :rebindUnit.0:currentUnit null
-    * ubind :rebindUnit.0:currentUnit
+  266 set :rebindUnit.0:currentUnit .UNIT_S1
+  267 jump *label71 equal :acquireUnit.0:currentUnit null
+  268 ubind :acquireUnit.0:currentUnit
   269 sensor *tmp83 @unit @dead
   270 op strictEqual *tmp84 *tmp83 0
   271 sensor *tmp85 @unit @controller
 
   277 label *label74
   278 label *label71
   279 label *label72
-    * ubind .TYPE
+  280 ubind *tmp3
   281 set :rebindUnit.0:firstUnit @unit
   282 jump *label75 equal :rebindUnit.0:firstUnit null
   283 label *label77
 
   286 jump *label70 always
   287 label *label80
   288 label *label81
-    * ubind .TYPE
+  289 ubind *tmp3
   290 label *label78
   291 op notEqual *tmp95 @unit :rebindUnit.0:firstUnit
   292 sensor *tmp96 :rebindUnit.0:firstUnit @dead
 
   301 ucontrol flag 1
   302 set *tmp79 @unit
   303 jump *label69 always
-    * set *tmp79 null
   304 label *label69
   305 set .UNIT_S1 *tmp79
   306 # "Function: inline def acquireUnit(in currentUnit)"
   307 set :acquireUnit.1:currentUnit .UNIT_P1
   308 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * jump *label84 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  309 set :rebindUnit.1:currentUnit .UNIT_P1
+  310 jump *label84 equal :acquireUnit.1:currentUnit null
+  311 ubind :acquireUnit.1:currentUnit
   312 sensor *tmp103 @unit @dead
   313 op strictEqual *tmp104 *tmp103 0
   314 sensor *tmp105 @unit @controller
 
   320 label *label87
   321 label *label84
   322 label *label85
-    * ubind .TYPE
+  323 ubind *tmp3
   324 set :rebindUnit.1:firstUnit @unit
   325 jump *label88 equal :rebindUnit.1:firstUnit null
   326 label *label90
 
   329 jump *label83 always
   330 label *label93
   331 label *label94
-    * ubind .TYPE
+  332 ubind *tmp3
   333 label *label91
   334 op notEqual *tmp115 @unit :rebindUnit.1:firstUnit
   335 sensor *tmp116 :rebindUnit.1:firstUnit @dead
 
   344 ucontrol flag 1
   345 set *tmp99 @unit
   346 jump *label82 always
-    * set *tmp99 null
   347 label *label82
   348 set .UNIT_P1 *tmp99
-    * sensor *tmp119 .UNIT_S1 @firstItem
+  349 sensor *tmp119 *tmp79 @firstItem
   350 op equal *tmp120 *tmp119 @phase-fabric
-    * sensor *tmp121 .UNIT_P1 @firstItem
+  351 sensor *tmp121 *tmp99 @firstItem
   352 op equal *tmp122 *tmp121 @silicon
   353 op or *tmp123 *tmp120 *tmp122
   354 jump *label95 equal *tmp123 false
-    * set :u .UNIT_S1
-    * set .UNIT_S1 .UNIT_P1
+  355 set :u *tmp79
+  356 set .UNIT_S1 *tmp99
   357 set .UNIT_P1 :u
   358 label *label95
   359 label *label96
 
   382 op sub *tmp141 .DOME_Y .CORE_Y
   383 op len *tmp142 *tmp140 *tmp141
   384 op mul *tmp143 2 *tmp142
-    * sensor *tmp144 :needsFourUnits.2:unit @speed
-    * op div :needsFourUnits.2:travel_time *tmp143 *tmp144
+  385 sensor *tmp144 .UNIT_S1 @speed
+  386 op div :needsFourUnits.2:travel_time *tmp143 .SPEED
   387 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   388 jump *label102 always
-    * set *tmp139 null
   389 label *label102
   390 set .FOUR_UNITS *tmp139
-    * jump *label103 equal .FOUR_UNITS false
+  391 jump *label103 equal *tmp139 false
   392 # "Function: inline def acquireUnit(in currentUnit)"
   393 set :acquireUnit.2:currentUnit .UNIT_S2
   394 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * jump *label107 equal :rebindUnit.2:currentUnit null
-    * ubind :rebindUnit.2:currentUnit
+  395 set :rebindUnit.2:currentUnit .UNIT_S2
+  396 jump *label107 equal :acquireUnit.2:currentUnit null
+  397 ubind :acquireUnit.2:currentUnit
   398 sensor *tmp152 @unit @dead
   399 op strictEqual *tmp153 *tmp152 0
   400 sensor *tmp154 @unit @controller
 
   406 label *label110
   407 label *label107
   408 label *label108
-    * ubind .TYPE
+  409 ubind *tmp3
   410 set :rebindUnit.2:firstUnit @unit
   411 jump *label111 equal :rebindUnit.2:firstUnit null
   412 label *label113
 
   415 jump *label106 always
   416 label *label116
   417 label *label117
-    * ubind .TYPE
+  418 ubind *tmp3
   419 label *label114
   420 op notEqual *tmp164 @unit :rebindUnit.2:firstUnit
   421 sensor *tmp165 :rebindUnit.2:firstUnit @dead
 
   430 ucontrol flag 1
   431 set *tmp148 @unit
   432 jump *label105 always
-    * set *tmp148 null
   433 label *label105
   434 set .UNIT_S2 *tmp148
   435 # "Function: inline def acquireUnit(in currentUnit)"
   436 set :acquireUnit.3:currentUnit .UNIT_P2
   437 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * jump *label120 equal :rebindUnit.3:currentUnit null
-    * ubind :rebindUnit.3:currentUnit
+  438 set :rebindUnit.3:currentUnit .UNIT_P2
+  439 jump *label120 equal :acquireUnit.3:currentUnit null
+  440 ubind :acquireUnit.3:currentUnit
   441 sensor *tmp172 @unit @dead
   442 op strictEqual *tmp173 *tmp172 0
   443 sensor *tmp174 @unit @controller
 
   449 label *label123
   450 label *label120
   451 label *label121
-    * ubind .TYPE
+  452 ubind *tmp3
   453 set :rebindUnit.3:firstUnit @unit
   454 jump *label124 equal :rebindUnit.3:firstUnit null
   455 label *label126
 
   458 jump *label119 always
   459 label *label129
   460 label *label130
-    * ubind .TYPE
+  461 ubind *tmp3
   462 label *label127
   463 op notEqual *tmp184 @unit :rebindUnit.3:firstUnit
   464 sensor *tmp185 :rebindUnit.3:firstUnit @dead
 
   473 ucontrol flag 1
   474 set *tmp168 @unit
   475 jump *label118 always
-    * set *tmp168 null
   476 label *label118
   477 set .UNIT_P2 *tmp168
   478 sensor *tmp188 .UNIT_S1 @firstItem
   479 op equal *tmp189 *tmp188 @phase-fabric
-    * sensor *tmp190 .UNIT_P2 @firstItem
+  480 sensor *tmp190 *tmp168 @firstItem
   481 op notEqual *tmp191 *tmp190 @phase-fabric
   482 op land *tmp192 *tmp189 *tmp191
   483 jump *label131 equal *tmp192 false
   484 set :u .UNIT_S1
-    * set .UNIT_S1 .UNIT_P2
+  485 set .UNIT_S1 *tmp168
   486 set .UNIT_P2 :u
   487 label *label131
   488 label *label132
-    * sensor *tmp194 .UNIT_S2 @firstItem
+  489 sensor *tmp194 *tmp148 @firstItem
   490 op equal *tmp195 *tmp194 @phase-fabric
   491 sensor *tmp196 .UNIT_P2 @firstItem
   492 op equal *tmp197 *tmp196 @silicon
   493 op or *tmp198 *tmp195 *tmp197
   494 jump *label133 equal *tmp198 false
-    * set :u .UNIT_S2
+  495 set :u *tmp148
   496 set .UNIT_S2 .UNIT_P2
   497 set .UNIT_P2 :u
   498 label *label133
 
   510 set .GROUP1 "unit"
   511 set .GROUP2 ""
   512 label *label104
-    * op equal *tmp200 .FOUR_UNITS false
+  513 op equal *tmp200 *tmp139 false
   514 sensor *tmp201 .UNIT_S1 @totalItems
   515 sensor *tmp202 .UNIT_S2 @totalItems
   516 op lessThan *tmp203 *tmp201 *tmp202
   517 op or .SUPPLY_S_FIRST *tmp200 *tmp203
-    * op equal *tmp205 .FOUR_UNITS false
+  518 op equal *tmp205 *tmp139 false
   519 sensor *tmp206 .UNIT_P1 @totalItems
   520 sensor *tmp207 .UNIT_P2 @totalItems
   521 op lessThan *tmp208 *tmp206 *tmp207
-    * op or .SUPPLY_P_FIRST *tmp205 *tmp208
+  522 op or .SUPPLY_P_FIRST *tmp200 *tmp208
   523 op add :unitCheck @time 5000
   524 label *label135
   525 sensor *tmp211 switch1 @enabled
 
   529 print "\n"
   530 print "\n"
   531 print "Unit type: [green]"
-    * print .TYPE
+  532 print *tmp3
   533 print "["
   534 print "]"
   535 print "\n"
   536 # "Function: inline def printDomeStatus(in item, in text)"
   537 set :printDomeStatus.0:item @silicon
   538 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
-    * print :printDomeStatus.0:text
-    * sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
+  539 print "\n[green]Silicon[] status:\n"
+  540 sensor :printDomeStatus.0:level .DOME @silicon
   541 jump *label139 lessThanEq :printDomeStatus.0:level 3
   542 print "  dome:  [green]"
   543 print :printDomeStatus.0:level
 
   559 set :processUnit.0:group .GROUP1
   560 set :processUnit.0:supply .SUPPLY_S_FIRST
   561 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit :processUnit.0:unit
-    * jump *label143 equal :rebindUnit.4:currentUnit null
-    * ubind :rebindUnit.4:currentUnit
+  562 set :rebindUnit.4:currentUnit .UNIT_S1
+  563 jump *label143 equal :processUnit.0:unit null
+  564 ubind :processUnit.0:unit
   565 sensor *tmp221 @unit @dead
   566 op strictEqual *tmp222 *tmp221 0
   567 sensor *tmp223 @unit @controller
 
   573 label *label146
   574 label *label143
   575 label *label144
-    * ubind .TYPE
+  576 ubind *tmp3
   577 set :rebindUnit.4:firstUnit @unit
   578 jump *label147 equal :rebindUnit.4:firstUnit null
   579 label *label149
 
   582 jump *label142 always
   583 label *label152
   584 label *label153
-    * ubind .TYPE
+  585 ubind *tmp3
   586 label *label150
   587 op notEqual *tmp233 @unit :rebindUnit.4:firstUnit
   588 sensor *tmp234 :rebindUnit.4:firstUnit @dead
 
   603 op or *tmp240 *tmp238 *tmp239
   604 jump *label154 equal *tmp240 false
   605 sensor *tmp242 @unit @firstItem
-    * jump *label156 notEqual *tmp242 :processUnit.0:item
+  606 jump *label156 notEqual *tmp242 @silicon
   607 set :processUnit.0:state 3
   608 jump *label157 always
   609 label *label156
 
   626 jump *label162 notEqual :processUnit.0:state 2
   627 ucontrol within .CORE_X .CORE_Y 8 *tmp252
   628 jump *label164 equal *tmp252 false
-    * ucontrol itemTake .CORE :processUnit.0:item .UNIT_CAPACITY
+  629 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   630 sensor *tmp254 @unit @totalItems
   631 jump *label166 lessThan *tmp254 .UNIT_CAPACITY
   632 ucontrol approach .DOME_X .DOME_Y 6
 
   652 jump *label168 notEqual :processUnit.0:state 3
   653 ucontrol within .DOME_X .DOME_Y 8 *tmp266
   654 jump *label170 equal *tmp266 false
-    * jump *label172 equal :processUnit.0:supply false
+  655 jump *label172 equal .SUPPLY_S_FIRST false
   656 ucontrol itemDrop .DOME .UNIT_CAPACITY
   657 set :processUnit.0:msg ", supplying\n"
   658 jump *label173 always
 
   683 ucontrol flag :processUnit.0:state
   684 sensor *tmp279 @unit @totalItems
   685 print "  "
-    * print :processUnit.0:group
+  686 print .GROUP1
   687 print ":"
   688 print " ["
-    * print :processUnit.0:color
+  689 print "gold"
   690 print "]"
   691 print *tmp279
   692 print "["
 
   703 label *label177
   704 set *tmp217 @unit
   705 jump *label141 always
-    * set *tmp217 null
   706 label *label141
   707 set .UNIT_S1 *tmp217
-    * jump *label178 equal .FOUR_UNITS false
+  708 jump *label178 equal *tmp139 false
   709 op equal *tmp283 .SUPPLY_S_FIRST false
   710 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
   711 set :processUnit.1:unit .UNIT_S2
 
   713 set :processUnit.1:group .GROUP2
   714 set :processUnit.1:supply *tmp283
   715 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * jump *label182 equal :rebindUnit.5:currentUnit null
-    * ubind :rebindUnit.5:currentUnit
+  716 set :rebindUnit.5:currentUnit .UNIT_S2
+  717 jump *label182 equal :processUnit.1:unit null
+  718 ubind :processUnit.1:unit
   719 sensor *tmp288 @unit @dead
   720 op strictEqual *tmp289 *tmp288 0
   721 sensor *tmp290 @unit @controller
 
   727 label *label185
   728 label *label182
   729 label *label183
-    * ubind .TYPE
+  730 ubind *tmp3
   731 set :rebindUnit.5:firstUnit @unit
   732 jump *label186 equal :rebindUnit.5:firstUnit null
   733 label *label188
 
   736 jump *label181 always
   737 label *label191
   738 label *label192
-    * ubind .TYPE
+  739 ubind *tmp3
   740 label *label189
   741 op notEqual *tmp300 @unit :rebindUnit.5:firstUnit
   742 sensor *tmp301 :rebindUnit.5:firstUnit @dead
 
   757 op or *tmp307 *tmp305 *tmp306
   758 jump *label193 equal *tmp307 false
   759 sensor *tmp309 @unit @firstItem
-    * jump *label195 notEqual *tmp309 :processUnit.1:item
+  760 jump *label195 notEqual *tmp309 @silicon
   761 set :processUnit.1:state 3
   762 jump *label196 always
   763 label *label195
 
   780 jump *label201 notEqual :processUnit.1:state 2
   781 ucontrol within .CORE_X .CORE_Y 8 *tmp319
   782 jump *label203 equal *tmp319 false
-    * ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
+  783 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   784 sensor *tmp321 @unit @totalItems
   785 jump *label205 lessThan *tmp321 .UNIT_CAPACITY
   786 ucontrol approach .DOME_X .DOME_Y 6
 
   806 jump *label207 notEqual :processUnit.1:state 3
   807 ucontrol within .DOME_X .DOME_Y 8 *tmp333
   808 jump *label209 equal *tmp333 false
-    * jump *label211 equal :processUnit.1:supply false
+  809 jump *label211 equal *tmp283 false
   810 ucontrol itemDrop .DOME .UNIT_CAPACITY
   811 set :processUnit.1:msg ", supplying\n"
   812 jump *label212 always
 
   837 ucontrol flag :processUnit.1:state
   838 sensor *tmp346 @unit @totalItems
   839 print "  "
-    * print :processUnit.1:group
+  840 print .GROUP2
   841 print ":"
   842 print " ["
-    * print :processUnit.1:color
+  843 print "gold"
   844 print "]"
   845 print *tmp346
   846 print "["
 
   857 label *label216
   858 set *tmp284 @unit
   859 jump *label180 always
-    * set *tmp284 null
   860 label *label180
   861 set .UNIT_S2 *tmp284
   862 jump *label217 equal .SUPPLY_S_FIRST false
-    * sensor *tmp350 .UNIT_S1 @totalItems
+  863 sensor *tmp350 *tmp217 @totalItems
   864 op greaterThan *tmp349 *tmp350 0
   865 jump *label218 always
   866 label *label217
-    * sensor *tmp352 .UNIT_S2 @totalItems
+  867 sensor *tmp352 *tmp284 @totalItems
   868 op equal *tmp349 *tmp352 0
   869 label *label218
   870 set .SUPPLY_S_FIRST *tmp349
 
   873 # "Function: inline def printDomeStatus(in item, in text)"
   874 set :printDomeStatus.1:item @phase-fabric
   875 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
-    * print :printDomeStatus.1:text
-    * sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
+  876 print "\n[green]Phase fabric[] status:\n"
+  877 sensor :printDomeStatus.1:level .DOME @phase-fabric
   878 jump *label220 lessThanEq :printDomeStatus.1:level 3
   879 print "  dome:  [green]"
   880 print :printDomeStatus.1:level
 
   896 set :processUnit.2:group .GROUP1
   897 set :processUnit.2:supply .SUPPLY_P_FIRST
   898 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * jump *label224 equal :rebindUnit.6:currentUnit null
-    * ubind :rebindUnit.6:currentUnit
+  899 set :rebindUnit.6:currentUnit .UNIT_P1
+  900 jump *label224 equal :processUnit.2:unit null
+  901 ubind :processUnit.2:unit
   902 sensor *tmp362 @unit @dead
   903 op strictEqual *tmp363 *tmp362 0
   904 sensor *tmp364 @unit @controller
 
   910 label *label227
   911 label *label224
   912 label *label225
-    * ubind .TYPE
+  913 ubind *tmp3
   914 set :rebindUnit.6:firstUnit @unit
   915 jump *label228 equal :rebindUnit.6:firstUnit null
   916 label *label230
 
   919 jump *label223 always
   920 label *label233
   921 label *label234
-    * ubind .TYPE
+  922 ubind *tmp3
   923 label *label231
   924 op notEqual *tmp374 @unit :rebindUnit.6:firstUnit
   925 sensor *tmp375 :rebindUnit.6:firstUnit @dead
 
   940 op or *tmp381 *tmp379 *tmp380
   941 jump *label235 equal *tmp381 false
   942 sensor *tmp383 @unit @firstItem
-    * jump *label237 notEqual *tmp383 :processUnit.2:item
+  943 jump *label237 notEqual *tmp383 @phase-fabric
   944 set :processUnit.2:state 3
   945 jump *label238 always
   946 label *label237
 
   963 jump *label243 notEqual :processUnit.2:state 2
   964 ucontrol within .CORE_X .CORE_Y 8 *tmp393
   965 jump *label245 equal *tmp393 false
-    * ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
+  966 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
   967 sensor *tmp395 @unit @totalItems
   968 jump *label247 lessThan *tmp395 .UNIT_CAPACITY
   969 ucontrol approach .DOME_X .DOME_Y 6
 
   989 jump *label249 notEqual :processUnit.2:state 3
   990 ucontrol within .DOME_X .DOME_Y 8 *tmp407
   991 jump *label251 equal *tmp407 false
-    * jump *label253 equal :processUnit.2:supply false
+  992 jump *label253 equal .SUPPLY_P_FIRST false
   993 ucontrol itemDrop .DOME .UNIT_CAPACITY
   994 set :processUnit.2:msg ", supplying\n"
   995 jump *label254 always
 
  1020 ucontrol flag :processUnit.2:state
  1021 sensor *tmp420 @unit @totalItems
  1022 print "  "
-    * print :processUnit.2:group
+ 1023 print .GROUP1
  1024 print ":"
  1025 print " ["
-    * print :processUnit.2:color
+ 1026 print "gold"
  1027 print "]"
  1028 print *tmp420
  1029 print "["
 
  1040 label *label258
  1041 set *tmp358 @unit
  1042 jump *label222 always
-    * set *tmp358 null
  1043 label *label222
  1044 set .UNIT_P1 *tmp358
-    * jump *label259 equal .FOUR_UNITS false
+ 1045 jump *label259 equal *tmp139 false
  1046 op equal *tmp424 .SUPPLY_P_FIRST false
  1047 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
  1048 set :processUnit.3:unit .UNIT_P2
 
  1050 set :processUnit.3:group .GROUP2
  1051 set :processUnit.3:supply *tmp424
  1052 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * jump *label263 equal :rebindUnit.7:currentUnit null
-    * ubind :rebindUnit.7:currentUnit
+ 1053 set :rebindUnit.7:currentUnit .UNIT_P2
+ 1054 jump *label263 equal :processUnit.3:unit null
+ 1055 ubind :processUnit.3:unit
  1056 sensor *tmp429 @unit @dead
  1057 op strictEqual *tmp430 *tmp429 0
  1058 sensor *tmp431 @unit @controller
 
  1064 label *label266
  1065 label *label263
  1066 label *label264
-    * ubind .TYPE
+ 1067 ubind *tmp3
  1068 set :rebindUnit.7:firstUnit @unit
  1069 jump *label267 equal :rebindUnit.7:firstUnit null
  1070 label *label269
 
  1073 jump *label262 always
  1074 label *label272
  1075 label *label273
-    * ubind .TYPE
+ 1076 ubind *tmp3
  1077 label *label270
  1078 op notEqual *tmp441 @unit :rebindUnit.7:firstUnit
  1079 sensor *tmp442 :rebindUnit.7:firstUnit @dead
 
  1094 op or *tmp448 *tmp446 *tmp447
  1095 jump *label274 equal *tmp448 false
  1096 sensor *tmp450 @unit @firstItem
-    * jump *label276 notEqual *tmp450 :processUnit.3:item
+ 1097 jump *label276 notEqual *tmp450 @phase-fabric
  1098 set :processUnit.3:state 3
  1099 jump *label277 always
  1100 label *label276
 
  1117 jump *label282 notEqual :processUnit.3:state 2
  1118 ucontrol within .CORE_X .CORE_Y 8 *tmp460
  1119 jump *label284 equal *tmp460 false
-    * ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
+ 1120 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1121 sensor *tmp462 @unit @totalItems
  1122 jump *label286 lessThan *tmp462 .UNIT_CAPACITY
  1123 ucontrol approach .DOME_X .DOME_Y 6
 
  1143 jump *label288 notEqual :processUnit.3:state 3
  1144 ucontrol within .DOME_X .DOME_Y 8 *tmp474
  1145 jump *label290 equal *tmp474 false
-    * jump *label292 equal :processUnit.3:supply false
+ 1146 jump *label292 equal *tmp424 false
  1147 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1148 set :processUnit.3:msg ", supplying\n"
  1149 jump *label293 always
 
  1174 ucontrol flag :processUnit.3:state
  1175 sensor *tmp487 @unit @totalItems
  1176 print "  "
-    * print :processUnit.3:group
+ 1177 print .GROUP2
  1178 print ":"
  1179 print " ["
-    * print :processUnit.3:color
+ 1180 print "gold"
  1181 print "]"
  1182 print *tmp487
  1183 print "["
 
  1194 label *label297
  1195 set *tmp425 @unit
  1196 jump *label261 always
-    * set *tmp425 null
  1197 label *label261
  1198 set .UNIT_P2 *tmp425
  1199 jump *label298 equal .SUPPLY_P_FIRST false
-    * sensor *tmp491 .UNIT_P1 @totalItems
+ 1200 sensor *tmp491 *tmp358 @totalItems
  1201 op greaterThan *tmp490 *tmp491 0
  1202 jump *label299 always
  1203 label *label298
-    * sensor *tmp493 .UNIT_P2 @totalItems
+ 1204 sensor *tmp493 *tmp425 @totalItems
  1205 op equal *tmp490 *tmp493 0
  1206 label *label299
  1207 set .SUPPLY_P_FIRST *tmp490
 
  1215 print " "
  1216 print "ms"
  1217 printflush message1
-    * op notEqual *tmp497 .TYPE UNIT_TYPE
+ 1218 op notEqual *tmp497 *tmp3 UNIT_TYPE
  1219 op greaterThan *tmp498 :unitCheck @time
  1220 op land *tmp499 *tmp497 *tmp498
  1221 jump *label300 equal *tmp499 false
 
  1223 set :areUnitsAvailable.2:type UNIT_TYPE
  1224 set :areUnitsAvailable.2:output false
  1225 set :areUnitsAvailable.2:needed 0
-    * set :areUnitsAvailable.2:occupied :areUnitsAvailable.2:needed
-    * set :areUnitsAvailable.2:free :areUnitsAvailable.2:occupied
-    * ubind :areUnitsAvailable.2:type
+ 1226 set :areUnitsAvailable.2:occupied 0
+ 1227 set :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1228 ubind UNIT_TYPE
  1229 set :areUnitsAvailable.2:firstUnit @unit
  1230 jump *label303 equal :areUnitsAvailable.2:firstUnit null
  1231 # "Function: inline def needsFourUnits(in unit)"
  1232 set :needsFourUnits.3:unit @unit
  1233 op sub *tmp506 .DOME_X .CORE_X
  1234 op sub *tmp507 .DOME_Y .CORE_Y
-    * op len *tmp508 *tmp506 *tmp507
-    * op mul *tmp509 2 *tmp508
+ 1235 op len *tmp508 *tmp140 *tmp141
+ 1236 op mul *tmp509 2 *tmp142
  1237 sensor *tmp510 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp509 *tmp510
+ 1238 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1239 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1240 jump *label305 always
-    * set *tmp505 null
  1241 label *label305
  1242 jump *label306 equal *tmp505 false
  1243 set *tmp513 4
 
  1254 op or *tmp518 *tmp515 *tmp517
  1255 jump *label311 equal *tmp518 false
  1256 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label313 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1257 jump *label313 lessThan :areUnitsAvailable.2:free *tmp513
  1258 set *tmp501 true
  1259 jump *label302 always
  1260 label *label313
 
  1263 label *label311
  1264 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1265 label *label312
-    * ubind :areUnitsAvailable.2:type
+ 1266 ubind UNIT_TYPE
  1267 label *label309
  1268 op notEqual *tmp522 @unit :areUnitsAvailable.2:firstUnit
  1269 sensor *tmp523 :areUnitsAvailable.2:firstUnit @dead
 
  1273 label *label310
  1274 label *label303
  1275 label *label304
-    * jump *label315 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+ 1276 jump *label315 equal false false
+ 1277 print UNIT_TYPE
  1278 print ":"
  1279 print " occupied: "
  1280 print :areUnitsAvailable.2:occupied
 
  1291 label *label316
  1292 set *tmp501 false
  1293 jump *label302 always
-    * set *tmp501 null
  1294 label *label302
  1295 jump *label319 equal *tmp501 false
  1296 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-42 instructions):
 
     3 remark "Do not modify anything below this line."
     4 set .DOME_Y null
     5 set .DOME_X null
-    * set .CORE_Y .DOME_Y
-    * set .CORE_X .DOME_X
+    6 set .CORE_Y null
+    7 set .CORE_X null
     8 set .DOME dome1
     9 label *label0
    10 jump *label2 notEqual .DOME null
 
    31 remark "chooseUnitType: "
    32 remark UNIT_TYPE
    33 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.0:type UNIT_TYPE
-    * set :areUnitsAvailable.0:output true
    34 set :areUnitsAvailable.0:needed 0
    35 set :areUnitsAvailable.0:occupied 0
-    * set :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   36 set :areUnitsAvailable.0:free 0
    37 ubind UNIT_TYPE
    38 set :areUnitsAvailable.0:firstUnit @unit
    39 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    40 # "Function: inline def needsFourUnits(in unit)"
    41 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 .DOME_Y .CORE_Y
-    * op sub *tmp10 null .DOME_X
-    * op len *tmp11 *tmp9 *tmp10
+   42 op sub *tmp9 null .DOME_Y
+   43 op sub *tmp10 null null
+   44 op len *tmp11 *tmp9 0
    45 op mul *tmp12 2 *tmp11
    46 sensor *tmp13 :needsFourUnits.0:unit @speed
    47 op div :needsFourUnits.0:travel_time *tmp12 *tmp13
 
   128 remark "chooseUnitType: "
   129 remark :chooseUnitType.0:type
   130 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:type :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:output true
   131 set :areUnitsAvailable.1:needed 0
   132 set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  133 set :areUnitsAvailable.1:free 0
   134 ubind :chooseUnitType.0:type
   135 set :areUnitsAvailable.1:firstUnit @unit
   136 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   137 # "Function: inline def needsFourUnits(in unit)"
   138 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 .DOME_Y .CORE_Y
-    * op sub *tmp42 null .DOME_X
-    * op len *tmp43 *tmp41 *tmp42
+  139 op sub *tmp41 null .DOME_Y
+  140 op sub *tmp42 null null
+  141 op len *tmp43 *tmp41 0
   142 op mul *tmp44 2 *tmp43
   143 sensor *tmp45 :needsFourUnits.1:unit @speed
   144 op div :needsFourUnits.1:travel_time *tmp44 *tmp45
 
   217 label *label9
   218 set *tmp3 null
   219 label *label6
-    * set .TYPE *tmp3
   220 print "[gold]Binding units..."
   221 printflush message1
   222 # "Function: inline def rebindUnits()"
   223 set .UNIT_P2 null
   224 set .UNIT_S2 null
-    * set .UNIT_P1 .UNIT_P2
-    * set .UNIT_S1 .UNIT_S2
+  225 set .UNIT_P1 null
+  226 set .UNIT_S1 null
   227 set :rebindUnits.0:count 0
   228 ubind *tmp3
   229 set :rebindUnits.0:firstUnit @unit
 
   258 # "Function: inline def acquireUnit(in currentUnit)"
   259 set :acquireUnit.0:currentUnit .UNIT_S1
   260 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.0:currentUnit .UNIT_S1
-    * jump *label71 equal :acquireUnit.0:currentUnit null
-    * ubind :acquireUnit.0:currentUnit
+  261 jump *label71 equal .UNIT_S1 null
+  262 ubind .UNIT_S1
   263 sensor *tmp83 @unit @dead
   264 op strictEqual *tmp84 *tmp83 0
   265 sensor *tmp85 @unit @controller
 
   300 # "Function: inline def acquireUnit(in currentUnit)"
   301 set :acquireUnit.1:currentUnit .UNIT_P1
   302 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit .UNIT_P1
-    * jump *label84 equal :acquireUnit.1:currentUnit null
-    * ubind :acquireUnit.1:currentUnit
+  303 jump *label84 equal .UNIT_P1 null
+  304 ubind .UNIT_P1
   305 sensor *tmp103 @unit @dead
   306 op strictEqual *tmp104 *tmp103 0
   307 sensor *tmp105 @unit @controller
 
   347 jump *label95 equal *tmp123 false
   348 set :u *tmp79
   349 set .UNIT_S1 *tmp99
-    * set .UNIT_P1 :u
+  350 set .UNIT_P1 *tmp79
   351 label *label95
   352 label *label96
   353 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   370 sensor .DOME_X .DOME @x
   371 sensor .DOME_Y .DOME @y
   372 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.2:unit .UNIT_S1
   373 op sub *tmp140 .DOME_X .CORE_X
   374 op sub *tmp141 .DOME_Y .CORE_Y
   375 op len *tmp142 *tmp140 *tmp141
 
   379 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   380 jump *label102 always
   381 label *label102
-    * set .FOUR_UNITS *tmp139
   382 jump *label103 equal *tmp139 false
   383 # "Function: inline def acquireUnit(in currentUnit)"
   384 set :acquireUnit.2:currentUnit .UNIT_S2
   385 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit .UNIT_S2
-    * jump *label107 equal :acquireUnit.2:currentUnit null
-    * ubind :acquireUnit.2:currentUnit
+  386 jump *label107 equal .UNIT_S2 null
+  387 ubind .UNIT_S2
   388 sensor *tmp152 @unit @dead
   389 op strictEqual *tmp153 *tmp152 0
   390 sensor *tmp154 @unit @controller
 
   425 # "Function: inline def acquireUnit(in currentUnit)"
   426 set :acquireUnit.3:currentUnit .UNIT_P2
   427 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit .UNIT_P2
-    * jump *label120 equal :acquireUnit.3:currentUnit null
-    * ubind :acquireUnit.3:currentUnit
+  428 jump *label120 equal .UNIT_P2 null
+  429 ubind .UNIT_P2
   430 sensor *tmp172 @unit @dead
   431 op strictEqual *tmp173 *tmp172 0
   432 sensor *tmp174 @unit @controller
 
   483 jump *label133 equal *tmp198 false
   484 set :u *tmp148
   485 set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P2 :u
+  486 set .UNIT_P2 *tmp148
   487 label *label133
   488 label *label134
   489 set .GROUP1 "unit  1"
 
   504 sensor *tmp202 .UNIT_S2 @totalItems
   505 op lessThan *tmp203 *tmp201 *tmp202
   506 op or .SUPPLY_S_FIRST *tmp200 *tmp203
-    * op equal *tmp205 *tmp139 false
   507 sensor *tmp206 .UNIT_P1 @totalItems
   508 sensor *tmp207 .UNIT_P2 @totalItems
   509 op lessThan *tmp208 *tmp206 *tmp207
 
   522 print "]"
   523 print "\n"
   524 # "Function: inline def printDomeStatus(in item, in text)"
-    * set :printDomeStatus.0:item @silicon
-    * set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   525 print "\n[green]Silicon[] status:\n"
   526 sensor :printDomeStatus.0:level .DOME @silicon
   527 jump *label139 lessThanEq :printDomeStatus.0:level 3
 
   541 label *label138
   542 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
   543 set :processUnit.0:unit .UNIT_S1
-    * set :processUnit.0:item @silicon
-    * set :processUnit.0:group .GROUP1
-    * set :processUnit.0:supply .SUPPLY_S_FIRST
   544 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit .UNIT_S1
-    * jump *label143 equal :processUnit.0:unit null
-    * ubind :processUnit.0:unit
+  545 jump *label143 equal .UNIT_S1 null
+  546 ubind .UNIT_S1
   547 sensor *tmp221 @unit @dead
   548 op strictEqual *tmp222 *tmp221 0
   549 sensor *tmp223 @unit @controller
 
   579 set :processUnit.0:msg ""
   580 sensor :processUnit.0:state @unit @flag
   581 set :processUnit.0:distance -1
-    * set :processUnit.0:color "gold"
   582 op lessThan *tmp238 :processUnit.0:state 2
   583 op greaterThan *tmp239 :processUnit.0:state 3
   584 op or *tmp240 *tmp238 *tmp239
 
   690 op equal *tmp283 .SUPPLY_S_FIRST false
   691 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
   692 set :processUnit.1:unit .UNIT_S2
-    * set :processUnit.1:item @silicon
-    * set :processUnit.1:group .GROUP2
-    * set :processUnit.1:supply *tmp283
   693 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit .UNIT_S2
-    * jump *label182 equal :processUnit.1:unit null
-    * ubind :processUnit.1:unit
+  694 jump *label182 equal .UNIT_S2 null
+  695 ubind .UNIT_S2
   696 sensor *tmp288 @unit @dead
   697 op strictEqual *tmp289 *tmp288 0
   698 sensor *tmp290 @unit @controller
 
   728 set :processUnit.1:msg ""
   729 sensor :processUnit.1:state @unit @flag
   730 set :processUnit.1:distance -1
-    * set :processUnit.1:color "gold"
   731 op lessThan *tmp305 :processUnit.1:state 2
   732 op greaterThan *tmp306 :processUnit.1:state 3
   733 op or *tmp307 *tmp305 *tmp306
 
   847 label *label178
   848 label *label179
   849 # "Function: inline def printDomeStatus(in item, in text)"
-    * set :printDomeStatus.1:item @phase-fabric
-    * set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   850 print "\n[green]Phase fabric[] status:\n"
   851 sensor :printDomeStatus.1:level .DOME @phase-fabric
   852 jump *label220 lessThanEq :printDomeStatus.1:level 3
 
   866 label *label219
   867 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
   868 set :processUnit.2:unit .UNIT_P1
-    * set :processUnit.2:item @phase-fabric
-    * set :processUnit.2:group .GROUP1
-    * set :processUnit.2:supply .SUPPLY_P_FIRST
   869 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit .UNIT_P1
-    * jump *label224 equal :processUnit.2:unit null
-    * ubind :processUnit.2:unit
+  870 jump *label224 equal .UNIT_P1 null
+  871 ubind .UNIT_P1
   872 sensor *tmp362 @unit @dead
   873 op strictEqual *tmp363 *tmp362 0
   874 sensor *tmp364 @unit @controller
 
   904 set :processUnit.2:msg ""
   905 sensor :processUnit.2:state @unit @flag
   906 set :processUnit.2:distance -1
-    * set :processUnit.2:color "gold"
   907 op lessThan *tmp379 :processUnit.2:state 2
   908 op greaterThan *tmp380 :processUnit.2:state 3
   909 op or *tmp381 *tmp379 *tmp380
 
  1015 op equal *tmp424 .SUPPLY_P_FIRST false
  1016 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
  1017 set :processUnit.3:unit .UNIT_P2
-    * set :processUnit.3:item @phase-fabric
-    * set :processUnit.3:group .GROUP2
-    * set :processUnit.3:supply *tmp424
  1018 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit .UNIT_P2
-    * jump *label263 equal :processUnit.3:unit null
-    * ubind :processUnit.3:unit
+ 1019 jump *label263 equal .UNIT_P2 null
+ 1020 ubind .UNIT_P2
  1021 sensor *tmp429 @unit @dead
  1022 op strictEqual *tmp430 *tmp429 0
  1023 sensor *tmp431 @unit @controller
 
  1053 set :processUnit.3:msg ""
  1054 sensor :processUnit.3:state @unit @flag
  1055 set :processUnit.3:distance -1
-    * set :processUnit.3:color "gold"
  1056 op lessThan *tmp446 :processUnit.3:state 2
  1057 op greaterThan *tmp447 :processUnit.3:state 3
  1058 op or *tmp448 *tmp446 *tmp447
 
  1184 op land *tmp499 *tmp497 *tmp498
  1185 jump *label300 equal *tmp499 false
  1186 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
  1187 set :areUnitsAvailable.2:needed 0
  1188 set :areUnitsAvailable.2:occupied 0
-    * set :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1189 set :areUnitsAvailable.2:free 0
  1190 ubind UNIT_TYPE
  1191 set :areUnitsAvailable.2:firstUnit @unit
  1192 jump *label303 equal :areUnitsAvailable.2:firstUnit null
  1193 # "Function: inline def needsFourUnits(in unit)"
  1194 set :needsFourUnits.3:unit @unit
-    * op sub *tmp506 .DOME_X .CORE_X
-    * op sub *tmp507 .DOME_Y .CORE_Y
-    * op len *tmp508 *tmp140 *tmp141
-    * op mul *tmp509 2 *tmp142
  1195 sensor *tmp510 :needsFourUnits.3:unit @speed
  1196 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1197 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-15 instructions):
 
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
     4 set .DOME_Y null
-    * set .DOME_X null
-    * set .CORE_Y null
-    * set .CORE_X null
     5 set .DOME dome1
     6 label *label0
     7 jump *label2 notEqual .DOME null
 
    36 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    37 # "Function: inline def needsFourUnits(in unit)"
    38 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 null .DOME_Y
-    * op sub *tmp10 null null
-    * op len *tmp11 *tmp9 0
-    * op mul *tmp12 2 *tmp11
+   39 op sub *tmp9 null null
+   40 op len *tmp11 0 0
+   41 op mul *tmp12 2 0
    42 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * op div :needsFourUnits.0:travel_time *tmp12 *tmp13
+   43 op div :needsFourUnits.0:travel_time 0 *tmp13
    44 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    45 jump *label13 always
    46 label *label13
 
   132 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   133 # "Function: inline def needsFourUnits(in unit)"
   134 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 null .DOME_Y
-    * op sub *tmp42 null null
-    * op len *tmp43 *tmp41 0
-    * op mul *tmp44 2 *tmp43
+  135 op sub *tmp41 null null
+  136 op len *tmp43 0 0
+  137 op mul *tmp44 2 0
   138 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp44 *tmp45
+  139 op div :needsFourUnits.1:travel_time 0 *tmp45
   140 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   141 jump *label43 always
   142 label *label43
 
   251 label *label64
   252 label *label59
   253 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.0:currentUnit .UNIT_S1
   254 # "Function: inline def rebindUnit(in currentUnit)"
   255 jump *label71 equal .UNIT_S1 null
   256 ubind .UNIT_S1
 
   292 label *label69
   293 set .UNIT_S1 *tmp79
   294 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.1:currentUnit .UNIT_P1
   295 # "Function: inline def rebindUnit(in currentUnit)"
   296 jump *label84 equal .UNIT_P1 null
   297 ubind .UNIT_P1
 
   338 op equal *tmp122 *tmp121 @silicon
   339 op or *tmp123 *tmp120 *tmp122
   340 jump *label95 equal *tmp123 false
-    * set :u *tmp79
   341 set .UNIT_S1 *tmp99
   342 set .UNIT_P1 *tmp79
   343 label *label95
 
   373 label *label102
   374 jump *label103 equal *tmp139 false
   375 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.2:currentUnit .UNIT_S2
   376 # "Function: inline def rebindUnit(in currentUnit)"
   377 jump *label107 equal .UNIT_S2 null
   378 ubind .UNIT_S2
 
   414 label *label105
   415 set .UNIT_S2 *tmp148
   416 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.3:currentUnit .UNIT_P2
   417 # "Function: inline def rebindUnit(in currentUnit)"
   418 jump *label120 equal .UNIT_P2 null
   419 ubind .UNIT_P2
 
   471 op equal *tmp197 *tmp196 @silicon
   472 op or *tmp198 *tmp195 *tmp197
   473 jump *label133 equal *tmp198 false
-    * set :u *tmp148
   474 set .UNIT_S2 .UNIT_P2
   475 set .UNIT_P2 *tmp148
   476 label *label133
 
   529 label *label140
   530 label *label138
   531 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
-    * set :processUnit.0:unit .UNIT_S1
   532 # "Function: inline def rebindUnit(in currentUnit)"
   533 jump *label143 equal .UNIT_S1 null
   534 ubind .UNIT_S1
 
   677 jump *label178 equal *tmp139 false
   678 op equal *tmp283 .SUPPLY_S_FIRST false
   679 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
-    * set :processUnit.1:unit .UNIT_S2
   680 # "Function: inline def rebindUnit(in currentUnit)"
   681 jump *label182 equal .UNIT_S2 null
   682 ubind .UNIT_S2
 
   852 label *label221
   853 label *label219
   854 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
-    * set :processUnit.2:unit .UNIT_P1
   855 # "Function: inline def rebindUnit(in currentUnit)"
   856 jump *label224 equal .UNIT_P1 null
   857 ubind .UNIT_P1
 
  1000 jump *label259 equal *tmp139 false
  1001 op equal *tmp424 .SUPPLY_P_FIRST false
  1002 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
-    * set :processUnit.3:unit .UNIT_P2
  1003 # "Function: inline def rebindUnit(in currentUnit)"
  1004 jump *label263 equal .UNIT_P2 null
  1005 ubind .UNIT_P2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-7 instructions):
 
     1 remark "If no units of this type exist, we'll try using other types."
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
-    * set .DOME_Y null
     4 set .DOME dome1
     5 label *label0
     6 jump *label2 notEqual .DOME null
 
    35 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    36 # "Function: inline def needsFourUnits(in unit)"
    37 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 null null
-    * op len *tmp11 0 0
-    * op mul *tmp12 2 0
    38 sensor *tmp13 :needsFourUnits.0:unit @speed
    39 op div :needsFourUnits.0:travel_time 0 *tmp13
    40 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
 
   128 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   129 # "Function: inline def needsFourUnits(in unit)"
   130 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 null null
-    * op len *tmp43 0 0
-    * op mul *tmp44 2 0
   131 sensor *tmp45 :needsFourUnits.1:unit @speed
   132 op div :needsFourUnits.1:travel_time 0 *tmp45
   133 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     4 set .DOME dome1
     5 label *label0
     6 jump *label2 notEqual .DOME null
+    7 label *label321
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label1
-    * jump *label0 always
+   12 jump *label321 equal .DOME null
    13 label *label2
    14 label *label3
    15 sensor *tmp1 switch1 @enabled

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    34 ubind UNIT_TYPE
    35 set :areUnitsAvailable.0:firstUnit @unit
    36 jump *label11 equal :areUnitsAvailable.0:firstUnit null
+   37 set *tmp16 2
    38 # "Function: inline def needsFourUnits(in unit)"
    39 set :needsFourUnits.0:unit @unit
    40 sensor *tmp13 :needsFourUnits.0:unit @speed
 
    42 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    43 jump *label13 always
    44 label *label13
-    * jump *label14 equal *tmp8 false
+   45 jump *label15 equal *tmp8 false
    46 set *tmp16 4
    47 jump *label15 always
-    * label *label14
-    * set *tmp16 2
    48 label *label15
    49 set :areUnitsAvailable.0:needed *tmp16
    50 label *label16
 
   126 ubind :chooseUnitType.0:type
   127 set :areUnitsAvailable.1:firstUnit @unit
   128 jump *label41 equal :areUnitsAvailable.1:firstUnit null
+  129 set *tmp48 2
   130 # "Function: inline def needsFourUnits(in unit)"
   131 set :needsFourUnits.1:unit @unit
   132 sensor *tmp45 :needsFourUnits.1:unit @speed
 
   134 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   135 jump *label43 always
   136 label *label43
-    * jump *label44 equal *tmp40 false
+  137 jump *label45 equal *tmp40 false
   138 set *tmp48 4
   139 jump *label45 always
-    * label *label44
-    * set *tmp48 2
   140 label *label45
   141 set :areUnitsAvailable.1:needed *tmp48
   142 label *label46
 
   816 set .UNIT_S2 *tmp284
   817 jump *label217 equal .SUPPLY_S_FIRST false
   818 sensor *tmp350 *tmp217 @totalItems
-    * op greaterThan *tmp349 *tmp350 0
+  819 op greaterThan .SUPPLY_S_FIRST *tmp350 0
   820 jump *label218 always
   821 label *label217
   822 sensor *tmp352 *tmp284 @totalItems
-    * op equal *tmp349 *tmp352 0
+  823 op equal .SUPPLY_S_FIRST *tmp352 0
   824 label *label218
-    * set .SUPPLY_S_FIRST *tmp349
   825 label *label178
   826 label *label179
   827 # "Function: inline def printDomeStatus(in item, in text)"
 
  1138 set .UNIT_P2 *tmp425
  1139 jump *label298 equal .SUPPLY_P_FIRST false
  1140 sensor *tmp491 *tmp358 @totalItems
-    * op greaterThan *tmp490 *tmp491 0
+ 1141 op greaterThan .SUPPLY_P_FIRST *tmp491 0
  1142 jump *label299 always
  1143 label *label298
  1144 sensor *tmp493 *tmp425 @totalItems
-    * op equal *tmp490 *tmp493 0
+ 1145 op equal .SUPPLY_P_FIRST *tmp493 0
  1146 label *label299
-    * set .SUPPLY_P_FIRST *tmp490
  1147 label *label259
  1148 label *label260
  1149 op sub *tmp495 @time :start
 
  1165 ubind UNIT_TYPE
  1166 set :areUnitsAvailable.2:firstUnit @unit
  1167 jump *label303 equal :areUnitsAvailable.2:firstUnit null
+ 1168 set *tmp513 2
  1169 # "Function: inline def needsFourUnits(in unit)"
  1170 set :needsFourUnits.3:unit @unit
  1171 sensor *tmp510 :needsFourUnits.3:unit @speed
 
  1173 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1174 jump *label305 always
  1175 label *label305
-    * jump *label306 equal *tmp505 false
+ 1176 jump *label307 equal *tmp505 false
  1177 set *tmp513 4
  1178 jump *label307 always
-    * label *label306
-    * set *tmp513 2
  1179 label *label307
  1180 set :areUnitsAvailable.2:needed *tmp513
  1181 label *label308

Modifications by Replicate loop condition at line 44:1 (+1 instructions):
 
    14 label *label3
    15 sensor *tmp1 switch1 @enabled
    16 jump *label5 notEqual *tmp1 false
+   17 label *label322
    18 print "[coral]Activate switch to begin supplying overdrive dome..."
    19 print "\n"
    20 printflush message1
    21 label *label4
-    * jump *label3 always
+   22 sensor *tmp1 switch1 @enabled
+   23 jump *label322 equal *tmp1 false
    24 label *label5
    25 # "Function: inline def chooseUnitType()"
    26 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 remark "Do not modify anything below this line."
     4 set .DOME dome1
     5 label *label0
-    * jump *label2 notEqual .DOME null
+    6 jump *label2 notEqual dome1 null
     7 label *label321
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label1
-    * jump *label321 equal .DOME null
+   12 jump *label321 equal dome1 null
    13 label *label2
    14 label *label3
    15 sensor *tmp1 switch1 @enabled

Modifications by Replicate loop condition at line 127:1 (+1 instructions):
 
   495 label *label135
   496 sensor *tmp211 switch1 @enabled
   497 jump *label137 equal *tmp211 false
+  498 label *label323
   499 set :start @time
   500 print " === [gold]Supplying Overdrive Dome[] === "
   501 print "\n"
 
  1235 label *label300
  1236 label *label301
  1237 label *label136
-    * jump *label135 always
+ 1238 sensor *tmp211 switch1 @enabled
+ 1239 jump *label323 notEqual *tmp211 false
  1240 label *label137
  1241 end

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    76 label *label18
    77 label *label11
    78 label *label12
-    * jump *label23 equal true false
    79 print UNIT_TYPE
    80 print ":"
    81 print " occupied: "
 
   167 label *label48
   168 label *label41
   169 label *label42
-    * jump *label53 equal true false
   170 print :chooseUnitType.0:type
   171 print ":"
   172 print " occupied: "
 
  1206 label *label310
  1207 label *label303
  1208 label *label304
-    * jump *label315 equal false false
+ 1209 jump *label315 always
  1210 print UNIT_TYPE
  1211 print ":"
  1212 print " occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-18 instructions):
 
    42 sensor *tmp13 :needsFourUnits.0:unit @speed
    43 op div :needsFourUnits.0:travel_time 0 *tmp13
    44 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
-    * jump *label13 always
    45 label *label13
    46 jump *label15 equal *tmp8 false
    47 set *tmp16 4
-    * jump *label15 always
    48 label *label15
    49 set :areUnitsAvailable.0:needed *tmp16
    50 label *label16
 
    90 label *label23
    91 label *label24
    92 set *tmp4 false
-    * jump *label10 always
    93 label *label10
    94 jump *label27 equal *tmp4 false
    95 set *tmp3 UNIT_TYPE
 
   130 sensor *tmp45 :needsFourUnits.1:unit @speed
   131 op div :needsFourUnits.1:travel_time 0 *tmp45
   132 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
-    * jump *label43 always
   133 label *label43
   134 jump *label45 equal *tmp40 false
   135 set *tmp48 4
-    * jump *label45 always
   136 label *label45
   137 set :areUnitsAvailable.1:needed *tmp48
   138 label *label46
 
   178 label *label53
   179 label *label54
   180 set *tmp36 false
-    * jump *label40 always
   181 label *label40
   182 jump *label57 equal *tmp36 false
   183 printflush null
 
   274 label *label70
   275 ucontrol flag 1
   276 set *tmp79 @unit
-    * jump *label69 always
   277 label *label69
   278 set .UNIT_S1 *tmp79
   279 # "Function: inline def acquireUnit(in currentUnit)"
 
   314 label *label83
   315 ucontrol flag 1
   316 set *tmp99 @unit
-    * jump *label82 always
   317 label *label82
   318 set .UNIT_P1 *tmp99
   319 sensor *tmp119 *tmp79 @firstItem
 
   353 sensor *tmp144 .UNIT_S1 @speed
   354 op div :needsFourUnits.2:travel_time *tmp143 .SPEED
   355 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
-    * jump *label102 always
   356 label *label102
   357 jump *label103 equal *tmp139 false
   358 # "Function: inline def acquireUnit(in currentUnit)"
 
   393 label *label106
   394 ucontrol flag 1
   395 set *tmp148 @unit
-    * jump *label105 always
   396 label *label105
   397 set .UNIT_S2 *tmp148
   398 # "Function: inline def acquireUnit(in currentUnit)"
 
   433 label *label119
   434 ucontrol flag 1
   435 set *tmp168 @unit
-    * jump *label118 always
   436 label *label118
   437 set .UNIT_P2 *tmp168
   438 sensor *tmp188 .UNIT_S1 @firstItem
 
   653 print :processUnit.0:msg
   654 label *label177
   655 set *tmp217 @unit
-    * jump *label141 always
   656 label *label141
   657 set .UNIT_S1 *tmp217
   658 jump *label178 equal *tmp139 false
 
   800 print :processUnit.1:msg
   801 label *label216
   802 set *tmp284 @unit
-    * jump *label180 always
   803 label *label180
   804 set .UNIT_S2 *tmp284
   805 jump *label217 equal .SUPPLY_S_FIRST false
 
   973 print :processUnit.2:msg
   974 label *label258
   975 set *tmp358 @unit
-    * jump *label222 always
   976 label *label222
   977 set .UNIT_P1 *tmp358
   978 jump *label259 equal *tmp139 false
 
  1120 print :processUnit.3:msg
  1121 label *label297
  1122 set *tmp425 @unit
-    * jump *label261 always
  1123 label *label261
  1124 set .UNIT_P2 *tmp425
  1125 jump *label298 equal .SUPPLY_P_FIRST false
 
  1157 sensor *tmp510 :needsFourUnits.3:unit @speed
  1158 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1159 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
-    * jump *label305 always
  1160 label *label305
  1161 jump *label307 equal *tmp505 false
  1162 set *tmp513 4
-    * jump *label307 always
  1163 label *label307
  1164 set :areUnitsAvailable.2:needed *tmp513
  1165 label *label308
 
  1206 label *label315
  1207 label *label316
  1208 set *tmp501 false
-    * jump *label302 always
  1209 label *label302
  1210 jump *label319 equal *tmp501 false
  1211 end

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    40 # "Function: inline def needsFourUnits(in unit)"
    41 set :needsFourUnits.0:unit @unit
    42 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * op div :needsFourUnits.0:travel_time 0 *tmp13
+   43 set :needsFourUnits.0:travel_time 0
    44 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    45 label *label13
    46 jump *label15 equal *tmp8 false
 
   128 # "Function: inline def needsFourUnits(in unit)"
   129 set :needsFourUnits.1:unit @unit
   130 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time 0 *tmp45
+  131 set :needsFourUnits.1:travel_time 0
   132 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   133 label *label43
   134 jump *label45 equal *tmp40 false

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   441 op notEqual *tmp191 *tmp190 @phase-fabric
   442 op land *tmp192 *tmp189 *tmp191
   443 jump *label131 equal *tmp192 false
-    * set :u .UNIT_S1
+  444 set .UNIT_P2 .UNIT_S1
   445 set .UNIT_S1 *tmp168
-    * set .UNIT_P2 :u
   446 label *label131
   447 label *label132
   448 sensor *tmp194 *tmp148 @firstItem

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-2 instructions):
 
    41 set :needsFourUnits.0:unit @unit
    42 sensor *tmp13 :needsFourUnits.0:unit @speed
    43 set :needsFourUnits.0:travel_time 0
-    * op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
+   44 op greaterThanEq *tmp8 0 47
    45 label *label13
-    * jump *label15 equal *tmp8 false
+   46 jump *label15 equal false false
    47 set *tmp16 4
    48 label *label15
-    * set :areUnitsAvailable.0:needed *tmp16
+   49 set :areUnitsAvailable.0:needed 2
    50 label *label16
    51 sensor *tmp17 @unit @controlled
    52 op equal *tmp18 *tmp17 0
 
    55 op or *tmp21 *tmp18 *tmp20
    56 jump *label19 equal *tmp21 false
    57 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label21 lessThan :areUnitsAvailable.0:free *tmp16
+   58 jump *label21 lessThan :areUnitsAvailable.0:free 2
    59 set *tmp4 true
    60 jump *label10 always
    61 label *label21
 
   129 set :needsFourUnits.1:unit @unit
   130 sensor *tmp45 :needsFourUnits.1:unit @speed
   131 set :needsFourUnits.1:travel_time 0
-    * op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
+  132 op greaterThanEq *tmp40 0 47
   133 label *label43
-    * jump *label45 equal *tmp40 false
+  134 jump *label45 equal false false
   135 set *tmp48 4
   136 label *label45
-    * set :areUnitsAvailable.1:needed *tmp48
+  137 set :areUnitsAvailable.1:needed 2
   138 label *label46
   139 sensor *tmp49 @unit @controlled
   140 op equal *tmp50 *tmp49 0
 
   143 op or *tmp53 *tmp50 *tmp52
   144 jump *label49 equal *tmp53 false
   145 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label51 lessThan :areUnitsAvailable.1:free *tmp48
+  146 jump *label51 lessThan :areUnitsAvailable.1:free 2
   147 set *tmp36 true
   148 jump *label40 always
   149 label *label51
 
  1144 op land *tmp499 *tmp497 *tmp498
  1145 jump *label300 equal *tmp499 false
  1146 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.2:needed 0
  1147 set :areUnitsAvailable.2:occupied 0
  1148 set :areUnitsAvailable.2:free 0
  1149 ubind UNIT_TYPE
 
  1159 jump *label307 equal *tmp505 false
  1160 set *tmp513 4
  1161 label *label307
-    * set :areUnitsAvailable.2:needed *tmp513
  1162 label *label308
  1163 sensor *tmp514 @unit @controlled
  1164 op equal *tmp515 *tmp514 0

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-8 instructions):
 
    36 ubind UNIT_TYPE
    37 set :areUnitsAvailable.0:firstUnit @unit
    38 jump *label11 equal :areUnitsAvailable.0:firstUnit null
-    * set *tmp16 2
    39 # "Function: inline def needsFourUnits(in unit)"
    40 set :needsFourUnits.0:unit @unit
    41 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * set :needsFourUnits.0:travel_time 0
-    * op greaterThanEq *tmp8 0 47
    42 label *label13
    43 jump *label15 equal false false
-    * set *tmp16 4
    44 label *label15
    45 set :areUnitsAvailable.0:needed 2
    46 label *label16
 
   120 ubind :chooseUnitType.0:type
   121 set :areUnitsAvailable.1:firstUnit @unit
   122 jump *label41 equal :areUnitsAvailable.1:firstUnit null
-    * set *tmp48 2
   123 # "Function: inline def needsFourUnits(in unit)"
   124 set :needsFourUnits.1:unit @unit
   125 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * set :needsFourUnits.1:travel_time 0
-    * op greaterThanEq *tmp40 0 47
   126 label *label43
   127 jump *label45 equal false false
-    * set *tmp48 4
   128 label *label45
   129 set :areUnitsAvailable.1:needed 2
   130 label *label46

Modifications by Unroll iteration loop at line 177:9 (+141 instructions):
 
    92 jump *label6 always
    93 label *label27
    94 label *label28
-    * set :chooseUnitType.0:type @flare
-    * op add *tmp33 @counter 1
-    * jump *label29 always
-    * multilabel *label32
-    * set :chooseUnitType.0:type @poly
-    * op add *tmp33 @counter 1
-    * jump *label29 always
-    * multilabel *label33
-    * set :chooseUnitType.0:type @mega
-    * op add *tmp33 @counter 1
-    * jump *label29 always
-    * multilabel *label34
-    * set :chooseUnitType.0:type @mono
-    * op add *tmp33 @counter 1
-    * jump *label29 always
-    * multilabel *label36
-    * jump *label37 always
-    * label *label29
-    * jump *label38 equal :chooseUnitType.0:type UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
-    * # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:needed 0
-    * set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label41 equal :areUnitsAvailable.1:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
-    * label *label43
-    * jump *label45 equal false false
-    * label *label45
-    * set :areUnitsAvailable.1:needed 2
-    * label *label46
-    * sensor *tmp49 @unit @controlled
-    * op equal *tmp50 *tmp49 0
-    * sensor *tmp51 @unit @controller
-    * op equal *tmp52 *tmp51 @this
-    * op or *tmp53 *tmp50 *tmp52
-    * jump *label49 equal *tmp53 false
-    * op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label51 lessThan :areUnitsAvailable.1:free 2
-    * set *tmp36 true
-    * jump *label40 always
-    * label *label51
-    * label *label52
-    * jump *label50 always
-    * label *label49
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label50
-    * ubind :chooseUnitType.0:type
-    * label *label47
-    * op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp59 *tmp58 0
-    * op land *tmp60 *tmp57 *tmp59
-    * jump *label46 notEqual *tmp60 false
-    * label *label48
-    * label *label41
-    * label *label42
-    * print :chooseUnitType.0:type
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.1:free
-    * jump *label55 lessThanEq :areUnitsAvailable.1:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.1:needed
-    * label *label55
-    * label *label56
-    * print "\n"
-    * label *label53
-    * label *label54
-    * set *tmp36 false
-    * label *label40
-    * jump *label57 equal *tmp36 false
-    * printflush null
-    * set *tmp3 :chooseUnitType.0:type
-    * jump *label6 always
-    * label *label57
-    * label *label58
-    * label *label38
-    * label *label39
-    * label *label30
-    * multijump *tmp33 0 0
-    * multilabel *label35
-    * label *label37
-    * label *label31
+   95 set :chooseUnitType.0:type @flare
+   96 op add *tmp33 @counter 1
+   97 label *label324
+   98 jump *label343 equal :chooseUnitType.0:type UNIT_TYPE
+   99 remark "chooseUnitType: "
+  100 remark :chooseUnitType.0:type
+  101 # "Function: inline def areUnitsAvailable(in type, in output)"
+  102 set :areUnitsAvailable.1:needed 0
+  103 set :areUnitsAvailable.1:occupied 0
+  104 set :areUnitsAvailable.1:free 0
+  105 ubind :chooseUnitType.0:type
+  106 set :areUnitsAvailable.1:firstUnit @unit
+  107 jump *label334 equal :areUnitsAvailable.1:firstUnit null
+  108 # "Function: inline def needsFourUnits(in unit)"
+  109 set :needsFourUnits.1:unit @unit
+  110 sensor *tmp45 :needsFourUnits.1:unit @speed
+  111 label *label325
+  112 jump *label326 equal false false
+  113 label *label326
+  114 set :areUnitsAvailable.1:needed 2
+  115 label *label327
+  116 sensor *tmp49 @unit @controlled
+  117 op equal *tmp50 *tmp49 0
+  118 sensor *tmp51 @unit @controller
+  119 op equal *tmp52 *tmp51 @this
+  120 op or *tmp53 *tmp50 *tmp52
+  121 jump *label330 equal *tmp53 false
+  122 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  123 jump *label328 lessThan :areUnitsAvailable.1:free 2
+  124 set *tmp36 true
+  125 jump *label340 always
+  126 label *label328
+  127 label *label329
+  128 jump *label331 always
+  129 label *label330
+  130 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  131 label *label331
+  132 ubind :chooseUnitType.0:type
+  133 label *label332
+  134 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  135 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  136 op equal *tmp59 *tmp58 0
+  137 op land *tmp60 *tmp57 *tmp59
+  138 jump *label327 notEqual *tmp60 false
+  139 label *label333
+  140 label *label334
+  141 label *label335
+  142 print :chooseUnitType.0:type
+  143 print ":"
+  144 print " occupied: "
+  145 print :areUnitsAvailable.1:occupied
+  146 print ","
+  147 print " free: "
+  148 print :areUnitsAvailable.1:free
+  149 jump *label336 lessThanEq :areUnitsAvailable.1:needed 0
+  150 print ", needed: "
+  151 print :areUnitsAvailable.1:needed
+  152 label *label336
+  153 label *label337
+  154 print "\n"
+  155 label *label338
+  156 label *label339
+  157 set *tmp36 false
+  158 label *label340
+  159 jump *label341 equal *tmp36 false
+  160 printflush null
+  161 set *tmp3 :chooseUnitType.0:type
+  162 jump *label6 always
+  163 label *label341
+  164 label *label342
+  165 label *label343
+  166 label *label344
+  167 label *label345
+  168 set :chooseUnitType.0:type @poly
+  169 op add *tmp33 @counter 1
+  170 label *label348
+  171 jump *label367 equal :chooseUnitType.0:type UNIT_TYPE
+  172 remark "chooseUnitType: "
+  173 remark :chooseUnitType.0:type
+  174 # "Function: inline def areUnitsAvailable(in type, in output)"
+  175 set :areUnitsAvailable.1:needed 0
+  176 set :areUnitsAvailable.1:occupied 0
+  177 set :areUnitsAvailable.1:free 0
+  178 ubind :chooseUnitType.0:type
+  179 set :areUnitsAvailable.1:firstUnit @unit
+  180 jump *label358 equal :areUnitsAvailable.1:firstUnit null
+  181 # "Function: inline def needsFourUnits(in unit)"
+  182 set :needsFourUnits.1:unit @unit
+  183 sensor *tmp45 :needsFourUnits.1:unit @speed
+  184 label *label349
+  185 jump *label350 equal false false
+  186 label *label350
+  187 set :areUnitsAvailable.1:needed 2
+  188 label *label351
+  189 sensor *tmp49 @unit @controlled
+  190 op equal *tmp50 *tmp49 0
+  191 sensor *tmp51 @unit @controller
+  192 op equal *tmp52 *tmp51 @this
+  193 op or *tmp53 *tmp50 *tmp52
+  194 jump *label354 equal *tmp53 false
+  195 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  196 jump *label352 lessThan :areUnitsAvailable.1:free 2
+  197 set *tmp36 true
+  198 jump *label364 always
+  199 label *label352
+  200 label *label353
+  201 jump *label355 always
+  202 label *label354
+  203 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  204 label *label355
+  205 ubind :chooseUnitType.0:type
+  206 label *label356
+  207 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  208 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  209 op equal *tmp59 *tmp58 0
+  210 op land *tmp60 *tmp57 *tmp59
+  211 jump *label351 notEqual *tmp60 false
+  212 label *label357
+  213 label *label358
+  214 label *label359
+  215 print :chooseUnitType.0:type
+  216 print ":"
+  217 print " occupied: "
+  218 print :areUnitsAvailable.1:occupied
+  219 print ","
+  220 print " free: "
+  221 print :areUnitsAvailable.1:free
+  222 jump *label360 lessThanEq :areUnitsAvailable.1:needed 0
+  223 print ", needed: "
+  224 print :areUnitsAvailable.1:needed
+  225 label *label360
+  226 label *label361
+  227 print "\n"
+  228 label *label362
+  229 label *label363
+  230 set *tmp36 false
+  231 label *label364
+  232 jump *label365 equal *tmp36 false
+  233 printflush null
+  234 set *tmp3 :chooseUnitType.0:type
+  235 jump *label6 always
+  236 label *label365
+  237 label *label366
+  238 label *label367
+  239 label *label368
+  240 label *label369
+  241 set :chooseUnitType.0:type @mega
+  242 op add *tmp33 @counter 1
+  243 label *label372
+  244 jump *label391 equal :chooseUnitType.0:type UNIT_TYPE
+  245 remark "chooseUnitType: "
+  246 remark :chooseUnitType.0:type
+  247 # "Function: inline def areUnitsAvailable(in type, in output)"
+  248 set :areUnitsAvailable.1:needed 0
+  249 set :areUnitsAvailable.1:occupied 0
+  250 set :areUnitsAvailable.1:free 0
+  251 ubind :chooseUnitType.0:type
+  252 set :areUnitsAvailable.1:firstUnit @unit
+  253 jump *label382 equal :areUnitsAvailable.1:firstUnit null
+  254 # "Function: inline def needsFourUnits(in unit)"
+  255 set :needsFourUnits.1:unit @unit
+  256 sensor *tmp45 :needsFourUnits.1:unit @speed
+  257 label *label373
+  258 jump *label374 equal false false
+  259 label *label374
+  260 set :areUnitsAvailable.1:needed 2
+  261 label *label375
+  262 sensor *tmp49 @unit @controlled
+  263 op equal *tmp50 *tmp49 0
+  264 sensor *tmp51 @unit @controller
+  265 op equal *tmp52 *tmp51 @this
+  266 op or *tmp53 *tmp50 *tmp52
+  267 jump *label378 equal *tmp53 false
+  268 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  269 jump *label376 lessThan :areUnitsAvailable.1:free 2
+  270 set *tmp36 true
+  271 jump *label388 always
+  272 label *label376
+  273 label *label377
+  274 jump *label379 always
+  275 label *label378
+  276 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  277 label *label379
+  278 ubind :chooseUnitType.0:type
+  279 label *label380
+  280 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  281 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  282 op equal *tmp59 *tmp58 0
+  283 op land *tmp60 *tmp57 *tmp59
+  284 jump *label375 notEqual *tmp60 false
+  285 label *label381
+  286 label *label382
+  287 label *label383
+  288 print :chooseUnitType.0:type
+  289 print ":"
+  290 print " occupied: "
+  291 print :areUnitsAvailable.1:occupied
+  292 print ","
+  293 print " free: "
+  294 print :areUnitsAvailable.1:free
+  295 jump *label384 lessThanEq :areUnitsAvailable.1:needed 0
+  296 print ", needed: "
+  297 print :areUnitsAvailable.1:needed
+  298 label *label384
+  299 label *label385
+  300 print "\n"
+  301 label *label386
+  302 label *label387
+  303 set *tmp36 false
+  304 label *label388
+  305 jump *label389 equal *tmp36 false
+  306 printflush null
+  307 set *tmp3 :chooseUnitType.0:type
+  308 jump *label6 always
+  309 label *label389
+  310 label *label390
+  311 label *label391
+  312 label *label392
+  313 label *label393
+  314 set :chooseUnitType.0:type @mono
+  315 op add *tmp33 @counter 1
+  316 label *label396
+  317 jump *label415 equal :chooseUnitType.0:type UNIT_TYPE
+  318 remark "chooseUnitType: "
+  319 remark :chooseUnitType.0:type
+  320 # "Function: inline def areUnitsAvailable(in type, in output)"
+  321 set :areUnitsAvailable.1:needed 0
+  322 set :areUnitsAvailable.1:occupied 0
+  323 set :areUnitsAvailable.1:free 0
+  324 ubind :chooseUnitType.0:type
+  325 set :areUnitsAvailable.1:firstUnit @unit
+  326 jump *label406 equal :areUnitsAvailable.1:firstUnit null
+  327 # "Function: inline def needsFourUnits(in unit)"
+  328 set :needsFourUnits.1:unit @unit
+  329 sensor *tmp45 :needsFourUnits.1:unit @speed
+  330 label *label397
+  331 jump *label398 equal false false
+  332 label *label398
+  333 set :areUnitsAvailable.1:needed 2
+  334 label *label399
+  335 sensor *tmp49 @unit @controlled
+  336 op equal *tmp50 *tmp49 0
+  337 sensor *tmp51 @unit @controller
+  338 op equal *tmp52 *tmp51 @this
+  339 op or *tmp53 *tmp50 *tmp52
+  340 jump *label402 equal *tmp53 false
+  341 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  342 jump *label400 lessThan :areUnitsAvailable.1:free 2
+  343 set *tmp36 true
+  344 jump *label412 always
+  345 label *label400
+  346 label *label401
+  347 jump *label403 always
+  348 label *label402
+  349 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  350 label *label403
+  351 ubind :chooseUnitType.0:type
+  352 label *label404
+  353 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  354 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  355 op equal *tmp59 *tmp58 0
+  356 op land *tmp60 *tmp57 *tmp59
+  357 jump *label399 notEqual *tmp60 false
+  358 label *label405
+  359 label *label406
+  360 label *label407
+  361 print :chooseUnitType.0:type
+  362 print ":"
+  363 print " occupied: "
+  364 print :areUnitsAvailable.1:occupied
+  365 print ","
+  366 print " free: "
+  367 print :areUnitsAvailable.1:free
+  368 jump *label408 lessThanEq :areUnitsAvailable.1:needed 0
+  369 print ", needed: "
+  370 print :areUnitsAvailable.1:needed
+  371 label *label408
+  372 label *label409
+  373 print "\n"
+  374 label *label410
+  375 label *label411
+  376 set *tmp36 false
+  377 label *label412
+  378 jump *label413 equal *tmp36 false
+  379 printflush null
+  380 set *tmp3 :chooseUnitType.0:type
+  381 jump *label6 always
+  382 label *label413
+  383 label *label414
+  384 label *label415
+  385 label *label416
+  386 label *label417
+  387 label *label37
+  388 label *label31
   389 printflush message1
   390 label *label8
   391 jump *label7 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-4 instructions):
 
    93 label *label27
    94 label *label28
    95 set :chooseUnitType.0:type @flare
-    * op add *tmp33 @counter 1
    96 label *label324
-    * jump *label343 equal :chooseUnitType.0:type UNIT_TYPE
+   97 jump *label343 equal @flare UNIT_TYPE
    98 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+   99 remark @flare
   100 # "Function: inline def areUnitsAvailable(in type, in output)"
   101 set :areUnitsAvailable.1:needed 0
   102 set :areUnitsAvailable.1:occupied 0
   103 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  104 ubind @flare
   105 set :areUnitsAvailable.1:firstUnit @unit
   106 jump *label334 equal :areUnitsAvailable.1:firstUnit null
   107 # "Function: inline def needsFourUnits(in unit)"
 
   128 label *label330
   129 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   130 label *label331
-    * ubind :chooseUnitType.0:type
+  131 ubind @flare
   132 label *label332
   133 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   134 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   138 label *label333
   139 label *label334
   140 label *label335
-    * print :chooseUnitType.0:type
+  141 print @flare
   142 print ":"
   143 print " occupied: "
   144 print :areUnitsAvailable.1:occupied
 
   157 label *label340
   158 jump *label341 equal *tmp36 false
   159 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  160 set *tmp3 @flare
   161 jump *label6 always
   162 label *label341
   163 label *label342
 
   165 label *label344
   166 label *label345
   167 set :chooseUnitType.0:type @poly
-    * op add *tmp33 @counter 1
   168 label *label348
-    * jump *label367 equal :chooseUnitType.0:type UNIT_TYPE
+  169 jump *label367 equal @poly UNIT_TYPE
   170 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+  171 remark @poly
   172 # "Function: inline def areUnitsAvailable(in type, in output)"
   173 set :areUnitsAvailable.1:needed 0
   174 set :areUnitsAvailable.1:occupied 0
   175 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  176 ubind @poly
   177 set :areUnitsAvailable.1:firstUnit @unit
   178 jump *label358 equal :areUnitsAvailable.1:firstUnit null
   179 # "Function: inline def needsFourUnits(in unit)"
 
   200 label *label354
   201 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   202 label *label355
-    * ubind :chooseUnitType.0:type
+  203 ubind @poly
   204 label *label356
   205 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   206 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   210 label *label357
   211 label *label358
   212 label *label359
-    * print :chooseUnitType.0:type
+  213 print @poly
   214 print ":"
   215 print " occupied: "
   216 print :areUnitsAvailable.1:occupied
 
   229 label *label364
   230 jump *label365 equal *tmp36 false
   231 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  232 set *tmp3 @poly
   233 jump *label6 always
   234 label *label365
   235 label *label366
 
   237 label *label368
   238 label *label369
   239 set :chooseUnitType.0:type @mega
-    * op add *tmp33 @counter 1
   240 label *label372
-    * jump *label391 equal :chooseUnitType.0:type UNIT_TYPE
+  241 jump *label391 equal @mega UNIT_TYPE
   242 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+  243 remark @mega
   244 # "Function: inline def areUnitsAvailable(in type, in output)"
   245 set :areUnitsAvailable.1:needed 0
   246 set :areUnitsAvailable.1:occupied 0
   247 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  248 ubind @mega
   249 set :areUnitsAvailable.1:firstUnit @unit
   250 jump *label382 equal :areUnitsAvailable.1:firstUnit null
   251 # "Function: inline def needsFourUnits(in unit)"
 
   272 label *label378
   273 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   274 label *label379
-    * ubind :chooseUnitType.0:type
+  275 ubind @mega
   276 label *label380
   277 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   278 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   282 label *label381
   283 label *label382
   284 label *label383
-    * print :chooseUnitType.0:type
+  285 print @mega
   286 print ":"
   287 print " occupied: "
   288 print :areUnitsAvailable.1:occupied
 
   301 label *label388
   302 jump *label389 equal *tmp36 false
   303 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  304 set *tmp3 @mega
   305 jump *label6 always
   306 label *label389
   307 label *label390
 
   309 label *label392
   310 label *label393
   311 set :chooseUnitType.0:type @mono
-    * op add *tmp33 @counter 1
   312 label *label396
-    * jump *label415 equal :chooseUnitType.0:type UNIT_TYPE
+  313 jump *label415 equal @mono UNIT_TYPE
   314 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+  315 remark @mono
   316 # "Function: inline def areUnitsAvailable(in type, in output)"
   317 set :areUnitsAvailable.1:needed 0
   318 set :areUnitsAvailable.1:occupied 0
   319 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  320 ubind @mono
   321 set :areUnitsAvailable.1:firstUnit @unit
   322 jump *label406 equal :areUnitsAvailable.1:firstUnit null
   323 # "Function: inline def needsFourUnits(in unit)"
 
   344 label *label402
   345 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   346 label *label403
-    * ubind :chooseUnitType.0:type
+  347 ubind @mono
   348 label *label404
   349 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   350 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   354 label *label405
   355 label *label406
   356 label *label407
-    * print :chooseUnitType.0:type
+  357 print @mono
   358 print ":"
   359 print " occupied: "
   360 print :areUnitsAvailable.1:occupied
 
   373 label *label412
   374 jump *label413 equal *tmp36 false
   375 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  376 set *tmp3 @mono
   377 jump *label6 always
   378 label *label413
   379 label *label414

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-4 instructions):
 
    92 jump *label6 always
    93 label *label27
    94 label *label28
-    * set :chooseUnitType.0:type @flare
    95 label *label324
    96 jump *label343 equal @flare UNIT_TYPE
    97 remark "chooseUnitType: "
 
   163 label *label343
   164 label *label344
   165 label *label345
-    * set :chooseUnitType.0:type @poly
   166 label *label348
   167 jump *label367 equal @poly UNIT_TYPE
   168 remark "chooseUnitType: "
 
   234 label *label367
   235 label *label368
   236 label *label369
-    * set :chooseUnitType.0:type @mega
   237 label *label372
   238 jump *label391 equal @mega UNIT_TYPE
   239 remark "chooseUnitType: "
 
   305 label *label391
   306 label *label392
   307 label *label393
-    * set :chooseUnitType.0:type @mono
   308 label *label396
   309 jump *label415 equal @mono UNIT_TYPE
   310 remark "chooseUnitType: "

Modifications by Iterated phase, Jump Normalization, pass 3, iteration 1:
 
    40 set :needsFourUnits.0:unit @unit
    41 sensor *tmp13 :needsFourUnits.0:unit @speed
    42 label *label13
-    * jump *label15 equal false false
+   43 jump *label15 always
    44 label *label15
    45 set :areUnitsAvailable.0:needed 2
    46 label *label16
 
   107 set :needsFourUnits.1:unit @unit
   108 sensor *tmp45 :needsFourUnits.1:unit @speed
   109 label *label325
-    * jump *label326 equal false false
+  110 jump *label326 always
   111 label *label326
   112 set :areUnitsAvailable.1:needed 2
   113 label *label327
 
   178 set :needsFourUnits.1:unit @unit
   179 sensor *tmp45 :needsFourUnits.1:unit @speed
   180 label *label349
-    * jump *label350 equal false false
+  181 jump *label350 always
   182 label *label350
   183 set :areUnitsAvailable.1:needed 2
   184 label *label351
 
   249 set :needsFourUnits.1:unit @unit
   250 sensor *tmp45 :needsFourUnits.1:unit @speed
   251 label *label373
-    * jump *label374 equal false false
+  252 jump *label374 always
   253 label *label374
   254 set :areUnitsAvailable.1:needed 2
   255 label *label375
 
   320 set :needsFourUnits.1:unit @unit
   321 sensor *tmp45 :needsFourUnits.1:unit @speed
   322 label *label397
-    * jump *label398 equal false false
+  323 jump *label398 always
   324 label *label398
   325 set :areUnitsAvailable.1:needed 2
   326 label *label399

Modifications by Iterated phase, Jump Optimization, pass 3, iteration 1 (-1 instructions):
 
  1340 set :needsFourUnits.3:unit @unit
  1341 sensor *tmp510 :needsFourUnits.3:unit @speed
  1342 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
-    * op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1343 label *label305
-    * jump *label307 equal *tmp505 false
+ 1344 jump *label307 lessThan :needsFourUnits.3:travel_time 47
  1345 set *tmp513 4
  1346 label *label307
  1347 label *label308

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-5 instructions):
 
    40 set :needsFourUnits.0:unit @unit
    41 sensor *tmp13 :needsFourUnits.0:unit @speed
    42 label *label13
-    * jump *label15 always
    43 label *label15
    44 set :areUnitsAvailable.0:needed 2
    45 label *label16
 
   106 set :needsFourUnits.1:unit @unit
   107 sensor *tmp45 :needsFourUnits.1:unit @speed
   108 label *label325
-    * jump *label326 always
   109 label *label326
   110 set :areUnitsAvailable.1:needed 2
   111 label *label327
 
   176 set :needsFourUnits.1:unit @unit
   177 sensor *tmp45 :needsFourUnits.1:unit @speed
   178 label *label349
-    * jump *label350 always
   179 label *label350
   180 set :areUnitsAvailable.1:needed 2
   181 label *label351
 
   246 set :needsFourUnits.1:unit @unit
   247 sensor *tmp45 :needsFourUnits.1:unit @speed
   248 label *label373
-    * jump *label374 always
   249 label *label374
   250 set :areUnitsAvailable.1:needed 2
   251 label *label375
 
   316 set :needsFourUnits.1:unit @unit
   317 sensor *tmp45 :needsFourUnits.1:unit @speed
   318 label *label397
-    * jump *label398 always
   319 label *label398
   320 set :areUnitsAvailable.1:needed 2
   321 label *label399

Modifications by Final phase, Jump Straightening, iteration 1 (-17 instructions):
 
   402 set .UNIT_P2 .UNIT_S1
   403 set .UNIT_S1 .UNIT_P1
   404 set .UNIT_P1 @unit
-    * jump *label67 equal .UNIT_S2 null
-    * jump *label64 always
+  405 jump *label64 notEqual .UNIT_S2 null
   406 label *label67
   407 label *label68
   408 label *label65
 
   425 sensor *tmp85 @unit @controller
   426 op equal *tmp86 *tmp85 @this
   427 op land *tmp87 *tmp84 *tmp86
-    * jump *label73 equal *tmp87 false
-    * jump *label70 always
+  428 jump *label70 notEqual *tmp87 false
   429 label *label73
   430 label *label74
   431 label *label71
 
   435 jump *label75 equal :rebindUnit.0:firstUnit null
   436 label *label77
   437 sensor *tmp92 @unit @controlled
-    * jump *label80 notEqual *tmp92 0
-    * jump *label70 always
+  438 jump *label70 equal *tmp92 0
   439 label *label80
   440 label *label81
   441 ubind *tmp3
 
   463 sensor *tmp105 @unit @controller
   464 op equal *tmp106 *tmp105 @this
   465 op land *tmp107 *tmp104 *tmp106
-    * jump *label86 equal *tmp107 false
-    * jump *label83 always
+  466 jump *label83 notEqual *tmp107 false
   467 label *label86
   468 label *label87
   469 label *label84
 
   473 jump *label88 equal :rebindUnit.1:firstUnit null
   474 label *label90
   475 sensor *tmp112 @unit @controlled
-    * jump *label93 notEqual *tmp112 0
-    * jump *label83 always
+  476 jump *label83 equal *tmp112 0
   477 label *label93
   478 label *label94
   479 ubind *tmp3
 
   540 sensor *tmp154 @unit @controller
   541 op equal *tmp155 *tmp154 @this
   542 op land *tmp156 *tmp153 *tmp155
-    * jump *label109 equal *tmp156 false
-    * jump *label106 always
+  543 jump *label106 notEqual *tmp156 false
   544 label *label109
   545 label *label110
   546 label *label107
 
   550 jump *label111 equal :rebindUnit.2:firstUnit null
   551 label *label113
   552 sensor *tmp161 @unit @controlled
-    * jump *label116 notEqual *tmp161 0
-    * jump *label106 always
+  553 jump *label106 equal *tmp161 0
   554 label *label116
   555 label *label117
   556 ubind *tmp3
 
   578 sensor *tmp174 @unit @controller
   579 op equal *tmp175 *tmp174 @this
   580 op land *tmp176 *tmp173 *tmp175
-    * jump *label122 equal *tmp176 false
-    * jump *label119 always
+  581 jump *label119 notEqual *tmp176 false
   582 label *label122
   583 label *label123
   584 label *label120
 
   588 jump *label124 equal :rebindUnit.3:firstUnit null
   589 label *label126
   590 sensor *tmp181 @unit @controlled
-    * jump *label129 notEqual *tmp181 0
-    * jump *label119 always
+  591 jump *label119 equal *tmp181 0
   592 label *label129
   593 label *label130
   594 ubind *tmp3
 
   690 sensor *tmp223 @unit @controller
   691 op equal *tmp224 *tmp223 @this
   692 op land *tmp225 *tmp222 *tmp224
-    * jump *label145 equal *tmp225 false
-    * jump *label142 always
+  693 jump *label142 notEqual *tmp225 false
   694 label *label145
   695 label *label146
   696 label *label143
 
   700 jump *label147 equal :rebindUnit.4:firstUnit null
   701 label *label149
   702 sensor *tmp230 @unit @controlled
-    * jump *label152 notEqual *tmp230 0
-    * jump *label142 always
+  703 jump *label142 equal *tmp230 0
   704 label *label152
   705 label *label153
   706 ubind *tmp3
 
   835 sensor *tmp290 @unit @controller
   836 op equal *tmp291 *tmp290 @this
   837 op land *tmp292 *tmp289 *tmp291
-    * jump *label184 equal *tmp292 false
-    * jump *label181 always
+  838 jump *label181 notEqual *tmp292 false
   839 label *label184
   840 label *label185
   841 label *label182
 
   845 jump *label186 equal :rebindUnit.5:firstUnit null
   846 label *label188
   847 sensor *tmp297 @unit @controlled
-    * jump *label191 notEqual *tmp297 0
-    * jump *label181 always
+  848 jump *label181 equal *tmp297 0
   849 label *label191
   850 label *label192
   851 ubind *tmp3
 
  1006 sensor *tmp364 @unit @controller
  1007 op equal *tmp365 *tmp364 @this
  1008 op land *tmp366 *tmp363 *tmp365
-    * jump *label226 equal *tmp366 false
-    * jump *label223 always
+ 1009 jump *label223 notEqual *tmp366 false
  1010 label *label226
  1011 label *label227
  1012 label *label224
 
  1016 jump *label228 equal :rebindUnit.6:firstUnit null
  1017 label *label230
  1018 sensor *tmp371 @unit @controlled
-    * jump *label233 notEqual *tmp371 0
-    * jump *label223 always
+ 1019 jump *label223 equal *tmp371 0
  1020 label *label233
  1021 label *label234
  1022 ubind *tmp3
 
  1151 sensor *tmp431 @unit @controller
  1152 op equal *tmp432 *tmp431 @this
  1153 op land *tmp433 *tmp430 *tmp432
-    * jump *label265 equal *tmp433 false
-    * jump *label262 always
+ 1154 jump *label262 notEqual *tmp433 false
  1155 label *label265
  1156 label *label266
  1157 label *label263
 
  1161 jump *label267 equal :rebindUnit.7:firstUnit null
  1162 label *label269
  1163 sensor *tmp438 @unit @controlled
-    * jump *label272 notEqual *tmp438 0
-    * jump *label262 always
+ 1164 jump *label262 equal *tmp438 0
  1165 label *label272
  1166 label *label273
  1167 ubind *tmp3

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @flare
 
    51 op or *tmp21 *tmp18 *tmp20
    52 jump *label19 equal *tmp21 false
    53 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label21 lessThan :areUnitsAvailable.0:free 2
+   54 jump *label20 lessThan :areUnitsAvailable.0:free 2
    55 set *tmp4 true
    56 jump *label10 always
    57 label *label21
 
   117 op or *tmp53 *tmp50 *tmp52
   118 jump *label330 equal *tmp53 false
   119 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label328 lessThan :areUnitsAvailable.1:free 2
+  120 jump *label331 lessThan :areUnitsAvailable.1:free 2
   121 set *tmp36 true
   122 jump *label340 always
   123 label *label328
 
   187 op or *tmp53 *tmp50 *tmp52
   188 jump *label354 equal *tmp53 false
   189 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label352 lessThan :areUnitsAvailable.1:free 2
+  190 jump *label355 lessThan :areUnitsAvailable.1:free 2
   191 set *tmp36 true
   192 jump *label364 always
   193 label *label352
 
   257 op or *tmp53 *tmp50 *tmp52
   258 jump *label378 equal *tmp53 false
   259 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label376 lessThan :areUnitsAvailable.1:free 2
+  260 jump *label379 lessThan :areUnitsAvailable.1:free 2
   261 set *tmp36 true
   262 jump *label388 always
   263 label *label376
 
   327 op or *tmp53 *tmp50 *tmp52
   328 jump *label402 equal *tmp53 false
   329 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label400 lessThan :areUnitsAvailable.1:free 2
+  330 jump *label403 lessThan :areUnitsAvailable.1:free 2
   331 set *tmp36 true
   332 jump *label412 always
   333 label *label400
 
   433 label *label72
   434 ubind *tmp3
   435 set :rebindUnit.0:firstUnit @unit
-    * jump *label75 equal :rebindUnit.0:firstUnit null
+  436 jump __start__ equal :rebindUnit.0:firstUnit null
   437 label *label77
   438 sensor *tmp92 @unit @controlled
   439 jump *label70 equal *tmp92 0
 
   471 label *label85
   472 ubind *tmp3
   473 set :rebindUnit.1:firstUnit @unit
-    * jump *label88 equal :rebindUnit.1:firstUnit null
+  474 jump __start__ equal :rebindUnit.1:firstUnit null
   475 label *label90
   476 sensor *tmp112 @unit @controlled
   477 jump *label83 equal *tmp112 0
 
   548 label *label108
   549 ubind *tmp3
   550 set :rebindUnit.2:firstUnit @unit
-    * jump *label111 equal :rebindUnit.2:firstUnit null
+  551 jump __start__ equal :rebindUnit.2:firstUnit null
   552 label *label113
   553 sensor *tmp161 @unit @controlled
   554 jump *label106 equal *tmp161 0
 
   586 label *label121
   587 ubind *tmp3
   588 set :rebindUnit.3:firstUnit @unit
-    * jump *label124 equal :rebindUnit.3:firstUnit null
+  589 jump __start__ equal :rebindUnit.3:firstUnit null
   590 label *label126
   591 sensor *tmp181 @unit @controlled
   592 jump *label119 equal *tmp181 0
 
   653 op add :unitCheck @time 5000
   654 label *label135
   655 sensor *tmp211 switch1 @enabled
-    * jump *label137 equal *tmp211 false
+  656 jump __start__ equal *tmp211 false
   657 label *label323
   658 set :start @time
   659 print " === [gold]Supplying Overdrive Dome[] === "
 
   698 label *label144
   699 ubind *tmp3
   700 set :rebindUnit.4:firstUnit @unit
-    * jump *label147 equal :rebindUnit.4:firstUnit null
+  701 jump __start__ equal :rebindUnit.4:firstUnit null
   702 label *label149
   703 sensor *tmp230 @unit @controlled
   704 jump *label142 equal *tmp230 0
 
   752 jump *label166 lessThan *tmp254 .UNIT_CAPACITY
   753 ucontrol approach .DOME_X .DOME_Y 6
   754 set :processUnit.0:state 3
-    * jump *label167 always
+  755 jump *label165 always
   756 label *label166
   757 set :processUnit.0:msg ", loading\n"
   758 label *label167
 
   782 set :processUnit.0:msg ", waiting\n"
   783 label *label173
   784 sensor *tmp269 @unit @totalItems
-    * jump *label174 greaterThan *tmp269 0
+  785 jump *label171 greaterThan *tmp269 0
   786 ucontrol approach .CORE_X .CORE_Y 6
   787 set :processUnit.0:state 2
   788 label *label174
 
   843 label *label183
   844 ubind *tmp3
   845 set :rebindUnit.5:firstUnit @unit
-    * jump *label186 equal :rebindUnit.5:firstUnit null
+  846 jump __start__ equal :rebindUnit.5:firstUnit null
   847 label *label188
   848 sensor *tmp297 @unit @controlled
   849 jump *label181 equal *tmp297 0
 
   897 jump *label205 lessThan *tmp321 .UNIT_CAPACITY
   898 ucontrol approach .DOME_X .DOME_Y 6
   899 set :processUnit.1:state 3
-    * jump *label206 always
+  900 jump *label204 always
   901 label *label205
   902 set :processUnit.1:msg ", loading\n"
   903 label *label206
 
   927 set :processUnit.1:msg ", waiting\n"
   928 label *label212
   929 sensor *tmp336 @unit @totalItems
-    * jump *label213 greaterThan *tmp336 0
+  930 jump *label210 greaterThan *tmp336 0
   931 ucontrol approach .CORE_X .CORE_Y 6
   932 set :processUnit.1:state 2
   933 label *label213
 
  1014 label *label225
  1015 ubind *tmp3
  1016 set :rebindUnit.6:firstUnit @unit
-    * jump *label228 equal :rebindUnit.6:firstUnit null
+ 1017 jump __start__ equal :rebindUnit.6:firstUnit null
  1018 label *label230
  1019 sensor *tmp371 @unit @controlled
  1020 jump *label223 equal *tmp371 0
 
  1068 jump *label247 lessThan *tmp395 .UNIT_CAPACITY
  1069 ucontrol approach .DOME_X .DOME_Y 6
  1070 set :processUnit.2:state 3
-    * jump *label248 always
+ 1071 jump *label246 always
  1072 label *label247
  1073 set :processUnit.2:msg ", loading\n"
  1074 label *label248
 
  1098 set :processUnit.2:msg ", waiting\n"
  1099 label *label254
  1100 sensor *tmp410 @unit @totalItems
-    * jump *label255 greaterThan *tmp410 0
+ 1101 jump *label252 greaterThan *tmp410 0
  1102 ucontrol approach .CORE_X .CORE_Y 6
  1103 set :processUnit.2:state 2
  1104 label *label255
 
  1159 label *label264
  1160 ubind *tmp3
  1161 set :rebindUnit.7:firstUnit @unit
-    * jump *label267 equal :rebindUnit.7:firstUnit null
+ 1162 jump __start__ equal :rebindUnit.7:firstUnit null
  1163 label *label269
  1164 sensor *tmp438 @unit @controlled
  1165 jump *label262 equal *tmp438 0
 
  1213 jump *label286 lessThan *tmp462 .UNIT_CAPACITY
  1214 ucontrol approach .DOME_X .DOME_Y 6
  1215 set :processUnit.3:state 3
-    * jump *label287 always
+ 1216 jump *label285 always
  1217 label *label286
  1218 set :processUnit.3:msg ", loading\n"
  1219 label *label287
 
  1243 set :processUnit.3:msg ", waiting\n"
  1244 label *label293
  1245 sensor *tmp477 @unit @totalItems
-    * jump *label294 greaterThan *tmp477 0
+ 1246 jump *label291 greaterThan *tmp477 0
  1247 ucontrol approach .CORE_X .CORE_Y 6
  1248 set :processUnit.3:state 2
  1249 label *label294
 
  1313 set :areUnitsAvailable.2:free 0
  1314 ubind UNIT_TYPE
  1315 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label303 equal :areUnitsAvailable.2:firstUnit null
+ 1316 jump *label315 equal :areUnitsAvailable.2:firstUnit null
  1317 set *tmp513 2
  1318 # "Function: inline def needsFourUnits(in unit)"
  1319 set :needsFourUnits.3:unit @unit
 
  1331 op or *tmp518 *tmp515 *tmp517
  1332 jump *label311 equal *tmp518 false
  1333 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label313 lessThan :areUnitsAvailable.2:free *tmp513
+ 1334 jump *label312 lessThan :areUnitsAvailable.2:free *tmp513
  1335 set *tmp501 true
  1336 jump *label302 always
  1337 label *label313

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-18 instructions):
 
    54 jump *label20 lessThan :areUnitsAvailable.0:free 2
    55 set *tmp4 true
    56 jump *label10 always
-    * label *label21
-    * label *label22
-    * jump *label20 always
    57 label *label19
    58 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
    59 label *label20
 
   117 jump *label331 lessThan :areUnitsAvailable.1:free 2
   118 set *tmp36 true
   119 jump *label340 always
-    * label *label328
-    * label *label329
-    * jump *label331 always
   120 label *label330
   121 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   122 label *label331
 
   184 jump *label355 lessThan :areUnitsAvailable.1:free 2
   185 set *tmp36 true
   186 jump *label364 always
-    * label *label352
-    * label *label353
-    * jump *label355 always
   187 label *label354
   188 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   189 label *label355
 
   251 jump *label379 lessThan :areUnitsAvailable.1:free 2
   252 set *tmp36 true
   253 jump *label388 always
-    * label *label376
-    * label *label377
-    * jump *label379 always
   254 label *label378
   255 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   256 label *label379
 
   318 jump *label403 lessThan :areUnitsAvailable.1:free 2
   319 set *tmp36 true
   320 jump *label412 always
-    * label *label400
-    * label *label401
-    * jump *label403 always
   321 label *label402
   322 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   323 label *label403
 
   362 printflush message1
   363 label *label8
   364 jump *label7 always
-    * label *label9
-    * set *tmp3 null
   365 label *label6
   366 print "[gold]Binding units..."
   367 printflush message1
 
  1317 jump *label312 lessThan :areUnitsAvailable.2:free *tmp513
  1318 set *tmp501 true
  1319 jump *label302 always
-    * label *label313
-    * label *label314
-    * jump *label312 always
  1320 label *label311
  1321 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1322 label *label312
 
  1331 label *label303
  1332 label *label304
  1333 jump *label315 always
-    * print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.2:free
-    * jump *label317 lessThanEq :areUnitsAvailable.2:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.2:needed
-    * label *label317
-    * label *label318
-    * print "\n"
  1334 label *label315
  1335 label *label316
  1336 set *tmp501 false

Modifications by Final phase, Dead Code Elimination, iteration 1 (-6 instructions):
 
    39 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    40 # "Function: inline def needsFourUnits(in unit)"
    41 set :needsFourUnits.0:unit @unit
-    * sensor *tmp13 :needsFourUnits.0:unit @speed
    42 label *label13
    43 label *label15
    44 set :areUnitsAvailable.0:needed 2
 
   101 jump *label334 equal :areUnitsAvailable.1:firstUnit null
   102 # "Function: inline def needsFourUnits(in unit)"
   103 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   104 label *label325
   105 label *label326
   106 set :areUnitsAvailable.1:needed 2
 
   167 jump *label358 equal :areUnitsAvailable.1:firstUnit null
   168 # "Function: inline def needsFourUnits(in unit)"
   169 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   170 label *label349
   171 label *label350
   172 set :areUnitsAvailable.1:needed 2
 
   233 jump *label382 equal :areUnitsAvailable.1:firstUnit null
   234 # "Function: inline def needsFourUnits(in unit)"
   235 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   236 label *label373
   237 label *label374
   238 set :areUnitsAvailable.1:needed 2
 
   299 jump *label406 equal :areUnitsAvailable.1:firstUnit null
   300 # "Function: inline def needsFourUnits(in unit)"
   301 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   302 label *label397
   303 label *label398
   304 set :areUnitsAvailable.1:needed 2
 
   505 op sub *tmp141 .DOME_Y .CORE_Y
   506 op len *tmp142 *tmp140 *tmp141
   507 op mul *tmp143 2 *tmp142
-    * sensor *tmp144 .UNIT_S1 @speed
   508 op div :needsFourUnits.2:travel_time *tmp143 .SPEED
   509 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   510 label *label102

Modifications by Final phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
    38 set :areUnitsAvailable.0:firstUnit @unit
    39 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    40 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.0:unit @unit
    41 label *label13
    42 label *label15
    43 set :areUnitsAvailable.0:needed 2
 
    99 set :areUnitsAvailable.1:firstUnit @unit
   100 jump *label334 equal :areUnitsAvailable.1:firstUnit null
   101 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
   102 label *label325
   103 label *label326
   104 set :areUnitsAvailable.1:needed 2
 
   164 set :areUnitsAvailable.1:firstUnit @unit
   165 jump *label358 equal :areUnitsAvailable.1:firstUnit null
   166 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
   167 label *label349
   168 label *label350
   169 set :areUnitsAvailable.1:needed 2
 
   229 set :areUnitsAvailable.1:firstUnit @unit
   230 jump *label382 equal :areUnitsAvailable.1:firstUnit null
   231 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
   232 label *label373
   233 label *label374
   234 set :areUnitsAvailable.1:needed 2
 
   294 set :areUnitsAvailable.1:firstUnit @unit
   295 jump *label406 equal :areUnitsAvailable.1:firstUnit null
   296 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
   297 label *label397
   298 label *label398
   299 set :areUnitsAvailable.1:needed 2

Modifications by Final phase, Single Step Elimination, iteration 1 (-2 instructions):
 
  1319 label *label310
  1320 label *label303
  1321 label *label304
-    * jump *label315 always
  1322 label *label315
  1323 label *label316
  1324 set *tmp501 false
 
  1334 sensor *tmp211 switch1 @enabled
  1335 jump *label323 notEqual *tmp211 false
  1336 label *label137
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-83 instructions):
 
    16 sensor *tmp1 switch1 @enabled
    17 jump *label5 notEqual *tmp1 false
    18 label *label322
-    * print "[coral]Activate switch to begin supplying overdrive dome..."
-    * print "\n"
+   19 print "[coral]Activate switch to begin supplying overdrive dome...\n"
    20 printflush message1
    21 label *label4
    22 sensor *tmp1 switch1 @enabled
 
    25 # "Function: inline def chooseUnitType()"
    26 label *label7
    27 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   28 print "[gold]Looking for suitable unit type:[]\n"
    29 remark "chooseUnitType: "
    30 remark UNIT_TYPE
    31 # "Function: inline def areUnitsAvailable(in type, in output)"
 
    64 label *label11
    65 label *label12
    66 print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.0:occupied
-    * print ","
-    * print " free: "
+   67 print ": occupied: {0}, free: "
+   68 format :areUnitsAvailable.0:occupied
    69 print :areUnitsAvailable.0:free
    70 jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
    71 print ", needed: "
 
    84 label *label28
    85 label *label324
    86 jump *label343 equal @flare UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @flare
+   87 remark "chooseUnitType: flare"
    88 # "Function: inline def areUnitsAvailable(in type, in output)"
    89 set :areUnitsAvailable.1:needed 0
    90 set :areUnitsAvailable.1:occupied 0
 
   120 label *label333
   121 label *label334
   122 label *label335
-    * print @flare
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  123 print "flare: occupied: {0}, free: "
+  124 format :areUnitsAvailable.1:occupied
   125 print :areUnitsAvailable.1:free
   126 jump *label336 lessThanEq :areUnitsAvailable.1:needed 0
   127 print ", needed: "
 
   144 label *label345
   145 label *label348
   146 jump *label367 equal @poly UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @poly
+  147 remark "chooseUnitType: poly"
   148 # "Function: inline def areUnitsAvailable(in type, in output)"
   149 set :areUnitsAvailable.1:needed 0
   150 set :areUnitsAvailable.1:occupied 0
 
   180 label *label357
   181 label *label358
   182 label *label359
-    * print @poly
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  183 print "poly: occupied: {0}, free: "
+  184 format :areUnitsAvailable.1:occupied
   185 print :areUnitsAvailable.1:free
   186 jump *label360 lessThanEq :areUnitsAvailable.1:needed 0
   187 print ", needed: "
 
   204 label *label369
   205 label *label372
   206 jump *label391 equal @mega UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @mega
+  207 remark "chooseUnitType: mega"
   208 # "Function: inline def areUnitsAvailable(in type, in output)"
   209 set :areUnitsAvailable.1:needed 0
   210 set :areUnitsAvailable.1:occupied 0
 
   240 label *label381
   241 label *label382
   242 label *label383
-    * print @mega
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  243 print "mega: occupied: {0}, free: "
+  244 format :areUnitsAvailable.1:occupied
   245 print :areUnitsAvailable.1:free
   246 jump *label384 lessThanEq :areUnitsAvailable.1:needed 0
   247 print ", needed: "
 
   264 label *label393
   265 label *label396
   266 jump *label415 equal @mono UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @mono
+  267 remark "chooseUnitType: mono"
   268 # "Function: inline def areUnitsAvailable(in type, in output)"
   269 set :areUnitsAvailable.1:needed 0
   270 set :areUnitsAvailable.1:occupied 0
 
   300 label *label405
   301 label *label406
   302 label *label407
-    * print @mono
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  303 print "mono: occupied: {0}, free: "
+  304 format :areUnitsAvailable.1:occupied
   305 print :areUnitsAvailable.1:free
   306 jump *label408 lessThanEq :areUnitsAvailable.1:needed 0
   307 print ", needed: "
 
   603 jump __start__ equal *tmp211 false
   604 label *label323
   605 set :start @time
-    * print " === [gold]Supplying Overdrive Dome[] === "
-    * print "\n"
-    * print "\n"
-    * print "Unit type: [green]"
-    * print *tmp3
-    * print "["
-    * print "]"
-    * print "\n"
+  606 print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
+  607 format *tmp3
   608 # "Function: inline def printDomeStatus(in item, in text)"
-    * print "\n[green]Silicon[] status:\n"
   609 sensor :printDomeStatus.0:level .DOME @silicon
   610 jump *label139 lessThanEq :printDomeStatus.0:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.0:level
-    * print "["
-    * print "]"
-    * print "\n"
+  611 print "  dome:  [green]{0}[]\n"
+  612 format :printDomeStatus.0:level
   613 jump *label140 always
   614 label *label139
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.0:level
-    * print "["
-    * print "]"
-    * print "\n"
+  615 print "  dome:  [coral]{0}[]\n"
+  616 format :printDomeStatus.0:level
   617 label *label140
   618 label *label138
   619 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
 
   737 label *label169
   738 ucontrol flag :processUnit.0:state
   739 sensor *tmp279 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp279
-    * print "["
-    * print "]"
+  740 print "  {0}: [gold]{0}[]"
+  741 format .GROUP1
+  742 format *tmp279
   743 jump *label176 lessThan :processUnit.0:distance 0
   744 print :processUnit.0:msg
   745 print :processUnit.0:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  746 print "[] sec\n"
   747 jump *label177 always
   748 label *label176
   749 print :processUnit.0:msg
 
   874 label *label208
   875 ucontrol flag :processUnit.1:state
   876 sensor *tmp346 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp346
-    * print "["
-    * print "]"
+  877 print "  {0}: [gold]{0}[]"
+  878 format .GROUP2
+  879 format *tmp346
   880 jump *label215 lessThan :processUnit.1:distance 0
   881 print :processUnit.1:msg
   882 print :processUnit.1:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  883 print "[] sec\n"
   884 jump *label216 always
   885 label *label215
   886 print :processUnit.1:msg
 
   902 print "\n[green]Phase fabric[] status:\n"
   903 sensor :printDomeStatus.1:level .DOME @phase-fabric
   904 jump *label220 lessThanEq :printDomeStatus.1:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  905 print "  dome:  [green]{0}[]\n"
+  906 format :printDomeStatus.1:level
   907 jump *label221 always
   908 label *label220
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  909 print "  dome:  [coral]{0}[]\n"
+  910 format :printDomeStatus.1:level
   911 label *label221
   912 label *label219
   913 # "Function: inline def processUnit(in unit, in item, in group, in supply)"
 
  1031 label *label250
  1032 ucontrol flag :processUnit.2:state
  1033 sensor *tmp420 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp420
-    * print "["
-    * print "]"
+ 1034 print "  {0}: [gold]{0}[]"
+ 1035 format .GROUP1
+ 1036 format *tmp420
  1037 jump *label257 lessThan :processUnit.2:distance 0
  1038 print :processUnit.2:msg
  1039 print :processUnit.2:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1040 print "[] sec\n"
  1041 jump *label258 always
  1042 label *label257
  1043 print :processUnit.2:msg
 
  1168 label *label289
  1169 ucontrol flag :processUnit.3:state
  1170 sensor *tmp487 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp487
-    * print "["
-    * print "]"
+ 1171 print "  {0}: [gold]{0}[]"
+ 1172 format .GROUP2
+ 1173 format *tmp487
  1174 jump *label296 lessThan :processUnit.3:distance 0
  1175 print :processUnit.3:msg
  1176 print :processUnit.3:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1177 print "[] sec\n"
  1178 jump *label297 always
  1179 label *label296
  1180 print :processUnit.3:msg
 
  1194 label *label260
  1195 op sub *tmp495 @time :start
  1196 op floor *tmp496 *tmp495
-    * print "\n"
-    * print "[lightgray]Loop time: "
-    * print *tmp496
-    * print " "
-    * print "ms"
+ 1197 print "\n[lightgray]Loop time: {0} ms"
+ 1198 format *tmp496
  1199 printflush message1
  1200 op notEqual *tmp497 *tmp3 UNIT_TYPE
  1201 op greaterThan *tmp498 :unitCheck @time

Final code before resolving virtual instructions:

label __start__
remark "This is the preferred unit type to use for bringing in supplies."
remark "If no units of this type exist, we'll try using other types."
set UNIT_TYPE @flare
remark "Do not modify anything below this line."
set .DOME dome1
jump *label2 notEqual dome1 null
label *label321
print "[gold]Waiting for an overdrive dome to be connected..."
printflush message1
set .DOME dome1
jump *label321 equal dome1 null
label *label2
sensor *tmp1 switch1 @enabled
jump *label5 notEqual *tmp1 false
label *label322
print "[coral]Activate switch to begin supplying overdrive dome...\n"
printflush message1
sensor *tmp1 switch1 @enabled
jump *label322 equal *tmp1 false
label *label5
# "Function: inline def chooseUnitType()"
label *label7
printflush null
print "[gold]Looking for suitable unit type:[]\n"
remark "chooseUnitType: "
remark UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.0:needed 0
set :areUnitsAvailable.0:occupied 0
set :areUnitsAvailable.0:free 0
ubind UNIT_TYPE
set :areUnitsAvailable.0:firstUnit @unit
jump *label11 equal :areUnitsAvailable.0:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :areUnitsAvailable.0:needed 2
label *label16
sensor *tmp17 @unit @controlled
op equal *tmp18 *tmp17 0
sensor *tmp19 @unit @controller
op equal *tmp20 *tmp19 @this
op or *tmp21 *tmp18 *tmp20
jump *label19 equal *tmp21 false
op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
jump *label20 lessThan :areUnitsAvailable.0:free 2
set *tmp4 true
jump *label10 always
label *label19
op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
label *label20
ubind UNIT_TYPE
op notEqual *tmp25 @unit :areUnitsAvailable.0:firstUnit
sensor *tmp26 :areUnitsAvailable.0:firstUnit @dead
op equal *tmp27 *tmp26 0
op land *tmp28 *tmp25 *tmp27
jump *label16 notEqual *tmp28 false
label *label11
print UNIT_TYPE
print ": occupied: {0}, free: "
format :areUnitsAvailable.0:occupied
print :areUnitsAvailable.0:free
jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
print ", needed: "
print :areUnitsAvailable.0:needed
label *label25
print "\n"
set *tmp4 false
label *label10
jump *label27 equal *tmp4 false
set *tmp3 UNIT_TYPE
jump *label6 always
label *label27
jump *label343 equal @flare UNIT_TYPE
remark "chooseUnitType: flare"
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @flare
set :areUnitsAvailable.1:firstUnit @unit
jump *label334 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :areUnitsAvailable.1:needed 2
label *label327
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label330 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label331 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label340 always
label *label330
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label331
ubind @flare
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label327 notEqual *tmp60 false
label *label334
print "flare: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label336 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label336
print "\n"
set *tmp36 false
label *label340
jump *label341 equal *tmp36 false
printflush null
set *tmp3 @flare
jump *label6 always
label *label341
label *label343
jump *label367 equal @poly UNIT_TYPE
remark "chooseUnitType: poly"
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @poly
set :areUnitsAvailable.1:firstUnit @unit
jump *label358 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :areUnitsAvailable.1:needed 2
label *label351
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label354 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label355 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label364 always
label *label354
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label355
ubind @poly
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label351 notEqual *tmp60 false
label *label358
print "poly: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label360 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label360
print "\n"
set *tmp36 false
label *label364
jump *label365 equal *tmp36 false
printflush null
set *tmp3 @poly
jump *label6 always
label *label365
label *label367
jump *label391 equal @mega UNIT_TYPE
remark "chooseUnitType: mega"
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @mega
set :areUnitsAvailable.1:firstUnit @unit
jump *label382 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :areUnitsAvailable.1:needed 2
label *label375
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label378 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label379 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label388 always
label *label378
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label379
ubind @mega
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label375 notEqual *tmp60 false
label *label382
print "mega: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label384 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label384
print "\n"
set *tmp36 false
label *label388
jump *label389 equal *tmp36 false
printflush null
set *tmp3 @mega
jump *label6 always
label *label389
label *label391
jump *label415 equal @mono UNIT_TYPE
remark "chooseUnitType: mono"
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @mono
set :areUnitsAvailable.1:firstUnit @unit
jump *label406 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :areUnitsAvailable.1:needed 2
label *label399
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label402 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label403 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label412 always
label *label402
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label403
ubind @mono
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label399 notEqual *tmp60 false
label *label406
print "mono: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label408 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label408
print "\n"
set *tmp36 false
label *label412
jump *label413 equal *tmp36 false
printflush null
set *tmp3 @mono
jump *label6 always
label *label413
label *label415
printflush message1
jump *label7 always
label *label6
print "[gold]Binding units..."
printflush message1
# "Function: inline def rebindUnits()"
set .UNIT_P2 null
set .UNIT_S2 null
set .UNIT_P1 null
set .UNIT_S1 null
set :rebindUnits.0:count 0
ubind *tmp3
set :rebindUnits.0:firstUnit @unit
jump *label60 notEqual :rebindUnits.0:firstUnit null
end
label *label60
label *label62
sensor *tmp69 @unit @controller
jump *label65 notEqual *tmp69 @this
op add :rebindUnits.0:count :rebindUnits.0:count 1
ucontrol flag 1
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 .UNIT_P1
set .UNIT_P1 @unit
jump *label64 notEqual .UNIT_S2 null
label *label65
ubind *tmp3
op notEqual *tmp75 @unit :rebindUnits.0:firstUnit
sensor *tmp76 :rebindUnits.0:firstUnit @dead
op equal *tmp77 *tmp76 0
op land *tmp78 *tmp75 *tmp77
jump *label62 notEqual *tmp78 false
label *label64
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label71 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp83 @unit @dead
op strictEqual *tmp84 *tmp83 0
sensor *tmp85 @unit @controller
op equal *tmp86 *tmp85 @this
op land *tmp87 *tmp84 *tmp86
jump *label70 notEqual *tmp87 false
label *label71
ubind *tmp3
set :rebindUnit.0:firstUnit @unit
jump __start__ equal :rebindUnit.0:firstUnit null
label *label77
sensor *tmp92 @unit @controlled
jump *label70 equal *tmp92 0
ubind *tmp3
op notEqual *tmp95 @unit :rebindUnit.0:firstUnit
sensor *tmp96 :rebindUnit.0:firstUnit @dead
op equal *tmp97 *tmp96 0
op land *tmp98 *tmp95 *tmp97
jump *label77 notEqual *tmp98 false
end
label *label70
ucontrol flag 1
set *tmp79 @unit
set .UNIT_S1 *tmp79
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label84 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp103 @unit @dead
op strictEqual *tmp104 *tmp103 0
sensor *tmp105 @unit @controller
op equal *tmp106 *tmp105 @this
op land *tmp107 *tmp104 *tmp106
jump *label83 notEqual *tmp107 false
label *label84
ubind *tmp3
set :rebindUnit.1:firstUnit @unit
jump __start__ equal :rebindUnit.1:firstUnit null
label *label90
sensor *tmp112 @unit @controlled
jump *label83 equal *tmp112 0
ubind *tmp3
op notEqual *tmp115 @unit :rebindUnit.1:firstUnit
sensor *tmp116 :rebindUnit.1:firstUnit @dead
op equal *tmp117 *tmp116 0
op land *tmp118 *tmp115 *tmp117
jump *label90 notEqual *tmp118 false
end
label *label83
ucontrol flag 1
set *tmp99 @unit
set .UNIT_P1 *tmp99
sensor *tmp119 *tmp79 @firstItem
op equal *tmp120 *tmp119 @phase-fabric
sensor *tmp121 *tmp99 @firstItem
op equal *tmp122 *tmp121 @silicon
op or *tmp123 *tmp120 *tmp122
jump *label95 equal *tmp123 false
set .UNIT_S1 *tmp99
set .UNIT_P1 *tmp79
label *label95
sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
sensor .SPEED .UNIT_S1 @speed
op div .SPEED_TENTHS .SPEED 10
op strictEqual *tmp128 .SPEED null
jump *label97 equal *tmp128 false
stop
label *label97
print "[gold]Locating core..."
printflush message1
label *label99
ulocate building core false @copper 0 0 0 .CORE
jump *label99 equal .CORE null
sensor .CORE_X .CORE @x
sensor .CORE_Y .CORE @y
sensor .DOME_X .DOME @x
sensor .DOME_Y .DOME @y
# "Function: inline def needsFourUnits(in unit)"
op sub *tmp140 .DOME_X .CORE_X
op sub *tmp141 .DOME_Y .CORE_Y
op len *tmp142 *tmp140 *tmp141
op mul *tmp143 2 *tmp142
op div :needsFourUnits.2:travel_time *tmp143 .SPEED
op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
jump *label103 equal *tmp139 false
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label107 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp152 @unit @dead
op strictEqual *tmp153 *tmp152 0
sensor *tmp154 @unit @controller
op equal *tmp155 *tmp154 @this
op land *tmp156 *tmp153 *tmp155
jump *label106 notEqual *tmp156 false
label *label107
ubind *tmp3
set :rebindUnit.2:firstUnit @unit
jump __start__ equal :rebindUnit.2:firstUnit null
label *label113
sensor *tmp161 @unit @controlled
jump *label106 equal *tmp161 0
ubind *tmp3
op notEqual *tmp164 @unit :rebindUnit.2:firstUnit
sensor *tmp165 :rebindUnit.2:firstUnit @dead
op equal *tmp166 *tmp165 0
op land *tmp167 *tmp164 *tmp166
jump *label113 notEqual *tmp167 false
end
label *label106
ucontrol flag 1
set *tmp148 @unit
set .UNIT_S2 *tmp148
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label120 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp172 @unit @dead
op strictEqual *tmp173 *tmp172 0
sensor *tmp174 @unit @controller
op equal *tmp175 *tmp174 @this
op land *tmp176 *tmp173 *tmp175
jump *label119 notEqual *tmp176 false
label *label120
ubind *tmp3
set :rebindUnit.3:firstUnit @unit
jump __start__ equal :rebindUnit.3:firstUnit null
label *label126
sensor *tmp181 @unit @controlled
jump *label119 equal *tmp181 0
ubind *tmp3
op notEqual *tmp184 @unit :rebindUnit.3:firstUnit
sensor *tmp185 :rebindUnit.3:firstUnit @dead
op equal *tmp186 *tmp185 0
op land *tmp187 *tmp184 *tmp186
jump *label126 notEqual *tmp187 false
end
label *label119
ucontrol flag 1
set *tmp168 @unit
set .UNIT_P2 *tmp168
sensor *tmp188 .UNIT_S1 @firstItem
op equal *tmp189 *tmp188 @phase-fabric
sensor *tmp190 *tmp168 @firstItem
op notEqual *tmp191 *tmp190 @phase-fabric
op land *tmp192 *tmp189 *tmp191
jump *label131 equal *tmp192 false
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 *tmp168
label *label131
sensor *tmp194 *tmp148 @firstItem
op equal *tmp195 *tmp194 @phase-fabric
sensor *tmp196 .UNIT_P2 @firstItem
op equal *tmp197 *tmp196 @silicon
op or *tmp198 *tmp195 *tmp197
jump *label133 equal *tmp198 false
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 *tmp148
label *label133
set .GROUP1 "unit  1"
set .GROUP2 "unit 2"
jump *label104 always
label *label103
ubind .UNIT_S2
ucontrol unbind
set .UNIT_S2 null
ubind .UNIT_P2
ucontrol unbind
set .UNIT_P2 null
set .GROUP1 "unit"
set .GROUP2 ""
label *label104
op equal *tmp200 *tmp139 false
sensor *tmp201 .UNIT_S1 @totalItems
sensor *tmp202 .UNIT_S2 @totalItems
op lessThan *tmp203 *tmp201 *tmp202
op or .SUPPLY_S_FIRST *tmp200 *tmp203
sensor *tmp206 .UNIT_P1 @totalItems
sensor *tmp207 .UNIT_P2 @totalItems
op lessThan *tmp208 *tmp206 *tmp207
op or .SUPPLY_P_FIRST *tmp200 *tmp208
op add :unitCheck @time 5000
sensor *tmp211 switch1 @enabled
jump __start__ equal *tmp211 false
label *label323
set :start @time
print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
format *tmp3
# "Function: inline def printDomeStatus(in item, in text)"
sensor :printDomeStatus.0:level .DOME @silicon
jump *label139 lessThanEq :printDomeStatus.0:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.0:level
jump *label140 always
label *label139
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.0:level
label *label140
# "Function: inline def processUnit(in unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label143 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp221 @unit @dead
op strictEqual *tmp222 *tmp221 0
sensor *tmp223 @unit @controller
op equal *tmp224 *tmp223 @this
op land *tmp225 *tmp222 *tmp224
jump *label142 notEqual *tmp225 false
label *label143
ubind *tmp3
set :rebindUnit.4:firstUnit @unit
jump __start__ equal :rebindUnit.4:firstUnit null
label *label149
sensor *tmp230 @unit @controlled
jump *label142 equal *tmp230 0
ubind *tmp3
op notEqual *tmp233 @unit :rebindUnit.4:firstUnit
sensor *tmp234 :rebindUnit.4:firstUnit @dead
op equal *tmp235 *tmp234 0
op land *tmp236 *tmp233 *tmp235
jump *label149 notEqual *tmp236 false
end
label *label142
set :processUnit.0:msg ""
sensor :processUnit.0:state @unit @flag
set :processUnit.0:distance -1
op lessThan *tmp238 :processUnit.0:state 2
op greaterThan *tmp239 :processUnit.0:state 3
op or *tmp240 *tmp238 *tmp239
jump *label154 equal *tmp240 false
sensor *tmp242 @unit @firstItem
jump *label156 notEqual *tmp242 @silicon
set :processUnit.0:state 3
jump *label157 always
label *label156
sensor *tmp245 @unit @totalItems
jump *label158 notEqual *tmp245 0
set :processUnit.0:state 2
jump *label159 always
label *label158
set :processUnit.0:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp248
jump *label160 equal *tmp248 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label160
label *label159
label *label157
label *label154
jump *label162 notEqual :processUnit.0:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp252
jump *label164 equal *tmp252 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp254 @unit @totalItems
jump *label166 lessThan *tmp254 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.0:state 3
jump *label165 always
label *label166
set :processUnit.0:msg ", loading\n"
jump *label165 always
label *label164
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.0:msg ", fetching in [gold]"
sensor *tmp257 @unit @x
op sub *tmp258 .CORE_X *tmp257
sensor *tmp259 @unit @y
op sub *tmp260 .CORE_Y *tmp259
op len *tmp261 *tmp258 *tmp260
op idiv *tmp262 *tmp261 .SPEED_TENTHS
op div :processUnit.0:distance *tmp262 10
label *label165
label *label162
jump *label168 notEqual :processUnit.0:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp266
jump *label170 equal *tmp266 false
jump *label172 equal .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.0:msg ", supplying\n"
jump *label173 always
label *label172
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.0:msg ", waiting\n"
label *label173
sensor *tmp269 @unit @totalItems
jump *label171 greaterThan *tmp269 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.0:state 2
jump *label171 always
label *label170
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.0:msg ", returning in [gold]"
sensor *tmp272 @unit @x
op sub *tmp273 .DOME_X *tmp272
sensor *tmp274 @unit @y
op sub *tmp275 .DOME_Y *tmp274
op len *tmp276 *tmp273 *tmp275
op idiv *tmp277 *tmp276 .SPEED_TENTHS
op div :processUnit.0:distance *tmp277 10
label *label171
label *label168
ucontrol flag :processUnit.0:state
sensor *tmp279 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp279
jump *label176 lessThan :processUnit.0:distance 0
print :processUnit.0:msg
print :processUnit.0:distance
print "[] sec\n"
jump *label177 always
label *label176
print :processUnit.0:msg
label *label177
set *tmp217 @unit
set .UNIT_S1 *tmp217
jump *label178 equal *tmp139 false
op equal *tmp283 .SUPPLY_S_FIRST false
# "Function: inline def processUnit(in unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label182 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp288 @unit @dead
op strictEqual *tmp289 *tmp288 0
sensor *tmp290 @unit @controller
op equal *tmp291 *tmp290 @this
op land *tmp292 *tmp289 *tmp291
jump *label181 notEqual *tmp292 false
label *label182
ubind *tmp3
set :rebindUnit.5:firstUnit @unit
jump __start__ equal :rebindUnit.5:firstUnit null
label *label188
sensor *tmp297 @unit @controlled
jump *label181 equal *tmp297 0
ubind *tmp3
op notEqual *tmp300 @unit :rebindUnit.5:firstUnit
sensor *tmp301 :rebindUnit.5:firstUnit @dead
op equal *tmp302 *tmp301 0
op land *tmp303 *tmp300 *tmp302
jump *label188 notEqual *tmp303 false
end
label *label181
set :processUnit.1:msg ""
sensor :processUnit.1:state @unit @flag
set :processUnit.1:distance -1
op lessThan *tmp305 :processUnit.1:state 2
op greaterThan *tmp306 :processUnit.1:state 3
op or *tmp307 *tmp305 *tmp306
jump *label193 equal *tmp307 false
sensor *tmp309 @unit @firstItem
jump *label195 notEqual *tmp309 @silicon
set :processUnit.1:state 3
jump *label196 always
label *label195
sensor *tmp312 @unit @totalItems
jump *label197 notEqual *tmp312 0
set :processUnit.1:state 2
jump *label198 always
label *label197
set :processUnit.1:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp315
jump *label199 equal *tmp315 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label199
label *label198
label *label196
label *label193
jump *label201 notEqual :processUnit.1:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp319
jump *label203 equal *tmp319 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp321 @unit @totalItems
jump *label205 lessThan *tmp321 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:state 3
jump *label204 always
label *label205
set :processUnit.1:msg ", loading\n"
jump *label204 always
label *label203
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:msg ", fetching in [gold]"
sensor *tmp324 @unit @x
op sub *tmp325 .CORE_X *tmp324
sensor *tmp326 @unit @y
op sub *tmp327 .CORE_Y *tmp326
op len *tmp328 *tmp325 *tmp327
op idiv *tmp329 *tmp328 .SPEED_TENTHS
op div :processUnit.1:distance *tmp329 10
label *label204
label *label201
jump *label207 notEqual :processUnit.1:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp333
jump *label209 equal *tmp333 false
jump *label211 equal *tmp283 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.1:msg ", supplying\n"
jump *label212 always
label *label211
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:msg ", waiting\n"
label *label212
sensor *tmp336 @unit @totalItems
jump *label210 greaterThan *tmp336 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:state 2
jump *label210 always
label *label209
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:msg ", returning in [gold]"
sensor *tmp339 @unit @x
op sub *tmp340 .DOME_X *tmp339
sensor *tmp341 @unit @y
op sub *tmp342 .DOME_Y *tmp341
op len *tmp343 *tmp340 *tmp342
op idiv *tmp344 *tmp343 .SPEED_TENTHS
op div :processUnit.1:distance *tmp344 10
label *label210
label *label207
ucontrol flag :processUnit.1:state
sensor *tmp346 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp346
jump *label215 lessThan :processUnit.1:distance 0
print :processUnit.1:msg
print :processUnit.1:distance
print "[] sec\n"
jump *label216 always
label *label215
print :processUnit.1:msg
label *label216
set *tmp284 @unit
set .UNIT_S2 *tmp284
jump *label217 equal .SUPPLY_S_FIRST false
sensor *tmp350 *tmp217 @totalItems
op greaterThan .SUPPLY_S_FIRST *tmp350 0
jump *label218 always
label *label217
sensor *tmp352 *tmp284 @totalItems
op equal .SUPPLY_S_FIRST *tmp352 0
label *label218
label *label178
# "Function: inline def printDomeStatus(in item, in text)"
print "\n[green]Phase fabric[] status:\n"
sensor :printDomeStatus.1:level .DOME @phase-fabric
jump *label220 lessThanEq :printDomeStatus.1:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.1:level
jump *label221 always
label *label220
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.1:level
label *label221
# "Function: inline def processUnit(in unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label224 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp362 @unit @dead
op strictEqual *tmp363 *tmp362 0
sensor *tmp364 @unit @controller
op equal *tmp365 *tmp364 @this
op land *tmp366 *tmp363 *tmp365
jump *label223 notEqual *tmp366 false
label *label224
ubind *tmp3
set :rebindUnit.6:firstUnit @unit
jump __start__ equal :rebindUnit.6:firstUnit null
label *label230
sensor *tmp371 @unit @controlled
jump *label223 equal *tmp371 0
ubind *tmp3
op notEqual *tmp374 @unit :rebindUnit.6:firstUnit
sensor *tmp375 :rebindUnit.6:firstUnit @dead
op equal *tmp376 *tmp375 0
op land *tmp377 *tmp374 *tmp376
jump *label230 notEqual *tmp377 false
end
label *label223
set :processUnit.2:msg ""
sensor :processUnit.2:state @unit @flag
set :processUnit.2:distance -1
op lessThan *tmp379 :processUnit.2:state 2
op greaterThan *tmp380 :processUnit.2:state 3
op or *tmp381 *tmp379 *tmp380
jump *label235 equal *tmp381 false
sensor *tmp383 @unit @firstItem
jump *label237 notEqual *tmp383 @phase-fabric
set :processUnit.2:state 3
jump *label238 always
label *label237
sensor *tmp386 @unit @totalItems
jump *label239 notEqual *tmp386 0
set :processUnit.2:state 2
jump *label240 always
label *label239
set :processUnit.2:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp389
jump *label241 equal *tmp389 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label241
label *label240
label *label238
label *label235
jump *label243 notEqual :processUnit.2:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp393
jump *label245 equal *tmp393 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp395 @unit @totalItems
jump *label247 lessThan *tmp395 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:state 3
jump *label246 always
label *label247
set :processUnit.2:msg ", loading\n"
jump *label246 always
label *label245
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:msg ", fetching in [gold]"
sensor *tmp398 @unit @x
op sub *tmp399 .CORE_X *tmp398
sensor *tmp400 @unit @y
op sub *tmp401 .CORE_Y *tmp400
op len *tmp402 *tmp399 *tmp401
op idiv *tmp403 *tmp402 .SPEED_TENTHS
op div :processUnit.2:distance *tmp403 10
label *label246
label *label243
jump *label249 notEqual :processUnit.2:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp407
jump *label251 equal *tmp407 false
jump *label253 equal .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.2:msg ", supplying\n"
jump *label254 always
label *label253
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:msg ", waiting\n"
label *label254
sensor *tmp410 @unit @totalItems
jump *label252 greaterThan *tmp410 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:state 2
jump *label252 always
label *label251
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:msg ", returning in [gold]"
sensor *tmp413 @unit @x
op sub *tmp414 .DOME_X *tmp413
sensor *tmp415 @unit @y
op sub *tmp416 .DOME_Y *tmp415
op len *tmp417 *tmp414 *tmp416
op idiv *tmp418 *tmp417 .SPEED_TENTHS
op div :processUnit.2:distance *tmp418 10
label *label252
label *label249
ucontrol flag :processUnit.2:state
sensor *tmp420 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp420
jump *label257 lessThan :processUnit.2:distance 0
print :processUnit.2:msg
print :processUnit.2:distance
print "[] sec\n"
jump *label258 always
label *label257
print :processUnit.2:msg
label *label258
set *tmp358 @unit
set .UNIT_P1 *tmp358
jump *label259 equal *tmp139 false
op equal *tmp424 .SUPPLY_P_FIRST false
# "Function: inline def processUnit(in unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label263 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp429 @unit @dead
op strictEqual *tmp430 *tmp429 0
sensor *tmp431 @unit @controller
op equal *tmp432 *tmp431 @this
op land *tmp433 *tmp430 *tmp432
jump *label262 notEqual *tmp433 false
label *label263
ubind *tmp3
set :rebindUnit.7:firstUnit @unit
jump __start__ equal :rebindUnit.7:firstUnit null
label *label269
sensor *tmp438 @unit @controlled
jump *label262 equal *tmp438 0
ubind *tmp3
op notEqual *tmp441 @unit :rebindUnit.7:firstUnit
sensor *tmp442 :rebindUnit.7:firstUnit @dead
op equal *tmp443 *tmp442 0
op land *tmp444 *tmp441 *tmp443
jump *label269 notEqual *tmp444 false
end
label *label262
set :processUnit.3:msg ""
sensor :processUnit.3:state @unit @flag
set :processUnit.3:distance -1
op lessThan *tmp446 :processUnit.3:state 2
op greaterThan *tmp447 :processUnit.3:state 3
op or *tmp448 *tmp446 *tmp447
jump *label274 equal *tmp448 false
sensor *tmp450 @unit @firstItem
jump *label276 notEqual *tmp450 @phase-fabric
set :processUnit.3:state 3
jump *label277 always
label *label276
sensor *tmp453 @unit @totalItems
jump *label278 notEqual *tmp453 0
set :processUnit.3:state 2
jump *label279 always
label *label278
set :processUnit.3:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp456
jump *label280 equal *tmp456 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label280
label *label279
label *label277
label *label274
jump *label282 notEqual :processUnit.3:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp460
jump *label284 equal *tmp460 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp462 @unit @totalItems
jump *label286 lessThan *tmp462 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:state 3
jump *label285 always
label *label286
set :processUnit.3:msg ", loading\n"
jump *label285 always
label *label284
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:msg ", fetching in [gold]"
sensor *tmp465 @unit @x
op sub *tmp466 .CORE_X *tmp465
sensor *tmp467 @unit @y
op sub *tmp468 .CORE_Y *tmp467
op len *tmp469 *tmp466 *tmp468
op idiv *tmp470 *tmp469 .SPEED_TENTHS
op div :processUnit.3:distance *tmp470 10
label *label285
label *label282
jump *label288 notEqual :processUnit.3:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp474
jump *label290 equal *tmp474 false
jump *label292 equal *tmp424 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.3:msg ", supplying\n"
jump *label293 always
label *label292
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:msg ", waiting\n"
label *label293
sensor *tmp477 @unit @totalItems
jump *label291 greaterThan *tmp477 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:state 2
jump *label291 always
label *label290
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:msg ", returning in [gold]"
sensor *tmp480 @unit @x
op sub *tmp481 .DOME_X *tmp480
sensor *tmp482 @unit @y
op sub *tmp483 .DOME_Y *tmp482
op len *tmp484 *tmp481 *tmp483
op idiv *tmp485 *tmp484 .SPEED_TENTHS
op div :processUnit.3:distance *tmp485 10
label *label291
label *label288
ucontrol flag :processUnit.3:state
sensor *tmp487 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp487
jump *label296 lessThan :processUnit.3:distance 0
print :processUnit.3:msg
print :processUnit.3:distance
print "[] sec\n"
jump *label297 always
label *label296
print :processUnit.3:msg
label *label297
set *tmp425 @unit
set .UNIT_P2 *tmp425
jump *label298 equal .SUPPLY_P_FIRST false
sensor *tmp491 *tmp358 @totalItems
op greaterThan .SUPPLY_P_FIRST *tmp491 0
jump *label299 always
label *label298
sensor *tmp493 *tmp425 @totalItems
op equal .SUPPLY_P_FIRST *tmp493 0
label *label299
label *label259
op sub *tmp495 @time :start
op floor *tmp496 *tmp495
print "\n[lightgray]Loop time: {0} ms"
format *tmp496
printflush message1
op notEqual *tmp497 *tmp3 UNIT_TYPE
op greaterThan *tmp498 :unitCheck @time
op land *tmp499 *tmp497 *tmp498
jump *label300 equal *tmp499 false
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.2:occupied 0
set :areUnitsAvailable.2:free 0
ubind UNIT_TYPE
set :areUnitsAvailable.2:firstUnit @unit
jump *label315 equal :areUnitsAvailable.2:firstUnit null
set *tmp513 2
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.3:unit @unit
sensor *tmp510 :needsFourUnits.3:unit @speed
op div :needsFourUnits.3:travel_time *tmp143 *tmp510
jump *label307 lessThan :needsFourUnits.3:travel_time 47
set *tmp513 4
label *label307
label *label308
sensor *tmp514 @unit @controlled
op equal *tmp515 *tmp514 0
sensor *tmp516 @unit @controller
op equal *tmp517 *tmp516 @this
op or *tmp518 *tmp515 *tmp517
jump *label311 equal *tmp518 false
op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
jump *label312 lessThan :areUnitsAvailable.2:free *tmp513
set *tmp501 true
jump *label302 always
label *label311
op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
label *label312
ubind UNIT_TYPE
op notEqual *tmp522 @unit :areUnitsAvailable.2:firstUnit
sensor *tmp523 :areUnitsAvailable.2:firstUnit @dead
op equal *tmp524 *tmp523 0
op land *tmp525 *tmp522 *tmp524
jump *label308 notEqual *tmp525 false
label *label315
set *tmp501 false
label *label302
jump *label319 equal *tmp501 false
end
label *label319
op add :unitCheck @time 5000
label *label300
sensor *tmp211 switch1 @enabled
jump *label323 notEqual *tmp211 false
