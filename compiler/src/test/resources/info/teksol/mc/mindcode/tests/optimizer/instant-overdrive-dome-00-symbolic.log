  1434 instructions before optimizations.
    52 instructions eliminated by Temp Variables Elimination.
   263 instructions eliminated by Dead Code Elimination (2 passes, 8 iterations).
     3 instructions eliminated by Jump Normalization (3 passes, 5 iterations).
    71 instructions eliminated by Jump Optimization (2 passes, 5 iterations).
   104 instructions eliminated by Single Step Elimination (4 passes, 9 iterations).
     2 instructions modified by Expression Optimization (4 iterations).
     2 instructions eliminated by If Expression Optimization (4 iterations).
    98 instructions eliminated by Data Flow Optimization (4 passes, 17 iterations).
     2 instructions added by Loop Optimization (4 iterations).
     3 loops improved by Loop Optimization.
   141 instructions added by Loop Unrolling (7 iterations).
     1 loops unrolled by Loop Unrolling.
    17 instructions eliminated by Jump Straightening (5 iterations).
    24 instructions updated by JumpThreading.
    18 instructions eliminated by Unreachable Code Elimination.
    83 instructions eliminated by Print Merging.
   866 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 201):
  * Replicate loop condition at line 44:1                        cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
    Replicate loop condition at line 127:1                       cost     1, benefit       25.0, efficiency       25.0
  ! Unroll iteration loop at line 177:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 1: speed optimization selection (cost limit 200):
  * Replicate loop condition at line 127:1                       cost     1, benefit       25.0, efficiency       25.0 (+1 instructions)
  ! Unroll iteration loop at line 177:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 1: speed optimization selection (cost limit 199):
  ! Unroll iteration loop at line 177:9                          cost   213, benefit      375.0, efficiency        1.8

Pass 2: speed optimization selection (cost limit 230):
  * Unroll iteration loop at line 177:9                          cost   181, benefit      375.0, efficiency        2.1 (+133 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-166 instructions):
 
    79 label *label21
    80 set *tmp24 null
    81 label *label22
-    * set *tmp22 *tmp24
    82 jump *label20 always
    83 label *label19
    84 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
-    * set *tmp22 :areUnitsAvailable.0:occupied
    85 label *label20
    86 ubind :areUnitsAvailable.0:type
    87 label *label17
 
    91 op land *tmp28 *tmp25 *tmp27
    92 jump *label16 notEqual *tmp28 false
    93 label *label18
-    * set *tmp7 null
    94 jump *label12 always
    95 label *label11
-    * set *tmp7 null
    96 label *label12
    97 jump *label23 equal :areUnitsAvailable.0:output false
    98 print :areUnitsAvailable.0:type
 
   106 jump *label25 equal *tmp30 false
   107 print ", needed: "
   108 print :areUnitsAvailable.0:needed
-    * set *tmp31 null
   109 jump *label26 always
   110 label *label25
-    * set *tmp31 null
   111 label *label26
   112 print "\n"
-    * set *tmp29 null
   113 jump *label24 always
   114 label *label23
-    * set *tmp29 null
   115 label *label24
   116 set *tmp4 false
   117 jump *label10 always
 
   120 jump *label27 equal *tmp4 false
   121 set *tmp3 UNIT_TYPE
   122 jump *label6 always
-    * set *tmp32 null
   123 jump *label28 always
   124 label *label27
-    * set *tmp32 null
   125 label *label28
   126 set :chooseUnitType.0:type @flare
   127 op add *tmp33 @counter 1
 
   192 label *label51
   193 set *tmp56 null
   194 label *label52
-    * set *tmp54 *tmp56
   195 jump *label50 always
   196 label *label49
   197 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp54 :areUnitsAvailable.1:occupied
   198 label *label50
   199 ubind :areUnitsAvailable.1:type
   200 label *label47
 
   204 op land *tmp60 *tmp57 *tmp59
   205 jump *label46 notEqual *tmp60 false
   206 label *label48
-    * set *tmp39 null
   207 jump *label42 always
   208 label *label41
-    * set *tmp39 null
   209 label *label42
   210 jump *label53 equal :areUnitsAvailable.1:output false
   211 print :areUnitsAvailable.1:type
 
   219 jump *label55 equal *tmp62 false
   220 print ", needed: "
   221 print :areUnitsAvailable.1:needed
-    * set *tmp63 null
   222 jump *label56 always
   223 label *label55
-    * set *tmp63 null
   224 label *label56
   225 print "\n"
-    * set *tmp61 null
   226 jump *label54 always
   227 label *label53
-    * set *tmp61 null
   228 label *label54
   229 set *tmp36 false
   230 jump *label40 always
 
   239 label *label57
   240 set *tmp64 null
   241 label *label58
-    * set *tmp35 *tmp64
   242 jump *label39 always
   243 label *label38
-    * set *tmp35 null
   244 label *label39
   245 label *label30
   246 multijump *tmp33 0 0
 
   267 op equal *tmp67 :rebindUnits.0:firstUnit null
   268 jump *label60 equal *tmp67 false
   269 end
-    * set *tmp68 null
   270 jump *label61 always
   271 label *label60
-    * set *tmp68 null
   272 label *label61
   273 label *label62
   274 sensor *tmp69 @unit @controller
 
   289 label *label67
   290 set *tmp74 null
   291 label *label68
-    * set *tmp71 *tmp74
   292 jump *label66 always
   293 label *label65
-    * set *tmp71 null
   294 label *label66
   295 ubind .TYPE
   296 label *label63
 
   300 op land *tmp78 *tmp75 *tmp77
   301 jump *label62 notEqual *tmp78 false
   302 label *label64
-    * set *tmp65 :rebindUnits.0:count
   303 jump *label59 always
-    * set *tmp65 null
   304 label *label59
   305 set :acquireUnit.0:currentUnit .UNIT_S1
   306 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
 
   313 op equal *tmp86 *tmp85 @this
   314 op land *tmp87 *tmp84 *tmp86
   315 jump *label73 equal *tmp87 false
-    * set *tmp80 :rebindUnit.0:currentUnit
   316 jump *label70 always
   317 set *tmp88 null
   318 jump *label74 always
   319 label *label73
   320 set *tmp88 null
   321 label *label74
-    * set *tmp82 *tmp88
   322 jump *label72 always
   323 label *label71
-    * set *tmp82 null
   324 label *label72
   325 ubind .TYPE
   326 set *tmp89 @unit
 
   331 sensor *tmp92 @unit @controlled
   332 op equal *tmp93 *tmp92 0
   333 jump *label80 equal *tmp93 false
-    * set *tmp80 @unit
   334 jump *label70 always
-    * set *tmp94 null
   335 jump *label81 always
   336 label *label80
-    * set *tmp94 null
   337 label *label81
   338 ubind .TYPE
   339 label *label78
 
   343 op land *tmp98 *tmp95 *tmp97
   344 jump *label77 notEqual *tmp98 false
   345 label *label79
-    * set *tmp91 null
   346 jump *label76 always
   347 label *label75
-    * set *tmp91 null
   348 label *label76
   349 end
-    * set *tmp80 null
   350 label *label70
   351 ucontrol flag 1
   352 set *tmp79 @unit
 
   365 op equal *tmp106 *tmp105 @this
   366 op land *tmp107 *tmp104 *tmp106
   367 jump *label86 equal *tmp107 false
-    * set *tmp100 :rebindUnit.1:currentUnit
   368 jump *label83 always
   369 set *tmp108 null
   370 jump *label87 always
   371 label *label86
   372 set *tmp108 null
   373 label *label87
-    * set *tmp102 *tmp108
   374 jump *label85 always
   375 label *label84
-    * set *tmp102 null
   376 label *label85
   377 ubind .TYPE
   378 set *tmp109 @unit
 
   383 sensor *tmp112 @unit @controlled
   384 op equal *tmp113 *tmp112 0
   385 jump *label93 equal *tmp113 false
-    * set *tmp100 @unit
   386 jump *label83 always
-    * set *tmp114 null
   387 jump *label94 always
   388 label *label93
-    * set *tmp114 null
   389 label *label94
   390 ubind .TYPE
   391 label *label91
 
   395 op land *tmp118 *tmp115 *tmp117
   396 jump *label90 notEqual *tmp118 false
   397 label *label92
-    * set *tmp111 null
   398 jump *label89 always
   399 label *label88
-    * set *tmp111 null
   400 label *label89
   401 end
-    * set *tmp100 null
   402 label *label83
   403 ucontrol flag 1
   404 set *tmp99 @unit
 
   415 set :u .UNIT_S1
   416 set .UNIT_S1 .UNIT_P1
   417 set .UNIT_P1 :u
-    * set *tmp124 .UNIT_P1
   418 jump *label96 always
   419 label *label95
-    * set *tmp124 null
   420 label *label96
   421 sensor *tmp125 .UNIT_S1 @itemCapacity
   422 set .UNIT_CAPACITY *tmp125
 
   427 op strictEqual *tmp128 .SPEED null
   428 jump *label97 equal *tmp128 false
   429 stop
-    * set *tmp129 null
   430 jump *label98 always
   431 label *label97
-    * set *tmp129 null
   432 label *label98
   433 print "[gold]Locating core..."
   434 printflush message1
 
   473 op equal *tmp155 *tmp154 @this
   474 op land *tmp156 *tmp153 *tmp155
   475 jump *label109 equal *tmp156 false
-    * set *tmp149 :rebindUnit.2:currentUnit
   476 jump *label106 always
   477 set *tmp157 null
   478 jump *label110 always
   479 label *label109
   480 set *tmp157 null
   481 label *label110
-    * set *tmp151 *tmp157
   482 jump *label108 always
   483 label *label107
-    * set *tmp151 null
   484 label *label108
   485 ubind .TYPE
   486 set *tmp158 @unit
 
   491 sensor *tmp161 @unit @controlled
   492 op equal *tmp162 *tmp161 0
   493 jump *label116 equal *tmp162 false
-    * set *tmp149 @unit
   494 jump *label106 always
-    * set *tmp163 null
   495 jump *label117 always
   496 label *label116
-    * set *tmp163 null
   497 label *label117
   498 ubind .TYPE
   499 label *label114
 
   503 op land *tmp167 *tmp164 *tmp166
   504 jump *label113 notEqual *tmp167 false
   505 label *label115
-    * set *tmp160 null
   506 jump *label112 always
   507 label *label111
-    * set *tmp160 null
   508 label *label112
   509 end
-    * set *tmp149 null
   510 label *label106
   511 ucontrol flag 1
   512 set *tmp148 @unit
 
   525 op equal *tmp175 *tmp174 @this
   526 op land *tmp176 *tmp173 *tmp175
   527 jump *label122 equal *tmp176 false
-    * set *tmp169 :rebindUnit.3:currentUnit
   528 jump *label119 always
   529 set *tmp177 null
   530 jump *label123 always
   531 label *label122
   532 set *tmp177 null
   533 label *label123
-    * set *tmp171 *tmp177
   534 jump *label121 always
   535 label *label120
-    * set *tmp171 null
   536 label *label121
   537 ubind .TYPE
   538 set *tmp178 @unit
 
   543 sensor *tmp181 @unit @controlled
   544 op equal *tmp182 *tmp181 0
   545 jump *label129 equal *tmp182 false
-    * set *tmp169 @unit
   546 jump *label119 always
-    * set *tmp183 null
   547 jump *label130 always
   548 label *label129
-    * set *tmp183 null
   549 label *label130
   550 ubind .TYPE
   551 label *label127
 
   555 op land *tmp187 *tmp184 *tmp186
   556 jump *label126 notEqual *tmp187 false
   557 label *label128
-    * set *tmp180 null
   558 jump *label125 always
   559 label *label124
-    * set *tmp180 null
   560 label *label125
   561 end
-    * set *tmp169 null
   562 label *label119
   563 ucontrol flag 1
   564 set *tmp168 @unit
 
   575 set :u .UNIT_S1
   576 set .UNIT_S1 .UNIT_P2
   577 set .UNIT_P2 :u
-    * set *tmp193 .UNIT_P2
   578 jump *label132 always
   579 label *label131
-    * set *tmp193 null
   580 label *label132
   581 sensor *tmp194 .UNIT_S2 @firstItem
   582 op equal *tmp195 *tmp194 @phase-fabric
 
   587 set :u .UNIT_S2
   588 set .UNIT_S2 .UNIT_P2
   589 set .UNIT_P2 :u
-    * set *tmp199 .UNIT_P2
   590 jump *label134 always
   591 label *label133
-    * set *tmp199 null
   592 label *label134
   593 set .GROUP1 "unit  1"
   594 set .GROUP2 "unit 2"
-    * set *tmp147 .GROUP2
   595 jump *label104 always
   596 label *label103
   597 ubind .UNIT_S2
 
   602 set .UNIT_P2 null
   603 set .GROUP1 "unit"
   604 set .GROUP2 ""
-    * set *tmp147 .GROUP2
   605 label *label104
   606 op equal *tmp200 .FOUR_UNITS false
   607 sensor *tmp201 .UNIT_S1 @totalItems
 
   652 print "\n"
   653 set *tmp216 null
   654 label *label140
-    * set *tmp213 *tmp216
   655 label *label138
   656 set :processUnit.0:unit .UNIT_S1
   657 set :processUnit.0:item @silicon
 
   667 op equal *tmp224 *tmp223 @this
   668 op land *tmp225 *tmp222 *tmp224
   669 jump *label145 equal *tmp225 false
-    * set *tmp218 :rebindUnit.4:currentUnit
   670 jump *label142 always
   671 set *tmp226 null
   672 jump *label146 always
   673 label *label145
   674 set *tmp226 null
   675 label *label146
-    * set *tmp220 *tmp226
   676 jump *label144 always
   677 label *label143
-    * set *tmp220 null
   678 label *label144
   679 ubind .TYPE
   680 set *tmp227 @unit
 
   685 sensor *tmp230 @unit @controlled
   686 op equal *tmp231 *tmp230 0
   687 jump *label152 equal *tmp231 false
-    * set *tmp218 @unit
   688 jump *label142 always
-    * set *tmp232 null
   689 jump *label153 always
   690 label *label152
-    * set *tmp232 null
   691 label *label153
   692 ubind .TYPE
   693 label *label150
 
   697 op land *tmp236 *tmp233 *tmp235
   698 jump *label149 notEqual *tmp236 false
   699 label *label151
-    * set *tmp229 null
   700 jump *label148 always
   701 label *label147
-    * set *tmp229 null
   702 label *label148
   703 end
-    * set *tmp218 null
   704 label *label142
   705 set :processUnit.0:msg ""
   706 sensor *tmp237 @unit @flag
 
   739 label *label159
   740 set *tmp244 *tmp247
   741 label *label157
-    * set *tmp241 *tmp244
   742 jump *label155 always
   743 label *label154
-    * set *tmp241 null
   744 label *label155
   745 op equal *tmp250 :processUnit.0:state 2
   746 jump *label162 equal *tmp250 false
 
   773 set :processUnit.0:distance *tmp263
   774 set *tmp253 :processUnit.0:distance
   775 label *label165
-    * set *tmp251 *tmp253
   776 jump *label163 always
   777 label *label162
-    * set *tmp251 null
   778 label *label163
   779 op equal *tmp264 :processUnit.0:state 3
   780 jump *label168 equal *tmp264 false
 
   783 jump *label172 equal :processUnit.0:supply false
   784 ucontrol itemDrop .DOME .UNIT_CAPACITY
   785 set :processUnit.0:msg ", supplying\n"
-    * set *tmp268 :processUnit.0:msg
   786 jump *label173 always
   787 label *label172
   788 ucontrol approach .DOME_X .DOME_Y 6
   789 set :processUnit.0:msg ", waiting\n"
-    * set *tmp268 :processUnit.0:msg
   790 label *label173
   791 sensor *tmp269 @unit @totalItems
   792 op lessThanEq *tmp270 *tmp269 0
 
   813 set :processUnit.0:distance *tmp278
   814 set *tmp267 :processUnit.0:distance
   815 label *label171
-    * set *tmp265 *tmp267
   816 jump *label169 always
   817 label *label168
-    * set *tmp265 null
   818 label *label169
   819 ucontrol flag :processUnit.0:state
   820 sensor *tmp279 @unit @totalItems
 
   834 print "["
   835 print "] sec"
   836 print "\n"
-    * set *tmp281 null
   837 jump *label177 always
   838 label *label176
   839 print :processUnit.0:msg
-    * set *tmp281 :processUnit.0:msg
   840 label *label177
   841 set *tmp217 @unit
   842 jump *label141 always
 
   859 op equal *tmp291 *tmp290 @this
   860 op land *tmp292 *tmp289 *tmp291
   861 jump *label184 equal *tmp292 false
-    * set *tmp285 :rebindUnit.5:currentUnit
   862 jump *label181 always
   863 set *tmp293 null
   864 jump *label185 always
   865 label *label184
   866 set *tmp293 null
   867 label *label185
-    * set *tmp287 *tmp293
   868 jump *label183 always
   869 label *label182
-    * set *tmp287 null
   870 label *label183
   871 ubind .TYPE
   872 set *tmp294 @unit
 
   877 sensor *tmp297 @unit @controlled
   878 op equal *tmp298 *tmp297 0
   879 jump *label191 equal *tmp298 false
-    * set *tmp285 @unit
   880 jump *label181 always
-    * set *tmp299 null
   881 jump *label192 always
   882 label *label191
-    * set *tmp299 null
   883 label *label192
   884 ubind .TYPE
   885 label *label189
 
   889 op land *tmp303 *tmp300 *tmp302
   890 jump *label188 notEqual *tmp303 false
   891 label *label190
-    * set *tmp296 null
   892 jump *label187 always
   893 label *label186
-    * set *tmp296 null
   894 label *label187
   895 end
-    * set *tmp285 null
   896 label *label181
   897 set :processUnit.1:msg ""
   898 sensor *tmp304 @unit @flag
 
   931 label *label198
   932 set *tmp311 *tmp314
   933 label *label196
-    * set *tmp308 *tmp311
   934 jump *label194 always
   935 label *label193
-    * set *tmp308 null
   936 label *label194
   937 op equal *tmp317 :processUnit.1:state 2
   938 jump *label201 equal *tmp317 false
 
   965 set :processUnit.1:distance *tmp330
   966 set *tmp320 :processUnit.1:distance
   967 label *label204
-    * set *tmp318 *tmp320
   968 jump *label202 always
   969 label *label201
-    * set *tmp318 null
   970 label *label202
   971 op equal *tmp331 :processUnit.1:state 3
   972 jump *label207 equal *tmp331 false
 
   975 jump *label211 equal :processUnit.1:supply false
   976 ucontrol itemDrop .DOME .UNIT_CAPACITY
   977 set :processUnit.1:msg ", supplying\n"
-    * set *tmp335 :processUnit.1:msg
   978 jump *label212 always
   979 label *label211
   980 ucontrol approach .DOME_X .DOME_Y 6
   981 set :processUnit.1:msg ", waiting\n"
-    * set *tmp335 :processUnit.1:msg
   982 label *label212
   983 sensor *tmp336 @unit @totalItems
   984 op lessThanEq *tmp337 *tmp336 0
 
  1005 set :processUnit.1:distance *tmp345
  1006 set *tmp334 :processUnit.1:distance
  1007 label *label210
-    * set *tmp332 *tmp334
  1008 jump *label208 always
  1009 label *label207
-    * set *tmp332 null
  1010 label *label208
  1011 ucontrol flag :processUnit.1:state
  1012 sensor *tmp346 @unit @totalItems
 
  1026 print "["
  1027 print "] sec"
  1028 print "\n"
-    * set *tmp348 null
  1029 jump *label216 always
  1030 label *label215
  1031 print :processUnit.1:msg
-    * set *tmp348 :processUnit.1:msg
  1032 label *label216
  1033 set *tmp284 @unit
  1034 jump *label180 always
 
  1046 set *tmp349 *tmp353
  1047 label *label218
  1048 set .SUPPLY_S_FIRST *tmp349
-    * set *tmp282 .SUPPLY_S_FIRST
  1049 jump *label179 always
  1050 label *label178
-    * set *tmp282 null
  1051 label *label179
  1052 set :printDomeStatus.1:item @phase-fabric
  1053 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
 
  1071 print "\n"
  1072 set *tmp357 null
  1073 label *label221
-    * set *tmp354 *tmp357
  1074 label *label219
  1075 set :processUnit.2:unit .UNIT_P1
  1076 set :processUnit.2:item @phase-fabric
 
  1086 op equal *tmp365 *tmp364 @this
  1087 op land *tmp366 *tmp363 *tmp365
  1088 jump *label226 equal *tmp366 false
-    * set *tmp359 :rebindUnit.6:currentUnit
  1089 jump *label223 always
  1090 set *tmp367 null
  1091 jump *label227 always
  1092 label *label226
  1093 set *tmp367 null
  1094 label *label227
-    * set *tmp361 *tmp367
  1095 jump *label225 always
  1096 label *label224
-    * set *tmp361 null
  1097 label *label225
  1098 ubind .TYPE
  1099 set *tmp368 @unit
 
  1104 sensor *tmp371 @unit @controlled
  1105 op equal *tmp372 *tmp371 0
  1106 jump *label233 equal *tmp372 false
-    * set *tmp359 @unit
  1107 jump *label223 always
-    * set *tmp373 null
  1108 jump *label234 always
  1109 label *label233
-    * set *tmp373 null
  1110 label *label234
  1111 ubind .TYPE
  1112 label *label231
 
  1116 op land *tmp377 *tmp374 *tmp376
  1117 jump *label230 notEqual *tmp377 false
  1118 label *label232
-    * set *tmp370 null
  1119 jump *label229 always
  1120 label *label228
-    * set *tmp370 null
  1121 label *label229
  1122 end
-    * set *tmp359 null
  1123 label *label223
  1124 set :processUnit.2:msg ""
  1125 sensor *tmp378 @unit @flag
 
  1158 label *label240
  1159 set *tmp385 *tmp388
  1160 label *label238
-    * set *tmp382 *tmp385
  1161 jump *label236 always
  1162 label *label235
-    * set *tmp382 null
  1163 label *label236
  1164 op equal *tmp391 :processUnit.2:state 2
  1165 jump *label243 equal *tmp391 false
 
  1192 set :processUnit.2:distance *tmp404
  1193 set *tmp394 :processUnit.2:distance
  1194 label *label246
-    * set *tmp392 *tmp394
  1195 jump *label244 always
  1196 label *label243
-    * set *tmp392 null
  1197 label *label244
  1198 op equal *tmp405 :processUnit.2:state 3
  1199 jump *label249 equal *tmp405 false
 
  1202 jump *label253 equal :processUnit.2:supply false
  1203 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1204 set :processUnit.2:msg ", supplying\n"
-    * set *tmp409 :processUnit.2:msg
  1205 jump *label254 always
  1206 label *label253
  1207 ucontrol approach .DOME_X .DOME_Y 6
  1208 set :processUnit.2:msg ", waiting\n"
-    * set *tmp409 :processUnit.2:msg
  1209 label *label254
  1210 sensor *tmp410 @unit @totalItems
  1211 op lessThanEq *tmp411 *tmp410 0
 
  1232 set :processUnit.2:distance *tmp419
  1233 set *tmp408 :processUnit.2:distance
  1234 label *label252
-    * set *tmp406 *tmp408
  1235 jump *label250 always
  1236 label *label249
-    * set *tmp406 null
  1237 label *label250
  1238 ucontrol flag :processUnit.2:state
  1239 sensor *tmp420 @unit @totalItems
 
  1253 print "["
  1254 print "] sec"
  1255 print "\n"
-    * set *tmp422 null
  1256 jump *label258 always
  1257 label *label257
  1258 print :processUnit.2:msg
-    * set *tmp422 :processUnit.2:msg
  1259 label *label258
  1260 set *tmp358 @unit
  1261 jump *label222 always
 
  1278 op equal *tmp432 *tmp431 @this
  1279 op land *tmp433 *tmp430 *tmp432
  1280 jump *label265 equal *tmp433 false
-    * set *tmp426 :rebindUnit.7:currentUnit
  1281 jump *label262 always
  1282 set *tmp434 null
  1283 jump *label266 always
  1284 label *label265
  1285 set *tmp434 null
  1286 label *label266
-    * set *tmp428 *tmp434
  1287 jump *label264 always
  1288 label *label263
-    * set *tmp428 null
  1289 label *label264
  1290 ubind .TYPE
  1291 set *tmp435 @unit
 
  1296 sensor *tmp438 @unit @controlled
  1297 op equal *tmp439 *tmp438 0
  1298 jump *label272 equal *tmp439 false
-    * set *tmp426 @unit
  1299 jump *label262 always
-    * set *tmp440 null
  1300 jump *label273 always
  1301 label *label272
-    * set *tmp440 null
  1302 label *label273
  1303 ubind .TYPE
  1304 label *label270
 
  1308 op land *tmp444 *tmp441 *tmp443
  1309 jump *label269 notEqual *tmp444 false
  1310 label *label271
-    * set *tmp437 null
  1311 jump *label268 always
  1312 label *label267
-    * set *tmp437 null
  1313 label *label268
  1314 end
-    * set *tmp426 null
  1315 label *label262
  1316 set :processUnit.3:msg ""
  1317 sensor *tmp445 @unit @flag
 
  1350 label *label279
  1351 set *tmp452 *tmp455
  1352 label *label277
-    * set *tmp449 *tmp452
  1353 jump *label275 always
  1354 label *label274
-    * set *tmp449 null
  1355 label *label275
  1356 op equal *tmp458 :processUnit.3:state 2
  1357 jump *label282 equal *tmp458 false
 
  1384 set :processUnit.3:distance *tmp471
  1385 set *tmp461 :processUnit.3:distance
  1386 label *label285
-    * set *tmp459 *tmp461
  1387 jump *label283 always
  1388 label *label282
-    * set *tmp459 null
  1389 label *label283
  1390 op equal *tmp472 :processUnit.3:state 3
  1391 jump *label288 equal *tmp472 false
 
  1394 jump *label292 equal :processUnit.3:supply false
  1395 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1396 set :processUnit.3:msg ", supplying\n"
-    * set *tmp476 :processUnit.3:msg
  1397 jump *label293 always
  1398 label *label292
  1399 ucontrol approach .DOME_X .DOME_Y 6
  1400 set :processUnit.3:msg ", waiting\n"
-    * set *tmp476 :processUnit.3:msg
  1401 label *label293
  1402 sensor *tmp477 @unit @totalItems
  1403 op lessThanEq *tmp478 *tmp477 0
 
  1424 set :processUnit.3:distance *tmp486
  1425 set *tmp475 :processUnit.3:distance
  1426 label *label291
-    * set *tmp473 *tmp475
  1427 jump *label289 always
  1428 label *label288
-    * set *tmp473 null
  1429 label *label289
  1430 ucontrol flag :processUnit.3:state
  1431 sensor *tmp487 @unit @totalItems
 
  1445 print "["
  1446 print "] sec"
  1447 print "\n"
-    * set *tmp489 null
  1448 jump *label297 always
  1449 label *label296
  1450 print :processUnit.3:msg
-    * set *tmp489 :processUnit.3:msg
  1451 label *label297
  1452 set *tmp425 @unit
  1453 jump *label261 always
 
  1465 set *tmp490 *tmp494
  1466 label *label299
  1467 set .SUPPLY_P_FIRST *tmp490
-    * set *tmp423 .SUPPLY_P_FIRST
  1468 jump *label260 always
  1469 label *label259
-    * set *tmp423 null
  1470 label *label260
  1471 op sub *tmp495 @time :start
  1472 op floor *tmp496 *tmp495
 
  1527 label *label313
  1528 set *tmp521 null
  1529 label *label314
-    * set *tmp519 *tmp521
  1530 jump *label312 always
  1531 label *label311
  1532 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp519 :areUnitsAvailable.2:occupied
  1533 label *label312
  1534 ubind :areUnitsAvailable.2:type
  1535 label *label309
 
  1539 op land *tmp525 *tmp522 *tmp524
  1540 jump *label308 notEqual *tmp525 false
  1541 label *label310
-    * set *tmp504 null
  1542 jump *label304 always
  1543 label *label303
-    * set *tmp504 null
  1544 label *label304
  1545 jump *label315 equal :areUnitsAvailable.2:output false
  1546 print :areUnitsAvailable.2:type
 
  1554 jump *label317 equal *tmp527 false
  1555 print ", needed: "
  1556 print :areUnitsAvailable.2:needed
-    * set *tmp528 null
  1557 jump *label318 always
  1558 label *label317
-    * set *tmp528 null
  1559 label *label318
  1560 print "\n"
-    * set *tmp526 null
  1561 jump *label316 always
  1562 label *label315
-    * set *tmp526 null
  1563 label *label316
  1564 set *tmp501 false
  1565 jump *label302 always
 
  1567 label *label302
  1568 jump *label319 equal *tmp501 false
  1569 end
-    * set *tmp529 null
  1570 jump *label320 always
  1571 label *label319
-    * set *tmp529 null
  1572 label *label320
  1573 op add *tmp530 @time 5000
  1574 set :unitCheck *tmp530
-    * set *tmp500 :unitCheck
  1575 jump *label301 always
  1576 label *label300
-    * set *tmp500 null
  1577 label *label301
  1578 label *label136
  1579 jump *label135 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-54 instructions):
 
    74 jump *label21 equal *tmp23 false
    75 set *tmp4 true
    76 jump *label10 always
-    * set *tmp24 null
    77 jump *label22 always
    78 label *label21
-    * set *tmp24 null
    79 label *label22
    80 jump *label20 always
    81 label *label19
 
   185 jump *label51 equal *tmp55 false
   186 set *tmp36 true
   187 jump *label40 always
-    * set *tmp56 null
   188 jump *label52 always
   189 label *label51
-    * set *tmp56 null
   190 label *label52
   191 jump *label50 always
   192 label *label49
 
   230 printflush null
   231 set *tmp3 :chooseUnitType.0:type
   232 jump *label6 always
-    * set *tmp64 null
   233 jump *label58 always
   234 label *label57
-    * set *tmp64 null
   235 label *label58
   236 jump *label39 always
   237 label *label38
 
   278 op notEqual *tmp73 .UNIT_S2 null
   279 jump *label67 equal *tmp73 false
   280 jump *label64 always
-    * set *tmp74 null
   281 jump *label68 always
   282 label *label67
-    * set *tmp74 null
   283 label *label68
   284 jump *label66 always
   285 label *label65
 
   306 op land *tmp87 *tmp84 *tmp86
   307 jump *label73 equal *tmp87 false
   308 jump *label70 always
-    * set *tmp88 null
   309 jump *label74 always
   310 label *label73
-    * set *tmp88 null
   311 label *label74
   312 jump *label72 always
   313 label *label71
 
   356 op land *tmp107 *tmp104 *tmp106
   357 jump *label86 equal *tmp107 false
   358 jump *label83 always
-    * set *tmp108 null
   359 jump *label87 always
   360 label *label86
-    * set *tmp108 null
   361 label *label87
   362 jump *label85 always
   363 label *label84
 
   462 op land *tmp156 *tmp153 *tmp155
   463 jump *label109 equal *tmp156 false
   464 jump *label106 always
-    * set *tmp157 null
   465 jump *label110 always
   466 label *label109
-    * set *tmp157 null
   467 label *label110
   468 jump *label108 always
   469 label *label107
 
   512 op land *tmp176 *tmp173 *tmp175
   513 jump *label122 equal *tmp176 false
   514 jump *label119 always
-    * set *tmp177 null
   515 jump *label123 always
   516 label *label122
-    * set *tmp177 null
   517 label *label123
   518 jump *label121 always
   519 label *label120
 
   626 print "["
   627 print "]"
   628 print "\n"
-    * set *tmp216 null
   629 jump *label140 always
   630 label *label139
   631 print "  dome:  [coral]"
 
   633 print "["
   634 print "]"
   635 print "\n"
-    * set *tmp216 null
   636 label *label140
   637 label *label138
   638 set :processUnit.0:unit .UNIT_S1
 
   650 op land *tmp225 *tmp222 *tmp224
   651 jump *label145 equal *tmp225 false
   652 jump *label142 always
-    * set *tmp226 null
   653 jump *label146 always
   654 label *label145
-    * set *tmp226 null
   655 label *label146
   656 jump *label144 always
   657 label *label143
 
   695 op equal *tmp243 *tmp242 :processUnit.0:item
   696 jump *label156 equal *tmp243 false
   697 set :processUnit.0:state 3
-    * set *tmp244 :processUnit.0:state
   698 jump *label157 always
   699 label *label156
   700 sensor *tmp245 @unit @totalItems
 
   716 label *label161
   717 set *tmp247 *tmp249
   718 label *label159
-    * set *tmp244 *tmp247
   719 label *label157
   720 jump *label155 always
   721 label *label154
 
   736 set :processUnit.0:msg ", loading\n"
   737 set *tmp256 :processUnit.0:msg
   738 label *label167
-    * set *tmp253 *tmp256
   739 jump *label165 always
   740 label *label164
   741 ucontrol approach .CORE_X .CORE_Y 6
 
   748 op idiv *tmp262 *tmp261 .SPEED_TENTHS
   749 op div *tmp263 *tmp262 10
   750 set :processUnit.0:distance *tmp263
-    * set *tmp253 :processUnit.0:distance
   751 label *label165
   752 jump *label163 always
   753 label *label162
 
   774 label *label174
   775 set *tmp271 null
   776 label *label175
-    * set *tmp267 *tmp271
   777 jump *label171 always
   778 label *label170
   779 ucontrol approach .DOME_X .DOME_Y 6
 
   786 op idiv *tmp277 *tmp276 .SPEED_TENTHS
   787 op div *tmp278 *tmp277 10
   788 set :processUnit.0:distance *tmp278
-    * set *tmp267 :processUnit.0:distance
   789 label *label171
   790 jump *label169 always
   791 label *label168
 
   834 op land *tmp292 *tmp289 *tmp291
   835 jump *label184 equal *tmp292 false
   836 jump *label181 always
-    * set *tmp293 null
   837 jump *label185 always
   838 label *label184
-    * set *tmp293 null
   839 label *label185
   840 jump *label183 always
   841 label *label182
 
   879 op equal *tmp310 *tmp309 :processUnit.1:item
   880 jump *label195 equal *tmp310 false
   881 set :processUnit.1:state 3
-    * set *tmp311 :processUnit.1:state
   882 jump *label196 always
   883 label *label195
   884 sensor *tmp312 @unit @totalItems
 
   900 label *label200
   901 set *tmp314 *tmp316
   902 label *label198
-    * set *tmp311 *tmp314
   903 label *label196
   904 jump *label194 always
   905 label *label193
 
   920 set :processUnit.1:msg ", loading\n"
   921 set *tmp323 :processUnit.1:msg
   922 label *label206
-    * set *tmp320 *tmp323
   923 jump *label204 always
   924 label *label203
   925 ucontrol approach .CORE_X .CORE_Y 6
 
   932 op idiv *tmp329 *tmp328 .SPEED_TENTHS
   933 op div *tmp330 *tmp329 10
   934 set :processUnit.1:distance *tmp330
-    * set *tmp320 :processUnit.1:distance
   935 label *label204
   936 jump *label202 always
   937 label *label201
 
   958 label *label213
   959 set *tmp338 null
   960 label *label214
-    * set *tmp334 *tmp338
   961 jump *label210 always
   962 label *label209
   963 ucontrol approach .DOME_X .DOME_Y 6
 
   970 op idiv *tmp344 *tmp343 .SPEED_TENTHS
   971 op div *tmp345 *tmp344 10
   972 set :processUnit.1:distance *tmp345
-    * set *tmp334 :processUnit.1:distance
   973 label *label210
   974 jump *label208 always
   975 label *label207
 
  1027 print "["
  1028 print "]"
  1029 print "\n"
-    * set *tmp357 null
  1030 jump *label221 always
  1031 label *label220
  1032 print "  dome:  [coral]"
 
  1034 print "["
  1035 print "]"
  1036 print "\n"
-    * set *tmp357 null
  1037 label *label221
  1038 label *label219
  1039 set :processUnit.2:unit .UNIT_P1
 
  1051 op land *tmp366 *tmp363 *tmp365
  1052 jump *label226 equal *tmp366 false
  1053 jump *label223 always
-    * set *tmp367 null
  1054 jump *label227 always
  1055 label *label226
-    * set *tmp367 null
  1056 label *label227
  1057 jump *label225 always
  1058 label *label224
 
  1096 op equal *tmp384 *tmp383 :processUnit.2:item
  1097 jump *label237 equal *tmp384 false
  1098 set :processUnit.2:state 3
-    * set *tmp385 :processUnit.2:state
  1099 jump *label238 always
  1100 label *label237
  1101 sensor *tmp386 @unit @totalItems
 
  1117 label *label242
  1118 set *tmp388 *tmp390
  1119 label *label240
-    * set *tmp385 *tmp388
  1120 label *label238
  1121 jump *label236 always
  1122 label *label235
 
  1137 set :processUnit.2:msg ", loading\n"
  1138 set *tmp397 :processUnit.2:msg
  1139 label *label248
-    * set *tmp394 *tmp397
  1140 jump *label246 always
  1141 label *label245
  1142 ucontrol approach .CORE_X .CORE_Y 6
 
  1149 op idiv *tmp403 *tmp402 .SPEED_TENTHS
  1150 op div *tmp404 *tmp403 10
  1151 set :processUnit.2:distance *tmp404
-    * set *tmp394 :processUnit.2:distance
  1152 label *label246
  1153 jump *label244 always
  1154 label *label243
 
  1175 label *label255
  1176 set *tmp412 null
  1177 label *label256
-    * set *tmp408 *tmp412
  1178 jump *label252 always
  1179 label *label251
  1180 ucontrol approach .DOME_X .DOME_Y 6
 
  1187 op idiv *tmp418 *tmp417 .SPEED_TENTHS
  1188 op div *tmp419 *tmp418 10
  1189 set :processUnit.2:distance *tmp419
-    * set *tmp408 :processUnit.2:distance
  1190 label *label252
  1191 jump *label250 always
  1192 label *label249
 
  1235 op land *tmp433 *tmp430 *tmp432
  1236 jump *label265 equal *tmp433 false
  1237 jump *label262 always
-    * set *tmp434 null
  1238 jump *label266 always
  1239 label *label265
-    * set *tmp434 null
  1240 label *label266
  1241 jump *label264 always
  1242 label *label263
 
  1280 op equal *tmp451 *tmp450 :processUnit.3:item
  1281 jump *label276 equal *tmp451 false
  1282 set :processUnit.3:state 3
-    * set *tmp452 :processUnit.3:state
  1283 jump *label277 always
  1284 label *label276
  1285 sensor *tmp453 @unit @totalItems
 
  1301 label *label281
  1302 set *tmp455 *tmp457
  1303 label *label279
-    * set *tmp452 *tmp455
  1304 label *label277
  1305 jump *label275 always
  1306 label *label274
 
  1321 set :processUnit.3:msg ", loading\n"
  1322 set *tmp464 :processUnit.3:msg
  1323 label *label287
-    * set *tmp461 *tmp464
  1324 jump *label285 always
  1325 label *label284
  1326 ucontrol approach .CORE_X .CORE_Y 6
 
  1333 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1334 op div *tmp471 *tmp470 10
  1335 set :processUnit.3:distance *tmp471
-    * set *tmp461 :processUnit.3:distance
  1336 label *label285
  1337 jump *label283 always
  1338 label *label282
 
  1359 label *label294
  1360 set *tmp479 null
  1361 label *label295
-    * set *tmp475 *tmp479
  1362 jump *label291 always
  1363 label *label290
  1364 ucontrol approach .DOME_X .DOME_Y 6
 
  1371 op idiv *tmp485 *tmp484 .SPEED_TENTHS
  1372 op div *tmp486 *tmp485 10
  1373 set :processUnit.3:distance *tmp486
-    * set *tmp475 :processUnit.3:distance
  1374 label *label291
  1375 jump *label289 always
  1376 label *label288
 
  1470 jump *label313 equal *tmp520 false
  1471 set *tmp501 true
  1472 jump *label302 always
-    * set *tmp521 null
  1473 jump *label314 always
  1474 label *label313
-    * set *tmp521 null
  1475 label *label314
  1476 jump *label312 always
  1477 label *label311

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-24 instructions):
 
   701 op equal *tmp246 *tmp245 0
   702 jump *label158 equal *tmp246 false
   703 set :processUnit.0:state 2
-    * set *tmp247 :processUnit.0:state
   704 jump *label159 always
   705 label *label158
   706 set :processUnit.0:msg ", initializing\n"
 
   713 label *label160
   714 set *tmp249 null
   715 label *label161
-    * set *tmp247 *tmp249
   716 label *label159
   717 label *label157
   718 jump *label155 always
 
   728 jump *label166 equal *tmp255 false
   729 ucontrol approach .DOME_X .DOME_Y 6
   730 set :processUnit.0:state 3
-    * set *tmp256 :processUnit.0:state
   731 jump *label167 always
   732 label *label166
   733 set :processUnit.0:msg ", loading\n"
-    * set *tmp256 :processUnit.0:msg
   734 label *label167
   735 jump *label165 always
   736 label *label164
 
   765 jump *label174 equal *tmp270 false
   766 ucontrol approach .CORE_X .CORE_Y 6
   767 set :processUnit.0:state 2
-    * set *tmp271 :processUnit.0:state
   768 jump *label175 always
   769 label *label174
-    * set *tmp271 null
   770 label *label175
   771 jump *label171 always
   772 label *label170
 
   879 op equal *tmp313 *tmp312 0
   880 jump *label197 equal *tmp313 false
   881 set :processUnit.1:state 2
-    * set *tmp314 :processUnit.1:state
   882 jump *label198 always
   883 label *label197
   884 set :processUnit.1:msg ", initializing\n"
 
   891 label *label199
   892 set *tmp316 null
   893 label *label200
-    * set *tmp314 *tmp316
   894 label *label198
   895 label *label196
   896 jump *label194 always
 
   906 jump *label205 equal *tmp322 false
   907 ucontrol approach .DOME_X .DOME_Y 6
   908 set :processUnit.1:state 3
-    * set *tmp323 :processUnit.1:state
   909 jump *label206 always
   910 label *label205
   911 set :processUnit.1:msg ", loading\n"
-    * set *tmp323 :processUnit.1:msg
   912 label *label206
   913 jump *label204 always
   914 label *label203
 
   943 jump *label213 equal *tmp337 false
   944 ucontrol approach .CORE_X .CORE_Y 6
   945 set :processUnit.1:state 2
-    * set *tmp338 :processUnit.1:state
   946 jump *label214 always
   947 label *label213
-    * set *tmp338 null
   948 label *label214
   949 jump *label210 always
   950 label *label209
 
  1090 op equal *tmp387 *tmp386 0
  1091 jump *label239 equal *tmp387 false
  1092 set :processUnit.2:state 2
-    * set *tmp388 :processUnit.2:state
  1093 jump *label240 always
  1094 label *label239
  1095 set :processUnit.2:msg ", initializing\n"
 
  1102 label *label241
  1103 set *tmp390 null
  1104 label *label242
-    * set *tmp388 *tmp390
  1105 label *label240
  1106 label *label238
  1107 jump *label236 always
 
  1117 jump *label247 equal *tmp396 false
  1118 ucontrol approach .DOME_X .DOME_Y 6
  1119 set :processUnit.2:state 3
-    * set *tmp397 :processUnit.2:state
  1120 jump *label248 always
  1121 label *label247
  1122 set :processUnit.2:msg ", loading\n"
-    * set *tmp397 :processUnit.2:msg
  1123 label *label248
  1124 jump *label246 always
  1125 label *label245
 
  1154 jump *label255 equal *tmp411 false
  1155 ucontrol approach .CORE_X .CORE_Y 6
  1156 set :processUnit.2:state 2
-    * set *tmp412 :processUnit.2:state
  1157 jump *label256 always
  1158 label *label255
-    * set *tmp412 null
  1159 label *label256
  1160 jump *label252 always
  1161 label *label251
 
  1268 op equal *tmp454 *tmp453 0
  1269 jump *label278 equal *tmp454 false
  1270 set :processUnit.3:state 2
-    * set *tmp455 :processUnit.3:state
  1271 jump *label279 always
  1272 label *label278
  1273 set :processUnit.3:msg ", initializing\n"
 
  1280 label *label280
  1281 set *tmp457 null
  1282 label *label281
-    * set *tmp455 *tmp457
  1283 label *label279
  1284 label *label277
  1285 jump *label275 always
 
  1295 jump *label286 equal *tmp463 false
  1296 ucontrol approach .DOME_X .DOME_Y 6
  1297 set :processUnit.3:state 3
-    * set *tmp464 :processUnit.3:state
  1298 jump *label287 always
  1299 label *label286
  1300 set :processUnit.3:msg ", loading\n"
-    * set *tmp464 :processUnit.3:msg
  1301 label *label287
  1302 jump *label285 always
  1303 label *label284
 
  1332 jump *label294 equal *tmp478 false
  1333 ucontrol approach .CORE_X .CORE_Y 6
  1334 set :processUnit.3:state 2
-    * set *tmp479 :processUnit.3:state
  1335 jump *label295 always
  1336 label *label294
-    * set *tmp479 null
  1337 label *label295
  1338 jump *label291 always
  1339 label *label290

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
   708 ucontrol within .CORE_X .CORE_Y 8 *tmp248
   709 jump *label160 equal *tmp248 false
   710 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp249 null
   711 jump *label161 always
   712 label *label160
-    * set *tmp249 null
   713 label *label161
   714 label *label159
   715 label *label157
 
   884 ucontrol within .CORE_X .CORE_Y 8 *tmp315
   885 jump *label199 equal *tmp315 false
   886 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp316 null
   887 jump *label200 always
   888 label *label199
-    * set *tmp316 null
   889 label *label200
   890 label *label198
   891 label *label196
 
  1093 ucontrol within .CORE_X .CORE_Y 8 *tmp389
  1094 jump *label241 equal *tmp389 false
  1095 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp390 null
  1096 jump *label242 always
  1097 label *label241
-    * set *tmp390 null
  1098 label *label242
  1099 label *label240
  1100 label *label238
 
  1269 ucontrol within .CORE_X .CORE_Y 8 *tmp456
  1270 jump *label280 equal *tmp456 false
  1271 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp457 null
  1272 jump *label281 always
  1273 label *label280
-    * set *tmp457 null
  1274 label *label281
  1275 label *label279
  1276 label *label277

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-52 instructions):
 
    38 set :areUnitsAvailable.0:occupied :areUnitsAvailable.0:needed
    39 set :areUnitsAvailable.0:free :areUnitsAvailable.0:occupied
    40 ubind :areUnitsAvailable.0:type
-    * set *tmp5 @unit
-    * set :areUnitsAvailable.0:firstUnit *tmp5
+   41 set :areUnitsAvailable.0:firstUnit @unit
    42 op notEqual *tmp6 :areUnitsAvailable.0:firstUnit null
    43 jump *label11 equal *tmp6 false
    44 set :needsFourUnits.0:unit @unit
 
    47 op len *tmp11 *tmp9 *tmp10
    48 op mul *tmp12 2 *tmp11
    49 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * op div *tmp14 *tmp12 *tmp13
-    * set :needsFourUnits.0:travel_time *tmp14
-    * op greaterThanEq *tmp15 :needsFourUnits.0:travel_time 47
-    * set *tmp8 *tmp15
+   50 op div :needsFourUnits.0:travel_time *tmp12 *tmp13
+   51 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    52 jump *label13 always
    53 set *tmp8 null
    54 label *label13
 
   146 set :areUnitsAvailable.1:occupied :areUnitsAvailable.1:needed
   147 set :areUnitsAvailable.1:free :areUnitsAvailable.1:occupied
   148 ubind :areUnitsAvailable.1:type
-    * set *tmp37 @unit
-    * set :areUnitsAvailable.1:firstUnit *tmp37
+  149 set :areUnitsAvailable.1:firstUnit @unit
   150 op notEqual *tmp38 :areUnitsAvailable.1:firstUnit null
   151 jump *label41 equal *tmp38 false
   152 set :needsFourUnits.1:unit @unit
 
   155 op len *tmp43 *tmp41 *tmp42
   156 op mul *tmp44 2 *tmp43
   157 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * op div *tmp46 *tmp44 *tmp45
-    * set :needsFourUnits.1:travel_time *tmp46
-    * op greaterThanEq *tmp47 :needsFourUnits.1:travel_time 47
-    * set *tmp40 *tmp47
+  158 op div :needsFourUnits.1:travel_time *tmp44 *tmp45
+  159 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   160 jump *label43 always
   161 set *tmp40 null
   162 label *label43
 
   250 set .UNIT_S1 .UNIT_P1
   251 set :rebindUnits.0:count 0
   252 ubind .TYPE
-    * set *tmp66 @unit
-    * set :rebindUnits.0:firstUnit *tmp66
+  253 set :rebindUnits.0:firstUnit @unit
   254 op equal *tmp67 :rebindUnits.0:firstUnit null
   255 jump *label60 equal *tmp67 false
   256 end
 
   266 set .UNIT_S2 .UNIT_P2
   267 set .UNIT_P2 .UNIT_S1
   268 set .UNIT_S1 .UNIT_P1
-    * set *tmp72 @unit
-    * set .UNIT_P1 *tmp72
+  269 set .UNIT_P1 @unit
   270 op notEqual *tmp73 .UNIT_S2 null
   271 jump *label67 equal *tmp73 false
   272 jump *label64 always
 
   305 label *label71
   306 label *label72
   307 ubind .TYPE
-    * set *tmp89 @unit
-    * set :rebindUnit.0:firstUnit *tmp89
+  308 set :rebindUnit.0:firstUnit @unit
   309 op notEqual *tmp90 :rebindUnit.0:firstUnit null
   310 jump *label75 equal *tmp90 false
   311 label *label77
 
   354 label *label84
   355 label *label85
   356 ubind .TYPE
-    * set *tmp109 @unit
-    * set :rebindUnit.1:firstUnit *tmp109
+  357 set :rebindUnit.1:firstUnit @unit
   358 op notEqual *tmp110 :rebindUnit.1:firstUnit null
   359 jump *label88 equal *tmp110 false
   360 label *label90
 
   396 jump *label96 always
   397 label *label95
   398 label *label96
-    * sensor *tmp125 .UNIT_S1 @itemCapacity
-    * set .UNIT_CAPACITY *tmp125
-    * sensor *tmp126 .UNIT_S1 @speed
-    * set .SPEED *tmp126
-    * op div *tmp127 .SPEED 10
-    * set .SPEED_TENTHS *tmp127
+  399 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
+  400 sensor .SPEED .UNIT_S1 @speed
+  401 op div .SPEED_TENTHS .SPEED 10
   402 op strictEqual *tmp128 .SPEED null
   403 jump *label97 equal *tmp128 false
   404 stop
 
   408 print "[gold]Locating core..."
   409 printflush message1
   410 label *label99
-    * ulocate building core false @copper *tmp131 *tmp132 *tmp133 *tmp130
-    * set .CORE *tmp130
+  411 ulocate building core false @copper 0 0 0 .CORE
   412 label *label100
   413 op equal *tmp134 .CORE null
   414 jump *label99 notEqual *tmp134 false
   415 label *label101
-    * sensor *tmp135 .CORE @x
-    * set .CORE_X *tmp135
-    * sensor *tmp136 .CORE @y
-    * set .CORE_Y *tmp136
-    * sensor *tmp137 .DOME @x
-    * set .DOME_X *tmp137
-    * sensor *tmp138 .DOME @y
-    * set .DOME_Y *tmp138
+  416 sensor .CORE_X .CORE @x
+  417 sensor .CORE_Y .CORE @y
+  418 sensor .DOME_X .DOME @x
+  419 sensor .DOME_Y .DOME @y
   420 set :needsFourUnits.2:unit .UNIT_S1
   421 op sub *tmp140 .DOME_X .CORE_X
   422 op sub *tmp141 .DOME_Y .CORE_Y
   423 op len *tmp142 *tmp140 *tmp141
   424 op mul *tmp143 2 *tmp142
   425 sensor *tmp144 :needsFourUnits.2:unit @speed
-    * op div *tmp145 *tmp143 *tmp144
-    * set :needsFourUnits.2:travel_time *tmp145
-    * op greaterThanEq *tmp146 :needsFourUnits.2:travel_time 47
-    * set *tmp139 *tmp146
+  426 op div :needsFourUnits.2:travel_time *tmp143 *tmp144
+  427 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   428 jump *label102 always
   429 set *tmp139 null
   430 label *label102
 
   449 label *label107
   450 label *label108
   451 ubind .TYPE
-    * set *tmp158 @unit
-    * set :rebindUnit.2:firstUnit *tmp158
+  452 set :rebindUnit.2:firstUnit @unit
   453 op notEqual *tmp159 :rebindUnit.2:firstUnit null
   454 jump *label111 equal *tmp159 false
   455 label *label113
 
   498 label *label120
   499 label *label121
   500 ubind .TYPE
-    * set *tmp178 @unit
-    * set :rebindUnit.3:firstUnit *tmp178
+  501 set :rebindUnit.3:firstUnit @unit
   502 op notEqual *tmp179 :rebindUnit.3:firstUnit null
   503 jump *label124 equal *tmp179 false
   504 label *label126
 
   569 sensor *tmp201 .UNIT_S1 @totalItems
   570 sensor *tmp202 .UNIT_S2 @totalItems
   571 op lessThan *tmp203 *tmp201 *tmp202
-    * op or *tmp204 *tmp200 *tmp203
-    * set .SUPPLY_S_FIRST *tmp204
+  572 op or .SUPPLY_S_FIRST *tmp200 *tmp203
   573 op equal *tmp205 .FOUR_UNITS false
   574 sensor *tmp206 .UNIT_P1 @totalItems
   575 sensor *tmp207 .UNIT_P2 @totalItems
   576 op lessThan *tmp208 *tmp206 *tmp207
-    * op or *tmp209 *tmp205 *tmp208
-    * set .SUPPLY_P_FIRST *tmp209
-    * op add *tmp210 @time 5000
-    * set :unitCheck *tmp210
+  577 op or .SUPPLY_P_FIRST *tmp205 *tmp208
+  578 op add :unitCheck @time 5000
   579 label *label135
   580 sensor *tmp211 switch1 @enabled
   581 jump *label137 equal *tmp211 false
-    * set *tmp212 @time
-    * set :start *tmp212
+  582 set :start @time
   583 print " === [gold]Supplying Overdrive Dome[] === "
   584 print "\n"
   585 print "\n"
 
   591 set :printDomeStatus.0:item @silicon
   592 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   593 print :printDomeStatus.0:text
-    * sensor *tmp214 .DOME :printDomeStatus.0:item
-    * set :printDomeStatus.0:level *tmp214
+  594 sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
   595 op greaterThan *tmp215 :printDomeStatus.0:level 3
   596 jump *label139 equal *tmp215 false
   597 print "  dome:  [green]"
 
   630 label *label143
   631 label *label144
   632 ubind .TYPE
-    * set *tmp227 @unit
-    * set :rebindUnit.4:firstUnit *tmp227
+  633 set :rebindUnit.4:firstUnit @unit
   634 op notEqual *tmp228 :rebindUnit.4:firstUnit null
   635 jump *label147 equal *tmp228 false
   636 label *label149
 
   655 end
   656 label *label142
   657 set :processUnit.0:msg ""
-    * sensor *tmp237 @unit @flag
-    * set :processUnit.0:state *tmp237
+  658 sensor :processUnit.0:state @unit @flag
   659 set :processUnit.0:distance -1
   660 set :processUnit.0:color "gold"
   661 op lessThan *tmp238 :processUnit.0:state 2
 
   711 op sub *tmp260 .CORE_Y *tmp259
   712 op len *tmp261 *tmp258 *tmp260
   713 op idiv *tmp262 *tmp261 .SPEED_TENTHS
-    * op div *tmp263 *tmp262 10
-    * set :processUnit.0:distance *tmp263
+  714 op div :processUnit.0:distance *tmp262 10
   715 label *label165
   716 jump *label163 always
   717 label *label162
 
   746 op sub *tmp275 .DOME_Y *tmp274
   747 op len *tmp276 *tmp273 *tmp275
   748 op idiv *tmp277 *tmp276 .SPEED_TENTHS
-    * op div *tmp278 *tmp277 10
-    * set :processUnit.0:distance *tmp278
+  749 op div :processUnit.0:distance *tmp277 10
   750 label *label171
   751 jump *label169 always
   752 label *label168
 
   802 label *label182
   803 label *label183
   804 ubind .TYPE
-    * set *tmp294 @unit
-    * set :rebindUnit.5:firstUnit *tmp294
+  805 set :rebindUnit.5:firstUnit @unit
   806 op notEqual *tmp295 :rebindUnit.5:firstUnit null
   807 jump *label186 equal *tmp295 false
   808 label *label188
 
   827 end
   828 label *label181
   829 set :processUnit.1:msg ""
-    * sensor *tmp304 @unit @flag
-    * set :processUnit.1:state *tmp304
+  830 sensor :processUnit.1:state @unit @flag
   831 set :processUnit.1:distance -1
   832 set :processUnit.1:color "gold"
   833 op lessThan *tmp305 :processUnit.1:state 2
 
   883 op sub *tmp327 .CORE_Y *tmp326
   884 op len *tmp328 *tmp325 *tmp327
   885 op idiv *tmp329 *tmp328 .SPEED_TENTHS
-    * op div *tmp330 *tmp329 10
-    * set :processUnit.1:distance *tmp330
+  886 op div :processUnit.1:distance *tmp329 10
   887 label *label204
   888 jump *label202 always
   889 label *label201
 
   918 op sub *tmp342 .DOME_Y *tmp341
   919 op len *tmp343 *tmp340 *tmp342
   920 op idiv *tmp344 *tmp343 .SPEED_TENTHS
-    * op div *tmp345 *tmp344 10
-    * set :processUnit.1:distance *tmp345
+  921 op div :processUnit.1:distance *tmp344 10
   922 label *label210
   923 jump *label208 always
   924 label *label207
 
   952 set .UNIT_S2 *tmp284
   953 jump *label217 equal .SUPPLY_S_FIRST false
   954 sensor *tmp350 .UNIT_S1 @totalItems
-    * op greaterThan *tmp351 *tmp350 0
-    * set *tmp349 *tmp351
+  955 op greaterThan *tmp349 *tmp350 0
   956 jump *label218 always
   957 label *label217
   958 sensor *tmp352 .UNIT_S2 @totalItems
-    * op equal *tmp353 *tmp352 0
-    * set *tmp349 *tmp353
+  959 op equal *tmp349 *tmp352 0
   960 label *label218
   961 set .SUPPLY_S_FIRST *tmp349
   962 jump *label179 always
 
   965 set :printDomeStatus.1:item @phase-fabric
   966 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   967 print :printDomeStatus.1:text
-    * sensor *tmp355 .DOME :printDomeStatus.1:item
-    * set :printDomeStatus.1:level *tmp355
+  968 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
   969 op greaterThan *tmp356 :printDomeStatus.1:level 3
   970 jump *label220 equal *tmp356 false
   971 print "  dome:  [green]"
 
  1004 label *label224
  1005 label *label225
  1006 ubind .TYPE
-    * set *tmp368 @unit
-    * set :rebindUnit.6:firstUnit *tmp368
+ 1007 set :rebindUnit.6:firstUnit @unit
  1008 op notEqual *tmp369 :rebindUnit.6:firstUnit null
  1009 jump *label228 equal *tmp369 false
  1010 label *label230
 
  1029 end
  1030 label *label223
  1031 set :processUnit.2:msg ""
-    * sensor *tmp378 @unit @flag
-    * set :processUnit.2:state *tmp378
+ 1032 sensor :processUnit.2:state @unit @flag
  1033 set :processUnit.2:distance -1
  1034 set :processUnit.2:color "gold"
  1035 op lessThan *tmp379 :processUnit.2:state 2
 
  1085 op sub *tmp401 .CORE_Y *tmp400
  1086 op len *tmp402 *tmp399 *tmp401
  1087 op idiv *tmp403 *tmp402 .SPEED_TENTHS
-    * op div *tmp404 *tmp403 10
-    * set :processUnit.2:distance *tmp404
+ 1088 op div :processUnit.2:distance *tmp403 10
  1089 label *label246
  1090 jump *label244 always
  1091 label *label243
 
  1120 op sub *tmp416 .DOME_Y *tmp415
  1121 op len *tmp417 *tmp414 *tmp416
  1122 op idiv *tmp418 *tmp417 .SPEED_TENTHS
-    * op div *tmp419 *tmp418 10
-    * set :processUnit.2:distance *tmp419
+ 1123 op div :processUnit.2:distance *tmp418 10
  1124 label *label252
  1125 jump *label250 always
  1126 label *label249
 
  1176 label *label263
  1177 label *label264
  1178 ubind .TYPE
-    * set *tmp435 @unit
-    * set :rebindUnit.7:firstUnit *tmp435
+ 1179 set :rebindUnit.7:firstUnit @unit
  1180 op notEqual *tmp436 :rebindUnit.7:firstUnit null
  1181 jump *label267 equal *tmp436 false
  1182 label *label269
 
  1201 end
  1202 label *label262
  1203 set :processUnit.3:msg ""
-    * sensor *tmp445 @unit @flag
-    * set :processUnit.3:state *tmp445
+ 1204 sensor :processUnit.3:state @unit @flag
  1205 set :processUnit.3:distance -1
  1206 set :processUnit.3:color "gold"
  1207 op lessThan *tmp446 :processUnit.3:state 2
 
  1257 op sub *tmp468 .CORE_Y *tmp467
  1258 op len *tmp469 *tmp466 *tmp468
  1259 op idiv *tmp470 *tmp469 .SPEED_TENTHS
-    * op div *tmp471 *tmp470 10
-    * set :processUnit.3:distance *tmp471
+ 1260 op div :processUnit.3:distance *tmp470 10
  1261 label *label285
  1262 jump *label283 always
  1263 label *label282
 
  1292 op sub *tmp483 .DOME_Y *tmp482
  1293 op len *tmp484 *tmp481 *tmp483
  1294 op idiv *tmp485 *tmp484 .SPEED_TENTHS
-    * op div *tmp486 *tmp485 10
-    * set :processUnit.3:distance *tmp486
+ 1295 op div :processUnit.3:distance *tmp485 10
  1296 label *label291
  1297 jump *label289 always
  1298 label *label288
 
  1326 set .UNIT_P2 *tmp425
  1327 jump *label298 equal .SUPPLY_P_FIRST false
  1328 sensor *tmp491 .UNIT_P1 @totalItems
-    * op greaterThan *tmp492 *tmp491 0
-    * set *tmp490 *tmp492
+ 1329 op greaterThan *tmp490 *tmp491 0
  1330 jump *label299 always
  1331 label *label298
  1332 sensor *tmp493 .UNIT_P2 @totalItems
-    * op equal *tmp494 *tmp493 0
-    * set *tmp490 *tmp494
+ 1333 op equal *tmp490 *tmp493 0
  1334 label *label299
  1335 set .SUPPLY_P_FIRST *tmp490
  1336 jump *label260 always
 
  1354 set :areUnitsAvailable.2:occupied :areUnitsAvailable.2:needed
  1355 set :areUnitsAvailable.2:free :areUnitsAvailable.2:occupied
  1356 ubind :areUnitsAvailable.2:type
-    * set *tmp502 @unit
-    * set :areUnitsAvailable.2:firstUnit *tmp502
+ 1357 set :areUnitsAvailable.2:firstUnit @unit
  1358 op notEqual *tmp503 :areUnitsAvailable.2:firstUnit null
  1359 jump *label303 equal *tmp503 false
  1360 set :needsFourUnits.3:unit @unit
 
  1363 op len *tmp508 *tmp506 *tmp507
  1364 op mul *tmp509 2 *tmp508
  1365 sensor *tmp510 :needsFourUnits.3:unit @speed
-    * op div *tmp511 *tmp509 *tmp510
-    * set :needsFourUnits.3:travel_time *tmp511
-    * op greaterThanEq *tmp512 :needsFourUnits.3:travel_time 47
-    * set *tmp505 *tmp512
+ 1366 op div :needsFourUnits.3:travel_time *tmp509 *tmp510
+ 1367 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1368 jump *label305 always
  1369 set *tmp505 null
  1370 label *label305
 
  1433 jump *label320 always
  1434 label *label319
  1435 label *label320
-    * op add *tmp530 @time 5000
-    * set :unitCheck *tmp530
+ 1436 op add :unitCheck @time 5000
  1437 jump *label301 always
  1438 label *label300
  1439 label *label301

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-1 instructions):
 
    26 jump *label3 always
    27 label *label5
    28 label *label7
-    * jump *label9 equal true false
    29 printflush null
    30 print "[gold]Looking for suitable unit type:[]"
    31 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-70 instructions):
 
     7 set .CORE_X .CORE_Y
     8 set .DOME dome1
     9 label *label0
-    * op equal *tmp0 .DOME null
-    * jump *label2 equal *tmp0 false
+   10 jump *label2 notEqual .DOME null
    11 print "[gold]Waiting for an overdrive dome to be connected..."
    12 printflush message1
    13 set .DOME dome1
 
    16 label *label2
    17 label *label3
    18 sensor *tmp1 switch1 @enabled
-    * op equal *tmp2 *tmp1 false
-    * jump *label5 equal *tmp2 false
+   19 jump *label5 notEqual *tmp1 false
    20 print "[coral]Activate switch to begin supplying overdrive dome..."
    21 print "\n"
    22 printflush message1
 
    36 set :areUnitsAvailable.0:free :areUnitsAvailable.0:occupied
    37 ubind :areUnitsAvailable.0:type
    38 set :areUnitsAvailable.0:firstUnit @unit
-    * op notEqual *tmp6 :areUnitsAvailable.0:firstUnit null
-    * jump *label11 equal *tmp6 false
+   39 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    40 set :needsFourUnits.0:unit @unit
    41 op sub *tmp9 .DOME_X .CORE_X
    42 op sub *tmp10 .DOME_Y .CORE_Y
 
    63 op or *tmp21 *tmp18 *tmp20
    64 jump *label19 equal *tmp21 false
    65 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * op greaterThanEq *tmp23 :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
-    * jump *label21 equal *tmp23 false
+   66 jump *label21 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
    67 set *tmp4 true
    68 jump *label10 always
    69 jump *label22 always
 
    92 print ","
    93 print " free: "
    94 print :areUnitsAvailable.0:free
-    * op greaterThan *tmp30 :areUnitsAvailable.0:needed 0
-    * jump *label25 equal *tmp30 false
+   95 jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
    96 print ", needed: "
    97 print :areUnitsAvailable.0:needed
    98 jump *label26 always
 
   130 multilabel *label36
   131 jump *label37 always
   132 label *label29
-    * op notEqual *tmp34 :chooseUnitType.0:type UNIT_TYPE
-    * jump *label38 equal *tmp34 false
+  133 jump *label38 equal :chooseUnitType.0:type UNIT_TYPE
   134 remark "chooseUnitType: "
   135 remark :chooseUnitType.0:type
   136 set :areUnitsAvailable.1:type :chooseUnitType.0:type
 
   140 set :areUnitsAvailable.1:free :areUnitsAvailable.1:occupied
   141 ubind :areUnitsAvailable.1:type
   142 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp38 :areUnitsAvailable.1:firstUnit null
-    * jump *label41 equal *tmp38 false
+  143 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   144 set :needsFourUnits.1:unit @unit
   145 op sub *tmp41 .DOME_X .CORE_X
   146 op sub *tmp42 .DOME_Y .CORE_Y
 
   167 op or *tmp53 *tmp50 *tmp52
   168 jump *label49 equal *tmp53 false
   169 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * op greaterThanEq *tmp55 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
-    * jump *label51 equal *tmp55 false
+  170 jump *label51 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   171 set *tmp36 true
   172 jump *label40 always
   173 jump *label52 always
 
   196 print ","
   197 print " free: "
   198 print :areUnitsAvailable.1:free
-    * op greaterThan *tmp62 :areUnitsAvailable.1:needed 0
-    * jump *label55 equal *tmp62 false
+  199 jump *label55 lessThanEq :areUnitsAvailable.1:needed 0
   200 print ", needed: "
   201 print :areUnitsAvailable.1:needed
   202 jump *label56 always
 
   241 set :rebindUnits.0:count 0
   242 ubind .TYPE
   243 set :rebindUnits.0:firstUnit @unit
-    * op equal *tmp67 :rebindUnits.0:firstUnit null
-    * jump *label60 equal *tmp67 false
+  244 jump *label60 notEqual :rebindUnits.0:firstUnit null
   245 end
   246 jump *label61 always
   247 label *label60
   248 label *label61
   249 label *label62
   250 sensor *tmp69 @unit @controller
-    * op equal *tmp70 *tmp69 @this
-    * jump *label65 equal *tmp70 false
+  251 jump *label65 notEqual *tmp69 @this
   252 op add :rebindUnits.0:count :rebindUnits.0:count 1
   253 ucontrol flag 1
   254 set .UNIT_S2 .UNIT_P2
   255 set .UNIT_P2 .UNIT_S1
   256 set .UNIT_S1 .UNIT_P1
   257 set .UNIT_P1 @unit
-    * op notEqual *tmp73 .UNIT_S2 null
-    * jump *label67 equal *tmp73 false
+  258 jump *label67 equal .UNIT_S2 null
   259 jump *label64 always
   260 jump *label68 always
   261 label *label67
 
   275 label *label59
   276 set :acquireUnit.0:currentUnit .UNIT_S1
   277 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * op notEqual *tmp81 :rebindUnit.0:currentUnit null
-    * jump *label71 equal *tmp81 false
+  278 jump *label71 equal :rebindUnit.0:currentUnit null
   279 ubind :rebindUnit.0:currentUnit
   280 sensor *tmp83 @unit @dead
   281 op strictEqual *tmp84 *tmp83 0
 
   292 label *label72
   293 ubind .TYPE
   294 set :rebindUnit.0:firstUnit @unit
-    * op notEqual *tmp90 :rebindUnit.0:firstUnit null
-    * jump *label75 equal *tmp90 false
+  295 jump *label75 equal :rebindUnit.0:firstUnit null
   296 label *label77
   297 sensor *tmp92 @unit @controlled
-    * op equal *tmp93 *tmp92 0
-    * jump *label80 equal *tmp93 false
+  298 jump *label80 notEqual *tmp92 0
   299 jump *label70 always
   300 jump *label81 always
   301 label *label80
 
   321 set .UNIT_S1 *tmp79
   322 set :acquireUnit.1:currentUnit .UNIT_P1
   323 set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * op notEqual *tmp101 :rebindUnit.1:currentUnit null
-    * jump *label84 equal *tmp101 false
+  324 jump *label84 equal :rebindUnit.1:currentUnit null
   325 ubind :rebindUnit.1:currentUnit
   326 sensor *tmp103 @unit @dead
   327 op strictEqual *tmp104 *tmp103 0
 
   338 label *label85
   339 ubind .TYPE
   340 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp110 :rebindUnit.1:firstUnit null
-    * jump *label88 equal *tmp110 false
+  341 jump *label88 equal :rebindUnit.1:firstUnit null
   342 label *label90
   343 sensor *tmp112 @unit @controlled
-    * op equal *tmp113 *tmp112 0
-    * jump *label93 equal *tmp113 false
+  344 jump *label93 notEqual *tmp112 0
   345 jump *label83 always
   346 jump *label94 always
   347 label *label93
 
   391 label *label99
   392 ulocate building core false @copper 0 0 0 .CORE
   393 label *label100
-    * op equal *tmp134 .CORE null
-    * jump *label99 notEqual *tmp134 false
+  394 jump *label99 equal .CORE null
   395 label *label101
   396 sensor .CORE_X .CORE @x
   397 sensor .CORE_Y .CORE @y
 
   412 jump *label103 equal .FOUR_UNITS false
   413 set :acquireUnit.2:currentUnit .UNIT_S2
   414 set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * op notEqual *tmp150 :rebindUnit.2:currentUnit null
-    * jump *label107 equal *tmp150 false
+  415 jump *label107 equal :rebindUnit.2:currentUnit null
   416 ubind :rebindUnit.2:currentUnit
   417 sensor *tmp152 @unit @dead
   418 op strictEqual *tmp153 *tmp152 0
 
   429 label *label108
   430 ubind .TYPE
   431 set :rebindUnit.2:firstUnit @unit
-    * op notEqual *tmp159 :rebindUnit.2:firstUnit null
-    * jump *label111 equal *tmp159 false
+  432 jump *label111 equal :rebindUnit.2:firstUnit null
   433 label *label113
   434 sensor *tmp161 @unit @controlled
-    * op equal *tmp162 *tmp161 0
-    * jump *label116 equal *tmp162 false
+  435 jump *label116 notEqual *tmp161 0
   436 jump *label106 always
   437 jump *label117 always
   438 label *label116
 
   458 set .UNIT_S2 *tmp148
   459 set :acquireUnit.3:currentUnit .UNIT_P2
   460 set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * op notEqual *tmp170 :rebindUnit.3:currentUnit null
-    * jump *label120 equal *tmp170 false
+  461 jump *label120 equal :rebindUnit.3:currentUnit null
   462 ubind :rebindUnit.3:currentUnit
   463 sensor *tmp172 @unit @dead
   464 op strictEqual *tmp173 *tmp172 0
 
   475 label *label121
   476 ubind .TYPE
   477 set :rebindUnit.3:firstUnit @unit
-    * op notEqual *tmp179 :rebindUnit.3:firstUnit null
-    * jump *label124 equal *tmp179 false
+  478 jump *label124 equal :rebindUnit.3:firstUnit null
   479 label *label126
   480 sensor *tmp181 @unit @controlled
-    * op equal *tmp182 *tmp181 0
-    * jump *label129 equal *tmp182 false
+  481 jump *label129 notEqual *tmp181 0
   482 jump *label119 always
   483 jump *label130 always
   484 label *label129
 
   566 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   567 print :printDomeStatus.0:text
   568 sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
-    * op greaterThan *tmp215 :printDomeStatus.0:level 3
-    * jump *label139 equal *tmp215 false
+  569 jump *label139 lessThanEq :printDomeStatus.0:level 3
   570 print "  dome:  [green]"
   571 print :printDomeStatus.0:level
   572 print "["
 
   586 set :processUnit.0:group .GROUP1
   587 set :processUnit.0:supply .SUPPLY_S_FIRST
   588 set :rebindUnit.4:currentUnit :processUnit.0:unit
-    * op notEqual *tmp219 :rebindUnit.4:currentUnit null
-    * jump *label143 equal *tmp219 false
+  589 jump *label143 equal :rebindUnit.4:currentUnit null
   590 ubind :rebindUnit.4:currentUnit
   591 sensor *tmp221 @unit @dead
   592 op strictEqual *tmp222 *tmp221 0
 
   603 label *label144
   604 ubind .TYPE
   605 set :rebindUnit.4:firstUnit @unit
-    * op notEqual *tmp228 :rebindUnit.4:firstUnit null
-    * jump *label147 equal *tmp228 false
+  606 jump *label147 equal :rebindUnit.4:firstUnit null
   607 label *label149
   608 sensor *tmp230 @unit @controlled
-    * op equal *tmp231 *tmp230 0
-    * jump *label152 equal *tmp231 false
+  609 jump *label152 notEqual *tmp230 0
   610 jump *label142 always
   611 jump *label153 always
   612 label *label152
 
   633 op or *tmp240 *tmp238 *tmp239
   634 jump *label154 equal *tmp240 false
   635 sensor *tmp242 @unit @firstItem
-    * op equal *tmp243 *tmp242 :processUnit.0:item
-    * jump *label156 equal *tmp243 false
+  636 jump *label156 notEqual *tmp242 :processUnit.0:item
   637 set :processUnit.0:state 3
   638 jump *label157 always
   639 label *label156
   640 sensor *tmp245 @unit @totalItems
-    * op equal *tmp246 *tmp245 0
-    * jump *label158 equal *tmp246 false
+  641 jump *label158 notEqual *tmp245 0
   642 set :processUnit.0:state 2
   643 jump *label159 always
   644 label *label158
 
   655 jump *label155 always
   656 label *label154
   657 label *label155
-    * op equal *tmp250 :processUnit.0:state 2
-    * jump *label162 equal *tmp250 false
+  658 jump *label162 notEqual :processUnit.0:state 2
   659 ucontrol within .CORE_X .CORE_Y 8 *tmp252
   660 jump *label164 equal *tmp252 false
   661 ucontrol itemTake .CORE :processUnit.0:item .UNIT_CAPACITY
   662 sensor *tmp254 @unit @totalItems
-    * op greaterThanEq *tmp255 *tmp254 .UNIT_CAPACITY
-    * jump *label166 equal *tmp255 false
+  663 jump *label166 lessThan *tmp254 .UNIT_CAPACITY
   664 ucontrol approach .DOME_X .DOME_Y 6
   665 set :processUnit.0:state 3
   666 jump *label167 always
 
   682 jump *label163 always
   683 label *label162
   684 label *label163
-    * op equal *tmp264 :processUnit.0:state 3
-    * jump *label168 equal *tmp264 false
+  685 jump *label168 notEqual :processUnit.0:state 3
   686 ucontrol within .DOME_X .DOME_Y 8 *tmp266
   687 jump *label170 equal *tmp266 false
   688 jump *label172 equal :processUnit.0:supply false
 
   694 set :processUnit.0:msg ", waiting\n"
   695 label *label173
   696 sensor *tmp269 @unit @totalItems
-    * op lessThanEq *tmp270 *tmp269 0
-    * jump *label174 equal *tmp270 false
+  697 jump *label174 greaterThan *tmp269 0
   698 ucontrol approach .CORE_X .CORE_Y 6
   699 set :processUnit.0:state 2
   700 jump *label175 always
 
   726 print *tmp279
   727 print "["
   728 print "]"
-    * op greaterThanEq *tmp280 :processUnit.0:distance 0
-    * jump *label176 equal *tmp280 false
+  729 jump *label176 lessThan :processUnit.0:distance 0
   730 print :processUnit.0:msg
   731 print :processUnit.0:distance
   732 print "["
 
   748 set :processUnit.1:group .GROUP2
   749 set :processUnit.1:supply *tmp283
   750 set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * op notEqual *tmp286 :rebindUnit.5:currentUnit null
-    * jump *label182 equal *tmp286 false
+  751 jump *label182 equal :rebindUnit.5:currentUnit null
   752 ubind :rebindUnit.5:currentUnit
   753 sensor *tmp288 @unit @dead
   754 op strictEqual *tmp289 *tmp288 0
 
   765 label *label183
   766 ubind .TYPE
   767 set :rebindUnit.5:firstUnit @unit
-    * op notEqual *tmp295 :rebindUnit.5:firstUnit null
-    * jump *label186 equal *tmp295 false
+  768 jump *label186 equal :rebindUnit.5:firstUnit null
   769 label *label188
   770 sensor *tmp297 @unit @controlled
-    * op equal *tmp298 *tmp297 0
-    * jump *label191 equal *tmp298 false
+  771 jump *label191 notEqual *tmp297 0
   772 jump *label181 always
   773 jump *label192 always
   774 label *label191
 
   795 op or *tmp307 *tmp305 *tmp306
   796 jump *label193 equal *tmp307 false
   797 sensor *tmp309 @unit @firstItem
-    * op equal *tmp310 *tmp309 :processUnit.1:item
-    * jump *label195 equal *tmp310 false
+  798 jump *label195 notEqual *tmp309 :processUnit.1:item
   799 set :processUnit.1:state 3
   800 jump *label196 always
   801 label *label195
   802 sensor *tmp312 @unit @totalItems
-    * op equal *tmp313 *tmp312 0
-    * jump *label197 equal *tmp313 false
+  803 jump *label197 notEqual *tmp312 0
   804 set :processUnit.1:state 2
   805 jump *label198 always
   806 label *label197
 
   817 jump *label194 always
   818 label *label193
   819 label *label194
-    * op equal *tmp317 :processUnit.1:state 2
-    * jump *label201 equal *tmp317 false
+  820 jump *label201 notEqual :processUnit.1:state 2
   821 ucontrol within .CORE_X .CORE_Y 8 *tmp319
   822 jump *label203 equal *tmp319 false
   823 ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
   824 sensor *tmp321 @unit @totalItems
-    * op greaterThanEq *tmp322 *tmp321 .UNIT_CAPACITY
-    * jump *label205 equal *tmp322 false
+  825 jump *label205 lessThan *tmp321 .UNIT_CAPACITY
   826 ucontrol approach .DOME_X .DOME_Y 6
   827 set :processUnit.1:state 3
   828 jump *label206 always
 
   844 jump *label202 always
   845 label *label201
   846 label *label202
-    * op equal *tmp331 :processUnit.1:state 3
-    * jump *label207 equal *tmp331 false
+  847 jump *label207 notEqual :processUnit.1:state 3
   848 ucontrol within .DOME_X .DOME_Y 8 *tmp333
   849 jump *label209 equal *tmp333 false
   850 jump *label211 equal :processUnit.1:supply false
 
   856 set :processUnit.1:msg ", waiting\n"
   857 label *label212
   858 sensor *tmp336 @unit @totalItems
-    * op lessThanEq *tmp337 *tmp336 0
-    * jump *label213 equal *tmp337 false
+  859 jump *label213 greaterThan *tmp336 0
   860 ucontrol approach .CORE_X .CORE_Y 6
   861 set :processUnit.1:state 2
   862 jump *label214 always
 
   888 print *tmp346
   889 print "["
   890 print "]"
-    * op greaterThanEq *tmp347 :processUnit.1:distance 0
-    * jump *label215 equal *tmp347 false
+  891 jump *label215 lessThan :processUnit.1:distance 0
   892 print :processUnit.1:msg
   893 print :processUnit.1:distance
   894 print "["
 
   919 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   920 print :printDomeStatus.1:text
   921 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
-    * op greaterThan *tmp356 :printDomeStatus.1:level 3
-    * jump *label220 equal *tmp356 false
+  922 jump *label220 lessThanEq :printDomeStatus.1:level 3
   923 print "  dome:  [green]"
   924 print :printDomeStatus.1:level
   925 print "["
 
   939 set :processUnit.2:group .GROUP1
   940 set :processUnit.2:supply .SUPPLY_P_FIRST
   941 set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * op notEqual *tmp360 :rebindUnit.6:currentUnit null
-    * jump *label224 equal *tmp360 false
+  942 jump *label224 equal :rebindUnit.6:currentUnit null
   943 ubind :rebindUnit.6:currentUnit
   944 sensor *tmp362 @unit @dead
   945 op strictEqual *tmp363 *tmp362 0
 
   956 label *label225
   957 ubind .TYPE
   958 set :rebindUnit.6:firstUnit @unit
-    * op notEqual *tmp369 :rebindUnit.6:firstUnit null
-    * jump *label228 equal *tmp369 false
+  959 jump *label228 equal :rebindUnit.6:firstUnit null
   960 label *label230
   961 sensor *tmp371 @unit @controlled
-    * op equal *tmp372 *tmp371 0
-    * jump *label233 equal *tmp372 false
+  962 jump *label233 notEqual *tmp371 0
   963 jump *label223 always
   964 jump *label234 always
   965 label *label233
 
   986 op or *tmp381 *tmp379 *tmp380
   987 jump *label235 equal *tmp381 false
   988 sensor *tmp383 @unit @firstItem
-    * op equal *tmp384 *tmp383 :processUnit.2:item
-    * jump *label237 equal *tmp384 false
+  989 jump *label237 notEqual *tmp383 :processUnit.2:item
   990 set :processUnit.2:state 3
   991 jump *label238 always
   992 label *label237
   993 sensor *tmp386 @unit @totalItems
-    * op equal *tmp387 *tmp386 0
-    * jump *label239 equal *tmp387 false
+  994 jump *label239 notEqual *tmp386 0
   995 set :processUnit.2:state 2
   996 jump *label240 always
   997 label *label239
 
  1008 jump *label236 always
  1009 label *label235
  1010 label *label236
-    * op equal *tmp391 :processUnit.2:state 2
-    * jump *label243 equal *tmp391 false
+ 1011 jump *label243 notEqual :processUnit.2:state 2
  1012 ucontrol within .CORE_X .CORE_Y 8 *tmp393
  1013 jump *label245 equal *tmp393 false
  1014 ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
  1015 sensor *tmp395 @unit @totalItems
-    * op greaterThanEq *tmp396 *tmp395 .UNIT_CAPACITY
-    * jump *label247 equal *tmp396 false
+ 1016 jump *label247 lessThan *tmp395 .UNIT_CAPACITY
  1017 ucontrol approach .DOME_X .DOME_Y 6
  1018 set :processUnit.2:state 3
  1019 jump *label248 always
 
  1035 jump *label244 always
  1036 label *label243
  1037 label *label244
-    * op equal *tmp405 :processUnit.2:state 3
-    * jump *label249 equal *tmp405 false
+ 1038 jump *label249 notEqual :processUnit.2:state 3
  1039 ucontrol within .DOME_X .DOME_Y 8 *tmp407
  1040 jump *label251 equal *tmp407 false
  1041 jump *label253 equal :processUnit.2:supply false
 
  1047 set :processUnit.2:msg ", waiting\n"
  1048 label *label254
  1049 sensor *tmp410 @unit @totalItems
-    * op lessThanEq *tmp411 *tmp410 0
-    * jump *label255 equal *tmp411 false
+ 1050 jump *label255 greaterThan *tmp410 0
  1051 ucontrol approach .CORE_X .CORE_Y 6
  1052 set :processUnit.2:state 2
  1053 jump *label256 always
 
  1079 print *tmp420
  1080 print "["
  1081 print "]"
-    * op greaterThanEq *tmp421 :processUnit.2:distance 0
-    * jump *label257 equal *tmp421 false
+ 1082 jump *label257 lessThan :processUnit.2:distance 0
  1083 print :processUnit.2:msg
  1084 print :processUnit.2:distance
  1085 print "["
 
  1101 set :processUnit.3:group .GROUP2
  1102 set :processUnit.3:supply *tmp424
  1103 set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * op notEqual *tmp427 :rebindUnit.7:currentUnit null
-    * jump *label263 equal *tmp427 false
+ 1104 jump *label263 equal :rebindUnit.7:currentUnit null
  1105 ubind :rebindUnit.7:currentUnit
  1106 sensor *tmp429 @unit @dead
  1107 op strictEqual *tmp430 *tmp429 0
 
  1118 label *label264
  1119 ubind .TYPE
  1120 set :rebindUnit.7:firstUnit @unit
-    * op notEqual *tmp436 :rebindUnit.7:firstUnit null
-    * jump *label267 equal *tmp436 false
+ 1121 jump *label267 equal :rebindUnit.7:firstUnit null
  1122 label *label269
  1123 sensor *tmp438 @unit @controlled
-    * op equal *tmp439 *tmp438 0
-    * jump *label272 equal *tmp439 false
+ 1124 jump *label272 notEqual *tmp438 0
  1125 jump *label262 always
  1126 jump *label273 always
  1127 label *label272
 
  1148 op or *tmp448 *tmp446 *tmp447
  1149 jump *label274 equal *tmp448 false
  1150 sensor *tmp450 @unit @firstItem
-    * op equal *tmp451 *tmp450 :processUnit.3:item
-    * jump *label276 equal *tmp451 false
+ 1151 jump *label276 notEqual *tmp450 :processUnit.3:item
  1152 set :processUnit.3:state 3
  1153 jump *label277 always
  1154 label *label276
  1155 sensor *tmp453 @unit @totalItems
-    * op equal *tmp454 *tmp453 0
-    * jump *label278 equal *tmp454 false
+ 1156 jump *label278 notEqual *tmp453 0
  1157 set :processUnit.3:state 2
  1158 jump *label279 always
  1159 label *label278
 
  1170 jump *label275 always
  1171 label *label274
  1172 label *label275
-    * op equal *tmp458 :processUnit.3:state 2
-    * jump *label282 equal *tmp458 false
+ 1173 jump *label282 notEqual :processUnit.3:state 2
  1174 ucontrol within .CORE_X .CORE_Y 8 *tmp460
  1175 jump *label284 equal *tmp460 false
  1176 ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
  1177 sensor *tmp462 @unit @totalItems
-    * op greaterThanEq *tmp463 *tmp462 .UNIT_CAPACITY
-    * jump *label286 equal *tmp463 false
+ 1178 jump *label286 lessThan *tmp462 .UNIT_CAPACITY
  1179 ucontrol approach .DOME_X .DOME_Y 6
  1180 set :processUnit.3:state 3
  1181 jump *label287 always
 
  1197 jump *label283 always
  1198 label *label282
  1199 label *label283
-    * op equal *tmp472 :processUnit.3:state 3
-    * jump *label288 equal *tmp472 false
+ 1200 jump *label288 notEqual :processUnit.3:state 3
  1201 ucontrol within .DOME_X .DOME_Y 8 *tmp474
  1202 jump *label290 equal *tmp474 false
  1203 jump *label292 equal :processUnit.3:supply false
 
  1209 set :processUnit.3:msg ", waiting\n"
  1210 label *label293
  1211 sensor *tmp477 @unit @totalItems
-    * op lessThanEq *tmp478 *tmp477 0
-    * jump *label294 equal *tmp478 false
+ 1212 jump *label294 greaterThan *tmp477 0
  1213 ucontrol approach .CORE_X .CORE_Y 6
  1214 set :processUnit.3:state 2
  1215 jump *label295 always
 
  1241 print *tmp487
  1242 print "["
  1243 print "]"
-    * op greaterThanEq *tmp488 :processUnit.3:distance 0
-    * jump *label296 equal *tmp488 false
+ 1244 jump *label296 lessThan :processUnit.3:distance 0
  1245 print :processUnit.3:msg
  1246 print :processUnit.3:distance
  1247 print "["
 
  1287 set :areUnitsAvailable.2:free :areUnitsAvailable.2:occupied
  1288 ubind :areUnitsAvailable.2:type
  1289 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp503 :areUnitsAvailable.2:firstUnit null
-    * jump *label303 equal *tmp503 false
+ 1290 jump *label303 equal :areUnitsAvailable.2:firstUnit null
  1291 set :needsFourUnits.3:unit @unit
  1292 op sub *tmp506 .DOME_X .CORE_X
  1293 op sub *tmp507 .DOME_Y .CORE_Y
 
  1314 op or *tmp518 *tmp515 *tmp517
  1315 jump *label311 equal *tmp518 false
  1316 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * op greaterThanEq *tmp520 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
-    * jump *label313 equal *tmp520 false
+ 1317 jump *label313 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1318 set *tmp501 true
  1319 jump *label302 always
  1320 jump *label314 always
 
  1343 print ","
  1344 print " free: "
  1345 print :areUnitsAvailable.2:free
-    * op greaterThan *tmp527 :areUnitsAvailable.2:needed 0
-    * jump *label317 equal *tmp527 false
+ 1346 jump *label317 lessThanEq :areUnitsAvailable.2:needed 0
  1347 print ", needed: "
  1348 print :areUnitsAvailable.2:needed
  1349 jump *label318 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-79 instructions):
 
    66 jump *label21 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
    67 set *tmp4 true
    68 jump *label10 always
-    * jump *label22 always
    69 label *label21
    70 label *label22
    71 jump *label20 always
 
    80 op land *tmp28 *tmp25 *tmp27
    81 jump *label16 notEqual *tmp28 false
    82 label *label18
-    * jump *label12 always
    83 label *label11
    84 label *label12
    85 jump *label23 equal :areUnitsAvailable.0:output false
 
    93 jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
    94 print ", needed: "
    95 print :areUnitsAvailable.0:needed
-    * jump *label26 always
    96 label *label25
    97 label *label26
    98 print "\n"
-    * jump *label24 always
    99 label *label23
   100 label *label24
   101 set *tmp4 false
 
   105 jump *label27 equal *tmp4 false
   106 set *tmp3 UNIT_TYPE
   107 jump *label6 always
-    * jump *label28 always
   108 label *label27
   109 label *label28
   110 set :chooseUnitType.0:type @flare
 
   165 jump *label51 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   166 set *tmp36 true
   167 jump *label40 always
-    * jump *label52 always
   168 label *label51
   169 label *label52
   170 jump *label50 always
 
   179 op land *tmp60 *tmp57 *tmp59
   180 jump *label46 notEqual *tmp60 false
   181 label *label48
-    * jump *label42 always
   182 label *label41
   183 label *label42
   184 jump *label53 equal :areUnitsAvailable.1:output false
 
   192 jump *label55 lessThanEq :areUnitsAvailable.1:needed 0
   193 print ", needed: "
   194 print :areUnitsAvailable.1:needed
-    * jump *label56 always
   195 label *label55
   196 label *label56
   197 print "\n"
-    * jump *label54 always
   198 label *label53
   199 label *label54
   200 set *tmp36 false
 
   205 printflush null
   206 set *tmp3 :chooseUnitType.0:type
   207 jump *label6 always
-    * jump *label58 always
   208 label *label57
   209 label *label58
-    * jump *label39 always
   210 label *label38
   211 label *label39
   212 label *label30
 
   232 set :rebindUnits.0:firstUnit @unit
   233 jump *label60 notEqual :rebindUnits.0:firstUnit null
   234 end
-    * jump *label61 always
   235 label *label60
   236 label *label61
   237 label *label62
 
   245 set .UNIT_P1 @unit
   246 jump *label67 equal .UNIT_S2 null
   247 jump *label64 always
-    * jump *label68 always
   248 label *label67
   249 label *label68
-    * jump *label66 always
   250 label *label65
   251 label *label66
   252 ubind .TYPE
 
   257 op land *tmp78 *tmp75 *tmp77
   258 jump *label62 notEqual *tmp78 false
   259 label *label64
-    * jump *label59 always
   260 label *label59
   261 set :acquireUnit.0:currentUnit .UNIT_S1
   262 set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
 
   269 op land *tmp87 *tmp84 *tmp86
   270 jump *label73 equal *tmp87 false
   271 jump *label70 always
-    * jump *label74 always
   272 label *label73
   273 label *label74
-    * jump *label72 always
   274 label *label71
   275 label *label72
   276 ubind .TYPE
 
   280 sensor *tmp92 @unit @controlled
   281 jump *label80 notEqual *tmp92 0
   282 jump *label70 always
-    * jump *label81 always
   283 label *label80
   284 label *label81
   285 ubind .TYPE
 
   290 op land *tmp98 *tmp95 *tmp97
   291 jump *label77 notEqual *tmp98 false
   292 label *label79
-    * jump *label76 always
   293 label *label75
   294 label *label76
   295 end
 
   311 op land *tmp107 *tmp104 *tmp106
   312 jump *label86 equal *tmp107 false
   313 jump *label83 always
-    * jump *label87 always
   314 label *label86
   315 label *label87
-    * jump *label85 always
   316 label *label84
   317 label *label85
   318 ubind .TYPE
 
   322 sensor *tmp112 @unit @controlled
   323 jump *label93 notEqual *tmp112 0
   324 jump *label83 always
-    * jump *label94 always
   325 label *label93
   326 label *label94
   327 ubind .TYPE
 
   332 op land *tmp118 *tmp115 *tmp117
   333 jump *label90 notEqual *tmp118 false
   334 label *label92
-    * jump *label89 always
   335 label *label88
   336 label *label89
   337 end
 
   351 set :u .UNIT_S1
   352 set .UNIT_S1 .UNIT_P1
   353 set .UNIT_P1 :u
-    * jump *label96 always
   354 label *label95
   355 label *label96
   356 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   359 op strictEqual *tmp128 .SPEED null
   360 jump *label97 equal *tmp128 false
   361 stop
-    * jump *label98 always
   362 label *label97
   363 label *label98
   364 print "[gold]Locating core..."
 
   396 op land *tmp156 *tmp153 *tmp155
   397 jump *label109 equal *tmp156 false
   398 jump *label106 always
-    * jump *label110 always
   399 label *label109
   400 label *label110
-    * jump *label108 always
   401 label *label107
   402 label *label108
   403 ubind .TYPE
 
   407 sensor *tmp161 @unit @controlled
   408 jump *label116 notEqual *tmp161 0
   409 jump *label106 always
-    * jump *label117 always
   410 label *label116
   411 label *label117
   412 ubind .TYPE
 
   417 op land *tmp167 *tmp164 *tmp166
   418 jump *label113 notEqual *tmp167 false
   419 label *label115
-    * jump *label112 always
   420 label *label111
   421 label *label112
   422 end
 
   438 op land *tmp176 *tmp173 *tmp175
   439 jump *label122 equal *tmp176 false
   440 jump *label119 always
-    * jump *label123 always
   441 label *label122
   442 label *label123
-    * jump *label121 always
   443 label *label120
   444 label *label121
   445 ubind .TYPE
 
   449 sensor *tmp181 @unit @controlled
   450 jump *label129 notEqual *tmp181 0
   451 jump *label119 always
-    * jump *label130 always
   452 label *label129
   453 label *label130
   454 ubind .TYPE
 
   459 op land *tmp187 *tmp184 *tmp186
   460 jump *label126 notEqual *tmp187 false
   461 label *label128
-    * jump *label125 always
   462 label *label124
   463 label *label125
   464 end
 
   478 set :u .UNIT_S1
   479 set .UNIT_S1 .UNIT_P2
   480 set .UNIT_P2 :u
-    * jump *label132 always
   481 label *label131
   482 label *label132
   483 sensor *tmp194 .UNIT_S2 @firstItem
 
   489 set :u .UNIT_S2
   490 set .UNIT_S2 .UNIT_P2
   491 set .UNIT_P2 :u
-    * jump *label134 always
   492 label *label133
   493 label *label134
   494 set .GROUP1 "unit  1"
 
   560 op land *tmp225 *tmp222 *tmp224
   561 jump *label145 equal *tmp225 false
   562 jump *label142 always
-    * jump *label146 always
   563 label *label145
   564 label *label146
-    * jump *label144 always
   565 label *label143
   566 label *label144
   567 ubind .TYPE
 
   571 sensor *tmp230 @unit @controlled
   572 jump *label152 notEqual *tmp230 0
   573 jump *label142 always
-    * jump *label153 always
   574 label *label152
   575 label *label153
   576 ubind .TYPE
 
   581 op land *tmp236 *tmp233 *tmp235
   582 jump *label149 notEqual *tmp236 false
   583 label *label151
-    * jump *label148 always
   584 label *label147
   585 label *label148
   586 end
 
   608 ucontrol within .CORE_X .CORE_Y 8 *tmp248
   609 jump *label160 equal *tmp248 false
   610 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label161 always
   611 label *label160
   612 label *label161
   613 label *label159
   614 label *label157
-    * jump *label155 always
   615 label *label154
   616 label *label155
   617 jump *label162 notEqual :processUnit.0:state 2
 
   638 op idiv *tmp262 *tmp261 .SPEED_TENTHS
   639 op div :processUnit.0:distance *tmp262 10
   640 label *label165
-    * jump *label163 always
   641 label *label162
   642 label *label163
   643 jump *label168 notEqual :processUnit.0:state 3
 
   655 jump *label174 greaterThan *tmp269 0
   656 ucontrol approach .CORE_X .CORE_Y 6
   657 set :processUnit.0:state 2
-    * jump *label175 always
   658 label *label174
   659 label *label175
   660 jump *label171 always
 
   669 op idiv *tmp277 *tmp276 .SPEED_TENTHS
   670 op div :processUnit.0:distance *tmp277 10
   671 label *label171
-    * jump *label169 always
   672 label *label168
   673 label *label169
   674 ucontrol flag :processUnit.0:state
 
   713 op land *tmp292 *tmp289 *tmp291
   714 jump *label184 equal *tmp292 false
   715 jump *label181 always
-    * jump *label185 always
   716 label *label184
   717 label *label185
-    * jump *label183 always
   718 label *label182
   719 label *label183
   720 ubind .TYPE
 
   724 sensor *tmp297 @unit @controlled
   725 jump *label191 notEqual *tmp297 0
   726 jump *label181 always
-    * jump *label192 always
   727 label *label191
   728 label *label192
   729 ubind .TYPE
 
   734 op land *tmp303 *tmp300 *tmp302
   735 jump *label188 notEqual *tmp303 false
   736 label *label190
-    * jump *label187 always
   737 label *label186
   738 label *label187
   739 end
 
   761 ucontrol within .CORE_X .CORE_Y 8 *tmp315
   762 jump *label199 equal *tmp315 false
   763 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label200 always
   764 label *label199
   765 label *label200
   766 label *label198
   767 label *label196
-    * jump *label194 always
   768 label *label193
   769 label *label194
   770 jump *label201 notEqual :processUnit.1:state 2
 
   791 op idiv *tmp329 *tmp328 .SPEED_TENTHS
   792 op div :processUnit.1:distance *tmp329 10
   793 label *label204
-    * jump *label202 always
   794 label *label201
   795 label *label202
   796 jump *label207 notEqual :processUnit.1:state 3
 
   808 jump *label213 greaterThan *tmp336 0
   809 ucontrol approach .CORE_X .CORE_Y 6
   810 set :processUnit.1:state 2
-    * jump *label214 always
   811 label *label213
   812 label *label214
   813 jump *label210 always
 
   822 op idiv *tmp344 *tmp343 .SPEED_TENTHS
   823 op div :processUnit.1:distance *tmp344 10
   824 label *label210
-    * jump *label208 always
   825 label *label207
   826 label *label208
   827 ucontrol flag :processUnit.1:state
 
   859 op equal *tmp349 *tmp352 0
   860 label *label218
   861 set .SUPPLY_S_FIRST *tmp349
-    * jump *label179 always
   862 label *label178
   863 label *label179
   864 set :printDomeStatus.1:item @phase-fabric
 
   894 op land *tmp366 *tmp363 *tmp365
   895 jump *label226 equal *tmp366 false
   896 jump *label223 always
-    * jump *label227 always
   897 label *label226
   898 label *label227
-    * jump *label225 always
   899 label *label224
   900 label *label225
   901 ubind .TYPE
 
   905 sensor *tmp371 @unit @controlled
   906 jump *label233 notEqual *tmp371 0
   907 jump *label223 always
-    * jump *label234 always
   908 label *label233
   909 label *label234
   910 ubind .TYPE
 
   915 op land *tmp377 *tmp374 *tmp376
   916 jump *label230 notEqual *tmp377 false
   917 label *label232
-    * jump *label229 always
   918 label *label228
   919 label *label229
   920 end
 
   942 ucontrol within .CORE_X .CORE_Y 8 *tmp389
   943 jump *label241 equal *tmp389 false
   944 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label242 always
   945 label *label241
   946 label *label242
   947 label *label240
   948 label *label238
-    * jump *label236 always
   949 label *label235
   950 label *label236
   951 jump *label243 notEqual :processUnit.2:state 2
 
   972 op idiv *tmp403 *tmp402 .SPEED_TENTHS
   973 op div :processUnit.2:distance *tmp403 10
   974 label *label246
-    * jump *label244 always
   975 label *label243
   976 label *label244
   977 jump *label249 notEqual :processUnit.2:state 3
 
   989 jump *label255 greaterThan *tmp410 0
   990 ucontrol approach .CORE_X .CORE_Y 6
   991 set :processUnit.2:state 2
-    * jump *label256 always
   992 label *label255
   993 label *label256
   994 jump *label252 always
 
  1003 op idiv *tmp418 *tmp417 .SPEED_TENTHS
  1004 op div :processUnit.2:distance *tmp418 10
  1005 label *label252
-    * jump *label250 always
  1006 label *label249
  1007 label *label250
  1008 ucontrol flag :processUnit.2:state
 
  1047 op land *tmp433 *tmp430 *tmp432
  1048 jump *label265 equal *tmp433 false
  1049 jump *label262 always
-    * jump *label266 always
  1050 label *label265
  1051 label *label266
-    * jump *label264 always
  1052 label *label263
  1053 label *label264
  1054 ubind .TYPE
 
  1058 sensor *tmp438 @unit @controlled
  1059 jump *label272 notEqual *tmp438 0
  1060 jump *label262 always
-    * jump *label273 always
  1061 label *label272
  1062 label *label273
  1063 ubind .TYPE
 
  1068 op land *tmp444 *tmp441 *tmp443
  1069 jump *label269 notEqual *tmp444 false
  1070 label *label271
-    * jump *label268 always
  1071 label *label267
  1072 label *label268
  1073 end
 
  1095 ucontrol within .CORE_X .CORE_Y 8 *tmp456
  1096 jump *label280 equal *tmp456 false
  1097 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label281 always
  1098 label *label280
  1099 label *label281
  1100 label *label279
  1101 label *label277
-    * jump *label275 always
  1102 label *label274
  1103 label *label275
  1104 jump *label282 notEqual :processUnit.3:state 2
 
  1125 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1126 op div :processUnit.3:distance *tmp470 10
  1127 label *label285
-    * jump *label283 always
  1128 label *label282
  1129 label *label283
  1130 jump *label288 notEqual :processUnit.3:state 3
 
  1142 jump *label294 greaterThan *tmp477 0
  1143 ucontrol approach .CORE_X .CORE_Y 6
  1144 set :processUnit.3:state 2
-    * jump *label295 always
  1145 label *label294
  1146 label *label295
  1147 jump *label291 always
 
  1156 op idiv *tmp485 *tmp484 .SPEED_TENTHS
  1157 op div :processUnit.3:distance *tmp485 10
  1158 label *label291
-    * jump *label289 always
  1159 label *label288
  1160 label *label289
  1161 ucontrol flag :processUnit.3:state
 
  1193 op equal *tmp490 *tmp493 0
  1194 label *label299
  1195 set .SUPPLY_P_FIRST *tmp490
-    * jump *label260 always
  1196 label *label259
  1197 label *label260
  1198 op sub *tmp495 @time :start
 
  1244 jump *label313 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1245 set *tmp501 true
  1246 jump *label302 always
-    * jump *label314 always
  1247 label *label313
  1248 label *label314
  1249 jump *label312 always
 
  1258 op land *tmp525 *tmp522 *tmp524
  1259 jump *label308 notEqual *tmp525 false
  1260 label *label310
-    * jump *label304 always
  1261 label *label303
  1262 label *label304
  1263 jump *label315 equal :areUnitsAvailable.2:output false
 
  1271 jump *label317 lessThanEq :areUnitsAvailable.2:needed 0
  1272 print ", needed: "
  1273 print :areUnitsAvailable.2:needed
-    * jump *label318 always
  1274 label *label317
  1275 label *label318
  1276 print "\n"
-    * jump *label316 always
  1277 label *label315
  1278 label *label316
  1279 set *tmp501 false
 
  1282 label *label302
  1283 jump *label319 equal *tmp501 false
  1284 end
-    * jump *label320 always
  1285 label *label319
  1286 label *label320
  1287 op add :unitCheck @time 5000
-    * jump *label301 always
  1288 label *label300
  1289 label *label301
  1290 label *label136

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-15 instructions):
 
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
     4 set .DOME_Y null
-    * set .DOME_X .DOME_Y
-    * set .CORE_Y .DOME_X
-    * set .CORE_X .CORE_Y
+    5 set .DOME_X null
+    6 set .CORE_Y .DOME_Y
+    7 set .CORE_X .DOME_X
     8 set .DOME dome1
     9 label *label0
    10 jump *label2 notEqual .DOME null
 
    32 set :areUnitsAvailable.0:type UNIT_TYPE
    33 set :areUnitsAvailable.0:output true
    34 set :areUnitsAvailable.0:needed 0
-    * set :areUnitsAvailable.0:occupied :areUnitsAvailable.0:needed
-    * set :areUnitsAvailable.0:free :areUnitsAvailable.0:occupied
-    * ubind :areUnitsAvailable.0:type
+   35 set :areUnitsAvailable.0:occupied 0
+   36 set :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   37 ubind UNIT_TYPE
    38 set :areUnitsAvailable.0:firstUnit @unit
    39 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    40 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 .DOME_X .CORE_X
-    * op sub *tmp10 .DOME_Y .CORE_Y
+   41 op sub *tmp9 .DOME_Y .CORE_Y
+   42 op sub *tmp10 null .DOME_X
    43 op len *tmp11 *tmp9 *tmp10
    44 op mul *tmp12 2 *tmp11
    45 sensor *tmp13 :needsFourUnits.0:unit @speed
    46 op div :needsFourUnits.0:travel_time *tmp12 *tmp13
    47 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    48 jump *label13 always
-    * set *tmp8 null
    49 label *label13
    50 jump *label14 equal *tmp8 false
    51 set *tmp16 4
 
    62 op or *tmp21 *tmp18 *tmp20
    63 jump *label19 equal *tmp21 false
    64 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label21 lessThan :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   65 jump *label21 lessThan :areUnitsAvailable.0:free *tmp16
    66 set *tmp4 true
    67 jump *label10 always
    68 label *label21
 
    71 label *label19
    72 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
    73 label *label20
-    * ubind :areUnitsAvailable.0:type
+   74 ubind UNIT_TYPE
    75 label *label17
    76 op notEqual *tmp25 @unit :areUnitsAvailable.0:firstUnit
    77 sensor *tmp26 :areUnitsAvailable.0:firstUnit @dead
 
    81 label *label18
    82 label *label11
    83 label *label12
-    * jump *label23 equal :areUnitsAvailable.0:output false
-    * print :areUnitsAvailable.0:type
+   84 jump *label23 equal true false
+   85 print UNIT_TYPE
    86 print ":"
    87 print " occupied: "
    88 print :areUnitsAvailable.0:occupied
 
    99 label *label24
   100 set *tmp4 false
   101 jump *label10 always
-    * set *tmp4 null
   102 label *label10
   103 jump *label27 equal *tmp4 false
   104 set *tmp3 UNIT_TYPE
 
   129 set :areUnitsAvailable.1:type :chooseUnitType.0:type
   130 set :areUnitsAvailable.1:output true
   131 set :areUnitsAvailable.1:needed 0
-    * set :areUnitsAvailable.1:occupied :areUnitsAvailable.1:needed
-    * set :areUnitsAvailable.1:free :areUnitsAvailable.1:occupied
-    * ubind :areUnitsAvailable.1:type
+  132 set :areUnitsAvailable.1:occupied 0
+  133 set :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  134 ubind :chooseUnitType.0:type
   135 set :areUnitsAvailable.1:firstUnit @unit
   136 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   137 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 .DOME_X .CORE_X
-    * op sub *tmp42 .DOME_Y .CORE_Y
+  138 op sub *tmp41 .DOME_Y .CORE_Y
+  139 op sub *tmp42 null .DOME_X
   140 op len *tmp43 *tmp41 *tmp42
   141 op mul *tmp44 2 *tmp43
   142 sensor *tmp45 :needsFourUnits.1:unit @speed
   143 op div :needsFourUnits.1:travel_time *tmp44 *tmp45
   144 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   145 jump *label43 always
-    * set *tmp40 null
   146 label *label43
   147 jump *label44 equal *tmp40 false
   148 set *tmp48 4
 
   159 op or *tmp53 *tmp50 *tmp52
   160 jump *label49 equal *tmp53 false
   161 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label51 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  162 jump *label51 lessThan :areUnitsAvailable.1:free *tmp48
   163 set *tmp36 true
   164 jump *label40 always
   165 label *label51
 
   168 label *label49
   169 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   170 label *label50
-    * ubind :areUnitsAvailable.1:type
+  171 ubind :chooseUnitType.0:type
   172 label *label47
   173 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   174 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   178 label *label48
   179 label *label41
   180 label *label42
-    * jump *label53 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  181 jump *label53 equal true false
+  182 print :chooseUnitType.0:type
   183 print ":"
   184 print " occupied: "
   185 print :areUnitsAvailable.1:occupied
 
   196 label *label54
   197 set *tmp36 false
   198 jump *label40 always
-    * set *tmp36 null
   199 label *label40
   200 jump *label57 equal *tmp36 false
   201 printflush null
 
   220 print "[gold]Binding units..."
   221 printflush message1
   222 set .UNIT_P2 null
-    * set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P1 .UNIT_S2
-    * set .UNIT_S1 .UNIT_P1
+  223 set .UNIT_S2 null
+  224 set .UNIT_P1 .UNIT_P2
+  225 set .UNIT_S1 .UNIT_S2
   226 set :rebindUnits.0:count 0
-    * ubind .TYPE
+  227 ubind *tmp3
   228 set :rebindUnits.0:firstUnit @unit
   229 jump *label60 notEqual :rebindUnits.0:firstUnit null
   230 end
 
   245 label *label68
   246 label *label65
   247 label *label66
-    * ubind .TYPE
+  248 ubind *tmp3
   249 label *label63
   250 op notEqual *tmp75 @unit :rebindUnits.0:firstUnit
   251 sensor *tmp76 :rebindUnits.0:firstUnit @dead
 
   255 label *label64
   256 label *label59
   257 set :acquireUnit.0:currentUnit .UNIT_S1
-    * set :rebindUnit.0:currentUnit :acquireUnit.0:currentUnit
-    * jump *label71 equal :rebindUnit.0:currentUnit null
-    * ubind :rebindUnit.0:currentUnit
+  258 set :rebindUnit.0:currentUnit .UNIT_S1
+  259 jump *label71 equal :acquireUnit.0:currentUnit null
+  260 ubind :acquireUnit.0:currentUnit
   261 sensor *tmp83 @unit @dead
   262 op strictEqual *tmp84 *tmp83 0
   263 sensor *tmp85 @unit @controller
 
   269 label *label74
   270 label *label71
   271 label *label72
-    * ubind .TYPE
+  272 ubind *tmp3
   273 set :rebindUnit.0:firstUnit @unit
   274 jump *label75 equal :rebindUnit.0:firstUnit null
   275 label *label77
 
   278 jump *label70 always
   279 label *label80
   280 label *label81
-    * ubind .TYPE
+  281 ubind *tmp3
   282 label *label78
   283 op notEqual *tmp95 @unit :rebindUnit.0:firstUnit
   284 sensor *tmp96 :rebindUnit.0:firstUnit @dead
 
   293 ucontrol flag 1
   294 set *tmp79 @unit
   295 jump *label69 always
-    * set *tmp79 null
   296 label *label69
   297 set .UNIT_S1 *tmp79
   298 set :acquireUnit.1:currentUnit .UNIT_P1
-    * set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * jump *label84 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  299 set :rebindUnit.1:currentUnit .UNIT_P1
+  300 jump *label84 equal :acquireUnit.1:currentUnit null
+  301 ubind :acquireUnit.1:currentUnit
   302 sensor *tmp103 @unit @dead
   303 op strictEqual *tmp104 *tmp103 0
   304 sensor *tmp105 @unit @controller
 
   310 label *label87
   311 label *label84
   312 label *label85
-    * ubind .TYPE
+  313 ubind *tmp3
   314 set :rebindUnit.1:firstUnit @unit
   315 jump *label88 equal :rebindUnit.1:firstUnit null
   316 label *label90
 
   319 jump *label83 always
   320 label *label93
   321 label *label94
-    * ubind .TYPE
+  322 ubind *tmp3
   323 label *label91
   324 op notEqual *tmp115 @unit :rebindUnit.1:firstUnit
   325 sensor *tmp116 :rebindUnit.1:firstUnit @dead
 
   334 ucontrol flag 1
   335 set *tmp99 @unit
   336 jump *label82 always
-    * set *tmp99 null
   337 label *label82
   338 set .UNIT_P1 *tmp99
-    * sensor *tmp119 .UNIT_S1 @firstItem
+  339 sensor *tmp119 *tmp79 @firstItem
   340 op equal *tmp120 *tmp119 @phase-fabric
-    * sensor *tmp121 .UNIT_P1 @firstItem
+  341 sensor *tmp121 *tmp99 @firstItem
   342 op equal *tmp122 *tmp121 @silicon
   343 op or *tmp123 *tmp120 *tmp122
   344 jump *label95 equal *tmp123 false
-    * set :u .UNIT_S1
-    * set .UNIT_S1 .UNIT_P1
+  345 set :u *tmp79
+  346 set .UNIT_S1 *tmp99
   347 set .UNIT_P1 :u
   348 label *label95
   349 label *label96
 
   371 op sub *tmp141 .DOME_Y .CORE_Y
   372 op len *tmp142 *tmp140 *tmp141
   373 op mul *tmp143 2 *tmp142
-    * sensor *tmp144 :needsFourUnits.2:unit @speed
-    * op div :needsFourUnits.2:travel_time *tmp143 *tmp144
+  374 sensor *tmp144 .UNIT_S1 @speed
+  375 op div :needsFourUnits.2:travel_time *tmp143 .SPEED
   376 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   377 jump *label102 always
-    * set *tmp139 null
   378 label *label102
   379 set .FOUR_UNITS *tmp139
-    * jump *label103 equal .FOUR_UNITS false
+  380 jump *label103 equal *tmp139 false
   381 set :acquireUnit.2:currentUnit .UNIT_S2
-    * set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * jump *label107 equal :rebindUnit.2:currentUnit null
-    * ubind :rebindUnit.2:currentUnit
+  382 set :rebindUnit.2:currentUnit .UNIT_S2
+  383 jump *label107 equal :acquireUnit.2:currentUnit null
+  384 ubind :acquireUnit.2:currentUnit
   385 sensor *tmp152 @unit @dead
   386 op strictEqual *tmp153 *tmp152 0
   387 sensor *tmp154 @unit @controller
 
   393 label *label110
   394 label *label107
   395 label *label108
-    * ubind .TYPE
+  396 ubind *tmp3
   397 set :rebindUnit.2:firstUnit @unit
   398 jump *label111 equal :rebindUnit.2:firstUnit null
   399 label *label113
 
   402 jump *label106 always
   403 label *label116
   404 label *label117
-    * ubind .TYPE
+  405 ubind *tmp3
   406 label *label114
   407 op notEqual *tmp164 @unit :rebindUnit.2:firstUnit
   408 sensor *tmp165 :rebindUnit.2:firstUnit @dead
 
   417 ucontrol flag 1
   418 set *tmp148 @unit
   419 jump *label105 always
-    * set *tmp148 null
   420 label *label105
   421 set .UNIT_S2 *tmp148
   422 set :acquireUnit.3:currentUnit .UNIT_P2
-    * set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * jump *label120 equal :rebindUnit.3:currentUnit null
-    * ubind :rebindUnit.3:currentUnit
+  423 set :rebindUnit.3:currentUnit .UNIT_P2
+  424 jump *label120 equal :acquireUnit.3:currentUnit null
+  425 ubind :acquireUnit.3:currentUnit
   426 sensor *tmp172 @unit @dead
   427 op strictEqual *tmp173 *tmp172 0
   428 sensor *tmp174 @unit @controller
 
   434 label *label123
   435 label *label120
   436 label *label121
-    * ubind .TYPE
+  437 ubind *tmp3
   438 set :rebindUnit.3:firstUnit @unit
   439 jump *label124 equal :rebindUnit.3:firstUnit null
   440 label *label126
 
   443 jump *label119 always
   444 label *label129
   445 label *label130
-    * ubind .TYPE
+  446 ubind *tmp3
   447 label *label127
   448 op notEqual *tmp184 @unit :rebindUnit.3:firstUnit
   449 sensor *tmp185 :rebindUnit.3:firstUnit @dead
 
   458 ucontrol flag 1
   459 set *tmp168 @unit
   460 jump *label118 always
-    * set *tmp168 null
   461 label *label118
   462 set .UNIT_P2 *tmp168
   463 sensor *tmp188 .UNIT_S1 @firstItem
   464 op equal *tmp189 *tmp188 @phase-fabric
-    * sensor *tmp190 .UNIT_P2 @firstItem
+  465 sensor *tmp190 *tmp168 @firstItem
   466 op notEqual *tmp191 *tmp190 @phase-fabric
   467 op land *tmp192 *tmp189 *tmp191
   468 jump *label131 equal *tmp192 false
   469 set :u .UNIT_S1
-    * set .UNIT_S1 .UNIT_P2
+  470 set .UNIT_S1 *tmp168
   471 set .UNIT_P2 :u
   472 label *label131
   473 label *label132
-    * sensor *tmp194 .UNIT_S2 @firstItem
+  474 sensor *tmp194 *tmp148 @firstItem
   475 op equal *tmp195 *tmp194 @phase-fabric
   476 sensor *tmp196 .UNIT_P2 @firstItem
   477 op equal *tmp197 *tmp196 @silicon
   478 op or *tmp198 *tmp195 *tmp197
   479 jump *label133 equal *tmp198 false
-    * set :u .UNIT_S2
+  480 set :u *tmp148
   481 set .UNIT_S2 .UNIT_P2
   482 set .UNIT_P2 :u
   483 label *label133
 
   495 set .GROUP1 "unit"
   496 set .GROUP2 ""
   497 label *label104
-    * op equal *tmp200 .FOUR_UNITS false
+  498 op equal *tmp200 *tmp139 false
   499 sensor *tmp201 .UNIT_S1 @totalItems
   500 sensor *tmp202 .UNIT_S2 @totalItems
   501 op lessThan *tmp203 *tmp201 *tmp202
   502 op or .SUPPLY_S_FIRST *tmp200 *tmp203
-    * op equal *tmp205 .FOUR_UNITS false
+  503 op equal *tmp205 *tmp139 false
   504 sensor *tmp206 .UNIT_P1 @totalItems
   505 sensor *tmp207 .UNIT_P2 @totalItems
   506 op lessThan *tmp208 *tmp206 *tmp207
-    * op or .SUPPLY_P_FIRST *tmp205 *tmp208
+  507 op or .SUPPLY_P_FIRST *tmp200 *tmp208
   508 op add :unitCheck @time 5000
   509 label *label135
   510 sensor *tmp211 switch1 @enabled
 
   514 print "\n"
   515 print "\n"
   516 print "Unit type: [green]"
-    * print .TYPE
+  517 print *tmp3
   518 print "["
   519 print "]"
   520 print "\n"
   521 set :printDomeStatus.0:item @silicon
   522 set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
-    * print :printDomeStatus.0:text
-    * sensor :printDomeStatus.0:level .DOME :printDomeStatus.0:item
+  523 print "\n[green]Silicon[] status:\n"
+  524 sensor :printDomeStatus.0:level .DOME @silicon
   525 jump *label139 lessThanEq :printDomeStatus.0:level 3
   526 print "  dome:  [green]"
   527 print :printDomeStatus.0:level
 
   541 set :processUnit.0:item @silicon
   542 set :processUnit.0:group .GROUP1
   543 set :processUnit.0:supply .SUPPLY_S_FIRST
-    * set :rebindUnit.4:currentUnit :processUnit.0:unit
-    * jump *label143 equal :rebindUnit.4:currentUnit null
-    * ubind :rebindUnit.4:currentUnit
+  544 set :rebindUnit.4:currentUnit .UNIT_S1
+  545 jump *label143 equal :processUnit.0:unit null
+  546 ubind :processUnit.0:unit
   547 sensor *tmp221 @unit @dead
   548 op strictEqual *tmp222 *tmp221 0
   549 sensor *tmp223 @unit @controller
 
   555 label *label146
   556 label *label143
   557 label *label144
-    * ubind .TYPE
+  558 ubind *tmp3
   559 set :rebindUnit.4:firstUnit @unit
   560 jump *label147 equal :rebindUnit.4:firstUnit null
   561 label *label149
 
   564 jump *label142 always
   565 label *label152
   566 label *label153
-    * ubind .TYPE
+  567 ubind *tmp3
   568 label *label150
   569 op notEqual *tmp233 @unit :rebindUnit.4:firstUnit
   570 sensor *tmp234 :rebindUnit.4:firstUnit @dead
 
   585 op or *tmp240 *tmp238 *tmp239
   586 jump *label154 equal *tmp240 false
   587 sensor *tmp242 @unit @firstItem
-    * jump *label156 notEqual *tmp242 :processUnit.0:item
+  588 jump *label156 notEqual *tmp242 @silicon
   589 set :processUnit.0:state 3
   590 jump *label157 always
   591 label *label156
 
   608 jump *label162 notEqual :processUnit.0:state 2
   609 ucontrol within .CORE_X .CORE_Y 8 *tmp252
   610 jump *label164 equal *tmp252 false
-    * ucontrol itemTake .CORE :processUnit.0:item .UNIT_CAPACITY
+  611 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   612 sensor *tmp254 @unit @totalItems
   613 jump *label166 lessThan *tmp254 .UNIT_CAPACITY
   614 ucontrol approach .DOME_X .DOME_Y 6
 
   634 jump *label168 notEqual :processUnit.0:state 3
   635 ucontrol within .DOME_X .DOME_Y 8 *tmp266
   636 jump *label170 equal *tmp266 false
-    * jump *label172 equal :processUnit.0:supply false
+  637 jump *label172 equal .SUPPLY_S_FIRST false
   638 ucontrol itemDrop .DOME .UNIT_CAPACITY
   639 set :processUnit.0:msg ", supplying\n"
   640 jump *label173 always
 
   665 ucontrol flag :processUnit.0:state
   666 sensor *tmp279 @unit @totalItems
   667 print "  "
-    * print :processUnit.0:group
+  668 print .GROUP1
   669 print ":"
   670 print " ["
-    * print :processUnit.0:color
+  671 print "gold"
   672 print "]"
   673 print *tmp279
   674 print "["
 
   685 label *label177
   686 set *tmp217 @unit
   687 jump *label141 always
-    * set *tmp217 null
   688 label *label141
   689 set .UNIT_S1 *tmp217
-    * jump *label178 equal .FOUR_UNITS false
+  690 jump *label178 equal *tmp139 false
   691 op equal *tmp283 .SUPPLY_S_FIRST false
   692 set :processUnit.1:unit .UNIT_S2
   693 set :processUnit.1:item @silicon
   694 set :processUnit.1:group .GROUP2
   695 set :processUnit.1:supply *tmp283
-    * set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * jump *label182 equal :rebindUnit.5:currentUnit null
-    * ubind :rebindUnit.5:currentUnit
+  696 set :rebindUnit.5:currentUnit .UNIT_S2
+  697 jump *label182 equal :processUnit.1:unit null
+  698 ubind :processUnit.1:unit
   699 sensor *tmp288 @unit @dead
   700 op strictEqual *tmp289 *tmp288 0
   701 sensor *tmp290 @unit @controller
 
   707 label *label185
   708 label *label182
   709 label *label183
-    * ubind .TYPE
+  710 ubind *tmp3
   711 set :rebindUnit.5:firstUnit @unit
   712 jump *label186 equal :rebindUnit.5:firstUnit null
   713 label *label188
 
   716 jump *label181 always
   717 label *label191
   718 label *label192
-    * ubind .TYPE
+  719 ubind *tmp3
   720 label *label189
   721 op notEqual *tmp300 @unit :rebindUnit.5:firstUnit
   722 sensor *tmp301 :rebindUnit.5:firstUnit @dead
 
   737 op or *tmp307 *tmp305 *tmp306
   738 jump *label193 equal *tmp307 false
   739 sensor *tmp309 @unit @firstItem
-    * jump *label195 notEqual *tmp309 :processUnit.1:item
+  740 jump *label195 notEqual *tmp309 @silicon
   741 set :processUnit.1:state 3
   742 jump *label196 always
   743 label *label195
 
   760 jump *label201 notEqual :processUnit.1:state 2
   761 ucontrol within .CORE_X .CORE_Y 8 *tmp319
   762 jump *label203 equal *tmp319 false
-    * ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
+  763 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   764 sensor *tmp321 @unit @totalItems
   765 jump *label205 lessThan *tmp321 .UNIT_CAPACITY
   766 ucontrol approach .DOME_X .DOME_Y 6
 
   786 jump *label207 notEqual :processUnit.1:state 3
   787 ucontrol within .DOME_X .DOME_Y 8 *tmp333
   788 jump *label209 equal *tmp333 false
-    * jump *label211 equal :processUnit.1:supply false
+  789 jump *label211 equal *tmp283 false
   790 ucontrol itemDrop .DOME .UNIT_CAPACITY
   791 set :processUnit.1:msg ", supplying\n"
   792 jump *label212 always
 
   817 ucontrol flag :processUnit.1:state
   818 sensor *tmp346 @unit @totalItems
   819 print "  "
-    * print :processUnit.1:group
+  820 print .GROUP2
   821 print ":"
   822 print " ["
-    * print :processUnit.1:color
+  823 print "gold"
   824 print "]"
   825 print *tmp346
   826 print "["
 
   837 label *label216
   838 set *tmp284 @unit
   839 jump *label180 always
-    * set *tmp284 null
   840 label *label180
   841 set .UNIT_S2 *tmp284
   842 jump *label217 equal .SUPPLY_S_FIRST false
-    * sensor *tmp350 .UNIT_S1 @totalItems
+  843 sensor *tmp350 *tmp217 @totalItems
   844 op greaterThan *tmp349 *tmp350 0
   845 jump *label218 always
   846 label *label217
-    * sensor *tmp352 .UNIT_S2 @totalItems
+  847 sensor *tmp352 *tmp284 @totalItems
   848 op equal *tmp349 *tmp352 0
   849 label *label218
   850 set .SUPPLY_S_FIRST *tmp349
 
   852 label *label179
   853 set :printDomeStatus.1:item @phase-fabric
   854 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
-    * print :printDomeStatus.1:text
-    * sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
+  855 print "\n[green]Phase fabric[] status:\n"
+  856 sensor :printDomeStatus.1:level .DOME @phase-fabric
   857 jump *label220 lessThanEq :printDomeStatus.1:level 3
   858 print "  dome:  [green]"
   859 print :printDomeStatus.1:level
 
   873 set :processUnit.2:item @phase-fabric
   874 set :processUnit.2:group .GROUP1
   875 set :processUnit.2:supply .SUPPLY_P_FIRST
-    * set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * jump *label224 equal :rebindUnit.6:currentUnit null
-    * ubind :rebindUnit.6:currentUnit
+  876 set :rebindUnit.6:currentUnit .UNIT_P1
+  877 jump *label224 equal :processUnit.2:unit null
+  878 ubind :processUnit.2:unit
   879 sensor *tmp362 @unit @dead
   880 op strictEqual *tmp363 *tmp362 0
   881 sensor *tmp364 @unit @controller
 
   887 label *label227
   888 label *label224
   889 label *label225
-    * ubind .TYPE
+  890 ubind *tmp3
   891 set :rebindUnit.6:firstUnit @unit
   892 jump *label228 equal :rebindUnit.6:firstUnit null
   893 label *label230
 
   896 jump *label223 always
   897 label *label233
   898 label *label234
-    * ubind .TYPE
+  899 ubind *tmp3
   900 label *label231
   901 op notEqual *tmp374 @unit :rebindUnit.6:firstUnit
   902 sensor *tmp375 :rebindUnit.6:firstUnit @dead
 
   917 op or *tmp381 *tmp379 *tmp380
   918 jump *label235 equal *tmp381 false
   919 sensor *tmp383 @unit @firstItem
-    * jump *label237 notEqual *tmp383 :processUnit.2:item
+  920 jump *label237 notEqual *tmp383 @phase-fabric
   921 set :processUnit.2:state 3
   922 jump *label238 always
   923 label *label237
 
   940 jump *label243 notEqual :processUnit.2:state 2
   941 ucontrol within .CORE_X .CORE_Y 8 *tmp393
   942 jump *label245 equal *tmp393 false
-    * ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
+  943 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
   944 sensor *tmp395 @unit @totalItems
   945 jump *label247 lessThan *tmp395 .UNIT_CAPACITY
   946 ucontrol approach .DOME_X .DOME_Y 6
 
   966 jump *label249 notEqual :processUnit.2:state 3
   967 ucontrol within .DOME_X .DOME_Y 8 *tmp407
   968 jump *label251 equal *tmp407 false
-    * jump *label253 equal :processUnit.2:supply false
+  969 jump *label253 equal .SUPPLY_P_FIRST false
   970 ucontrol itemDrop .DOME .UNIT_CAPACITY
   971 set :processUnit.2:msg ", supplying\n"
   972 jump *label254 always
 
   997 ucontrol flag :processUnit.2:state
   998 sensor *tmp420 @unit @totalItems
   999 print "  "
-    * print :processUnit.2:group
+ 1000 print .GROUP1
  1001 print ":"
  1002 print " ["
-    * print :processUnit.2:color
+ 1003 print "gold"
  1004 print "]"
  1005 print *tmp420
  1006 print "["
 
  1017 label *label258
  1018 set *tmp358 @unit
  1019 jump *label222 always
-    * set *tmp358 null
  1020 label *label222
  1021 set .UNIT_P1 *tmp358
-    * jump *label259 equal .FOUR_UNITS false
+ 1022 jump *label259 equal *tmp139 false
  1023 op equal *tmp424 .SUPPLY_P_FIRST false
  1024 set :processUnit.3:unit .UNIT_P2
  1025 set :processUnit.3:item @phase-fabric
  1026 set :processUnit.3:group .GROUP2
  1027 set :processUnit.3:supply *tmp424
-    * set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * jump *label263 equal :rebindUnit.7:currentUnit null
-    * ubind :rebindUnit.7:currentUnit
+ 1028 set :rebindUnit.7:currentUnit .UNIT_P2
+ 1029 jump *label263 equal :processUnit.3:unit null
+ 1030 ubind :processUnit.3:unit
  1031 sensor *tmp429 @unit @dead
  1032 op strictEqual *tmp430 *tmp429 0
  1033 sensor *tmp431 @unit @controller
 
  1039 label *label266
  1040 label *label263
  1041 label *label264
-    * ubind .TYPE
+ 1042 ubind *tmp3
  1043 set :rebindUnit.7:firstUnit @unit
  1044 jump *label267 equal :rebindUnit.7:firstUnit null
  1045 label *label269
 
  1048 jump *label262 always
  1049 label *label272
  1050 label *label273
-    * ubind .TYPE
+ 1051 ubind *tmp3
  1052 label *label270
  1053 op notEqual *tmp441 @unit :rebindUnit.7:firstUnit
  1054 sensor *tmp442 :rebindUnit.7:firstUnit @dead
 
  1069 op or *tmp448 *tmp446 *tmp447
  1070 jump *label274 equal *tmp448 false
  1071 sensor *tmp450 @unit @firstItem
-    * jump *label276 notEqual *tmp450 :processUnit.3:item
+ 1072 jump *label276 notEqual *tmp450 @phase-fabric
  1073 set :processUnit.3:state 3
  1074 jump *label277 always
  1075 label *label276
 
  1092 jump *label282 notEqual :processUnit.3:state 2
  1093 ucontrol within .CORE_X .CORE_Y 8 *tmp460
  1094 jump *label284 equal *tmp460 false
-    * ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
+ 1095 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1096 sensor *tmp462 @unit @totalItems
  1097 jump *label286 lessThan *tmp462 .UNIT_CAPACITY
  1098 ucontrol approach .DOME_X .DOME_Y 6
 
  1118 jump *label288 notEqual :processUnit.3:state 3
  1119 ucontrol within .DOME_X .DOME_Y 8 *tmp474
  1120 jump *label290 equal *tmp474 false
-    * jump *label292 equal :processUnit.3:supply false
+ 1121 jump *label292 equal *tmp424 false
  1122 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1123 set :processUnit.3:msg ", supplying\n"
  1124 jump *label293 always
 
  1149 ucontrol flag :processUnit.3:state
  1150 sensor *tmp487 @unit @totalItems
  1151 print "  "
-    * print :processUnit.3:group
+ 1152 print .GROUP2
  1153 print ":"
  1154 print " ["
-    * print :processUnit.3:color
+ 1155 print "gold"
  1156 print "]"
  1157 print *tmp487
  1158 print "["
 
  1169 label *label297
  1170 set *tmp425 @unit
  1171 jump *label261 always
-    * set *tmp425 null
  1172 label *label261
  1173 set .UNIT_P2 *tmp425
  1174 jump *label298 equal .SUPPLY_P_FIRST false
-    * sensor *tmp491 .UNIT_P1 @totalItems
+ 1175 sensor *tmp491 *tmp358 @totalItems
  1176 op greaterThan *tmp490 *tmp491 0
  1177 jump *label299 always
  1178 label *label298
-    * sensor *tmp493 .UNIT_P2 @totalItems
+ 1179 sensor *tmp493 *tmp425 @totalItems
  1180 op equal *tmp490 *tmp493 0
  1181 label *label299
  1182 set .SUPPLY_P_FIRST *tmp490
 
  1190 print " "
  1191 print "ms"
  1192 printflush message1
-    * op notEqual *tmp497 .TYPE UNIT_TYPE
+ 1193 op notEqual *tmp497 *tmp3 UNIT_TYPE
  1194 op greaterThan *tmp498 :unitCheck @time
  1195 op land *tmp499 *tmp497 *tmp498
  1196 jump *label300 equal *tmp499 false
  1197 set :areUnitsAvailable.2:type UNIT_TYPE
  1198 set :areUnitsAvailable.2:output false
  1199 set :areUnitsAvailable.2:needed 0
-    * set :areUnitsAvailable.2:occupied :areUnitsAvailable.2:needed
-    * set :areUnitsAvailable.2:free :areUnitsAvailable.2:occupied
-    * ubind :areUnitsAvailable.2:type
+ 1200 set :areUnitsAvailable.2:occupied 0
+ 1201 set :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1202 ubind UNIT_TYPE
  1203 set :areUnitsAvailable.2:firstUnit @unit
  1204 jump *label303 equal :areUnitsAvailable.2:firstUnit null
  1205 set :needsFourUnits.3:unit @unit
  1206 op sub *tmp506 .DOME_X .CORE_X
  1207 op sub *tmp507 .DOME_Y .CORE_Y
-    * op len *tmp508 *tmp506 *tmp507
-    * op mul *tmp509 2 *tmp508
+ 1208 op len *tmp508 *tmp140 *tmp141
+ 1209 op mul *tmp509 2 *tmp142
  1210 sensor *tmp510 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp509 *tmp510
+ 1211 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1212 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1213 jump *label305 always
-    * set *tmp505 null
  1214 label *label305
  1215 jump *label306 equal *tmp505 false
  1216 set *tmp513 4
 
  1227 op or *tmp518 *tmp515 *tmp517
  1228 jump *label311 equal *tmp518 false
  1229 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label313 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1230 jump *label313 lessThan :areUnitsAvailable.2:free *tmp513
  1231 set *tmp501 true
  1232 jump *label302 always
  1233 label *label313
 
  1236 label *label311
  1237 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1238 label *label312
-    * ubind :areUnitsAvailable.2:type
+ 1239 ubind UNIT_TYPE
  1240 label *label309
  1241 op notEqual *tmp522 @unit :areUnitsAvailable.2:firstUnit
  1242 sensor *tmp523 :areUnitsAvailable.2:firstUnit @dead
 
  1246 label *label310
  1247 label *label303
  1248 label *label304
-    * jump *label315 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+ 1249 jump *label315 equal false false
+ 1250 print UNIT_TYPE
  1251 print ":"
  1252 print " occupied: "
  1253 print :areUnitsAvailable.2:occupied
 
  1264 label *label316
  1265 set *tmp501 false
  1266 jump *label302 always
-    * set *tmp501 null
  1267 label *label302
  1268 jump *label319 equal *tmp501 false
  1269 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-42 instructions):
 
     3 remark "Do not modify anything below this line."
     4 set .DOME_Y null
     5 set .DOME_X null
-    * set .CORE_Y .DOME_Y
-    * set .CORE_X .DOME_X
+    6 set .CORE_Y null
+    7 set .CORE_X null
     8 set .DOME dome1
     9 label *label0
    10 jump *label2 notEqual .DOME null
 
    29 print "\n"
    30 remark "chooseUnitType: "
    31 remark UNIT_TYPE
-    * set :areUnitsAvailable.0:type UNIT_TYPE
-    * set :areUnitsAvailable.0:output true
    32 set :areUnitsAvailable.0:needed 0
    33 set :areUnitsAvailable.0:occupied 0
-    * set :areUnitsAvailable.0:free :areUnitsAvailable.0:needed
+   34 set :areUnitsAvailable.0:free 0
    35 ubind UNIT_TYPE
    36 set :areUnitsAvailable.0:firstUnit @unit
    37 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    38 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 .DOME_Y .CORE_Y
-    * op sub *tmp10 null .DOME_X
-    * op len *tmp11 *tmp9 *tmp10
+   39 op sub *tmp9 null .DOME_Y
+   40 op sub *tmp10 null null
+   41 op len *tmp11 *tmp9 0
    42 op mul *tmp12 2 *tmp11
    43 sensor *tmp13 :needsFourUnits.0:unit @speed
    44 op div :needsFourUnits.0:travel_time *tmp12 *tmp13
 
   124 jump *label38 equal :chooseUnitType.0:type UNIT_TYPE
   125 remark "chooseUnitType: "
   126 remark :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:type :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:output true
   127 set :areUnitsAvailable.1:needed 0
   128 set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  129 set :areUnitsAvailable.1:free 0
   130 ubind :chooseUnitType.0:type
   131 set :areUnitsAvailable.1:firstUnit @unit
   132 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   133 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 .DOME_Y .CORE_Y
-    * op sub *tmp42 null .DOME_X
-    * op len *tmp43 *tmp41 *tmp42
+  134 op sub *tmp41 null .DOME_Y
+  135 op sub *tmp42 null null
+  136 op len *tmp43 *tmp41 0
   137 op mul *tmp44 2 *tmp43
   138 sensor *tmp45 :needsFourUnits.1:unit @speed
   139 op div :needsFourUnits.1:travel_time *tmp44 *tmp45
 
   212 label *label9
   213 set *tmp3 null
   214 label *label6
-    * set .TYPE *tmp3
   215 print "[gold]Binding units..."
   216 printflush message1
   217 set .UNIT_P2 null
   218 set .UNIT_S2 null
-    * set .UNIT_P1 .UNIT_P2
-    * set .UNIT_S1 .UNIT_S2
+  219 set .UNIT_P1 null
+  220 set .UNIT_S1 null
   221 set :rebindUnits.0:count 0
   222 ubind *tmp3
   223 set :rebindUnits.0:firstUnit @unit
 
   250 label *label64
   251 label *label59
   252 set :acquireUnit.0:currentUnit .UNIT_S1
-    * set :rebindUnit.0:currentUnit .UNIT_S1
-    * jump *label71 equal :acquireUnit.0:currentUnit null
-    * ubind :acquireUnit.0:currentUnit
+  253 jump *label71 equal .UNIT_S1 null
+  254 ubind .UNIT_S1
   255 sensor *tmp83 @unit @dead
   256 op strictEqual *tmp84 *tmp83 0
   257 sensor *tmp85 @unit @controller
 
   290 label *label69
   291 set .UNIT_S1 *tmp79
   292 set :acquireUnit.1:currentUnit .UNIT_P1
-    * set :rebindUnit.1:currentUnit .UNIT_P1
-    * jump *label84 equal :acquireUnit.1:currentUnit null
-    * ubind :acquireUnit.1:currentUnit
+  293 jump *label84 equal .UNIT_P1 null
+  294 ubind .UNIT_P1
   295 sensor *tmp103 @unit @dead
   296 op strictEqual *tmp104 *tmp103 0
   297 sensor *tmp105 @unit @controller
 
   337 jump *label95 equal *tmp123 false
   338 set :u *tmp79
   339 set .UNIT_S1 *tmp99
-    * set .UNIT_P1 :u
+  340 set .UNIT_P1 *tmp79
   341 label *label95
   342 label *label96
   343 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   359 sensor .CORE_Y .CORE @y
   360 sensor .DOME_X .DOME @x
   361 sensor .DOME_Y .DOME @y
-    * set :needsFourUnits.2:unit .UNIT_S1
   362 op sub *tmp140 .DOME_X .CORE_X
   363 op sub *tmp141 .DOME_Y .CORE_Y
   364 op len *tmp142 *tmp140 *tmp141
 
   368 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   369 jump *label102 always
   370 label *label102
-    * set .FOUR_UNITS *tmp139
   371 jump *label103 equal *tmp139 false
   372 set :acquireUnit.2:currentUnit .UNIT_S2
-    * set :rebindUnit.2:currentUnit .UNIT_S2
-    * jump *label107 equal :acquireUnit.2:currentUnit null
-    * ubind :acquireUnit.2:currentUnit
+  373 jump *label107 equal .UNIT_S2 null
+  374 ubind .UNIT_S2
   375 sensor *tmp152 @unit @dead
   376 op strictEqual *tmp153 *tmp152 0
   377 sensor *tmp154 @unit @controller
 
   410 label *label105
   411 set .UNIT_S2 *tmp148
   412 set :acquireUnit.3:currentUnit .UNIT_P2
-    * set :rebindUnit.3:currentUnit .UNIT_P2
-    * jump *label120 equal :acquireUnit.3:currentUnit null
-    * ubind :acquireUnit.3:currentUnit
+  413 jump *label120 equal .UNIT_P2 null
+  414 ubind .UNIT_P2
   415 sensor *tmp172 @unit @dead
   416 op strictEqual *tmp173 *tmp172 0
   417 sensor *tmp174 @unit @controller
 
   468 jump *label133 equal *tmp198 false
   469 set :u *tmp148
   470 set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P2 :u
+  471 set .UNIT_P2 *tmp148
   472 label *label133
   473 label *label134
   474 set .GROUP1 "unit  1"
 
   489 sensor *tmp202 .UNIT_S2 @totalItems
   490 op lessThan *tmp203 *tmp201 *tmp202
   491 op or .SUPPLY_S_FIRST *tmp200 *tmp203
-    * op equal *tmp205 *tmp139 false
   492 sensor *tmp206 .UNIT_P1 @totalItems
   493 sensor *tmp207 .UNIT_P2 @totalItems
   494 op lessThan *tmp208 *tmp206 *tmp207
 
   506 print "["
   507 print "]"
   508 print "\n"
-    * set :printDomeStatus.0:item @silicon
-    * set :printDomeStatus.0:text "\n[green]Silicon[] status:\n"
   509 print "\n[green]Silicon[] status:\n"
   510 sensor :printDomeStatus.0:level .DOME @silicon
   511 jump *label139 lessThanEq :printDomeStatus.0:level 3
 
   524 label *label140
   525 label *label138
   526 set :processUnit.0:unit .UNIT_S1
-    * set :processUnit.0:item @silicon
-    * set :processUnit.0:group .GROUP1
-    * set :processUnit.0:supply .SUPPLY_S_FIRST
-    * set :rebindUnit.4:currentUnit .UNIT_S1
-    * jump *label143 equal :processUnit.0:unit null
-    * ubind :processUnit.0:unit
+  527 jump *label143 equal .UNIT_S1 null
+  528 ubind .UNIT_S1
   529 sensor *tmp221 @unit @dead
   530 op strictEqual *tmp222 *tmp221 0
   531 sensor *tmp223 @unit @controller
 
   561 set :processUnit.0:msg ""
   562 sensor :processUnit.0:state @unit @flag
   563 set :processUnit.0:distance -1
-    * set :processUnit.0:color "gold"
   564 op lessThan *tmp238 :processUnit.0:state 2
   565 op greaterThan *tmp239 :processUnit.0:state 3
   566 op or *tmp240 *tmp238 *tmp239
 
   671 jump *label178 equal *tmp139 false
   672 op equal *tmp283 .SUPPLY_S_FIRST false
   673 set :processUnit.1:unit .UNIT_S2
-    * set :processUnit.1:item @silicon
-    * set :processUnit.1:group .GROUP2
-    * set :processUnit.1:supply *tmp283
-    * set :rebindUnit.5:currentUnit .UNIT_S2
-    * jump *label182 equal :processUnit.1:unit null
-    * ubind :processUnit.1:unit
+  674 jump *label182 equal .UNIT_S2 null
+  675 ubind .UNIT_S2
   676 sensor *tmp288 @unit @dead
   677 op strictEqual *tmp289 *tmp288 0
   678 sensor *tmp290 @unit @controller
 
   708 set :processUnit.1:msg ""
   709 sensor :processUnit.1:state @unit @flag
   710 set :processUnit.1:distance -1
-    * set :processUnit.1:color "gold"
   711 op lessThan *tmp305 :processUnit.1:state 2
   712 op greaterThan *tmp306 :processUnit.1:state 3
   713 op or *tmp307 *tmp305 *tmp306
 
   826 set .SUPPLY_S_FIRST *tmp349
   827 label *label178
   828 label *label179
-    * set :printDomeStatus.1:item @phase-fabric
-    * set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   829 print "\n[green]Phase fabric[] status:\n"
   830 sensor :printDomeStatus.1:level .DOME @phase-fabric
   831 jump *label220 lessThanEq :printDomeStatus.1:level 3
 
   844 label *label221
   845 label *label219
   846 set :processUnit.2:unit .UNIT_P1
-    * set :processUnit.2:item @phase-fabric
-    * set :processUnit.2:group .GROUP1
-    * set :processUnit.2:supply .SUPPLY_P_FIRST
-    * set :rebindUnit.6:currentUnit .UNIT_P1
-    * jump *label224 equal :processUnit.2:unit null
-    * ubind :processUnit.2:unit
+  847 jump *label224 equal .UNIT_P1 null
+  848 ubind .UNIT_P1
   849 sensor *tmp362 @unit @dead
   850 op strictEqual *tmp363 *tmp362 0
   851 sensor *tmp364 @unit @controller
 
   881 set :processUnit.2:msg ""
   882 sensor :processUnit.2:state @unit @flag
   883 set :processUnit.2:distance -1
-    * set :processUnit.2:color "gold"
   884 op lessThan *tmp379 :processUnit.2:state 2
   885 op greaterThan *tmp380 :processUnit.2:state 3
   886 op or *tmp381 *tmp379 *tmp380
 
   991 jump *label259 equal *tmp139 false
   992 op equal *tmp424 .SUPPLY_P_FIRST false
   993 set :processUnit.3:unit .UNIT_P2
-    * set :processUnit.3:item @phase-fabric
-    * set :processUnit.3:group .GROUP2
-    * set :processUnit.3:supply *tmp424
-    * set :rebindUnit.7:currentUnit .UNIT_P2
-    * jump *label263 equal :processUnit.3:unit null
-    * ubind :processUnit.3:unit
+  994 jump *label263 equal .UNIT_P2 null
+  995 ubind .UNIT_P2
   996 sensor *tmp429 @unit @dead
   997 op strictEqual *tmp430 *tmp429 0
   998 sensor *tmp431 @unit @controller
 
  1028 set :processUnit.3:msg ""
  1029 sensor :processUnit.3:state @unit @flag
  1030 set :processUnit.3:distance -1
-    * set :processUnit.3:color "gold"
  1031 op lessThan *tmp446 :processUnit.3:state 2
  1032 op greaterThan *tmp447 :processUnit.3:state 3
  1033 op or *tmp448 *tmp446 *tmp447
 
  1158 op greaterThan *tmp498 :unitCheck @time
  1159 op land *tmp499 *tmp497 *tmp498
  1160 jump *label300 equal *tmp499 false
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
  1161 set :areUnitsAvailable.2:needed 0
  1162 set :areUnitsAvailable.2:occupied 0
-    * set :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1163 set :areUnitsAvailable.2:free 0
  1164 ubind UNIT_TYPE
  1165 set :areUnitsAvailable.2:firstUnit @unit
  1166 jump *label303 equal :areUnitsAvailable.2:firstUnit null
  1167 set :needsFourUnits.3:unit @unit
-    * op sub *tmp506 .DOME_X .CORE_X
-    * op sub *tmp507 .DOME_Y .CORE_Y
-    * op len *tmp508 *tmp140 *tmp141
-    * op mul *tmp509 2 *tmp142
  1168 sensor *tmp510 :needsFourUnits.3:unit @speed
  1169 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1170 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-15 instructions):
 
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
     4 set .DOME_Y null
-    * set .DOME_X null
-    * set .CORE_Y null
-    * set .CORE_X null
     5 set .DOME dome1
     6 label *label0
     7 jump *label2 notEqual .DOME null
 
    33 set :areUnitsAvailable.0:firstUnit @unit
    34 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    35 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 null .DOME_Y
-    * op sub *tmp10 null null
-    * op len *tmp11 *tmp9 0
-    * op mul *tmp12 2 *tmp11
+   36 op sub *tmp9 null null
+   37 op len *tmp11 0 0
+   38 op mul *tmp12 2 0
    39 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * op div :needsFourUnits.0:travel_time *tmp12 *tmp13
+   40 op div :needsFourUnits.0:travel_time 0 *tmp13
    41 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    42 jump *label13 always
    43 label *label13
 
   127 set :areUnitsAvailable.1:firstUnit @unit
   128 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   129 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 null .DOME_Y
-    * op sub *tmp42 null null
-    * op len *tmp43 *tmp41 0
-    * op mul *tmp44 2 *tmp43
+  130 op sub *tmp41 null null
+  131 op len *tmp43 0 0
+  132 op mul *tmp44 2 0
   133 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp44 *tmp45
+  134 op div :needsFourUnits.1:travel_time 0 *tmp45
   135 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   136 jump *label43 always
   137 label *label43
 
   244 jump *label62 notEqual *tmp78 false
   245 label *label64
   246 label *label59
-    * set :acquireUnit.0:currentUnit .UNIT_S1
   247 jump *label71 equal .UNIT_S1 null
   248 ubind .UNIT_S1
   249 sensor *tmp83 @unit @dead
 
   283 jump *label69 always
   284 label *label69
   285 set .UNIT_S1 *tmp79
-    * set :acquireUnit.1:currentUnit .UNIT_P1
   286 jump *label84 equal .UNIT_P1 null
   287 ubind .UNIT_P1
   288 sensor *tmp103 @unit @dead
 
   328 op equal *tmp122 *tmp121 @silicon
   329 op or *tmp123 *tmp120 *tmp122
   330 jump *label95 equal *tmp123 false
-    * set :u *tmp79
   331 set .UNIT_S1 *tmp99
   332 set .UNIT_P1 *tmp79
   333 label *label95
 
   361 jump *label102 always
   362 label *label102
   363 jump *label103 equal *tmp139 false
-    * set :acquireUnit.2:currentUnit .UNIT_S2
   364 jump *label107 equal .UNIT_S2 null
   365 ubind .UNIT_S2
   366 sensor *tmp152 @unit @dead
 
   400 jump *label105 always
   401 label *label105
   402 set .UNIT_S2 *tmp148
-    * set :acquireUnit.3:currentUnit .UNIT_P2
   403 jump *label120 equal .UNIT_P2 null
   404 ubind .UNIT_P2
   405 sensor *tmp172 @unit @dead
 
   456 op equal *tmp197 *tmp196 @silicon
   457 op or *tmp198 *tmp195 *tmp197
   458 jump *label133 equal *tmp198 false
-    * set :u *tmp148
   459 set .UNIT_S2 .UNIT_P2
   460 set .UNIT_P2 *tmp148
   461 label *label133
 
   512 print "\n"
   513 label *label140
   514 label *label138
-    * set :processUnit.0:unit .UNIT_S1
   515 jump *label143 equal .UNIT_S1 null
   516 ubind .UNIT_S1
   517 sensor *tmp221 @unit @dead
 
   658 set .UNIT_S1 *tmp217
   659 jump *label178 equal *tmp139 false
   660 op equal *tmp283 .SUPPLY_S_FIRST false
-    * set :processUnit.1:unit .UNIT_S2
   661 jump *label182 equal .UNIT_S2 null
   662 ubind .UNIT_S2
   663 sensor *tmp288 @unit @dead
 
   830 print "\n"
   831 label *label221
   832 label *label219
-    * set :processUnit.2:unit .UNIT_P1
   833 jump *label224 equal .UNIT_P1 null
   834 ubind .UNIT_P1
   835 sensor *tmp362 @unit @dead
 
   976 set .UNIT_P1 *tmp358
   977 jump *label259 equal *tmp139 false
   978 op equal *tmp424 .SUPPLY_P_FIRST false
-    * set :processUnit.3:unit .UNIT_P2
   979 jump *label263 equal .UNIT_P2 null
   980 ubind .UNIT_P2
   981 sensor *tmp429 @unit @dead

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-7 instructions):
 
     1 remark "If no units of this type exist, we'll try using other types."
     2 set UNIT_TYPE @flare
     3 remark "Do not modify anything below this line."
-    * set .DOME_Y null
     4 set .DOME dome1
     5 label *label0
     6 jump *label2 notEqual .DOME null
 
    32 set :areUnitsAvailable.0:firstUnit @unit
    33 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    34 set :needsFourUnits.0:unit @unit
-    * op sub *tmp9 null null
-    * op len *tmp11 0 0
-    * op mul *tmp12 2 0
    35 sensor *tmp13 :needsFourUnits.0:unit @speed
    36 op div :needsFourUnits.0:travel_time 0 *tmp13
    37 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
 
   123 set :areUnitsAvailable.1:firstUnit @unit
   124 jump *label41 equal :areUnitsAvailable.1:firstUnit null
   125 set :needsFourUnits.1:unit @unit
-    * op sub *tmp41 null null
-    * op len *tmp43 0 0
-    * op mul *tmp44 2 0
   126 sensor *tmp45 :needsFourUnits.1:unit @speed
   127 op div :needsFourUnits.1:travel_time 0 *tmp45
   128 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     4 set .DOME dome1
     5 label *label0
     6 jump *label2 notEqual .DOME null
+    7 label *label321
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label1
-    * jump *label0 always
+   12 jump *label321 equal .DOME null
    13 label *label2
    14 label *label3
    15 sensor *tmp1 switch1 @enabled

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    32 ubind UNIT_TYPE
    33 set :areUnitsAvailable.0:firstUnit @unit
    34 jump *label11 equal :areUnitsAvailable.0:firstUnit null
+   35 set *tmp16 2
    36 set :needsFourUnits.0:unit @unit
    37 sensor *tmp13 :needsFourUnits.0:unit @speed
    38 op div :needsFourUnits.0:travel_time 0 *tmp13
    39 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    40 jump *label13 always
    41 label *label13
-    * jump *label14 equal *tmp8 false
+   42 jump *label15 equal *tmp8 false
    43 set *tmp16 4
    44 jump *label15 always
-    * label *label14
-    * set *tmp16 2
    45 label *label15
    46 set :areUnitsAvailable.0:needed *tmp16
    47 label *label16
 
   122 ubind :chooseUnitType.0:type
   123 set :areUnitsAvailable.1:firstUnit @unit
   124 jump *label41 equal :areUnitsAvailable.1:firstUnit null
+  125 set *tmp48 2
   126 set :needsFourUnits.1:unit @unit
   127 sensor *tmp45 :needsFourUnits.1:unit @speed
   128 op div :needsFourUnits.1:travel_time 0 *tmp45
   129 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   130 jump *label43 always
   131 label *label43
-    * jump *label44 equal *tmp40 false
+  132 jump *label45 equal *tmp40 false
   133 set *tmp48 4
   134 jump *label45 always
-    * label *label44
-    * set *tmp48 2
   135 label *label45
   136 set :areUnitsAvailable.1:needed *tmp48
   137 label *label46
 
   796 set .UNIT_S2 *tmp284
   797 jump *label217 equal .SUPPLY_S_FIRST false
   798 sensor *tmp350 *tmp217 @totalItems
-    * op greaterThan *tmp349 *tmp350 0
+  799 op greaterThan .SUPPLY_S_FIRST *tmp350 0
   800 jump *label218 always
   801 label *label217
   802 sensor *tmp352 *tmp284 @totalItems
-    * op equal *tmp349 *tmp352 0
+  803 op equal .SUPPLY_S_FIRST *tmp352 0
   804 label *label218
-    * set .SUPPLY_S_FIRST *tmp349
   805 label *label178
   806 label *label179
   807 print "\n[green]Phase fabric[] status:\n"
 
  1113 set .UNIT_P2 *tmp425
  1114 jump *label298 equal .SUPPLY_P_FIRST false
  1115 sensor *tmp491 *tmp358 @totalItems
-    * op greaterThan *tmp490 *tmp491 0
+ 1116 op greaterThan .SUPPLY_P_FIRST *tmp491 0
  1117 jump *label299 always
  1118 label *label298
  1119 sensor *tmp493 *tmp425 @totalItems
-    * op equal *tmp490 *tmp493 0
+ 1120 op equal .SUPPLY_P_FIRST *tmp493 0
  1121 label *label299
-    * set .SUPPLY_P_FIRST *tmp490
  1122 label *label259
  1123 label *label260
  1124 op sub *tmp495 @time :start
 
  1139 ubind UNIT_TYPE
  1140 set :areUnitsAvailable.2:firstUnit @unit
  1141 jump *label303 equal :areUnitsAvailable.2:firstUnit null
+ 1142 set *tmp513 2
  1143 set :needsFourUnits.3:unit @unit
  1144 sensor *tmp510 :needsFourUnits.3:unit @speed
  1145 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1146 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1147 jump *label305 always
  1148 label *label305
-    * jump *label306 equal *tmp505 false
+ 1149 jump *label307 equal *tmp505 false
  1150 set *tmp513 4
  1151 jump *label307 always
-    * label *label306
-    * set *tmp513 2
  1152 label *label307
  1153 set :areUnitsAvailable.2:needed *tmp513
  1154 label *label308

Modifications by Replicate loop condition at line 44:1 (+1 instructions):
 
    14 label *label3
    15 sensor *tmp1 switch1 @enabled
    16 jump *label5 notEqual *tmp1 false
+   17 label *label322
    18 print "[coral]Activate switch to begin supplying overdrive dome..."
    19 print "\n"
    20 printflush message1
    21 label *label4
-    * jump *label3 always
+   22 sensor *tmp1 switch1 @enabled
+   23 jump *label322 equal *tmp1 false
    24 label *label5
    25 label *label7
    26 printflush null

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     3 remark "Do not modify anything below this line."
     4 set .DOME dome1
     5 label *label0
-    * jump *label2 notEqual .DOME null
+    6 jump *label2 notEqual dome1 null
     7 label *label321
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
    11 label *label1
-    * jump *label321 equal .DOME null
+   12 jump *label321 equal dome1 null
    13 label *label2
    14 label *label3
    15 sensor *tmp1 switch1 @enabled

Modifications by Replicate loop condition at line 127:1 (+1 instructions):
 
   480 label *label135
   481 sensor *tmp211 switch1 @enabled
   482 jump *label137 equal *tmp211 false
+  483 label *label323
   484 set :start @time
   485 print " === [gold]Supplying Overdrive Dome[] === "
   486 print "\n"
 
  1208 label *label300
  1209 label *label301
  1210 label *label136
-    * jump *label135 always
+ 1211 sensor *tmp211 switch1 @enabled
+ 1212 jump *label323 notEqual *tmp211 false
  1213 label *label137
  1214 end

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
    73 label *label18
    74 label *label11
    75 label *label12
-    * jump *label23 equal true false
    76 print UNIT_TYPE
    77 print ":"
    78 print " occupied: "
 
   162 label *label48
   163 label *label41
   164 label *label42
-    * jump *label53 equal true false
   165 print :chooseUnitType.0:type
   166 print ":"
   167 print " occupied: "
 
  1179 label *label310
  1180 label *label303
  1181 label *label304
-    * jump *label315 equal false false
+ 1182 jump *label315 always
  1183 print UNIT_TYPE
  1184 print ":"
  1185 print " occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-18 instructions):
 
    39 sensor *tmp13 :needsFourUnits.0:unit @speed
    40 op div :needsFourUnits.0:travel_time 0 *tmp13
    41 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
-    * jump *label13 always
    42 label *label13
    43 jump *label15 equal *tmp8 false
    44 set *tmp16 4
-    * jump *label15 always
    45 label *label15
    46 set :areUnitsAvailable.0:needed *tmp16
    47 label *label16
 
    87 label *label23
    88 label *label24
    89 set *tmp4 false
-    * jump *label10 always
    90 label *label10
    91 jump *label27 equal *tmp4 false
    92 set *tmp3 UNIT_TYPE
 
   125 sensor *tmp45 :needsFourUnits.1:unit @speed
   126 op div :needsFourUnits.1:travel_time 0 *tmp45
   127 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
-    * jump *label43 always
   128 label *label43
   129 jump *label45 equal *tmp40 false
   130 set *tmp48 4
-    * jump *label45 always
   131 label *label45
   132 set :areUnitsAvailable.1:needed *tmp48
   133 label *label46
 
   173 label *label53
   174 label *label54
   175 set *tmp36 false
-    * jump *label40 always
   176 label *label40
   177 jump *label57 equal *tmp36 false
   178 printflush null
 
   266 label *label70
   267 ucontrol flag 1
   268 set *tmp79 @unit
-    * jump *label69 always
   269 label *label69
   270 set .UNIT_S1 *tmp79
   271 jump *label84 equal .UNIT_P1 null
 
   304 label *label83
   305 ucontrol flag 1
   306 set *tmp99 @unit
-    * jump *label82 always
   307 label *label82
   308 set .UNIT_P1 *tmp99
   309 sensor *tmp119 *tmp79 @firstItem
 
   342 sensor *tmp144 .UNIT_S1 @speed
   343 op div :needsFourUnits.2:travel_time *tmp143 .SPEED
   344 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
-    * jump *label102 always
   345 label *label102
   346 jump *label103 equal *tmp139 false
   347 jump *label107 equal .UNIT_S2 null
 
   380 label *label106
   381 ucontrol flag 1
   382 set *tmp148 @unit
-    * jump *label105 always
   383 label *label105
   384 set .UNIT_S2 *tmp148
   385 jump *label120 equal .UNIT_P2 null
 
   418 label *label119
   419 ucontrol flag 1
   420 set *tmp168 @unit
-    * jump *label118 always
   421 label *label118
   422 set .UNIT_P2 *tmp168
   423 sensor *tmp188 .UNIT_S1 @firstItem
 
   635 print :processUnit.0:msg
   636 label *label177
   637 set *tmp217 @unit
-    * jump *label141 always
   638 label *label141
   639 set .UNIT_S1 *tmp217
   640 jump *label178 equal *tmp139 false
 
   780 print :processUnit.1:msg
   781 label *label216
   782 set *tmp284 @unit
-    * jump *label180 always
   783 label *label180
   784 set .UNIT_S2 *tmp284
   785 jump *label217 equal .SUPPLY_S_FIRST false
 
   950 print :processUnit.2:msg
   951 label *label258
   952 set *tmp358 @unit
-    * jump *label222 always
   953 label *label222
   954 set .UNIT_P1 *tmp358
   955 jump *label259 equal *tmp139 false
 
  1095 print :processUnit.3:msg
  1096 label *label297
  1097 set *tmp425 @unit
-    * jump *label261 always
  1098 label *label261
  1099 set .UNIT_P2 *tmp425
  1100 jump *label298 equal .SUPPLY_P_FIRST false
 
  1130 sensor *tmp510 :needsFourUnits.3:unit @speed
  1131 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
  1132 op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
-    * jump *label305 always
  1133 label *label305
  1134 jump *label307 equal *tmp505 false
  1135 set *tmp513 4
-    * jump *label307 always
  1136 label *label307
  1137 set :areUnitsAvailable.2:needed *tmp513
  1138 label *label308
 
  1179 label *label315
  1180 label *label316
  1181 set *tmp501 false
-    * jump *label302 always
  1182 label *label302
  1183 jump *label319 equal *tmp501 false
  1184 end

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    37 set *tmp16 2
    38 set :needsFourUnits.0:unit @unit
    39 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * op div :needsFourUnits.0:travel_time 0 *tmp13
+   40 set :needsFourUnits.0:travel_time 0
    41 op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
    42 label *label13
    43 jump *label15 equal *tmp8 false
 
   123 set *tmp48 2
   124 set :needsFourUnits.1:unit @unit
   125 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time 0 *tmp45
+  126 set :needsFourUnits.1:travel_time 0
   127 op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
   128 label *label43
   129 jump *label45 equal *tmp40 false

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
   426 op notEqual *tmp191 *tmp190 @phase-fabric
   427 op land *tmp192 *tmp189 *tmp191
   428 jump *label131 equal *tmp192 false
-    * set :u .UNIT_S1
+  429 set .UNIT_P2 .UNIT_S1
   430 set .UNIT_S1 *tmp168
-    * set .UNIT_P2 :u
   431 label *label131
   432 label *label132
   433 sensor *tmp194 *tmp148 @firstItem

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-2 instructions):
 
    38 set :needsFourUnits.0:unit @unit
    39 sensor *tmp13 :needsFourUnits.0:unit @speed
    40 set :needsFourUnits.0:travel_time 0
-    * op greaterThanEq *tmp8 :needsFourUnits.0:travel_time 47
+   41 op greaterThanEq *tmp8 0 47
    42 label *label13
-    * jump *label15 equal *tmp8 false
+   43 jump *label15 equal false false
    44 set *tmp16 4
    45 label *label15
-    * set :areUnitsAvailable.0:needed *tmp16
+   46 set :areUnitsAvailable.0:needed 2
    47 label *label16
    48 sensor *tmp17 @unit @controlled
    49 op equal *tmp18 *tmp17 0
 
    52 op or *tmp21 *tmp18 *tmp20
    53 jump *label19 equal *tmp21 false
    54 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label21 lessThan :areUnitsAvailable.0:free *tmp16
+   55 jump *label21 lessThan :areUnitsAvailable.0:free 2
    56 set *tmp4 true
    57 jump *label10 always
    58 label *label21
 
   124 set :needsFourUnits.1:unit @unit
   125 sensor *tmp45 :needsFourUnits.1:unit @speed
   126 set :needsFourUnits.1:travel_time 0
-    * op greaterThanEq *tmp40 :needsFourUnits.1:travel_time 47
+  127 op greaterThanEq *tmp40 0 47
   128 label *label43
-    * jump *label45 equal *tmp40 false
+  129 jump *label45 equal false false
   130 set *tmp48 4
   131 label *label45
-    * set :areUnitsAvailable.1:needed *tmp48
+  132 set :areUnitsAvailable.1:needed 2
   133 label *label46
   134 sensor *tmp49 @unit @controlled
   135 op equal *tmp50 *tmp49 0
 
   138 op or *tmp53 *tmp50 *tmp52
   139 jump *label49 equal *tmp53 false
   140 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label51 lessThan :areUnitsAvailable.1:free *tmp48
+  141 jump *label51 lessThan :areUnitsAvailable.1:free 2
   142 set *tmp36 true
   143 jump *label40 always
   144 label *label51
 
  1118 op greaterThan *tmp498 :unitCheck @time
  1119 op land *tmp499 *tmp497 *tmp498
  1120 jump *label300 equal *tmp499 false
-    * set :areUnitsAvailable.2:needed 0
  1121 set :areUnitsAvailable.2:occupied 0
  1122 set :areUnitsAvailable.2:free 0
  1123 ubind UNIT_TYPE
 
  1132 jump *label307 equal *tmp505 false
  1133 set *tmp513 4
  1134 label *label307
-    * set :areUnitsAvailable.2:needed *tmp513
  1135 label *label308
  1136 sensor *tmp514 @unit @controlled
  1137 op equal *tmp515 *tmp514 0

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-8 instructions):
 
    34 ubind UNIT_TYPE
    35 set :areUnitsAvailable.0:firstUnit @unit
    36 jump *label11 equal :areUnitsAvailable.0:firstUnit null
-    * set *tmp16 2
    37 set :needsFourUnits.0:unit @unit
    38 sensor *tmp13 :needsFourUnits.0:unit @speed
-    * set :needsFourUnits.0:travel_time 0
-    * op greaterThanEq *tmp8 0 47
    39 label *label13
    40 jump *label15 equal false false
-    * set *tmp16 4
    41 label *label15
    42 set :areUnitsAvailable.0:needed 2
    43 label *label16
 
   116 ubind :chooseUnitType.0:type
   117 set :areUnitsAvailable.1:firstUnit @unit
   118 jump *label41 equal :areUnitsAvailable.1:firstUnit null
-    * set *tmp48 2
   119 set :needsFourUnits.1:unit @unit
   120 sensor *tmp45 :needsFourUnits.1:unit @speed
-    * set :needsFourUnits.1:travel_time 0
-    * op greaterThanEq *tmp40 0 47
   121 label *label43
   122 jump *label45 equal false false
-    * set *tmp48 4
   123 label *label45
   124 set :areUnitsAvailable.1:needed 2
   125 label *label46

Modifications by Unroll iteration loop at line 177:9 (+141 instructions):
 
    89 jump *label6 always
    90 label *label27
    91 label *label28
-    * set :chooseUnitType.0:type @flare
-    * op add *tmp33 @counter 1
-    * jump *label29 always
-    * multilabel *label32
-    * set :chooseUnitType.0:type @poly
-    * op add *tmp33 @counter 1
-    * jump *label29 always
-    * multilabel *label33
-    * set :chooseUnitType.0:type @mega
-    * op add *tmp33 @counter 1
-    * jump *label29 always
-    * multilabel *label34
-    * set :chooseUnitType.0:type @mono
-    * op add *tmp33 @counter 1
-    * jump *label29 always
-    * multilabel *label36
-    * jump *label37 always
-    * label *label29
-    * jump *label38 equal :chooseUnitType.0:type UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:needed 0
-    * set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label41 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
-    * label *label43
-    * jump *label45 equal false false
-    * label *label45
-    * set :areUnitsAvailable.1:needed 2
-    * label *label46
-    * sensor *tmp49 @unit @controlled
-    * op equal *tmp50 *tmp49 0
-    * sensor *tmp51 @unit @controller
-    * op equal *tmp52 *tmp51 @this
-    * op or *tmp53 *tmp50 *tmp52
-    * jump *label49 equal *tmp53 false
-    * op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label51 lessThan :areUnitsAvailable.1:free 2
-    * set *tmp36 true
-    * jump *label40 always
-    * label *label51
-    * label *label52
-    * jump *label50 always
-    * label *label49
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label50
-    * ubind :chooseUnitType.0:type
-    * label *label47
-    * op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp59 *tmp58 0
-    * op land *tmp60 *tmp57 *tmp59
-    * jump *label46 notEqual *tmp60 false
-    * label *label48
-    * label *label41
-    * label *label42
-    * print :chooseUnitType.0:type
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.1:free
-    * jump *label55 lessThanEq :areUnitsAvailable.1:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.1:needed
-    * label *label55
-    * label *label56
-    * print "\n"
-    * label *label53
-    * label *label54
-    * set *tmp36 false
-    * label *label40
-    * jump *label57 equal *tmp36 false
-    * printflush null
-    * set *tmp3 :chooseUnitType.0:type
-    * jump *label6 always
-    * label *label57
-    * label *label58
-    * label *label38
-    * label *label39
-    * label *label30
-    * multijump *tmp33 0 0
-    * multilabel *label35
-    * label *label37
-    * label *label31
+   92 set :chooseUnitType.0:type @flare
+   93 op add *tmp33 @counter 1
+   94 label *label324
+   95 jump *label343 equal :chooseUnitType.0:type UNIT_TYPE
+   96 remark "chooseUnitType: "
+   97 remark :chooseUnitType.0:type
+   98 set :areUnitsAvailable.1:needed 0
+   99 set :areUnitsAvailable.1:occupied 0
+  100 set :areUnitsAvailable.1:free 0
+  101 ubind :chooseUnitType.0:type
+  102 set :areUnitsAvailable.1:firstUnit @unit
+  103 jump *label334 equal :areUnitsAvailable.1:firstUnit null
+  104 set :needsFourUnits.1:unit @unit
+  105 sensor *tmp45 :needsFourUnits.1:unit @speed
+  106 label *label325
+  107 jump *label326 equal false false
+  108 label *label326
+  109 set :areUnitsAvailable.1:needed 2
+  110 label *label327
+  111 sensor *tmp49 @unit @controlled
+  112 op equal *tmp50 *tmp49 0
+  113 sensor *tmp51 @unit @controller
+  114 op equal *tmp52 *tmp51 @this
+  115 op or *tmp53 *tmp50 *tmp52
+  116 jump *label330 equal *tmp53 false
+  117 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  118 jump *label328 lessThan :areUnitsAvailable.1:free 2
+  119 set *tmp36 true
+  120 jump *label340 always
+  121 label *label328
+  122 label *label329
+  123 jump *label331 always
+  124 label *label330
+  125 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  126 label *label331
+  127 ubind :chooseUnitType.0:type
+  128 label *label332
+  129 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  130 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  131 op equal *tmp59 *tmp58 0
+  132 op land *tmp60 *tmp57 *tmp59
+  133 jump *label327 notEqual *tmp60 false
+  134 label *label333
+  135 label *label334
+  136 label *label335
+  137 print :chooseUnitType.0:type
+  138 print ":"
+  139 print " occupied: "
+  140 print :areUnitsAvailable.1:occupied
+  141 print ","
+  142 print " free: "
+  143 print :areUnitsAvailable.1:free
+  144 jump *label336 lessThanEq :areUnitsAvailable.1:needed 0
+  145 print ", needed: "
+  146 print :areUnitsAvailable.1:needed
+  147 label *label336
+  148 label *label337
+  149 print "\n"
+  150 label *label338
+  151 label *label339
+  152 set *tmp36 false
+  153 label *label340
+  154 jump *label341 equal *tmp36 false
+  155 printflush null
+  156 set *tmp3 :chooseUnitType.0:type
+  157 jump *label6 always
+  158 label *label341
+  159 label *label342
+  160 label *label343
+  161 label *label344
+  162 label *label345
+  163 set :chooseUnitType.0:type @poly
+  164 op add *tmp33 @counter 1
+  165 label *label348
+  166 jump *label367 equal :chooseUnitType.0:type UNIT_TYPE
+  167 remark "chooseUnitType: "
+  168 remark :chooseUnitType.0:type
+  169 set :areUnitsAvailable.1:needed 0
+  170 set :areUnitsAvailable.1:occupied 0
+  171 set :areUnitsAvailable.1:free 0
+  172 ubind :chooseUnitType.0:type
+  173 set :areUnitsAvailable.1:firstUnit @unit
+  174 jump *label358 equal :areUnitsAvailable.1:firstUnit null
+  175 set :needsFourUnits.1:unit @unit
+  176 sensor *tmp45 :needsFourUnits.1:unit @speed
+  177 label *label349
+  178 jump *label350 equal false false
+  179 label *label350
+  180 set :areUnitsAvailable.1:needed 2
+  181 label *label351
+  182 sensor *tmp49 @unit @controlled
+  183 op equal *tmp50 *tmp49 0
+  184 sensor *tmp51 @unit @controller
+  185 op equal *tmp52 *tmp51 @this
+  186 op or *tmp53 *tmp50 *tmp52
+  187 jump *label354 equal *tmp53 false
+  188 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  189 jump *label352 lessThan :areUnitsAvailable.1:free 2
+  190 set *tmp36 true
+  191 jump *label364 always
+  192 label *label352
+  193 label *label353
+  194 jump *label355 always
+  195 label *label354
+  196 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  197 label *label355
+  198 ubind :chooseUnitType.0:type
+  199 label *label356
+  200 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  201 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  202 op equal *tmp59 *tmp58 0
+  203 op land *tmp60 *tmp57 *tmp59
+  204 jump *label351 notEqual *tmp60 false
+  205 label *label357
+  206 label *label358
+  207 label *label359
+  208 print :chooseUnitType.0:type
+  209 print ":"
+  210 print " occupied: "
+  211 print :areUnitsAvailable.1:occupied
+  212 print ","
+  213 print " free: "
+  214 print :areUnitsAvailable.1:free
+  215 jump *label360 lessThanEq :areUnitsAvailable.1:needed 0
+  216 print ", needed: "
+  217 print :areUnitsAvailable.1:needed
+  218 label *label360
+  219 label *label361
+  220 print "\n"
+  221 label *label362
+  222 label *label363
+  223 set *tmp36 false
+  224 label *label364
+  225 jump *label365 equal *tmp36 false
+  226 printflush null
+  227 set *tmp3 :chooseUnitType.0:type
+  228 jump *label6 always
+  229 label *label365
+  230 label *label366
+  231 label *label367
+  232 label *label368
+  233 label *label369
+  234 set :chooseUnitType.0:type @mega
+  235 op add *tmp33 @counter 1
+  236 label *label372
+  237 jump *label391 equal :chooseUnitType.0:type UNIT_TYPE
+  238 remark "chooseUnitType: "
+  239 remark :chooseUnitType.0:type
+  240 set :areUnitsAvailable.1:needed 0
+  241 set :areUnitsAvailable.1:occupied 0
+  242 set :areUnitsAvailable.1:free 0
+  243 ubind :chooseUnitType.0:type
+  244 set :areUnitsAvailable.1:firstUnit @unit
+  245 jump *label382 equal :areUnitsAvailable.1:firstUnit null
+  246 set :needsFourUnits.1:unit @unit
+  247 sensor *tmp45 :needsFourUnits.1:unit @speed
+  248 label *label373
+  249 jump *label374 equal false false
+  250 label *label374
+  251 set :areUnitsAvailable.1:needed 2
+  252 label *label375
+  253 sensor *tmp49 @unit @controlled
+  254 op equal *tmp50 *tmp49 0
+  255 sensor *tmp51 @unit @controller
+  256 op equal *tmp52 *tmp51 @this
+  257 op or *tmp53 *tmp50 *tmp52
+  258 jump *label378 equal *tmp53 false
+  259 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  260 jump *label376 lessThan :areUnitsAvailable.1:free 2
+  261 set *tmp36 true
+  262 jump *label388 always
+  263 label *label376
+  264 label *label377
+  265 jump *label379 always
+  266 label *label378
+  267 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  268 label *label379
+  269 ubind :chooseUnitType.0:type
+  270 label *label380
+  271 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  272 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  273 op equal *tmp59 *tmp58 0
+  274 op land *tmp60 *tmp57 *tmp59
+  275 jump *label375 notEqual *tmp60 false
+  276 label *label381
+  277 label *label382
+  278 label *label383
+  279 print :chooseUnitType.0:type
+  280 print ":"
+  281 print " occupied: "
+  282 print :areUnitsAvailable.1:occupied
+  283 print ","
+  284 print " free: "
+  285 print :areUnitsAvailable.1:free
+  286 jump *label384 lessThanEq :areUnitsAvailable.1:needed 0
+  287 print ", needed: "
+  288 print :areUnitsAvailable.1:needed
+  289 label *label384
+  290 label *label385
+  291 print "\n"
+  292 label *label386
+  293 label *label387
+  294 set *tmp36 false
+  295 label *label388
+  296 jump *label389 equal *tmp36 false
+  297 printflush null
+  298 set *tmp3 :chooseUnitType.0:type
+  299 jump *label6 always
+  300 label *label389
+  301 label *label390
+  302 label *label391
+  303 label *label392
+  304 label *label393
+  305 set :chooseUnitType.0:type @mono
+  306 op add *tmp33 @counter 1
+  307 label *label396
+  308 jump *label415 equal :chooseUnitType.0:type UNIT_TYPE
+  309 remark "chooseUnitType: "
+  310 remark :chooseUnitType.0:type
+  311 set :areUnitsAvailable.1:needed 0
+  312 set :areUnitsAvailable.1:occupied 0
+  313 set :areUnitsAvailable.1:free 0
+  314 ubind :chooseUnitType.0:type
+  315 set :areUnitsAvailable.1:firstUnit @unit
+  316 jump *label406 equal :areUnitsAvailable.1:firstUnit null
+  317 set :needsFourUnits.1:unit @unit
+  318 sensor *tmp45 :needsFourUnits.1:unit @speed
+  319 label *label397
+  320 jump *label398 equal false false
+  321 label *label398
+  322 set :areUnitsAvailable.1:needed 2
+  323 label *label399
+  324 sensor *tmp49 @unit @controlled
+  325 op equal *tmp50 *tmp49 0
+  326 sensor *tmp51 @unit @controller
+  327 op equal *tmp52 *tmp51 @this
+  328 op or *tmp53 *tmp50 *tmp52
+  329 jump *label402 equal *tmp53 false
+  330 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  331 jump *label400 lessThan :areUnitsAvailable.1:free 2
+  332 set *tmp36 true
+  333 jump *label412 always
+  334 label *label400
+  335 label *label401
+  336 jump *label403 always
+  337 label *label402
+  338 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  339 label *label403
+  340 ubind :chooseUnitType.0:type
+  341 label *label404
+  342 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
+  343 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
+  344 op equal *tmp59 *tmp58 0
+  345 op land *tmp60 *tmp57 *tmp59
+  346 jump *label399 notEqual *tmp60 false
+  347 label *label405
+  348 label *label406
+  349 label *label407
+  350 print :chooseUnitType.0:type
+  351 print ":"
+  352 print " occupied: "
+  353 print :areUnitsAvailable.1:occupied
+  354 print ","
+  355 print " free: "
+  356 print :areUnitsAvailable.1:free
+  357 jump *label408 lessThanEq :areUnitsAvailable.1:needed 0
+  358 print ", needed: "
+  359 print :areUnitsAvailable.1:needed
+  360 label *label408
+  361 label *label409
+  362 print "\n"
+  363 label *label410
+  364 label *label411
+  365 set *tmp36 false
+  366 label *label412
+  367 jump *label413 equal *tmp36 false
+  368 printflush null
+  369 set *tmp3 :chooseUnitType.0:type
+  370 jump *label6 always
+  371 label *label413
+  372 label *label414
+  373 label *label415
+  374 label *label416
+  375 label *label417
+  376 label *label37
+  377 label *label31
   378 printflush message1
   379 label *label8
   380 jump *label7 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-4 instructions):
 
    90 label *label27
    91 label *label28
    92 set :chooseUnitType.0:type @flare
-    * op add *tmp33 @counter 1
    93 label *label324
-    * jump *label343 equal :chooseUnitType.0:type UNIT_TYPE
+   94 jump *label343 equal @flare UNIT_TYPE
    95 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+   96 remark @flare
    97 set :areUnitsAvailable.1:needed 0
    98 set :areUnitsAvailable.1:occupied 0
    99 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  100 ubind @flare
   101 set :areUnitsAvailable.1:firstUnit @unit
   102 jump *label334 equal :areUnitsAvailable.1:firstUnit null
   103 set :needsFourUnits.1:unit @unit
 
   123 label *label330
   124 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   125 label *label331
-    * ubind :chooseUnitType.0:type
+  126 ubind @flare
   127 label *label332
   128 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   129 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   133 label *label333
   134 label *label334
   135 label *label335
-    * print :chooseUnitType.0:type
+  136 print @flare
   137 print ":"
   138 print " occupied: "
   139 print :areUnitsAvailable.1:occupied
 
   152 label *label340
   153 jump *label341 equal *tmp36 false
   154 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  155 set *tmp3 @flare
   156 jump *label6 always
   157 label *label341
   158 label *label342
 
   160 label *label344
   161 label *label345
   162 set :chooseUnitType.0:type @poly
-    * op add *tmp33 @counter 1
   163 label *label348
-    * jump *label367 equal :chooseUnitType.0:type UNIT_TYPE
+  164 jump *label367 equal @poly UNIT_TYPE
   165 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+  166 remark @poly
   167 set :areUnitsAvailable.1:needed 0
   168 set :areUnitsAvailable.1:occupied 0
   169 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  170 ubind @poly
   171 set :areUnitsAvailable.1:firstUnit @unit
   172 jump *label358 equal :areUnitsAvailable.1:firstUnit null
   173 set :needsFourUnits.1:unit @unit
 
   193 label *label354
   194 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   195 label *label355
-    * ubind :chooseUnitType.0:type
+  196 ubind @poly
   197 label *label356
   198 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   199 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   203 label *label357
   204 label *label358
   205 label *label359
-    * print :chooseUnitType.0:type
+  206 print @poly
   207 print ":"
   208 print " occupied: "
   209 print :areUnitsAvailable.1:occupied
 
   222 label *label364
   223 jump *label365 equal *tmp36 false
   224 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  225 set *tmp3 @poly
   226 jump *label6 always
   227 label *label365
   228 label *label366
 
   230 label *label368
   231 label *label369
   232 set :chooseUnitType.0:type @mega
-    * op add *tmp33 @counter 1
   233 label *label372
-    * jump *label391 equal :chooseUnitType.0:type UNIT_TYPE
+  234 jump *label391 equal @mega UNIT_TYPE
   235 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+  236 remark @mega
   237 set :areUnitsAvailable.1:needed 0
   238 set :areUnitsAvailable.1:occupied 0
   239 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  240 ubind @mega
   241 set :areUnitsAvailable.1:firstUnit @unit
   242 jump *label382 equal :areUnitsAvailable.1:firstUnit null
   243 set :needsFourUnits.1:unit @unit
 
   263 label *label378
   264 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   265 label *label379
-    * ubind :chooseUnitType.0:type
+  266 ubind @mega
   267 label *label380
   268 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   269 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   273 label *label381
   274 label *label382
   275 label *label383
-    * print :chooseUnitType.0:type
+  276 print @mega
   277 print ":"
   278 print " occupied: "
   279 print :areUnitsAvailable.1:occupied
 
   292 label *label388
   293 jump *label389 equal *tmp36 false
   294 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  295 set *tmp3 @mega
   296 jump *label6 always
   297 label *label389
   298 label *label390
 
   300 label *label392
   301 label *label393
   302 set :chooseUnitType.0:type @mono
-    * op add *tmp33 @counter 1
   303 label *label396
-    * jump *label415 equal :chooseUnitType.0:type UNIT_TYPE
+  304 jump *label415 equal @mono UNIT_TYPE
   305 remark "chooseUnitType: "
-    * remark :chooseUnitType.0:type
+  306 remark @mono
   307 set :areUnitsAvailable.1:needed 0
   308 set :areUnitsAvailable.1:occupied 0
   309 set :areUnitsAvailable.1:free 0
-    * ubind :chooseUnitType.0:type
+  310 ubind @mono
   311 set :areUnitsAvailable.1:firstUnit @unit
   312 jump *label406 equal :areUnitsAvailable.1:firstUnit null
   313 set :needsFourUnits.1:unit @unit
 
   333 label *label402
   334 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   335 label *label403
-    * ubind :chooseUnitType.0:type
+  336 ubind @mono
   337 label *label404
   338 op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
   339 sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
 
   343 label *label405
   344 label *label406
   345 label *label407
-    * print :chooseUnitType.0:type
+  346 print @mono
   347 print ":"
   348 print " occupied: "
   349 print :areUnitsAvailable.1:occupied
 
   362 label *label412
   363 jump *label413 equal *tmp36 false
   364 printflush null
-    * set *tmp3 :chooseUnitType.0:type
+  365 set *tmp3 @mono
   366 jump *label6 always
   367 label *label413
   368 label *label414

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-4 instructions):
 
    89 jump *label6 always
    90 label *label27
    91 label *label28
-    * set :chooseUnitType.0:type @flare
    92 label *label324
    93 jump *label343 equal @flare UNIT_TYPE
    94 remark "chooseUnitType: "
 
   158 label *label343
   159 label *label344
   160 label *label345
-    * set :chooseUnitType.0:type @poly
   161 label *label348
   162 jump *label367 equal @poly UNIT_TYPE
   163 remark "chooseUnitType: "
 
   227 label *label367
   228 label *label368
   229 label *label369
-    * set :chooseUnitType.0:type @mega
   230 label *label372
   231 jump *label391 equal @mega UNIT_TYPE
   232 remark "chooseUnitType: "
 
   296 label *label391
   297 label *label392
   298 label *label393
-    * set :chooseUnitType.0:type @mono
   299 label *label396
   300 jump *label415 equal @mono UNIT_TYPE
   301 remark "chooseUnitType: "

Modifications by Iterated phase, Jump Normalization, pass 3, iteration 1:
 
    37 set :needsFourUnits.0:unit @unit
    38 sensor *tmp13 :needsFourUnits.0:unit @speed
    39 label *label13
-    * jump *label15 equal false false
+   40 jump *label15 always
    41 label *label15
    42 set :areUnitsAvailable.0:needed 2
    43 label *label16
 
   102 set :needsFourUnits.1:unit @unit
   103 sensor *tmp45 :needsFourUnits.1:unit @speed
   104 label *label325
-    * jump *label326 equal false false
+  105 jump *label326 always
   106 label *label326
   107 set :areUnitsAvailable.1:needed 2
   108 label *label327
 
   171 set :needsFourUnits.1:unit @unit
   172 sensor *tmp45 :needsFourUnits.1:unit @speed
   173 label *label349
-    * jump *label350 equal false false
+  174 jump *label350 always
   175 label *label350
   176 set :areUnitsAvailable.1:needed 2
   177 label *label351
 
   240 set :needsFourUnits.1:unit @unit
   241 sensor *tmp45 :needsFourUnits.1:unit @speed
   242 label *label373
-    * jump *label374 equal false false
+  243 jump *label374 always
   244 label *label374
   245 set :areUnitsAvailable.1:needed 2
   246 label *label375
 
   309 set :needsFourUnits.1:unit @unit
   310 sensor *tmp45 :needsFourUnits.1:unit @speed
   311 label *label397
-    * jump *label398 equal false false
+  312 jump *label398 always
   313 label *label398
   314 set :areUnitsAvailable.1:needed 2
   315 label *label399

Modifications by Iterated phase, Jump Optimization, pass 3, iteration 1 (-1 instructions):
 
  1307 set :needsFourUnits.3:unit @unit
  1308 sensor *tmp510 :needsFourUnits.3:unit @speed
  1309 op div :needsFourUnits.3:travel_time *tmp143 *tmp510
-    * op greaterThanEq *tmp505 :needsFourUnits.3:travel_time 47
  1310 label *label305
-    * jump *label307 equal *tmp505 false
+ 1311 jump *label307 lessThan :needsFourUnits.3:travel_time 47
  1312 set *tmp513 4
  1313 label *label307
  1314 label *label308

Modifications by Iterated phase, Single Step Elimination, pass 3, iteration 1 (-5 instructions):
 
    37 set :needsFourUnits.0:unit @unit
    38 sensor *tmp13 :needsFourUnits.0:unit @speed
    39 label *label13
-    * jump *label15 always
    40 label *label15
    41 set :areUnitsAvailable.0:needed 2
    42 label *label16
 
   101 set :needsFourUnits.1:unit @unit
   102 sensor *tmp45 :needsFourUnits.1:unit @speed
   103 label *label325
-    * jump *label326 always
   104 label *label326
   105 set :areUnitsAvailable.1:needed 2
   106 label *label327
 
   169 set :needsFourUnits.1:unit @unit
   170 sensor *tmp45 :needsFourUnits.1:unit @speed
   171 label *label349
-    * jump *label350 always
   172 label *label350
   173 set :areUnitsAvailable.1:needed 2
   174 label *label351
 
   237 set :needsFourUnits.1:unit @unit
   238 sensor *tmp45 :needsFourUnits.1:unit @speed
   239 label *label373
-    * jump *label374 always
   240 label *label374
   241 set :areUnitsAvailable.1:needed 2
   242 label *label375
 
   305 set :needsFourUnits.1:unit @unit
   306 sensor *tmp45 :needsFourUnits.1:unit @speed
   307 label *label397
-    * jump *label398 always
   308 label *label398
   309 set :areUnitsAvailable.1:needed 2
   310 label *label399

Modifications by Final phase, Jump Straightening, iteration 1 (-17 instructions):
 
   390 set .UNIT_P2 .UNIT_S1
   391 set .UNIT_S1 .UNIT_P1
   392 set .UNIT_P1 @unit
-    * jump *label67 equal .UNIT_S2 null
-    * jump *label64 always
+  393 jump *label64 notEqual .UNIT_S2 null
   394 label *label67
   395 label *label68
   396 label *label65
 
   411 sensor *tmp85 @unit @controller
   412 op equal *tmp86 *tmp85 @this
   413 op land *tmp87 *tmp84 *tmp86
-    * jump *label73 equal *tmp87 false
-    * jump *label70 always
+  414 jump *label70 notEqual *tmp87 false
   415 label *label73
   416 label *label74
   417 label *label71
 
   421 jump *label75 equal :rebindUnit.0:firstUnit null
   422 label *label77
   423 sensor *tmp92 @unit @controlled
-    * jump *label80 notEqual *tmp92 0
-    * jump *label70 always
+  424 jump *label70 equal *tmp92 0
   425 label *label80
   426 label *label81
   427 ubind *tmp3
 
   447 sensor *tmp105 @unit @controller
   448 op equal *tmp106 *tmp105 @this
   449 op land *tmp107 *tmp104 *tmp106
-    * jump *label86 equal *tmp107 false
-    * jump *label83 always
+  450 jump *label83 notEqual *tmp107 false
   451 label *label86
   452 label *label87
   453 label *label84
 
   457 jump *label88 equal :rebindUnit.1:firstUnit null
   458 label *label90
   459 sensor *tmp112 @unit @controlled
-    * jump *label93 notEqual *tmp112 0
-    * jump *label83 always
+  460 jump *label83 equal *tmp112 0
   461 label *label93
   462 label *label94
   463 ubind *tmp3
 
   521 sensor *tmp154 @unit @controller
   522 op equal *tmp155 *tmp154 @this
   523 op land *tmp156 *tmp153 *tmp155
-    * jump *label109 equal *tmp156 false
-    * jump *label106 always
+  524 jump *label106 notEqual *tmp156 false
   525 label *label109
   526 label *label110
   527 label *label107
 
   531 jump *label111 equal :rebindUnit.2:firstUnit null
   532 label *label113
   533 sensor *tmp161 @unit @controlled
-    * jump *label116 notEqual *tmp161 0
-    * jump *label106 always
+  534 jump *label106 equal *tmp161 0
   535 label *label116
   536 label *label117
   537 ubind *tmp3
 
   557 sensor *tmp174 @unit @controller
   558 op equal *tmp175 *tmp174 @this
   559 op land *tmp176 *tmp173 *tmp175
-    * jump *label122 equal *tmp176 false
-    * jump *label119 always
+  560 jump *label119 notEqual *tmp176 false
   561 label *label122
   562 label *label123
   563 label *label120
 
   567 jump *label124 equal :rebindUnit.3:firstUnit null
   568 label *label126
   569 sensor *tmp181 @unit @controlled
-    * jump *label129 notEqual *tmp181 0
-    * jump *label119 always
+  570 jump *label119 equal *tmp181 0
   571 label *label129
   572 label *label130
   573 ubind *tmp3
 
   666 sensor *tmp223 @unit @controller
   667 op equal *tmp224 *tmp223 @this
   668 op land *tmp225 *tmp222 *tmp224
-    * jump *label145 equal *tmp225 false
-    * jump *label142 always
+  669 jump *label142 notEqual *tmp225 false
   670 label *label145
   671 label *label146
   672 label *label143
 
   676 jump *label147 equal :rebindUnit.4:firstUnit null
   677 label *label149
   678 sensor *tmp230 @unit @controlled
-    * jump *label152 notEqual *tmp230 0
-    * jump *label142 always
+  679 jump *label142 equal *tmp230 0
   680 label *label152
   681 label *label153
   682 ubind *tmp3
 
   809 sensor *tmp290 @unit @controller
   810 op equal *tmp291 *tmp290 @this
   811 op land *tmp292 *tmp289 *tmp291
-    * jump *label184 equal *tmp292 false
-    * jump *label181 always
+  812 jump *label181 notEqual *tmp292 false
   813 label *label184
   814 label *label185
   815 label *label182
 
   819 jump *label186 equal :rebindUnit.5:firstUnit null
   820 label *label188
   821 sensor *tmp297 @unit @controlled
-    * jump *label191 notEqual *tmp297 0
-    * jump *label181 always
+  822 jump *label181 equal *tmp297 0
   823 label *label191
   824 label *label192
   825 ubind *tmp3
 
   977 sensor *tmp364 @unit @controller
   978 op equal *tmp365 *tmp364 @this
   979 op land *tmp366 *tmp363 *tmp365
-    * jump *label226 equal *tmp366 false
-    * jump *label223 always
+  980 jump *label223 notEqual *tmp366 false
   981 label *label226
   982 label *label227
   983 label *label224
 
   987 jump *label228 equal :rebindUnit.6:firstUnit null
   988 label *label230
   989 sensor *tmp371 @unit @controlled
-    * jump *label233 notEqual *tmp371 0
-    * jump *label223 always
+  990 jump *label223 equal *tmp371 0
   991 label *label233
   992 label *label234
   993 ubind *tmp3
 
  1120 sensor *tmp431 @unit @controller
  1121 op equal *tmp432 *tmp431 @this
  1122 op land *tmp433 *tmp430 *tmp432
-    * jump *label265 equal *tmp433 false
-    * jump *label262 always
+ 1123 jump *label262 notEqual *tmp433 false
  1124 label *label265
  1125 label *label266
  1126 label *label263
 
  1130 jump *label267 equal :rebindUnit.7:firstUnit null
  1131 label *label269
  1132 sensor *tmp438 @unit @controlled
-    * jump *label272 notEqual *tmp438 0
-    * jump *label262 always
+ 1133 jump *label262 equal *tmp438 0
  1134 label *label272
  1135 label *label273
  1136 ubind *tmp3

Modifications by Final phase, Jump Threading, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @flare
 
    48 op or *tmp21 *tmp18 *tmp20
    49 jump *label19 equal *tmp21 false
    50 op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
-    * jump *label21 lessThan :areUnitsAvailable.0:free 2
+   51 jump *label20 lessThan :areUnitsAvailable.0:free 2
    52 set *tmp4 true
    53 jump *label10 always
    54 label *label21
 
   112 op or *tmp53 *tmp50 *tmp52
   113 jump *label330 equal *tmp53 false
   114 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label328 lessThan :areUnitsAvailable.1:free 2
+  115 jump *label331 lessThan :areUnitsAvailable.1:free 2
   116 set *tmp36 true
   117 jump *label340 always
   118 label *label328
 
   180 op or *tmp53 *tmp50 *tmp52
   181 jump *label354 equal *tmp53 false
   182 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label352 lessThan :areUnitsAvailable.1:free 2
+  183 jump *label355 lessThan :areUnitsAvailable.1:free 2
   184 set *tmp36 true
   185 jump *label364 always
   186 label *label352
 
   248 op or *tmp53 *tmp50 *tmp52
   249 jump *label378 equal *tmp53 false
   250 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label376 lessThan :areUnitsAvailable.1:free 2
+  251 jump *label379 lessThan :areUnitsAvailable.1:free 2
   252 set *tmp36 true
   253 jump *label388 always
   254 label *label376
 
   316 op or *tmp53 *tmp50 *tmp52
   317 jump *label402 equal *tmp53 false
   318 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label400 lessThan :areUnitsAvailable.1:free 2
+  319 jump *label403 lessThan :areUnitsAvailable.1:free 2
   320 set *tmp36 true
   321 jump *label412 always
   322 label *label400
 
   419 label *label72
   420 ubind *tmp3
   421 set :rebindUnit.0:firstUnit @unit
-    * jump *label75 equal :rebindUnit.0:firstUnit null
+  422 jump __start__ equal :rebindUnit.0:firstUnit null
   423 label *label77
   424 sensor *tmp92 @unit @controlled
   425 jump *label70 equal *tmp92 0
 
   455 label *label85
   456 ubind *tmp3
   457 set :rebindUnit.1:firstUnit @unit
-    * jump *label88 equal :rebindUnit.1:firstUnit null
+  458 jump __start__ equal :rebindUnit.1:firstUnit null
   459 label *label90
   460 sensor *tmp112 @unit @controlled
   461 jump *label83 equal *tmp112 0
 
   529 label *label108
   530 ubind *tmp3
   531 set :rebindUnit.2:firstUnit @unit
-    * jump *label111 equal :rebindUnit.2:firstUnit null
+  532 jump __start__ equal :rebindUnit.2:firstUnit null
   533 label *label113
   534 sensor *tmp161 @unit @controlled
   535 jump *label106 equal *tmp161 0
 
   565 label *label121
   566 ubind *tmp3
   567 set :rebindUnit.3:firstUnit @unit
-    * jump *label124 equal :rebindUnit.3:firstUnit null
+  568 jump __start__ equal :rebindUnit.3:firstUnit null
   569 label *label126
   570 sensor *tmp181 @unit @controlled
   571 jump *label119 equal *tmp181 0
 
   632 op add :unitCheck @time 5000
   633 label *label135
   634 sensor *tmp211 switch1 @enabled
-    * jump *label137 equal *tmp211 false
+  635 jump __start__ equal *tmp211 false
   636 label *label323
   637 set :start @time
   638 print " === [gold]Supplying Overdrive Dome[] === "
 
   674 label *label144
   675 ubind *tmp3
   676 set :rebindUnit.4:firstUnit @unit
-    * jump *label147 equal :rebindUnit.4:firstUnit null
+  677 jump __start__ equal :rebindUnit.4:firstUnit null
   678 label *label149
   679 sensor *tmp230 @unit @controlled
   680 jump *label142 equal *tmp230 0
 
   728 jump *label166 lessThan *tmp254 .UNIT_CAPACITY
   729 ucontrol approach .DOME_X .DOME_Y 6
   730 set :processUnit.0:state 3
-    * jump *label167 always
+  731 jump *label165 always
   732 label *label166
   733 set :processUnit.0:msg ", loading\n"
   734 label *label167
 
   758 set :processUnit.0:msg ", waiting\n"
   759 label *label173
   760 sensor *tmp269 @unit @totalItems
-    * jump *label174 greaterThan *tmp269 0
+  761 jump *label171 greaterThan *tmp269 0
   762 ucontrol approach .CORE_X .CORE_Y 6
   763 set :processUnit.0:state 2
   764 label *label174
 
   817 label *label183
   818 ubind *tmp3
   819 set :rebindUnit.5:firstUnit @unit
-    * jump *label186 equal :rebindUnit.5:firstUnit null
+  820 jump __start__ equal :rebindUnit.5:firstUnit null
   821 label *label188
   822 sensor *tmp297 @unit @controlled
   823 jump *label181 equal *tmp297 0
 
   871 jump *label205 lessThan *tmp321 .UNIT_CAPACITY
   872 ucontrol approach .DOME_X .DOME_Y 6
   873 set :processUnit.1:state 3
-    * jump *label206 always
+  874 jump *label204 always
   875 label *label205
   876 set :processUnit.1:msg ", loading\n"
   877 label *label206
 
   901 set :processUnit.1:msg ", waiting\n"
   902 label *label212
   903 sensor *tmp336 @unit @totalItems
-    * jump *label213 greaterThan *tmp336 0
+  904 jump *label210 greaterThan *tmp336 0
   905 ucontrol approach .CORE_X .CORE_Y 6
   906 set :processUnit.1:state 2
   907 label *label213
 
   985 label *label225
   986 ubind *tmp3
   987 set :rebindUnit.6:firstUnit @unit
-    * jump *label228 equal :rebindUnit.6:firstUnit null
+  988 jump __start__ equal :rebindUnit.6:firstUnit null
   989 label *label230
   990 sensor *tmp371 @unit @controlled
   991 jump *label223 equal *tmp371 0
 
  1039 jump *label247 lessThan *tmp395 .UNIT_CAPACITY
  1040 ucontrol approach .DOME_X .DOME_Y 6
  1041 set :processUnit.2:state 3
-    * jump *label248 always
+ 1042 jump *label246 always
  1043 label *label247
  1044 set :processUnit.2:msg ", loading\n"
  1045 label *label248
 
  1069 set :processUnit.2:msg ", waiting\n"
  1070 label *label254
  1071 sensor *tmp410 @unit @totalItems
-    * jump *label255 greaterThan *tmp410 0
+ 1072 jump *label252 greaterThan *tmp410 0
  1073 ucontrol approach .CORE_X .CORE_Y 6
  1074 set :processUnit.2:state 2
  1075 label *label255
 
  1128 label *label264
  1129 ubind *tmp3
  1130 set :rebindUnit.7:firstUnit @unit
-    * jump *label267 equal :rebindUnit.7:firstUnit null
+ 1131 jump __start__ equal :rebindUnit.7:firstUnit null
  1132 label *label269
  1133 sensor *tmp438 @unit @controlled
  1134 jump *label262 equal *tmp438 0
 
  1182 jump *label286 lessThan *tmp462 .UNIT_CAPACITY
  1183 ucontrol approach .DOME_X .DOME_Y 6
  1184 set :processUnit.3:state 3
-    * jump *label287 always
+ 1185 jump *label285 always
  1186 label *label286
  1187 set :processUnit.3:msg ", loading\n"
  1188 label *label287
 
  1212 set :processUnit.3:msg ", waiting\n"
  1213 label *label293
  1214 sensor *tmp477 @unit @totalItems
-    * jump *label294 greaterThan *tmp477 0
+ 1215 jump *label291 greaterThan *tmp477 0
  1216 ucontrol approach .CORE_X .CORE_Y 6
  1217 set :processUnit.3:state 2
  1218 label *label294
 
  1281 set :areUnitsAvailable.2:free 0
  1282 ubind UNIT_TYPE
  1283 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label303 equal :areUnitsAvailable.2:firstUnit null
+ 1284 jump *label315 equal :areUnitsAvailable.2:firstUnit null
  1285 set *tmp513 2
  1286 set :needsFourUnits.3:unit @unit
  1287 sensor *tmp510 :needsFourUnits.3:unit @speed
 
  1298 op or *tmp518 *tmp515 *tmp517
  1299 jump *label311 equal *tmp518 false
  1300 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label313 lessThan :areUnitsAvailable.2:free *tmp513
+ 1301 jump *label312 lessThan :areUnitsAvailable.2:free *tmp513
  1302 set *tmp501 true
  1303 jump *label302 always
  1304 label *label313

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-18 instructions):
 
    51 jump *label20 lessThan :areUnitsAvailable.0:free 2
    52 set *tmp4 true
    53 jump *label10 always
-    * label *label21
-    * label *label22
-    * jump *label20 always
    54 label *label19
    55 op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
    56 label *label20
 
   112 jump *label331 lessThan :areUnitsAvailable.1:free 2
   113 set *tmp36 true
   114 jump *label340 always
-    * label *label328
-    * label *label329
-    * jump *label331 always
   115 label *label330
   116 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   117 label *label331
 
   177 jump *label355 lessThan :areUnitsAvailable.1:free 2
   178 set *tmp36 true
   179 jump *label364 always
-    * label *label352
-    * label *label353
-    * jump *label355 always
   180 label *label354
   181 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   182 label *label355
 
   242 jump *label379 lessThan :areUnitsAvailable.1:free 2
   243 set *tmp36 true
   244 jump *label388 always
-    * label *label376
-    * label *label377
-    * jump *label379 always
   245 label *label378
   246 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   247 label *label379
 
   307 jump *label403 lessThan :areUnitsAvailable.1:free 2
   308 set *tmp36 true
   309 jump *label412 always
-    * label *label400
-    * label *label401
-    * jump *label403 always
   310 label *label402
   311 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   312 label *label403
 
   351 printflush message1
   352 label *label8
   353 jump *label7 always
-    * label *label9
-    * set *tmp3 null
   354 label *label6
   355 print "[gold]Binding units..."
   356 printflush message1
 
  1284 jump *label312 lessThan :areUnitsAvailable.2:free *tmp513
  1285 set *tmp501 true
  1286 jump *label302 always
-    * label *label313
-    * label *label314
-    * jump *label312 always
  1287 label *label311
  1288 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1289 label *label312
 
  1298 label *label303
  1299 label *label304
  1300 jump *label315 always
-    * print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.2:free
-    * jump *label317 lessThanEq :areUnitsAvailable.2:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.2:needed
-    * label *label317
-    * label *label318
-    * print "\n"
  1301 label *label315
  1302 label *label316
  1303 set *tmp501 false

Modifications by Final phase, Dead Code Elimination, iteration 1 (-6 instructions):
 
    36 set :areUnitsAvailable.0:firstUnit @unit
    37 jump *label11 equal :areUnitsAvailable.0:firstUnit null
    38 set :needsFourUnits.0:unit @unit
-    * sensor *tmp13 :needsFourUnits.0:unit @speed
    39 label *label13
    40 label *label15
    41 set :areUnitsAvailable.0:needed 2
 
    96 set :areUnitsAvailable.1:firstUnit @unit
    97 jump *label334 equal :areUnitsAvailable.1:firstUnit null
    98 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
    99 label *label325
   100 label *label326
   101 set :areUnitsAvailable.1:needed 2
 
   160 set :areUnitsAvailable.1:firstUnit @unit
   161 jump *label358 equal :areUnitsAvailable.1:firstUnit null
   162 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   163 label *label349
   164 label *label350
   165 set :areUnitsAvailable.1:needed 2
 
   224 set :areUnitsAvailable.1:firstUnit @unit
   225 jump *label382 equal :areUnitsAvailable.1:firstUnit null
   226 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   227 label *label373
   228 label *label374
   229 set :areUnitsAvailable.1:needed 2
 
   288 set :areUnitsAvailable.1:firstUnit @unit
   289 jump *label406 equal :areUnitsAvailable.1:firstUnit null
   290 set :needsFourUnits.1:unit @unit
-    * sensor *tmp45 :needsFourUnits.1:unit @speed
   291 label *label397
   292 label *label398
   293 set :areUnitsAvailable.1:needed 2
 
   488 op sub *tmp141 .DOME_Y .CORE_Y
   489 op len *tmp142 *tmp140 *tmp141
   490 op mul *tmp143 2 *tmp142
-    * sensor *tmp144 .UNIT_S1 @speed
   491 op div :needsFourUnits.2:travel_time *tmp143 .SPEED
   492 op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
   493 label *label102

Modifications by Final phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
    35 ubind UNIT_TYPE
    36 set :areUnitsAvailable.0:firstUnit @unit
    37 jump *label11 equal :areUnitsAvailable.0:firstUnit null
-    * set :needsFourUnits.0:unit @unit
    38 label *label13
    39 label *label15
    40 set :areUnitsAvailable.0:needed 2
 
    94 ubind @flare
    95 set :areUnitsAvailable.1:firstUnit @unit
    96 jump *label334 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
    97 label *label325
    98 label *label326
    99 set :areUnitsAvailable.1:needed 2
 
   157 ubind @poly
   158 set :areUnitsAvailable.1:firstUnit @unit
   159 jump *label358 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
   160 label *label349
   161 label *label350
   162 set :areUnitsAvailable.1:needed 2
 
   220 ubind @mega
   221 set :areUnitsAvailable.1:firstUnit @unit
   222 jump *label382 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
   223 label *label373
   224 label *label374
   225 set :areUnitsAvailable.1:needed 2
 
   283 ubind @mono
   284 set :areUnitsAvailable.1:firstUnit @unit
   285 jump *label406 equal :areUnitsAvailable.1:firstUnit null
-    * set :needsFourUnits.1:unit @unit
   286 label *label397
   287 label *label398
   288 set :areUnitsAvailable.1:needed 2

Modifications by Final phase, Single Step Elimination, iteration 1 (-2 instructions):
 
  1286 label *label310
  1287 label *label303
  1288 label *label304
-    * jump *label315 always
  1289 label *label315
  1290 label *label316
  1291 set *tmp501 false
 
  1301 sensor *tmp211 switch1 @enabled
  1302 jump *label323 notEqual *tmp211 false
  1303 label *label137
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-83 instructions):
 
    16 sensor *tmp1 switch1 @enabled
    17 jump *label5 notEqual *tmp1 false
    18 label *label322
-    * print "[coral]Activate switch to begin supplying overdrive dome..."
-    * print "\n"
+   19 print "[coral]Activate switch to begin supplying overdrive dome...\n"
    20 printflush message1
    21 label *label4
    22 sensor *tmp1 switch1 @enabled
 
    24 label *label5
    25 label *label7
    26 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   27 print "[gold]Looking for suitable unit type:[]\n"
    28 remark "chooseUnitType: "
    29 remark UNIT_TYPE
    30 set :areUnitsAvailable.0:needed 0
 
    61 label *label11
    62 label *label12
    63 print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.0:occupied
-    * print ","
-    * print " free: "
+   64 print ": occupied: {0}, free: "
+   65 format :areUnitsAvailable.0:occupied
    66 print :areUnitsAvailable.0:free
    67 jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
    68 print ", needed: "
 
    81 label *label28
    82 label *label324
    83 jump *label343 equal @flare UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @flare
+   84 remark "chooseUnitType: flare"
    85 set :areUnitsAvailable.1:needed 0
    86 set :areUnitsAvailable.1:occupied 0
    87 set :areUnitsAvailable.1:free 0
 
   115 label *label333
   116 label *label334
   117 label *label335
-    * print @flare
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  118 print "flare: occupied: {0}, free: "
+  119 format :areUnitsAvailable.1:occupied
   120 print :areUnitsAvailable.1:free
   121 jump *label336 lessThanEq :areUnitsAvailable.1:needed 0
   122 print ", needed: "
 
   139 label *label345
   140 label *label348
   141 jump *label367 equal @poly UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @poly
+  142 remark "chooseUnitType: poly"
   143 set :areUnitsAvailable.1:needed 0
   144 set :areUnitsAvailable.1:occupied 0
   145 set :areUnitsAvailable.1:free 0
 
   173 label *label357
   174 label *label358
   175 label *label359
-    * print @poly
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  176 print "poly: occupied: {0}, free: "
+  177 format :areUnitsAvailable.1:occupied
   178 print :areUnitsAvailable.1:free
   179 jump *label360 lessThanEq :areUnitsAvailable.1:needed 0
   180 print ", needed: "
 
   197 label *label369
   198 label *label372
   199 jump *label391 equal @mega UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @mega
+  200 remark "chooseUnitType: mega"
   201 set :areUnitsAvailable.1:needed 0
   202 set :areUnitsAvailable.1:occupied 0
   203 set :areUnitsAvailable.1:free 0
 
   231 label *label381
   232 label *label382
   233 label *label383
-    * print @mega
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  234 print "mega: occupied: {0}, free: "
+  235 format :areUnitsAvailable.1:occupied
   236 print :areUnitsAvailable.1:free
   237 jump *label384 lessThanEq :areUnitsAvailable.1:needed 0
   238 print ", needed: "
 
   255 label *label393
   256 label *label396
   257 jump *label415 equal @mono UNIT_TYPE
-    * remark "chooseUnitType: "
-    * remark @mono
+  258 remark "chooseUnitType: mono"
   259 set :areUnitsAvailable.1:needed 0
   260 set :areUnitsAvailable.1:occupied 0
   261 set :areUnitsAvailable.1:free 0
 
   289 label *label405
   290 label *label406
   291 label *label407
-    * print @mono
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  292 print "mono: occupied: {0}, free: "
+  293 format :areUnitsAvailable.1:occupied
   294 print :areUnitsAvailable.1:free
   295 jump *label408 lessThanEq :areUnitsAvailable.1:needed 0
   296 print ", needed: "
 
   582 jump __start__ equal *tmp211 false
   583 label *label323
   584 set :start @time
-    * print " === [gold]Supplying Overdrive Dome[] === "
-    * print "\n"
-    * print "\n"
-    * print "Unit type: [green]"
-    * print *tmp3
-    * print "["
-    * print "]"
-    * print "\n"
-    * print "\n[green]Silicon[] status:\n"
+  585 print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
+  586 format *tmp3
   587 sensor :printDomeStatus.0:level .DOME @silicon
   588 jump *label139 lessThanEq :printDomeStatus.0:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.0:level
-    * print "["
-    * print "]"
-    * print "\n"
+  589 print "  dome:  [green]{0}[]\n"
+  590 format :printDomeStatus.0:level
   591 jump *label140 always
   592 label *label139
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.0:level
-    * print "["
-    * print "]"
-    * print "\n"
+  593 print "  dome:  [coral]{0}[]\n"
+  594 format :printDomeStatus.0:level
   595 label *label140
   596 label *label138
   597 jump *label143 equal .UNIT_S1 null
 
   713 label *label169
   714 ucontrol flag :processUnit.0:state
   715 sensor *tmp279 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp279
-    * print "["
-    * print "]"
+  716 print "  {0}: [gold]{0}[]"
+  717 format .GROUP1
+  718 format *tmp279
   719 jump *label176 lessThan :processUnit.0:distance 0
   720 print :processUnit.0:msg
   721 print :processUnit.0:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  722 print "[] sec\n"
   723 jump *label177 always
   724 label *label176
   725 print :processUnit.0:msg
 
   848 label *label208
   849 ucontrol flag :processUnit.1:state
   850 sensor *tmp346 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp346
-    * print "["
-    * print "]"
+  851 print "  {0}: [gold]{0}[]"
+  852 format .GROUP2
+  853 format *tmp346
   854 jump *label215 lessThan :processUnit.1:distance 0
   855 print :processUnit.1:msg
   856 print :processUnit.1:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  857 print "[] sec\n"
   858 jump *label216 always
   859 label *label215
   860 print :processUnit.1:msg
 
   875 print "\n[green]Phase fabric[] status:\n"
   876 sensor :printDomeStatus.1:level .DOME @phase-fabric
   877 jump *label220 lessThanEq :printDomeStatus.1:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  878 print "  dome:  [green]{0}[]\n"
+  879 format :printDomeStatus.1:level
   880 jump *label221 always
   881 label *label220
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  882 print "  dome:  [coral]{0}[]\n"
+  883 format :printDomeStatus.1:level
   884 label *label221
   885 label *label219
   886 jump *label224 equal .UNIT_P1 null
 
  1002 label *label250
  1003 ucontrol flag :processUnit.2:state
  1004 sensor *tmp420 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp420
-    * print "["
-    * print "]"
+ 1005 print "  {0}: [gold]{0}[]"
+ 1006 format .GROUP1
+ 1007 format *tmp420
  1008 jump *label257 lessThan :processUnit.2:distance 0
  1009 print :processUnit.2:msg
  1010 print :processUnit.2:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1011 print "[] sec\n"
  1012 jump *label258 always
  1013 label *label257
  1014 print :processUnit.2:msg
 
  1137 label *label289
  1138 ucontrol flag :processUnit.3:state
  1139 sensor *tmp487 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp487
-    * print "["
-    * print "]"
+ 1140 print "  {0}: [gold]{0}[]"
+ 1141 format .GROUP2
+ 1142 format *tmp487
  1143 jump *label296 lessThan :processUnit.3:distance 0
  1144 print :processUnit.3:msg
  1145 print :processUnit.3:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1146 print "[] sec\n"
  1147 jump *label297 always
  1148 label *label296
  1149 print :processUnit.3:msg
 
  1163 label *label260
  1164 op sub *tmp495 @time :start
  1165 op floor *tmp496 *tmp495
-    * print "\n"
-    * print "[lightgray]Loop time: "
-    * print *tmp496
-    * print " "
-    * print "ms"
+ 1166 print "\n[lightgray]Loop time: {0} ms"
+ 1167 format *tmp496
  1168 printflush message1
  1169 op notEqual *tmp497 *tmp3 UNIT_TYPE
  1170 op greaterThan *tmp498 :unitCheck @time

Final code before resolving virtual instructions:

label __start__
remark "This is the preferred unit type to use for bringing in supplies."
remark "If no units of this type exist, we'll try using other types."
set UNIT_TYPE @flare
remark "Do not modify anything below this line."
set .DOME dome1
jump *label2 notEqual dome1 null
label *label321
print "[gold]Waiting for an overdrive dome to be connected..."
printflush message1
set .DOME dome1
jump *label321 equal dome1 null
label *label2
sensor *tmp1 switch1 @enabled
jump *label5 notEqual *tmp1 false
label *label322
print "[coral]Activate switch to begin supplying overdrive dome...\n"
printflush message1
sensor *tmp1 switch1 @enabled
jump *label322 equal *tmp1 false
label *label5
label *label7
printflush null
print "[gold]Looking for suitable unit type:[]\n"
remark "chooseUnitType: "
remark UNIT_TYPE
set :areUnitsAvailable.0:needed 0
set :areUnitsAvailable.0:occupied 0
set :areUnitsAvailable.0:free 0
ubind UNIT_TYPE
set :areUnitsAvailable.0:firstUnit @unit
jump *label11 equal :areUnitsAvailable.0:firstUnit null
set :areUnitsAvailable.0:needed 2
label *label16
sensor *tmp17 @unit @controlled
op equal *tmp18 *tmp17 0
sensor *tmp19 @unit @controller
op equal *tmp20 *tmp19 @this
op or *tmp21 *tmp18 *tmp20
jump *label19 equal *tmp21 false
op add :areUnitsAvailable.0:free :areUnitsAvailable.0:free 1
jump *label20 lessThan :areUnitsAvailable.0:free 2
set *tmp4 true
jump *label10 always
label *label19
op add :areUnitsAvailable.0:occupied :areUnitsAvailable.0:occupied 1
label *label20
ubind UNIT_TYPE
op notEqual *tmp25 @unit :areUnitsAvailable.0:firstUnit
sensor *tmp26 :areUnitsAvailable.0:firstUnit @dead
op equal *tmp27 *tmp26 0
op land *tmp28 *tmp25 *tmp27
jump *label16 notEqual *tmp28 false
label *label11
print UNIT_TYPE
print ": occupied: {0}, free: "
format :areUnitsAvailable.0:occupied
print :areUnitsAvailable.0:free
jump *label25 lessThanEq :areUnitsAvailable.0:needed 0
print ", needed: "
print :areUnitsAvailable.0:needed
label *label25
print "\n"
set *tmp4 false
label *label10
jump *label27 equal *tmp4 false
set *tmp3 UNIT_TYPE
jump *label6 always
label *label27
jump *label343 equal @flare UNIT_TYPE
remark "chooseUnitType: flare"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @flare
set :areUnitsAvailable.1:firstUnit @unit
jump *label334 equal :areUnitsAvailable.1:firstUnit null
set :areUnitsAvailable.1:needed 2
label *label327
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label330 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label331 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label340 always
label *label330
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label331
ubind @flare
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label327 notEqual *tmp60 false
label *label334
print "flare: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label336 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label336
print "\n"
set *tmp36 false
label *label340
jump *label341 equal *tmp36 false
printflush null
set *tmp3 @flare
jump *label6 always
label *label341
label *label343
jump *label367 equal @poly UNIT_TYPE
remark "chooseUnitType: poly"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @poly
set :areUnitsAvailable.1:firstUnit @unit
jump *label358 equal :areUnitsAvailable.1:firstUnit null
set :areUnitsAvailable.1:needed 2
label *label351
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label354 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label355 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label364 always
label *label354
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label355
ubind @poly
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label351 notEqual *tmp60 false
label *label358
print "poly: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label360 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label360
print "\n"
set *tmp36 false
label *label364
jump *label365 equal *tmp36 false
printflush null
set *tmp3 @poly
jump *label6 always
label *label365
label *label367
jump *label391 equal @mega UNIT_TYPE
remark "chooseUnitType: mega"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @mega
set :areUnitsAvailable.1:firstUnit @unit
jump *label382 equal :areUnitsAvailable.1:firstUnit null
set :areUnitsAvailable.1:needed 2
label *label375
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label378 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label379 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label388 always
label *label378
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label379
ubind @mega
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label375 notEqual *tmp60 false
label *label382
print "mega: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label384 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label384
print "\n"
set *tmp36 false
label *label388
jump *label389 equal *tmp36 false
printflush null
set *tmp3 @mega
jump *label6 always
label *label389
label *label391
jump *label415 equal @mono UNIT_TYPE
remark "chooseUnitType: mono"
set :areUnitsAvailable.1:needed 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:free 0
ubind @mono
set :areUnitsAvailable.1:firstUnit @unit
jump *label406 equal :areUnitsAvailable.1:firstUnit null
set :areUnitsAvailable.1:needed 2
label *label399
sensor *tmp49 @unit @controlled
op equal *tmp50 *tmp49 0
sensor *tmp51 @unit @controller
op equal *tmp52 *tmp51 @this
op or *tmp53 *tmp50 *tmp52
jump *label402 equal *tmp53 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label403 lessThan :areUnitsAvailable.1:free 2
set *tmp36 true
jump *label412 always
label *label402
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label403
ubind @mono
op notEqual *tmp57 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp58 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp59 *tmp58 0
op land *tmp60 *tmp57 *tmp59
jump *label399 notEqual *tmp60 false
label *label406
print "mono: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label408 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label408
print "\n"
set *tmp36 false
label *label412
jump *label413 equal *tmp36 false
printflush null
set *tmp3 @mono
jump *label6 always
label *label413
label *label415
printflush message1
jump *label7 always
label *label6
print "[gold]Binding units..."
printflush message1
set .UNIT_P2 null
set .UNIT_S2 null
set .UNIT_P1 null
set .UNIT_S1 null
set :rebindUnits.0:count 0
ubind *tmp3
set :rebindUnits.0:firstUnit @unit
jump *label60 notEqual :rebindUnits.0:firstUnit null
end
label *label60
label *label62
sensor *tmp69 @unit @controller
jump *label65 notEqual *tmp69 @this
op add :rebindUnits.0:count :rebindUnits.0:count 1
ucontrol flag 1
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 .UNIT_P1
set .UNIT_P1 @unit
jump *label64 notEqual .UNIT_S2 null
label *label65
ubind *tmp3
op notEqual *tmp75 @unit :rebindUnits.0:firstUnit
sensor *tmp76 :rebindUnits.0:firstUnit @dead
op equal *tmp77 *tmp76 0
op land *tmp78 *tmp75 *tmp77
jump *label62 notEqual *tmp78 false
label *label64
jump *label71 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp83 @unit @dead
op strictEqual *tmp84 *tmp83 0
sensor *tmp85 @unit @controller
op equal *tmp86 *tmp85 @this
op land *tmp87 *tmp84 *tmp86
jump *label70 notEqual *tmp87 false
label *label71
ubind *tmp3
set :rebindUnit.0:firstUnit @unit
jump __start__ equal :rebindUnit.0:firstUnit null
label *label77
sensor *tmp92 @unit @controlled
jump *label70 equal *tmp92 0
ubind *tmp3
op notEqual *tmp95 @unit :rebindUnit.0:firstUnit
sensor *tmp96 :rebindUnit.0:firstUnit @dead
op equal *tmp97 *tmp96 0
op land *tmp98 *tmp95 *tmp97
jump *label77 notEqual *tmp98 false
end
label *label70
ucontrol flag 1
set *tmp79 @unit
set .UNIT_S1 *tmp79
jump *label84 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp103 @unit @dead
op strictEqual *tmp104 *tmp103 0
sensor *tmp105 @unit @controller
op equal *tmp106 *tmp105 @this
op land *tmp107 *tmp104 *tmp106
jump *label83 notEqual *tmp107 false
label *label84
ubind *tmp3
set :rebindUnit.1:firstUnit @unit
jump __start__ equal :rebindUnit.1:firstUnit null
label *label90
sensor *tmp112 @unit @controlled
jump *label83 equal *tmp112 0
ubind *tmp3
op notEqual *tmp115 @unit :rebindUnit.1:firstUnit
sensor *tmp116 :rebindUnit.1:firstUnit @dead
op equal *tmp117 *tmp116 0
op land *tmp118 *tmp115 *tmp117
jump *label90 notEqual *tmp118 false
end
label *label83
ucontrol flag 1
set *tmp99 @unit
set .UNIT_P1 *tmp99
sensor *tmp119 *tmp79 @firstItem
op equal *tmp120 *tmp119 @phase-fabric
sensor *tmp121 *tmp99 @firstItem
op equal *tmp122 *tmp121 @silicon
op or *tmp123 *tmp120 *tmp122
jump *label95 equal *tmp123 false
set .UNIT_S1 *tmp99
set .UNIT_P1 *tmp79
label *label95
sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
sensor .SPEED .UNIT_S1 @speed
op div .SPEED_TENTHS .SPEED 10
op strictEqual *tmp128 .SPEED null
jump *label97 equal *tmp128 false
stop
label *label97
print "[gold]Locating core..."
printflush message1
label *label99
ulocate building core false @copper 0 0 0 .CORE
jump *label99 equal .CORE null
sensor .CORE_X .CORE @x
sensor .CORE_Y .CORE @y
sensor .DOME_X .DOME @x
sensor .DOME_Y .DOME @y
op sub *tmp140 .DOME_X .CORE_X
op sub *tmp141 .DOME_Y .CORE_Y
op len *tmp142 *tmp140 *tmp141
op mul *tmp143 2 *tmp142
op div :needsFourUnits.2:travel_time *tmp143 .SPEED
op greaterThanEq *tmp139 :needsFourUnits.2:travel_time 47
jump *label103 equal *tmp139 false
jump *label107 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp152 @unit @dead
op strictEqual *tmp153 *tmp152 0
sensor *tmp154 @unit @controller
op equal *tmp155 *tmp154 @this
op land *tmp156 *tmp153 *tmp155
jump *label106 notEqual *tmp156 false
label *label107
ubind *tmp3
set :rebindUnit.2:firstUnit @unit
jump __start__ equal :rebindUnit.2:firstUnit null
label *label113
sensor *tmp161 @unit @controlled
jump *label106 equal *tmp161 0
ubind *tmp3
op notEqual *tmp164 @unit :rebindUnit.2:firstUnit
sensor *tmp165 :rebindUnit.2:firstUnit @dead
op equal *tmp166 *tmp165 0
op land *tmp167 *tmp164 *tmp166
jump *label113 notEqual *tmp167 false
end
label *label106
ucontrol flag 1
set *tmp148 @unit
set .UNIT_S2 *tmp148
jump *label120 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp172 @unit @dead
op strictEqual *tmp173 *tmp172 0
sensor *tmp174 @unit @controller
op equal *tmp175 *tmp174 @this
op land *tmp176 *tmp173 *tmp175
jump *label119 notEqual *tmp176 false
label *label120
ubind *tmp3
set :rebindUnit.3:firstUnit @unit
jump __start__ equal :rebindUnit.3:firstUnit null
label *label126
sensor *tmp181 @unit @controlled
jump *label119 equal *tmp181 0
ubind *tmp3
op notEqual *tmp184 @unit :rebindUnit.3:firstUnit
sensor *tmp185 :rebindUnit.3:firstUnit @dead
op equal *tmp186 *tmp185 0
op land *tmp187 *tmp184 *tmp186
jump *label126 notEqual *tmp187 false
end
label *label119
ucontrol flag 1
set *tmp168 @unit
set .UNIT_P2 *tmp168
sensor *tmp188 .UNIT_S1 @firstItem
op equal *tmp189 *tmp188 @phase-fabric
sensor *tmp190 *tmp168 @firstItem
op notEqual *tmp191 *tmp190 @phase-fabric
op land *tmp192 *tmp189 *tmp191
jump *label131 equal *tmp192 false
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 *tmp168
label *label131
sensor *tmp194 *tmp148 @firstItem
op equal *tmp195 *tmp194 @phase-fabric
sensor *tmp196 .UNIT_P2 @firstItem
op equal *tmp197 *tmp196 @silicon
op or *tmp198 *tmp195 *tmp197
jump *label133 equal *tmp198 false
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 *tmp148
label *label133
set .GROUP1 "unit  1"
set .GROUP2 "unit 2"
jump *label104 always
label *label103
ubind .UNIT_S2
ucontrol unbind
set .UNIT_S2 null
ubind .UNIT_P2
ucontrol unbind
set .UNIT_P2 null
set .GROUP1 "unit"
set .GROUP2 ""
label *label104
op equal *tmp200 *tmp139 false
sensor *tmp201 .UNIT_S1 @totalItems
sensor *tmp202 .UNIT_S2 @totalItems
op lessThan *tmp203 *tmp201 *tmp202
op or .SUPPLY_S_FIRST *tmp200 *tmp203
sensor *tmp206 .UNIT_P1 @totalItems
sensor *tmp207 .UNIT_P2 @totalItems
op lessThan *tmp208 *tmp206 *tmp207
op or .SUPPLY_P_FIRST *tmp200 *tmp208
op add :unitCheck @time 5000
sensor *tmp211 switch1 @enabled
jump __start__ equal *tmp211 false
label *label323
set :start @time
print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
format *tmp3
sensor :printDomeStatus.0:level .DOME @silicon
jump *label139 lessThanEq :printDomeStatus.0:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.0:level
jump *label140 always
label *label139
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.0:level
label *label140
jump *label143 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp221 @unit @dead
op strictEqual *tmp222 *tmp221 0
sensor *tmp223 @unit @controller
op equal *tmp224 *tmp223 @this
op land *tmp225 *tmp222 *tmp224
jump *label142 notEqual *tmp225 false
label *label143
ubind *tmp3
set :rebindUnit.4:firstUnit @unit
jump __start__ equal :rebindUnit.4:firstUnit null
label *label149
sensor *tmp230 @unit @controlled
jump *label142 equal *tmp230 0
ubind *tmp3
op notEqual *tmp233 @unit :rebindUnit.4:firstUnit
sensor *tmp234 :rebindUnit.4:firstUnit @dead
op equal *tmp235 *tmp234 0
op land *tmp236 *tmp233 *tmp235
jump *label149 notEqual *tmp236 false
end
label *label142
set :processUnit.0:msg ""
sensor :processUnit.0:state @unit @flag
set :processUnit.0:distance -1
op lessThan *tmp238 :processUnit.0:state 2
op greaterThan *tmp239 :processUnit.0:state 3
op or *tmp240 *tmp238 *tmp239
jump *label154 equal *tmp240 false
sensor *tmp242 @unit @firstItem
jump *label156 notEqual *tmp242 @silicon
set :processUnit.0:state 3
jump *label157 always
label *label156
sensor *tmp245 @unit @totalItems
jump *label158 notEqual *tmp245 0
set :processUnit.0:state 2
jump *label159 always
label *label158
set :processUnit.0:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp248
jump *label160 equal *tmp248 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label160
label *label159
label *label157
label *label154
jump *label162 notEqual :processUnit.0:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp252
jump *label164 equal *tmp252 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp254 @unit @totalItems
jump *label166 lessThan *tmp254 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.0:state 3
jump *label165 always
label *label166
set :processUnit.0:msg ", loading\n"
jump *label165 always
label *label164
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.0:msg ", fetching in [gold]"
sensor *tmp257 @unit @x
op sub *tmp258 .CORE_X *tmp257
sensor *tmp259 @unit @y
op sub *tmp260 .CORE_Y *tmp259
op len *tmp261 *tmp258 *tmp260
op idiv *tmp262 *tmp261 .SPEED_TENTHS
op div :processUnit.0:distance *tmp262 10
label *label165
label *label162
jump *label168 notEqual :processUnit.0:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp266
jump *label170 equal *tmp266 false
jump *label172 equal .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.0:msg ", supplying\n"
jump *label173 always
label *label172
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.0:msg ", waiting\n"
label *label173
sensor *tmp269 @unit @totalItems
jump *label171 greaterThan *tmp269 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.0:state 2
jump *label171 always
label *label170
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.0:msg ", returning in [gold]"
sensor *tmp272 @unit @x
op sub *tmp273 .DOME_X *tmp272
sensor *tmp274 @unit @y
op sub *tmp275 .DOME_Y *tmp274
op len *tmp276 *tmp273 *tmp275
op idiv *tmp277 *tmp276 .SPEED_TENTHS
op div :processUnit.0:distance *tmp277 10
label *label171
label *label168
ucontrol flag :processUnit.0:state
sensor *tmp279 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp279
jump *label176 lessThan :processUnit.0:distance 0
print :processUnit.0:msg
print :processUnit.0:distance
print "[] sec\n"
jump *label177 always
label *label176
print :processUnit.0:msg
label *label177
set *tmp217 @unit
set .UNIT_S1 *tmp217
jump *label178 equal *tmp139 false
op equal *tmp283 .SUPPLY_S_FIRST false
jump *label182 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp288 @unit @dead
op strictEqual *tmp289 *tmp288 0
sensor *tmp290 @unit @controller
op equal *tmp291 *tmp290 @this
op land *tmp292 *tmp289 *tmp291
jump *label181 notEqual *tmp292 false
label *label182
ubind *tmp3
set :rebindUnit.5:firstUnit @unit
jump __start__ equal :rebindUnit.5:firstUnit null
label *label188
sensor *tmp297 @unit @controlled
jump *label181 equal *tmp297 0
ubind *tmp3
op notEqual *tmp300 @unit :rebindUnit.5:firstUnit
sensor *tmp301 :rebindUnit.5:firstUnit @dead
op equal *tmp302 *tmp301 0
op land *tmp303 *tmp300 *tmp302
jump *label188 notEqual *tmp303 false
end
label *label181
set :processUnit.1:msg ""
sensor :processUnit.1:state @unit @flag
set :processUnit.1:distance -1
op lessThan *tmp305 :processUnit.1:state 2
op greaterThan *tmp306 :processUnit.1:state 3
op or *tmp307 *tmp305 *tmp306
jump *label193 equal *tmp307 false
sensor *tmp309 @unit @firstItem
jump *label195 notEqual *tmp309 @silicon
set :processUnit.1:state 3
jump *label196 always
label *label195
sensor *tmp312 @unit @totalItems
jump *label197 notEqual *tmp312 0
set :processUnit.1:state 2
jump *label198 always
label *label197
set :processUnit.1:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp315
jump *label199 equal *tmp315 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label199
label *label198
label *label196
label *label193
jump *label201 notEqual :processUnit.1:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp319
jump *label203 equal *tmp319 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp321 @unit @totalItems
jump *label205 lessThan *tmp321 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:state 3
jump *label204 always
label *label205
set :processUnit.1:msg ", loading\n"
jump *label204 always
label *label203
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:msg ", fetching in [gold]"
sensor *tmp324 @unit @x
op sub *tmp325 .CORE_X *tmp324
sensor *tmp326 @unit @y
op sub *tmp327 .CORE_Y *tmp326
op len *tmp328 *tmp325 *tmp327
op idiv *tmp329 *tmp328 .SPEED_TENTHS
op div :processUnit.1:distance *tmp329 10
label *label204
label *label201
jump *label207 notEqual :processUnit.1:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp333
jump *label209 equal *tmp333 false
jump *label211 equal *tmp283 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.1:msg ", supplying\n"
jump *label212 always
label *label211
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:msg ", waiting\n"
label *label212
sensor *tmp336 @unit @totalItems
jump *label210 greaterThan *tmp336 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:state 2
jump *label210 always
label *label209
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:msg ", returning in [gold]"
sensor *tmp339 @unit @x
op sub *tmp340 .DOME_X *tmp339
sensor *tmp341 @unit @y
op sub *tmp342 .DOME_Y *tmp341
op len *tmp343 *tmp340 *tmp342
op idiv *tmp344 *tmp343 .SPEED_TENTHS
op div :processUnit.1:distance *tmp344 10
label *label210
label *label207
ucontrol flag :processUnit.1:state
sensor *tmp346 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp346
jump *label215 lessThan :processUnit.1:distance 0
print :processUnit.1:msg
print :processUnit.1:distance
print "[] sec\n"
jump *label216 always
label *label215
print :processUnit.1:msg
label *label216
set *tmp284 @unit
set .UNIT_S2 *tmp284
jump *label217 equal .SUPPLY_S_FIRST false
sensor *tmp350 *tmp217 @totalItems
op greaterThan .SUPPLY_S_FIRST *tmp350 0
jump *label218 always
label *label217
sensor *tmp352 *tmp284 @totalItems
op equal .SUPPLY_S_FIRST *tmp352 0
label *label218
label *label178
print "\n[green]Phase fabric[] status:\n"
sensor :printDomeStatus.1:level .DOME @phase-fabric
jump *label220 lessThanEq :printDomeStatus.1:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.1:level
jump *label221 always
label *label220
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.1:level
label *label221
jump *label224 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp362 @unit @dead
op strictEqual *tmp363 *tmp362 0
sensor *tmp364 @unit @controller
op equal *tmp365 *tmp364 @this
op land *tmp366 *tmp363 *tmp365
jump *label223 notEqual *tmp366 false
label *label224
ubind *tmp3
set :rebindUnit.6:firstUnit @unit
jump __start__ equal :rebindUnit.6:firstUnit null
label *label230
sensor *tmp371 @unit @controlled
jump *label223 equal *tmp371 0
ubind *tmp3
op notEqual *tmp374 @unit :rebindUnit.6:firstUnit
sensor *tmp375 :rebindUnit.6:firstUnit @dead
op equal *tmp376 *tmp375 0
op land *tmp377 *tmp374 *tmp376
jump *label230 notEqual *tmp377 false
end
label *label223
set :processUnit.2:msg ""
sensor :processUnit.2:state @unit @flag
set :processUnit.2:distance -1
op lessThan *tmp379 :processUnit.2:state 2
op greaterThan *tmp380 :processUnit.2:state 3
op or *tmp381 *tmp379 *tmp380
jump *label235 equal *tmp381 false
sensor *tmp383 @unit @firstItem
jump *label237 notEqual *tmp383 @phase-fabric
set :processUnit.2:state 3
jump *label238 always
label *label237
sensor *tmp386 @unit @totalItems
jump *label239 notEqual *tmp386 0
set :processUnit.2:state 2
jump *label240 always
label *label239
set :processUnit.2:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp389
jump *label241 equal *tmp389 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label241
label *label240
label *label238
label *label235
jump *label243 notEqual :processUnit.2:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp393
jump *label245 equal *tmp393 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp395 @unit @totalItems
jump *label247 lessThan *tmp395 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:state 3
jump *label246 always
label *label247
set :processUnit.2:msg ", loading\n"
jump *label246 always
label *label245
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:msg ", fetching in [gold]"
sensor *tmp398 @unit @x
op sub *tmp399 .CORE_X *tmp398
sensor *tmp400 @unit @y
op sub *tmp401 .CORE_Y *tmp400
op len *tmp402 *tmp399 *tmp401
op idiv *tmp403 *tmp402 .SPEED_TENTHS
op div :processUnit.2:distance *tmp403 10
label *label246
label *label243
jump *label249 notEqual :processUnit.2:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp407
jump *label251 equal *tmp407 false
jump *label253 equal .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.2:msg ", supplying\n"
jump *label254 always
label *label253
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:msg ", waiting\n"
label *label254
sensor *tmp410 @unit @totalItems
jump *label252 greaterThan *tmp410 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:state 2
jump *label252 always
label *label251
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:msg ", returning in [gold]"
sensor *tmp413 @unit @x
op sub *tmp414 .DOME_X *tmp413
sensor *tmp415 @unit @y
op sub *tmp416 .DOME_Y *tmp415
op len *tmp417 *tmp414 *tmp416
op idiv *tmp418 *tmp417 .SPEED_TENTHS
op div :processUnit.2:distance *tmp418 10
label *label252
label *label249
ucontrol flag :processUnit.2:state
sensor *tmp420 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp420
jump *label257 lessThan :processUnit.2:distance 0
print :processUnit.2:msg
print :processUnit.2:distance
print "[] sec\n"
jump *label258 always
label *label257
print :processUnit.2:msg
label *label258
set *tmp358 @unit
set .UNIT_P1 *tmp358
jump *label259 equal *tmp139 false
op equal *tmp424 .SUPPLY_P_FIRST false
jump *label263 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp429 @unit @dead
op strictEqual *tmp430 *tmp429 0
sensor *tmp431 @unit @controller
op equal *tmp432 *tmp431 @this
op land *tmp433 *tmp430 *tmp432
jump *label262 notEqual *tmp433 false
label *label263
ubind *tmp3
set :rebindUnit.7:firstUnit @unit
jump __start__ equal :rebindUnit.7:firstUnit null
label *label269
sensor *tmp438 @unit @controlled
jump *label262 equal *tmp438 0
ubind *tmp3
op notEqual *tmp441 @unit :rebindUnit.7:firstUnit
sensor *tmp442 :rebindUnit.7:firstUnit @dead
op equal *tmp443 *tmp442 0
op land *tmp444 *tmp441 *tmp443
jump *label269 notEqual *tmp444 false
end
label *label262
set :processUnit.3:msg ""
sensor :processUnit.3:state @unit @flag
set :processUnit.3:distance -1
op lessThan *tmp446 :processUnit.3:state 2
op greaterThan *tmp447 :processUnit.3:state 3
op or *tmp448 *tmp446 *tmp447
jump *label274 equal *tmp448 false
sensor *tmp450 @unit @firstItem
jump *label276 notEqual *tmp450 @phase-fabric
set :processUnit.3:state 3
jump *label277 always
label *label276
sensor *tmp453 @unit @totalItems
jump *label278 notEqual *tmp453 0
set :processUnit.3:state 2
jump *label279 always
label *label278
set :processUnit.3:msg ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp456
jump *label280 equal *tmp456 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label280
label *label279
label *label277
label *label274
jump *label282 notEqual :processUnit.3:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp460
jump *label284 equal *tmp460 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp462 @unit @totalItems
jump *label286 lessThan *tmp462 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:state 3
jump *label285 always
label *label286
set :processUnit.3:msg ", loading\n"
jump *label285 always
label *label284
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:msg ", fetching in [gold]"
sensor *tmp465 @unit @x
op sub *tmp466 .CORE_X *tmp465
sensor *tmp467 @unit @y
op sub *tmp468 .CORE_Y *tmp467
op len *tmp469 *tmp466 *tmp468
op idiv *tmp470 *tmp469 .SPEED_TENTHS
op div :processUnit.3:distance *tmp470 10
label *label285
label *label282
jump *label288 notEqual :processUnit.3:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp474
jump *label290 equal *tmp474 false
jump *label292 equal *tmp424 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set :processUnit.3:msg ", supplying\n"
jump *label293 always
label *label292
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:msg ", waiting\n"
label *label293
sensor *tmp477 @unit @totalItems
jump *label291 greaterThan *tmp477 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:state 2
jump *label291 always
label *label290
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:msg ", returning in [gold]"
sensor *tmp480 @unit @x
op sub *tmp481 .DOME_X *tmp480
sensor *tmp482 @unit @y
op sub *tmp483 .DOME_Y *tmp482
op len *tmp484 *tmp481 *tmp483
op idiv *tmp485 *tmp484 .SPEED_TENTHS
op div :processUnit.3:distance *tmp485 10
label *label291
label *label288
ucontrol flag :processUnit.3:state
sensor *tmp487 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp487
jump *label296 lessThan :processUnit.3:distance 0
print :processUnit.3:msg
print :processUnit.3:distance
print "[] sec\n"
jump *label297 always
label *label296
print :processUnit.3:msg
label *label297
set *tmp425 @unit
set .UNIT_P2 *tmp425
jump *label298 equal .SUPPLY_P_FIRST false
sensor *tmp491 *tmp358 @totalItems
op greaterThan .SUPPLY_P_FIRST *tmp491 0
jump *label299 always
label *label298
sensor *tmp493 *tmp425 @totalItems
op equal .SUPPLY_P_FIRST *tmp493 0
label *label299
label *label259
op sub *tmp495 @time :start
op floor *tmp496 *tmp495
print "\n[lightgray]Loop time: {0} ms"
format *tmp496
printflush message1
op notEqual *tmp497 *tmp3 UNIT_TYPE
op greaterThan *tmp498 :unitCheck @time
op land *tmp499 *tmp497 *tmp498
jump *label300 equal *tmp499 false
set :areUnitsAvailable.2:occupied 0
set :areUnitsAvailable.2:free 0
ubind UNIT_TYPE
set :areUnitsAvailable.2:firstUnit @unit
jump *label315 equal :areUnitsAvailable.2:firstUnit null
set *tmp513 2
set :needsFourUnits.3:unit @unit
sensor *tmp510 :needsFourUnits.3:unit @speed
op div :needsFourUnits.3:travel_time *tmp143 *tmp510
jump *label307 lessThan :needsFourUnits.3:travel_time 47
set *tmp513 4
label *label307
label *label308
sensor *tmp514 @unit @controlled
op equal *tmp515 *tmp514 0
sensor *tmp516 @unit @controller
op equal *tmp517 *tmp516 @this
op or *tmp518 *tmp515 *tmp517
jump *label311 equal *tmp518 false
op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
jump *label312 lessThan :areUnitsAvailable.2:free *tmp513
set *tmp501 true
jump *label302 always
label *label311
op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
label *label312
ubind UNIT_TYPE
op notEqual *tmp522 @unit :areUnitsAvailable.2:firstUnit
sensor *tmp523 :areUnitsAvailable.2:firstUnit @dead
op equal *tmp524 *tmp523 0
op land *tmp525 *tmp522 *tmp524
jump *label308 notEqual *tmp525 false
label *label315
set *tmp501 false
label *label302
jump *label319 equal *tmp501 false
end
label *label319
op add :unitCheck @time 5000
label *label300
sensor *tmp211 switch1 @enabled
jump *label323 notEqual *tmp211 false
