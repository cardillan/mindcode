  1450 instructions before optimizations.
    43 instructions eliminated by Temp Variables Elimination (2 iterations).
   261 instructions eliminated by Dead Code Elimination (2 passes, 9 iterations).
     4 instructions eliminated by Jump Normalization (2 passes, 6 iterations).
    69 instructions eliminated by Jump Optimization (6 iterations).
    93 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
    11 instructions eliminated by If Expression Optimization (3 iterations).
    91 instructions eliminated by Data Flow Optimization (4 passes, 16 iterations).
     2 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
   156 instructions added by Loop Unrolling (7 iterations).
     2 loops unrolled by Loop Unrolling.
    22 instructions eliminated by Jump Straightening (2 passes, 6 iterations).
    24 instructions updated by Jump Threading.
    19 instructions eliminated by Unreachable Code Elimination (3 iterations).
    75 instructions eliminated by Print Merging.
   920 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 187):
    Replicate loop condition at line 54:5                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000
  * Unroll iteration loop at line 169:9                          size    +5, benefit      375.0, efficiency     75.000 (+1 instructions)
  ! Unroll iteration loop at line 201:9                          size  +201, benefit      375.0, efficiency      1.866

Pass 1: speed optimization selection (cost limit 186):
  * Replicate loop condition at line 54:5                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000
  ! Unroll iteration loop at line 201:9                          size  +201, benefit      375.0, efficiency      1.866

Pass 1: speed optimization selection (cost limit 185):
  * Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  ! Unroll iteration loop at line 201:9                          size  +201, benefit      375.0, efficiency      1.866

Pass 1: speed optimization selection (cost limit 184):
  ! Unroll iteration loop at line 201:9                          size  +201, benefit      375.0, efficiency      1.866

Pass 2: speed optimization selection (cost limit 199):
  * Unroll iteration loop at line 201:9                          size  +189, benefit      375.0, efficiency      1.984 (+139 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-173 instructions):
 
    39 call *label0 :locateCore*retaddr :locateCore*retval
    40 jump *label17 equal :locateCore*retval false
    41 jump *label1 always
-    * set *tmp2 null
    42 jump *label18 always
    43 label *label17
-    * set *tmp2 null
    44 label *label18
    45 label *label9
    46 multijump *tmp1 0 0 (m:marker0)
 
   123 label *label37
   124 set *tmp29 null
   125 label *label38
-    * set *tmp27 *tmp29
   126 jump *label36 always
   127 label *label35
   128 set *tmp30 :areUnitsAvailable:occupied
   129 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
-    * set *tmp27 *tmp30
   130 label *label36
   131 ubind :areUnitsAvailable:type
   132 label *label33
 
   136 op land *tmp34 *tmp31 *tmp33
   137 jump *label32 notEqual *tmp34 false
   138 label *label34
-    * set *tmp12 null
   139 jump *label28 always
   140 label *label27
-    * set *tmp12 null
   141 label *label28
   142 jump *label39 equal :areUnitsAvailable:output false
   143 print :areUnitsAvailable:type
 
   151 jump *label41 equal *tmp36 false
   152 print ", needed: "
   153 print :areUnitsAvailable:needed
-    * set *tmp37 null
   154 jump *label42 always
   155 label *label41
-    * set *tmp37 null
   156 label *label42
   157 print "\n"
-    * set *tmp35 null
   158 jump *label40 always
   159 label *label39
-    * set *tmp35 null
   160 label *label40
   161 set *tmp10 false
   162 jump *label26 always
 
   165 jump *label43 equal *tmp10 false
   166 set *tmp9 UNIT_TYPE
   167 jump *label22 always
-    * set *tmp38 null
   168 jump *label44 always
   169 label *label43
-    * set *tmp38 null
   170 label *label44
   171 set :chooseUnitType:type @flare
   172 op add *tmp39 @counter 1
 
   236 label *label67
   237 set *tmp61 null
   238 label *label68
-    * set *tmp59 *tmp61
   239 jump *label66 always
   240 label *label65
   241 set *tmp62 :areUnitsAvailable.1:occupied
   242 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp59 *tmp62
   243 label *label66
   244 ubind :areUnitsAvailable.1:type
   245 label *label63
 
   249 op land *tmp66 *tmp63 *tmp65
   250 jump *label62 notEqual *tmp66 false
   251 label *label64
-    * set *tmp44 null
   252 jump *label58 always
   253 label *label57
-    * set *tmp44 null
   254 label *label58
   255 jump *label69 equal :areUnitsAvailable.1:output false
   256 print :areUnitsAvailable.1:type
 
   264 jump *label71 equal *tmp68 false
   265 print ", needed: "
   266 print :areUnitsAvailable.1:needed
-    * set *tmp69 null
   267 jump *label72 always
   268 label *label71
-    * set *tmp69 null
   269 label *label72
   270 print "\n"
-    * set *tmp67 null
   271 jump *label70 always
   272 label *label69
-    * set *tmp67 null
   273 label *label70
   274 set *tmp42 false
   275 jump *label56 always
 
   284 label *label73
   285 set *tmp70 null
   286 label *label74
-    * set *tmp41 *tmp70
   287 jump *label55 always
   288 label *label54
-    * set *tmp41 null
   289 label *label55
   290 label *label46
   291 multijump *tmp39 0 0 (m:marker1)
 
   312 op equal *tmp72 :rebindUnits:firstUnit null
   313 jump *label76 equal *tmp72 false
   314 end
-    * set *tmp73 null
   315 jump *label77 always
   316 label *label76
-    * set *tmp73 null
   317 label *label77
   318 label *label78
   319 sensor *tmp74 @unit @controller
   320 op equal *tmp75 *tmp74 @this
   321 jump *label81 equal *tmp75 false
-    * set *tmp77 :rebindUnits:count
   322 op add :rebindUnits:count :rebindUnits:count 1
   323 ucontrol flag 1
   324 set .UNIT_S2 .UNIT_P2
 
   334 label *label83
   335 set *tmp80 null
   336 label *label84
-    * set *tmp76 *tmp80
   337 jump *label82 always
   338 label *label81
-    * set *tmp76 null
   339 label *label82
   340 ubind .TYPE
   341 label *label79
 
   345 op land *tmp84 *tmp81 *tmp83
   346 jump *label78 notEqual *tmp84 false
   347 label *label80
-    * set *tmp71 :rebindUnits:count
   348 jump *label75 always
-    * set *tmp71 null
   349 label *label75
   350 # "Function: inline def acquireUnit(in currentUnit)"
   351 set :acquireUnit:currentUnit .UNIT_S1
 
   360 op equal *tmp92 *tmp91 @this
   361 op land *tmp93 *tmp90 *tmp92
   362 jump *label89 equal *tmp93 false
-    * set *tmp86 :rebindUnit:currentUnit
   363 jump *label86 always
   364 set *tmp94 null
   365 jump *label90 always
   366 label *label89
   367 set *tmp94 null
   368 label *label90
-    * set *tmp88 *tmp94
   369 jump *label88 always
   370 label *label87
-    * set *tmp88 null
   371 label *label88
   372 ubind .TYPE
   373 set :rebindUnit:firstUnit @unit
 
   377 sensor *tmp97 @unit @controlled
   378 op equal *tmp98 *tmp97 0
   379 jump *label96 equal *tmp98 false
-    * set *tmp86 @unit
   380 jump *label86 always
-    * set *tmp99 null
   381 jump *label97 always
   382 label *label96
-    * set *tmp99 null
   383 label *label97
   384 ubind .TYPE
   385 label *label94
 
   389 op land *tmp103 *tmp100 *tmp102
   390 jump *label93 notEqual *tmp103 false
   391 label *label95
-    * set *tmp96 null
   392 jump *label92 always
   393 label *label91
-    * set *tmp96 null
   394 label *label92
   395 end
-    * set *tmp86 null
   396 label *label86
   397 ucontrol flag 1
   398 set *tmp85 @unit
 
   413 op equal *tmp111 *tmp110 @this
   414 op land *tmp112 *tmp109 *tmp111
   415 jump *label102 equal *tmp112 false
-    * set *tmp105 :rebindUnit.1:currentUnit
   416 jump *label99 always
   417 set *tmp113 null
   418 jump *label103 always
   419 label *label102
   420 set *tmp113 null
   421 label *label103
-    * set *tmp107 *tmp113
   422 jump *label101 always
   423 label *label100
-    * set *tmp107 null
   424 label *label101
   425 ubind .TYPE
   426 set :rebindUnit.1:firstUnit @unit
 
   430 sensor *tmp116 @unit @controlled
   431 op equal *tmp117 *tmp116 0
   432 jump *label109 equal *tmp117 false
-    * set *tmp105 @unit
   433 jump *label99 always
-    * set *tmp118 null
   434 jump *label110 always
   435 label *label109
-    * set *tmp118 null
   436 label *label110
   437 ubind .TYPE
   438 label *label107
 
   442 op land *tmp122 *tmp119 *tmp121
   443 jump *label106 notEqual *tmp122 false
   444 label *label108
-    * set *tmp115 null
   445 jump *label105 always
   446 label *label104
-    * set *tmp115 null
   447 label *label105
   448 end
-    * set *tmp105 null
   449 label *label99
   450 ucontrol flag 1
   451 set *tmp104 @unit
 
   468 label *label113
   469 set .UNIT_S1 :swap:a
   470 set .UNIT_P1 :swap:b
-    * set *tmp128 null
   471 jump *label112 always
   472 label *label111
-    * set *tmp128 null
   473 label *label112
   474 sensor *tmp129 .UNIT_S1 @itemCapacity
   475 set .UNIT_CAPACITY *tmp129
 
   480 op strictEqual *tmp132 .SPEED null
   481 jump *label114 equal *tmp132 false
   482 stop
-    * set *tmp133 null
   483 jump *label115 always
   484 label *label114
-    * set *tmp133 null
   485 label *label115
   486 # "Function: inline def needsFourUnits(in unit)"
   487 set :needsFourUnits.2:unit .UNIT_S1
 
   512 op equal *tmp150 *tmp149 @this
   513 op land *tmp151 *tmp148 *tmp150
   514 jump *label123 equal *tmp151 false
-    * set *tmp144 :rebindUnit.2:currentUnit
   515 jump *label120 always
   516 set *tmp152 null
   517 jump *label124 always
   518 label *label123
   519 set *tmp152 null
   520 label *label124
-    * set *tmp146 *tmp152
   521 jump *label122 always
   522 label *label121
-    * set *tmp146 null
   523 label *label122
   524 ubind .TYPE
   525 set :rebindUnit.2:firstUnit @unit
 
   529 sensor *tmp155 @unit @controlled
   530 op equal *tmp156 *tmp155 0
   531 jump *label130 equal *tmp156 false
-    * set *tmp144 @unit
   532 jump *label120 always
-    * set *tmp157 null
   533 jump *label131 always
   534 label *label130
-    * set *tmp157 null
   535 label *label131
   536 ubind .TYPE
   537 label *label128
 
   541 op land *tmp161 *tmp158 *tmp160
   542 jump *label127 notEqual *tmp161 false
   543 label *label129
-    * set *tmp154 null
   544 jump *label126 always
   545 label *label125
-    * set *tmp154 null
   546 label *label126
   547 end
-    * set *tmp144 null
   548 label *label120
   549 ucontrol flag 1
   550 set *tmp143 @unit
 
   565 op equal *tmp169 *tmp168 @this
   566 op land *tmp170 *tmp167 *tmp169
   567 jump *label136 equal *tmp170 false
-    * set *tmp163 :rebindUnit.3:currentUnit
   568 jump *label133 always
   569 set *tmp171 null
   570 jump *label137 always
   571 label *label136
   572 set *tmp171 null
   573 label *label137
-    * set *tmp165 *tmp171
   574 jump *label135 always
   575 label *label134
-    * set *tmp165 null
   576 label *label135
   577 ubind .TYPE
   578 set :rebindUnit.3:firstUnit @unit
 
   582 sensor *tmp174 @unit @controlled
   583 op equal *tmp175 *tmp174 0
   584 jump *label143 equal *tmp175 false
-    * set *tmp163 @unit
   585 jump *label133 always
-    * set *tmp176 null
   586 jump *label144 always
   587 label *label143
-    * set *tmp176 null
   588 label *label144
   589 ubind .TYPE
   590 label *label141
 
   594 op land *tmp180 *tmp177 *tmp179
   595 jump *label140 notEqual *tmp180 false
   596 label *label142
-    * set *tmp173 null
   597 jump *label139 always
   598 label *label138
-    * set *tmp173 null
   599 label *label139
   600 end
-    * set *tmp163 null
   601 label *label133
   602 ucontrol flag 1
   603 set *tmp162 @unit
 
   620 label *label147
   621 set .UNIT_S1 :swap.1:a
   622 set .UNIT_P2 :swap.1:b
-    * set *tmp186 null
   623 jump *label146 always
   624 label *label145
-    * set *tmp186 null
   625 label *label146
   626 sensor *tmp187 .UNIT_S2 @firstItem
   627 op equal *tmp188 *tmp187 @phase-fabric
 
   638 label *label150
   639 set .UNIT_S2 :swap.2:a
   640 set .UNIT_P2 :swap.2:b
-    * set *tmp192 null
   641 jump *label149 always
   642 label *label148
-    * set *tmp192 null
   643 label *label149
   644 set .GROUP1 "unit  1"
   645 set .GROUP2 "unit 2"
-    * set *tmp142 .GROUP2
   646 jump *label118 always
   647 label *label117
   648 ubind .UNIT_S2
 
   652 ucontrol unbind
   653 set .UNIT_P2 null
   654 set .GROUP1 "unit"
-    * set *tmp142 .GROUP1
   655 label *label118
   656 op equal *tmp193 .FOUR_UNITS false
   657 sensor *tmp194 .UNIT_S1 @totalItems
 
   692 print "["
   693 print "]"
   694 print "\n"
-    * set *tmp207 null
   695 jump *label156 always
   696 label *label155
   697 print "  dome:  [coral]"
 
   699 print "["
   700 print "]"
   701 print "\n"
-    * set *tmp207 null
   702 label *label156
   703 label *label154
   704 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
 
   717 op equal *tmp214 *tmp213 @this
   718 op land *tmp215 *tmp212 *tmp214
   719 jump *label161 equal *tmp215 false
-    * set *tmp208 :rebindUnit.4:currentUnit
   720 jump *label158 always
   721 set *tmp216 null
   722 jump *label162 always
   723 label *label161
   724 set *tmp216 null
   725 label *label162
-    * set *tmp210 *tmp216
   726 jump *label160 always
   727 label *label159
-    * set *tmp210 null
   728 label *label160
   729 ubind .TYPE
   730 set :rebindUnit.4:firstUnit @unit
 
   734 sensor *tmp219 @unit @controlled
   735 op equal *tmp220 *tmp219 0
   736 jump *label168 equal *tmp220 false
-    * set *tmp208 @unit
   737 jump *label158 always
-    * set *tmp221 null
   738 jump *label169 always
   739 label *label168
-    * set *tmp221 null
   740 label *label169
   741 ubind .TYPE
   742 label *label166
 
   746 op land *tmp225 *tmp222 *tmp224
   747 jump *label165 notEqual *tmp225 false
   748 label *label167
-    * set *tmp218 null
   749 jump *label164 always
   750 label *label163
-    * set *tmp218 null
   751 label *label164
   752 end
-    * set *tmp208 null
   753 label *label158
   754 sensor *tmp226 @unit @flag
   755 set :processUnit:state *tmp226
 
   787 label *label175
   788 set *tmp233 *tmp236
   789 label *label173
-    * set *tmp230 *tmp233
   790 jump *label171 always
   791 label *label170
-    * set *tmp230 null
   792 label *label171
   793 op equal *tmp239 :processUnit:state 2
   794 jump *label178 equal *tmp239 false
 
   821 set :processUnit:distance *tmp252
   822 set *tmp242 :processUnit:distance
   823 label *label181
-    * set *tmp240 *tmp242
   824 jump *label179 always
   825 label *label178
-    * set *tmp240 null
   826 label *label179
   827 op equal *tmp253 :processUnit:state 3
   828 jump *label184 equal *tmp253 false
 
   831 jump *label188 equal :processUnit:supply false
   832 ucontrol itemDrop .DOME .UNIT_CAPACITY
   833 set .MSG ", supplying\n"
-    * set *tmp257 .MSG
   834 jump *label189 always
   835 label *label188
   836 ucontrol approach .DOME_X .DOME_Y 6
   837 set .MSG ", waiting\n"
-    * set *tmp257 .MSG
   838 label *label189
   839 sensor *tmp258 @unit @totalItems
   840 op lessThanEq *tmp259 *tmp258 0
 
   861 set :processUnit:distance *tmp267
   862 set *tmp256 :processUnit:distance
   863 label *label187
-    * set *tmp254 *tmp256
   864 jump *label185 always
   865 label *label184
-    * set *tmp254 null
   866 label *label185
   867 ucontrol flag :processUnit:state
   868 sensor *tmp268 @unit @totalItems
 
   882 print "["
   883 print "] sec"
   884 print "\n"
-    * set *tmp270 null
   885 jump *label193 always
   886 label *label192
   887 print .MSG
-    * set *tmp270 .MSG
   888 label *label193
   889 set *tmp271 @unit
   890 set :processUnit:unit *tmp271
 
   908 op equal *tmp280 *tmp279 @this
   909 op land *tmp281 *tmp278 *tmp280
   910 jump *label200 equal *tmp281 false
-    * set *tmp274 :rebindUnit.5:currentUnit
   911 jump *label197 always
   912 set *tmp282 null
   913 jump *label201 always
   914 label *label200
   915 set *tmp282 null
   916 label *label201
-    * set *tmp276 *tmp282
   917 jump *label199 always
   918 label *label198
-    * set *tmp276 null
   919 label *label199
   920 ubind .TYPE
   921 set :rebindUnit.5:firstUnit @unit
 
   925 sensor *tmp285 @unit @controlled
   926 op equal *tmp286 *tmp285 0
   927 jump *label207 equal *tmp286 false
-    * set *tmp274 @unit
   928 jump *label197 always
-    * set *tmp287 null
   929 jump *label208 always
   930 label *label207
-    * set *tmp287 null
   931 label *label208
   932 ubind .TYPE
   933 label *label205
 
   937 op land *tmp291 *tmp288 *tmp290
   938 jump *label204 notEqual *tmp291 false
   939 label *label206
-    * set *tmp284 null
   940 jump *label203 always
   941 label *label202
-    * set *tmp284 null
   942 label *label203
   943 end
-    * set *tmp274 null
   944 label *label197
   945 sensor *tmp292 @unit @flag
   946 set :processUnit.1:state *tmp292
 
   978 label *label214
   979 set *tmp299 *tmp302
   980 label *label212
-    * set *tmp296 *tmp299
   981 jump *label210 always
   982 label *label209
-    * set *tmp296 null
   983 label *label210
   984 op equal *tmp305 :processUnit.1:state 2
   985 jump *label217 equal *tmp305 false
 
  1012 set :processUnit.1:distance *tmp318
  1013 set *tmp308 :processUnit.1:distance
  1014 label *label220
-    * set *tmp306 *tmp308
  1015 jump *label218 always
  1016 label *label217
-    * set *tmp306 null
  1017 label *label218
  1018 op equal *tmp319 :processUnit.1:state 3
  1019 jump *label223 equal *tmp319 false
 
  1022 jump *label227 equal :processUnit.1:supply false
  1023 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1024 set .MSG ", supplying\n"
-    * set *tmp323 .MSG
  1025 jump *label228 always
  1026 label *label227
  1027 ucontrol approach .DOME_X .DOME_Y 6
  1028 set .MSG ", waiting\n"
-    * set *tmp323 .MSG
  1029 label *label228
  1030 sensor *tmp324 @unit @totalItems
  1031 op lessThanEq *tmp325 *tmp324 0
 
  1052 set :processUnit.1:distance *tmp333
  1053 set *tmp322 :processUnit.1:distance
  1054 label *label226
-    * set *tmp320 *tmp322
  1055 jump *label224 always
  1056 label *label223
-    * set *tmp320 null
  1057 label *label224
  1058 ucontrol flag :processUnit.1:state
  1059 sensor *tmp334 @unit @totalItems
 
  1073 print "["
  1074 print "] sec"
  1075 print "\n"
-    * set *tmp336 null
  1076 jump *label232 always
  1077 label *label231
  1078 print .MSG
-    * set *tmp336 .MSG
  1079 label *label232
  1080 set *tmp337 @unit
  1081 set :processUnit.1:unit *tmp337
 
  1092 set *tmp338 *tmp342
  1093 label *label234
  1094 set .SUPPLY_S_FIRST *tmp338
-    * set *tmp272 .SUPPLY_S_FIRST
  1095 jump *label195 always
  1096 label *label194
-    * set *tmp272 null
  1097 label *label195
  1098 # "Function: inline void printDomeStatus(in item, in text)"
  1099 set :printDomeStatus.1:item @phase-fabric
 
  1108 print "["
  1109 print "]"
  1110 print "\n"
-    * set *tmp345 null
  1111 jump *label237 always
  1112 label *label236
  1113 print "  dome:  [coral]"
 
  1115 print "["
  1116 print "]"
  1117 print "\n"
-    * set *tmp345 null
  1118 label *label237
  1119 label *label235
  1120 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
 
  1133 op equal *tmp352 *tmp351 @this
  1134 op land *tmp353 *tmp350 *tmp352
  1135 jump *label242 equal *tmp353 false
-    * set *tmp346 :rebindUnit.6:currentUnit
  1136 jump *label239 always
  1137 set *tmp354 null
  1138 jump *label243 always
  1139 label *label242
  1140 set *tmp354 null
  1141 label *label243
-    * set *tmp348 *tmp354
  1142 jump *label241 always
  1143 label *label240
-    * set *tmp348 null
  1144 label *label241
  1145 ubind .TYPE
  1146 set :rebindUnit.6:firstUnit @unit
 
  1150 sensor *tmp357 @unit @controlled
  1151 op equal *tmp358 *tmp357 0
  1152 jump *label249 equal *tmp358 false
-    * set *tmp346 @unit
  1153 jump *label239 always
-    * set *tmp359 null
  1154 jump *label250 always
  1155 label *label249
-    * set *tmp359 null
  1156 label *label250
  1157 ubind .TYPE
  1158 label *label247
 
  1162 op land *tmp363 *tmp360 *tmp362
  1163 jump *label246 notEqual *tmp363 false
  1164 label *label248
-    * set *tmp356 null
  1165 jump *label245 always
  1166 label *label244
-    * set *tmp356 null
  1167 label *label245
  1168 end
-    * set *tmp346 null
  1169 label *label239
  1170 sensor *tmp364 @unit @flag
  1171 set :processUnit.2:state *tmp364
 
  1203 label *label256
  1204 set *tmp371 *tmp374
  1205 label *label254
-    * set *tmp368 *tmp371
  1206 jump *label252 always
  1207 label *label251
-    * set *tmp368 null
  1208 label *label252
  1209 op equal *tmp377 :processUnit.2:state 2
  1210 jump *label259 equal *tmp377 false
 
  1237 set :processUnit.2:distance *tmp390
  1238 set *tmp380 :processUnit.2:distance
  1239 label *label262
-    * set *tmp378 *tmp380
  1240 jump *label260 always
  1241 label *label259
-    * set *tmp378 null
  1242 label *label260
  1243 op equal *tmp391 :processUnit.2:state 3
  1244 jump *label265 equal *tmp391 false
 
  1247 jump *label269 equal :processUnit.2:supply false
  1248 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1249 set .MSG ", supplying\n"
-    * set *tmp395 .MSG
  1250 jump *label270 always
  1251 label *label269
  1252 ucontrol approach .DOME_X .DOME_Y 6
  1253 set .MSG ", waiting\n"
-    * set *tmp395 .MSG
  1254 label *label270
  1255 sensor *tmp396 @unit @totalItems
  1256 op lessThanEq *tmp397 *tmp396 0
 
  1277 set :processUnit.2:distance *tmp405
  1278 set *tmp394 :processUnit.2:distance
  1279 label *label268
-    * set *tmp392 *tmp394
  1280 jump *label266 always
  1281 label *label265
-    * set *tmp392 null
  1282 label *label266
  1283 ucontrol flag :processUnit.2:state
  1284 sensor *tmp406 @unit @totalItems
 
  1298 print "["
  1299 print "] sec"
  1300 print "\n"
-    * set *tmp408 null
  1301 jump *label274 always
  1302 label *label273
  1303 print .MSG
-    * set *tmp408 .MSG
  1304 label *label274
  1305 set *tmp409 @unit
  1306 set :processUnit.2:unit *tmp409
 
  1324 op equal *tmp418 *tmp417 @this
  1325 op land *tmp419 *tmp416 *tmp418
  1326 jump *label281 equal *tmp419 false
-    * set *tmp412 :rebindUnit.7:currentUnit
  1327 jump *label278 always
  1328 set *tmp420 null
  1329 jump *label282 always
  1330 label *label281
  1331 set *tmp420 null
  1332 label *label282
-    * set *tmp414 *tmp420
  1333 jump *label280 always
  1334 label *label279
-    * set *tmp414 null
  1335 label *label280
  1336 ubind .TYPE
  1337 set :rebindUnit.7:firstUnit @unit
 
  1341 sensor *tmp423 @unit @controlled
  1342 op equal *tmp424 *tmp423 0
  1343 jump *label288 equal *tmp424 false
-    * set *tmp412 @unit
  1344 jump *label278 always
-    * set *tmp425 null
  1345 jump *label289 always
  1346 label *label288
-    * set *tmp425 null
  1347 label *label289
  1348 ubind .TYPE
  1349 label *label286
 
  1353 op land *tmp429 *tmp426 *tmp428
  1354 jump *label285 notEqual *tmp429 false
  1355 label *label287
-    * set *tmp422 null
  1356 jump *label284 always
  1357 label *label283
-    * set *tmp422 null
  1358 label *label284
  1359 end
-    * set *tmp412 null
  1360 label *label278
  1361 sensor *tmp430 @unit @flag
  1362 set :processUnit.3:state *tmp430
 
  1394 label *label295
  1395 set *tmp437 *tmp440
  1396 label *label293
-    * set *tmp434 *tmp437
  1397 jump *label291 always
  1398 label *label290
-    * set *tmp434 null
  1399 label *label291
  1400 op equal *tmp443 :processUnit.3:state 2
  1401 jump *label298 equal *tmp443 false
 
  1428 set :processUnit.3:distance *tmp456
  1429 set *tmp446 :processUnit.3:distance
  1430 label *label301
-    * set *tmp444 *tmp446
  1431 jump *label299 always
  1432 label *label298
-    * set *tmp444 null
  1433 label *label299
  1434 op equal *tmp457 :processUnit.3:state 3
  1435 jump *label304 equal *tmp457 false
 
  1438 jump *label308 equal :processUnit.3:supply false
  1439 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1440 set .MSG ", supplying\n"
-    * set *tmp461 .MSG
  1441 jump *label309 always
  1442 label *label308
  1443 ucontrol approach .DOME_X .DOME_Y 6
  1444 set .MSG ", waiting\n"
-    * set *tmp461 .MSG
  1445 label *label309
  1446 sensor *tmp462 @unit @totalItems
  1447 op lessThanEq *tmp463 *tmp462 0
 
  1468 set :processUnit.3:distance *tmp471
  1469 set *tmp460 :processUnit.3:distance
  1470 label *label307
-    * set *tmp458 *tmp460
  1471 jump *label305 always
  1472 label *label304
-    * set *tmp458 null
  1473 label *label305
  1474 ucontrol flag :processUnit.3:state
  1475 sensor *tmp472 @unit @totalItems
 
  1489 print "["
  1490 print "] sec"
  1491 print "\n"
-    * set *tmp474 null
  1492 jump *label313 always
  1493 label *label312
  1494 print .MSG
-    * set *tmp474 .MSG
  1495 label *label313
  1496 set *tmp475 @unit
  1497 set :processUnit.3:unit *tmp475
 
  1508 set *tmp476 *tmp480
  1509 label *label315
  1510 set .SUPPLY_P_FIRST *tmp476
-    * set *tmp410 .SUPPLY_P_FIRST
  1511 jump *label276 always
  1512 label *label275
-    * set *tmp410 null
  1513 label *label276
  1514 op sub *tmp481 @time :start
  1515 op floor *tmp482 *tmp481
 
  1571 label *label329
  1572 set *tmp506 null
  1573 label *label330
-    * set *tmp504 *tmp506
  1574 jump *label328 always
  1575 label *label327
  1576 set *tmp507 :areUnitsAvailable.2:occupied
  1577 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp504 *tmp507
  1578 label *label328
  1579 ubind :areUnitsAvailable.2:type
  1580 label *label325
 
  1584 op land *tmp511 *tmp508 *tmp510
  1585 jump *label324 notEqual *tmp511 false
  1586 label *label326
-    * set *tmp489 null
  1587 jump *label320 always
  1588 label *label319
-    * set *tmp489 null
  1589 label *label320
  1590 jump *label331 equal :areUnitsAvailable.2:output false
  1591 print :areUnitsAvailable.2:type
 
  1599 jump *label333 equal *tmp513 false
  1600 print ", needed: "
  1601 print :areUnitsAvailable.2:needed
-    * set *tmp514 null
  1602 jump *label334 always
  1603 label *label333
-    * set *tmp514 null
  1604 label *label334
  1605 print "\n"
-    * set *tmp512 null
  1606 jump *label332 always
  1607 label *label331
-    * set *tmp512 null
  1608 label *label332
  1609 set *tmp487 false
  1610 jump *label318 always
 
  1612 label *label318
  1613 jump *label335 equal *tmp487 false
  1614 end
-    * set *tmp515 null
  1615 jump *label336 always
  1616 label *label335
-    * set *tmp515 null
  1617 label *label336
  1618 op add *tmp516 @time 5000
  1619 set :unitCheck *tmp516
-    * set *tmp486 :unitCheck
  1620 jump *label317 always
  1621 label *label316
-    * set *tmp486 null
  1622 label *label317
  1623 label *label152
  1624 jump *label151 always
 
  1635 jump *label338 equal *tmp521 false
  1636 ulocate building core false @copper *tmp524 *tmp525 *tmp526 *tmp523
  1637 set .CORE *tmp523
-    * set *tmp522 .CORE
  1638 jump *label339 always
  1639 label *label338
-    * set *tmp522 null
  1640 label *label339
  1641 set :locateCore*retval .CORE
  1642 label *label337

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-53 instructions):
 
   118 jump *label37 equal *tmp28 false
   119 set *tmp10 true
   120 jump *label26 always
-    * set *tmp29 null
   121 jump *label38 always
   122 label *label37
-    * set *tmp29 null
   123 label *label38
   124 jump *label36 always
   125 label *label35
-    * set *tmp30 :areUnitsAvailable:occupied
   126 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   127 label *label36
   128 ubind :areUnitsAvailable:type
 
   228 jump *label67 equal *tmp60 false
   229 set *tmp42 true
   230 jump *label56 always
-    * set *tmp61 null
   231 jump *label68 always
   232 label *label67
-    * set *tmp61 null
   233 label *label68
   234 jump *label66 always
   235 label *label65
-    * set *tmp62 :areUnitsAvailable.1:occupied
   236 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   237 label *label66
   238 ubind :areUnitsAvailable.1:type
 
   273 printflush null
   274 set *tmp9 :chooseUnitType:type
   275 jump *label22 always
-    * set *tmp70 null
   276 jump *label74 always
   277 label *label73
-    * set *tmp70 null
   278 label *label74
   279 jump *label55 always
   280 label *label54
 
   321 op notEqual *tmp79 .UNIT_S2 null
   322 jump *label83 equal *tmp79 false
   323 jump *label80 always
-    * set *tmp80 null
   324 jump *label84 always
   325 label *label83
-    * set *tmp80 null
   326 label *label84
   327 jump *label82 always
   328 label *label81
 
   351 op land *tmp93 *tmp90 *tmp92
   352 jump *label89 equal *tmp93 false
   353 jump *label86 always
-    * set *tmp94 null
   354 jump *label90 always
   355 label *label89
-    * set *tmp94 null
   356 label *label90
   357 jump *label88 always
   358 label *label87
 
   402 op land *tmp112 *tmp109 *tmp111
   403 jump *label102 equal *tmp112 false
   404 jump *label99 always
-    * set *tmp113 null
   405 jump *label103 always
   406 label *label102
-    * set *tmp113 null
   407 label *label103
   408 jump *label101 always
   409 label *label100
 
   499 op land *tmp151 *tmp148 *tmp150
   500 jump *label123 equal *tmp151 false
   501 jump *label120 always
-    * set *tmp152 null
   502 jump *label124 always
   503 label *label123
-    * set *tmp152 null
   504 label *label124
   505 jump *label122 always
   506 label *label121
 
   550 op land *tmp170 *tmp167 *tmp169
   551 jump *label136 equal *tmp170 false
   552 jump *label133 always
-    * set *tmp171 null
   553 jump *label137 always
   554 label *label136
-    * set *tmp171 null
   555 label *label137
   556 jump *label135 always
   557 label *label134
 
   700 op land *tmp215 *tmp212 *tmp214
   701 jump *label161 equal *tmp215 false
   702 jump *label158 always
-    * set *tmp216 null
   703 jump *label162 always
   704 label *label161
-    * set *tmp216 null
   705 label *label162
   706 jump *label160 always
   707 label *label159
 
   743 op equal *tmp232 *tmp231 :processUnit:item
   744 jump *label172 equal *tmp232 false
   745 set :processUnit:state 3
-    * set *tmp233 :processUnit:state
   746 jump *label173 always
   747 label *label172
   748 sensor *tmp234 @unit @totalItems
 
   764 label *label177
   765 set *tmp236 *tmp238
   766 label *label175
-    * set *tmp233 *tmp236
   767 label *label173
   768 jump *label171 always
   769 label *label170
 
   784 set .MSG ", loading\n"
   785 set *tmp245 .MSG
   786 label *label183
-    * set *tmp242 *tmp245
   787 jump *label181 always
   788 label *label180
   789 ucontrol approach .CORE_X .CORE_Y 6
 
   796 op idiv *tmp251 *tmp250 .SPEED_TENTHS
   797 op div *tmp252 *tmp251 10
   798 set :processUnit:distance *tmp252
-    * set *tmp242 :processUnit:distance
   799 label *label181
   800 jump *label179 always
   801 label *label178
 
   822 label *label190
   823 set *tmp260 null
   824 label *label191
-    * set *tmp256 *tmp260
   825 jump *label187 always
   826 label *label186
   827 ucontrol approach .DOME_X .DOME_Y 6
 
   834 op idiv *tmp266 *tmp265 .SPEED_TENTHS
   835 op div *tmp267 *tmp266 10
   836 set :processUnit:distance *tmp267
-    * set *tmp256 :processUnit:distance
   837 label *label187
   838 jump *label185 always
   839 label *label184
 
   883 op land *tmp281 *tmp278 *tmp280
   884 jump *label200 equal *tmp281 false
   885 jump *label197 always
-    * set *tmp282 null
   886 jump *label201 always
   887 label *label200
-    * set *tmp282 null
   888 label *label201
   889 jump *label199 always
   890 label *label198
 
   926 op equal *tmp298 *tmp297 :processUnit.1:item
   927 jump *label211 equal *tmp298 false
   928 set :processUnit.1:state 3
-    * set *tmp299 :processUnit.1:state
   929 jump *label212 always
   930 label *label211
   931 sensor *tmp300 @unit @totalItems
 
   947 label *label216
   948 set *tmp302 *tmp304
   949 label *label214
-    * set *tmp299 *tmp302
   950 label *label212
   951 jump *label210 always
   952 label *label209
 
   967 set .MSG ", loading\n"
   968 set *tmp311 .MSG
   969 label *label222
-    * set *tmp308 *tmp311
   970 jump *label220 always
   971 label *label219
   972 ucontrol approach .CORE_X .CORE_Y 6
 
   979 op idiv *tmp317 *tmp316 .SPEED_TENTHS
   980 op div *tmp318 *tmp317 10
   981 set :processUnit.1:distance *tmp318
-    * set *tmp308 :processUnit.1:distance
   982 label *label220
   983 jump *label218 always
   984 label *label217
 
  1005 label *label229
  1006 set *tmp326 null
  1007 label *label230
-    * set *tmp322 *tmp326
  1008 jump *label226 always
  1009 label *label225
  1010 ucontrol approach .DOME_X .DOME_Y 6
 
  1017 op idiv *tmp332 *tmp331 .SPEED_TENTHS
  1018 op div *tmp333 *tmp332 10
  1019 set :processUnit.1:distance *tmp333
-    * set *tmp322 :processUnit.1:distance
  1020 label *label226
  1021 jump *label224 always
  1022 label *label223
 
  1100 op land *tmp353 *tmp350 *tmp352
  1101 jump *label242 equal *tmp353 false
  1102 jump *label239 always
-    * set *tmp354 null
  1103 jump *label243 always
  1104 label *label242
-    * set *tmp354 null
  1105 label *label243
  1106 jump *label241 always
  1107 label *label240
 
  1143 op equal *tmp370 *tmp369 :processUnit.2:item
  1144 jump *label253 equal *tmp370 false
  1145 set :processUnit.2:state 3
-    * set *tmp371 :processUnit.2:state
  1146 jump *label254 always
  1147 label *label253
  1148 sensor *tmp372 @unit @totalItems
 
  1164 label *label258
  1165 set *tmp374 *tmp376
  1166 label *label256
-    * set *tmp371 *tmp374
  1167 label *label254
  1168 jump *label252 always
  1169 label *label251
 
  1184 set .MSG ", loading\n"
  1185 set *tmp383 .MSG
  1186 label *label264
-    * set *tmp380 *tmp383
  1187 jump *label262 always
  1188 label *label261
  1189 ucontrol approach .CORE_X .CORE_Y 6
 
  1196 op idiv *tmp389 *tmp388 .SPEED_TENTHS
  1197 op div *tmp390 *tmp389 10
  1198 set :processUnit.2:distance *tmp390
-    * set *tmp380 :processUnit.2:distance
  1199 label *label262
  1200 jump *label260 always
  1201 label *label259
 
  1222 label *label271
  1223 set *tmp398 null
  1224 label *label272
-    * set *tmp394 *tmp398
  1225 jump *label268 always
  1226 label *label267
  1227 ucontrol approach .DOME_X .DOME_Y 6
 
  1234 op idiv *tmp404 *tmp403 .SPEED_TENTHS
  1235 op div *tmp405 *tmp404 10
  1236 set :processUnit.2:distance *tmp405
-    * set *tmp394 :processUnit.2:distance
  1237 label *label268
  1238 jump *label266 always
  1239 label *label265
 
  1283 op land *tmp419 *tmp416 *tmp418
  1284 jump *label281 equal *tmp419 false
  1285 jump *label278 always
-    * set *tmp420 null
  1286 jump *label282 always
  1287 label *label281
-    * set *tmp420 null
  1288 label *label282
  1289 jump *label280 always
  1290 label *label279
 
  1326 op equal *tmp436 *tmp435 :processUnit.3:item
  1327 jump *label292 equal *tmp436 false
  1328 set :processUnit.3:state 3
-    * set *tmp437 :processUnit.3:state
  1329 jump *label293 always
  1330 label *label292
  1331 sensor *tmp438 @unit @totalItems
 
  1347 label *label297
  1348 set *tmp440 *tmp442
  1349 label *label295
-    * set *tmp437 *tmp440
  1350 label *label293
  1351 jump *label291 always
  1352 label *label290
 
  1367 set .MSG ", loading\n"
  1368 set *tmp449 .MSG
  1369 label *label303
-    * set *tmp446 *tmp449
  1370 jump *label301 always
  1371 label *label300
  1372 ucontrol approach .CORE_X .CORE_Y 6
 
  1379 op idiv *tmp455 *tmp454 .SPEED_TENTHS
  1380 op div *tmp456 *tmp455 10
  1381 set :processUnit.3:distance *tmp456
-    * set *tmp446 :processUnit.3:distance
  1382 label *label301
  1383 jump *label299 always
  1384 label *label298
 
  1405 label *label310
  1406 set *tmp464 null
  1407 label *label311
-    * set *tmp460 *tmp464
  1408 jump *label307 always
  1409 label *label306
  1410 ucontrol approach .DOME_X .DOME_Y 6
 
  1417 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1418 op div *tmp471 *tmp470 10
  1419 set :processUnit.3:distance *tmp471
-    * set *tmp460 :processUnit.3:distance
  1420 label *label307
  1421 jump *label305 always
  1422 label *label304
 
  1516 jump *label329 equal *tmp505 false
  1517 set *tmp487 true
  1518 jump *label318 always
-    * set *tmp506 null
  1519 jump *label330 always
  1520 label *label329
-    * set *tmp506 null
  1521 label *label330
  1522 jump *label328 always
  1523 label *label327
-    * set *tmp507 :areUnitsAvailable.2:occupied
  1524 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1525 label *label328
  1526 ubind :areUnitsAvailable.2:type

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-24 instructions):
 
   749 op equal *tmp235 *tmp234 0
   750 jump *label174 equal *tmp235 false
   751 set :processUnit:state 2
-    * set *tmp236 :processUnit:state
   752 jump *label175 always
   753 label *label174
   754 set .MSG ", initializing\n"
 
   761 label *label176
   762 set *tmp238 null
   763 label *label177
-    * set *tmp236 *tmp238
   764 label *label175
   765 label *label173
   766 jump *label171 always
 
   776 jump *label182 equal *tmp244 false
   777 ucontrol approach .DOME_X .DOME_Y 6
   778 set :processUnit:state 3
-    * set *tmp245 :processUnit:state
   779 jump *label183 always
   780 label *label182
   781 set .MSG ", loading\n"
-    * set *tmp245 .MSG
   782 label *label183
   783 jump *label181 always
   784 label *label180
 
   813 jump *label190 equal *tmp259 false
   814 ucontrol approach .CORE_X .CORE_Y 6
   815 set :processUnit:state 2
-    * set *tmp260 :processUnit:state
   816 jump *label191 always
   817 label *label190
-    * set *tmp260 null
   818 label *label191
   819 jump *label187 always
   820 label *label186
 
   926 op equal *tmp301 *tmp300 0
   927 jump *label213 equal *tmp301 false
   928 set :processUnit.1:state 2
-    * set *tmp302 :processUnit.1:state
   929 jump *label214 always
   930 label *label213
   931 set .MSG ", initializing\n"
 
   938 label *label215
   939 set *tmp304 null
   940 label *label216
-    * set *tmp302 *tmp304
   941 label *label214
   942 label *label212
   943 jump *label210 always
 
   953 jump *label221 equal *tmp310 false
   954 ucontrol approach .DOME_X .DOME_Y 6
   955 set :processUnit.1:state 3
-    * set *tmp311 :processUnit.1:state
   956 jump *label222 always
   957 label *label221
   958 set .MSG ", loading\n"
-    * set *tmp311 .MSG
   959 label *label222
   960 jump *label220 always
   961 label *label219
 
   990 jump *label229 equal *tmp325 false
   991 ucontrol approach .CORE_X .CORE_Y 6
   992 set :processUnit.1:state 2
-    * set *tmp326 :processUnit.1:state
   993 jump *label230 always
   994 label *label229
-    * set *tmp326 null
   995 label *label230
   996 jump *label226 always
   997 label *label225
 
  1137 op equal *tmp373 *tmp372 0
  1138 jump *label255 equal *tmp373 false
  1139 set :processUnit.2:state 2
-    * set *tmp374 :processUnit.2:state
  1140 jump *label256 always
  1141 label *label255
  1142 set .MSG ", initializing\n"
 
  1149 label *label257
  1150 set *tmp376 null
  1151 label *label258
-    * set *tmp374 *tmp376
  1152 label *label256
  1153 label *label254
  1154 jump *label252 always
 
  1164 jump *label263 equal *tmp382 false
  1165 ucontrol approach .DOME_X .DOME_Y 6
  1166 set :processUnit.2:state 3
-    * set *tmp383 :processUnit.2:state
  1167 jump *label264 always
  1168 label *label263
  1169 set .MSG ", loading\n"
-    * set *tmp383 .MSG
  1170 label *label264
  1171 jump *label262 always
  1172 label *label261
 
  1201 jump *label271 equal *tmp397 false
  1202 ucontrol approach .CORE_X .CORE_Y 6
  1203 set :processUnit.2:state 2
-    * set *tmp398 :processUnit.2:state
  1204 jump *label272 always
  1205 label *label271
-    * set *tmp398 null
  1206 label *label272
  1207 jump *label268 always
  1208 label *label267
 
  1314 op equal *tmp439 *tmp438 0
  1315 jump *label294 equal *tmp439 false
  1316 set :processUnit.3:state 2
-    * set *tmp440 :processUnit.3:state
  1317 jump *label295 always
  1318 label *label294
  1319 set .MSG ", initializing\n"
 
  1326 label *label296
  1327 set *tmp442 null
  1328 label *label297
-    * set *tmp440 *tmp442
  1329 label *label295
  1330 label *label293
  1331 jump *label291 always
 
  1341 jump *label302 equal *tmp448 false
  1342 ucontrol approach .DOME_X .DOME_Y 6
  1343 set :processUnit.3:state 3
-    * set *tmp449 :processUnit.3:state
  1344 jump *label303 always
  1345 label *label302
  1346 set .MSG ", loading\n"
-    * set *tmp449 .MSG
  1347 label *label303
  1348 jump *label301 always
  1349 label *label300
 
  1378 jump *label310 equal *tmp463 false
  1379 ucontrol approach .CORE_X .CORE_Y 6
  1380 set :processUnit.3:state 2
-    * set *tmp464 :processUnit.3:state
  1381 jump *label311 always
  1382 label *label310
-    * set *tmp464 null
  1383 label *label311
  1384 jump *label307 always
  1385 label *label306

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
   756 ucontrol within .CORE_X .CORE_Y 8 *tmp237
   757 jump *label176 equal *tmp237 false
   758 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp238 null
   759 jump *label177 always
   760 label *label176
-    * set *tmp238 null
   761 label *label177
   762 label *label175
   763 label *label173
 
   931 ucontrol within .CORE_X .CORE_Y 8 *tmp303
   932 jump *label215 equal *tmp303 false
   933 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp304 null
   934 jump *label216 always
   935 label *label215
-    * set *tmp304 null
   936 label *label216
   937 label *label214
   938 label *label212
 
  1140 ucontrol within .CORE_X .CORE_Y 8 *tmp375
  1141 jump *label257 equal *tmp375 false
  1142 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp376 null
  1143 jump *label258 always
  1144 label *label257
-    * set *tmp376 null
  1145 label *label258
  1146 label *label256
  1147 label *label254
 
  1315 ucontrol within .CORE_X .CORE_Y 8 *tmp441
  1316 jump *label296 equal *tmp441 false
  1317 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp442 null
  1318 jump *label297 always
  1319 label *label296
-    * set *tmp442 null
  1320 label *label297
  1321 label *label295
  1322 label *label293

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-43 instructions):
 
    51 jump *label5 always
    52 label *label7
    53 label *label1
-    * sensor *tmp3 .CORE @x
-    * set .CORE_X *tmp3
-    * sensor *tmp4 .CORE @y
-    * set .CORE_Y *tmp4
-    * sensor *tmp5 .DOME @x
-    * set .DOME_X *tmp5
-    * sensor *tmp6 .DOME @y
-    * set .DOME_Y *tmp6
+   54 sensor .CORE_X .CORE @x
+   55 sensor .CORE_Y .CORE @y
+   56 sensor .DOME_X .DOME @x
+   57 sensor .DOME_Y .DOME @y
    58 label *label19
    59 sensor *tmp7 switch1 @enabled
    60 op equal *tmp8 *tmp7 false
 
    88 op len *tmp16 *tmp14 *tmp15
    89 op mul *tmp17 2 *tmp16
    90 sensor *tmp18 :needsFourUnits:unit @speed
-    * op div *tmp19 *tmp17 *tmp18
-    * set :needsFourUnits:travel_time *tmp19
-    * op greaterThanEq *tmp20 :needsFourUnits:travel_time 47
-    * set *tmp13 *tmp20
+   91 op div :needsFourUnits:travel_time *tmp17 *tmp18
+   92 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    93 jump *label29 always
    94 set *tmp13 null
    95 label *label29
 
   196 op len *tmp48 *tmp46 *tmp47
   197 op mul *tmp49 2 *tmp48
   198 sensor *tmp50 :needsFourUnits.1:unit @speed
-    * op div *tmp51 *tmp49 *tmp50
-    * set :needsFourUnits.1:travel_time *tmp51
-    * op greaterThanEq *tmp52 :needsFourUnits.1:travel_time 47
-    * set *tmp45 *tmp52
+  199 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  200 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   201 jump *label59 always
   202 set *tmp45 null
   203 label *label59
 
   308 set .UNIT_S2 .UNIT_P2
   309 set .UNIT_P2 .UNIT_S1
   310 set .UNIT_S1 .UNIT_P1
-    * set *tmp78 @unit
-    * set .UNIT_P1 *tmp78
+  311 set .UNIT_P1 @unit
   312 op notEqual *tmp79 .UNIT_S2 null
   313 jump *label83 equal *tmp79 false
   314 jump *label80 always
 
   448 jump *label112 always
   449 label *label111
   450 label *label112
-    * sensor *tmp129 .UNIT_S1 @itemCapacity
-    * set .UNIT_CAPACITY *tmp129
-    * sensor *tmp130 .UNIT_S1 @speed
-    * set .SPEED *tmp130
-    * op div *tmp131 .SPEED 10
-    * set .SPEED_TENTHS *tmp131
+  451 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
+  452 sensor .SPEED .UNIT_S1 @speed
+  453 op div .SPEED_TENTHS .SPEED 10
   454 op strictEqual *tmp132 .SPEED null
   455 jump *label114 equal *tmp132 false
   456 stop
 
   464 op len *tmp137 *tmp135 *tmp136
   465 op mul *tmp138 2 *tmp137
   466 sensor *tmp139 :needsFourUnits.2:unit @speed
-    * op div *tmp140 *tmp138 *tmp139
-    * set :needsFourUnits.2:travel_time *tmp140
-    * op greaterThanEq *tmp141 :needsFourUnits.2:travel_time 47
-    * set *tmp134 *tmp141
+  467 op div :needsFourUnits.2:travel_time *tmp138 *tmp139
+  468 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   469 jump *label116 always
   470 set *tmp134 null
   471 label *label116
 
   625 sensor *tmp194 .UNIT_S1 @totalItems
   626 sensor *tmp195 .UNIT_S2 @totalItems
   627 op lessThan *tmp196 *tmp194 *tmp195
-    * op or *tmp197 *tmp193 *tmp196
-    * set .SUPPLY_S_FIRST *tmp197
+  628 op or .SUPPLY_S_FIRST *tmp193 *tmp196
   629 op equal *tmp198 .FOUR_UNITS false
   630 sensor *tmp199 .UNIT_P1 @totalItems
   631 sensor *tmp200 .UNIT_P2 @totalItems
   632 op lessThan *tmp201 *tmp199 *tmp200
-    * op or *tmp202 *tmp198 *tmp201
-    * set .SUPPLY_P_FIRST *tmp202
-    * op add *tmp203 @time 5000
-    * set :unitCheck *tmp203
+  633 op or .SUPPLY_P_FIRST *tmp198 *tmp201
+  634 op add :unitCheck @time 5000
   635 label *label151
   636 sensor *tmp204 switch1 @enabled
   637 jump *label153 equal *tmp204 false
 
   648 set :printDomeStatus:item @silicon
   649 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   650 print :printDomeStatus:text
-    * sensor *tmp205 .DOME :printDomeStatus:item
-    * set :printDomeStatus:level *tmp205
+  651 sensor :printDomeStatus:level .DOME :printDomeStatus:item
   652 op greaterThan *tmp206 :printDomeStatus:level 3
   653 jump *label155 equal *tmp206 false
   654 print "  dome:  [green]"
 
   713 label *label164
   714 end
   715 label *label158
-    * sensor *tmp226 @unit @flag
-    * set :processUnit:state *tmp226
+  716 sensor :processUnit:state @unit @flag
   717 set :processUnit:distance -1
   718 set :processUnit:color "gold"
   719 op lessThan *tmp227 :processUnit:state 2
 
   769 op sub *tmp249 .CORE_Y *tmp248
   770 op len *tmp250 *tmp247 *tmp249
   771 op idiv *tmp251 *tmp250 .SPEED_TENTHS
-    * op div *tmp252 *tmp251 10
-    * set :processUnit:distance *tmp252
+  772 op div :processUnit:distance *tmp251 10
   773 label *label181
   774 jump *label179 always
   775 label *label178
 
   804 op sub *tmp264 .DOME_Y *tmp263
   805 op len *tmp265 *tmp262 *tmp264
   806 op idiv *tmp266 *tmp265 .SPEED_TENTHS
-    * op div *tmp267 *tmp266 10
-    * set :processUnit:distance *tmp267
+  807 op div :processUnit:distance *tmp266 10
   808 label *label187
   809 jump *label185 always
   810 label *label184
 
   831 label *label192
   832 print .MSG
   833 label *label193
-    * set *tmp271 @unit
-    * set :processUnit:unit *tmp271
+  834 set :processUnit:unit @unit
   835 label *label157
   836 set .UNIT_S1 :processUnit:unit
   837 jump *label194 equal .FOUR_UNITS false
 
   884 label *label203
   885 end
   886 label *label197
-    * sensor *tmp292 @unit @flag
-    * set :processUnit.1:state *tmp292
+  887 sensor :processUnit.1:state @unit @flag
   888 set :processUnit.1:distance -1
   889 set :processUnit.1:color "gold"
   890 op lessThan *tmp293 :processUnit.1:state 2
 
   940 op sub *tmp315 .CORE_Y *tmp314
   941 op len *tmp316 *tmp313 *tmp315
   942 op idiv *tmp317 *tmp316 .SPEED_TENTHS
-    * op div *tmp318 *tmp317 10
-    * set :processUnit.1:distance *tmp318
+  943 op div :processUnit.1:distance *tmp317 10
   944 label *label220
   945 jump *label218 always
   946 label *label217
 
   975 op sub *tmp330 .DOME_Y *tmp329
   976 op len *tmp331 *tmp328 *tmp330
   977 op idiv *tmp332 *tmp331 .SPEED_TENTHS
-    * op div *tmp333 *tmp332 10
-    * set :processUnit.1:distance *tmp333
+  978 op div :processUnit.1:distance *tmp332 10
   979 label *label226
   980 jump *label224 always
   981 label *label223
 
  1002 label *label231
  1003 print .MSG
  1004 label *label232
-    * set *tmp337 @unit
-    * set :processUnit.1:unit *tmp337
+ 1005 set :processUnit.1:unit @unit
  1006 label *label196
  1007 set .UNIT_S2 :processUnit.1:unit
  1008 jump *label233 equal .SUPPLY_S_FIRST false
  1009 sensor *tmp339 .UNIT_S1 @totalItems
-    * op greaterThan *tmp340 *tmp339 0
-    * set *tmp338 *tmp340
+ 1010 op greaterThan *tmp338 *tmp339 0
  1011 jump *label234 always
  1012 label *label233
  1013 sensor *tmp341 .UNIT_S2 @totalItems
-    * op equal *tmp342 *tmp341 0
-    * set *tmp338 *tmp342
+ 1014 op equal *tmp338 *tmp341 0
  1015 label *label234
  1016 set .SUPPLY_S_FIRST *tmp338
  1017 jump *label195 always
 
  1021 set :printDomeStatus.1:item @phase-fabric
  1022 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
  1023 print :printDomeStatus.1:text
-    * sensor *tmp343 .DOME :printDomeStatus.1:item
-    * set :printDomeStatus.1:level *tmp343
+ 1024 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
  1025 op greaterThan *tmp344 :printDomeStatus.1:level 3
  1026 jump *label236 equal *tmp344 false
  1027 print "  dome:  [green]"
 
  1086 label *label245
  1087 end
  1088 label *label239
-    * sensor *tmp364 @unit @flag
-    * set :processUnit.2:state *tmp364
+ 1089 sensor :processUnit.2:state @unit @flag
  1090 set :processUnit.2:distance -1
  1091 set :processUnit.2:color "gold"
  1092 op lessThan *tmp365 :processUnit.2:state 2
 
  1142 op sub *tmp387 .CORE_Y *tmp386
  1143 op len *tmp388 *tmp385 *tmp387
  1144 op idiv *tmp389 *tmp388 .SPEED_TENTHS
-    * op div *tmp390 *tmp389 10
-    * set :processUnit.2:distance *tmp390
+ 1145 op div :processUnit.2:distance *tmp389 10
  1146 label *label262
  1147 jump *label260 always
  1148 label *label259
 
  1177 op sub *tmp402 .DOME_Y *tmp401
  1178 op len *tmp403 *tmp400 *tmp402
  1179 op idiv *tmp404 *tmp403 .SPEED_TENTHS
-    * op div *tmp405 *tmp404 10
-    * set :processUnit.2:distance *tmp405
+ 1180 op div :processUnit.2:distance *tmp404 10
  1181 label *label268
  1182 jump *label266 always
  1183 label *label265
 
  1204 label *label273
  1205 print .MSG
  1206 label *label274
-    * set *tmp409 @unit
-    * set :processUnit.2:unit *tmp409
+ 1207 set :processUnit.2:unit @unit
  1208 label *label238
  1209 set .UNIT_P1 :processUnit.2:unit
  1210 jump *label275 equal .FOUR_UNITS false
 
  1257 label *label284
  1258 end
  1259 label *label278
-    * sensor *tmp430 @unit @flag
-    * set :processUnit.3:state *tmp430
+ 1260 sensor :processUnit.3:state @unit @flag
  1261 set :processUnit.3:distance -1
  1262 set :processUnit.3:color "gold"
  1263 op lessThan *tmp431 :processUnit.3:state 2
 
  1313 op sub *tmp453 .CORE_Y *tmp452
  1314 op len *tmp454 *tmp451 *tmp453
  1315 op idiv *tmp455 *tmp454 .SPEED_TENTHS
-    * op div *tmp456 *tmp455 10
-    * set :processUnit.3:distance *tmp456
+ 1316 op div :processUnit.3:distance *tmp455 10
  1317 label *label301
  1318 jump *label299 always
  1319 label *label298
 
  1348 op sub *tmp468 .DOME_Y *tmp467
  1349 op len *tmp469 *tmp466 *tmp468
  1350 op idiv *tmp470 *tmp469 .SPEED_TENTHS
-    * op div *tmp471 *tmp470 10
-    * set :processUnit.3:distance *tmp471
+ 1351 op div :processUnit.3:distance *tmp470 10
  1352 label *label307
  1353 jump *label305 always
  1354 label *label304
 
  1375 label *label312
  1376 print .MSG
  1377 label *label313
-    * set *tmp475 @unit
-    * set :processUnit.3:unit *tmp475
+ 1378 set :processUnit.3:unit @unit
  1379 label *label277
  1380 set .UNIT_P2 :processUnit.3:unit
  1381 jump *label314 equal .SUPPLY_P_FIRST false
  1382 sensor *tmp477 .UNIT_P1 @totalItems
-    * op greaterThan *tmp478 *tmp477 0
-    * set *tmp476 *tmp478
+ 1383 op greaterThan *tmp476 *tmp477 0
  1384 jump *label315 always
  1385 label *label314
  1386 sensor *tmp479 .UNIT_P2 @totalItems
-    * op equal *tmp480 *tmp479 0
-    * set *tmp476 *tmp480
+ 1387 op equal *tmp476 *tmp479 0
  1388 label *label315
  1389 set .SUPPLY_P_FIRST *tmp476
  1390 jump *label276 always
 
  1419 op len *tmp493 *tmp491 *tmp492
  1420 op mul *tmp494 2 *tmp493
  1421 sensor *tmp495 :needsFourUnits.3:unit @speed
-    * op div *tmp496 *tmp494 *tmp495
-    * set :needsFourUnits.3:travel_time *tmp496
-    * op greaterThanEq *tmp497 :needsFourUnits.3:travel_time 47
-    * set *tmp490 *tmp497
+ 1422 op div :needsFourUnits.3:travel_time *tmp494 *tmp495
+ 1423 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1424 jump *label321 always
  1425 set *tmp490 null
  1426 label *label321
 
  1489 jump *label336 always
  1490 label *label335
  1491 label *label336
-    * op add *tmp516 @time 5000
-    * set :unitCheck *tmp516
+ 1492 op add :unitCheck @time 5000
  1493 jump *label317 always
  1494 label *label316
  1495 label *label317
 
  1506 op equal *tmp520 *tmp519 @this
  1507 op or *tmp521 *tmp518 *tmp520
  1508 jump *label338 equal *tmp521 false
-    * ulocate building core false @copper *tmp524 *tmp525 *tmp526 *tmp523
-    * set .CORE *tmp523
+ 1509 ulocate building core false @copper 0 0 0 .CORE
  1510 jump *label339 always
  1511 label *label338
  1512 label *label339

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * jump *label7 equal true false
    19 set :locateDomeAndCore:type @flare
    20 op add *tmp1 @counter 1
    21 jump *label8 always
 
    66 label *label21
    67 # "Function: inline def chooseUnitType()"
    68 label *label23
-    * jump *label25 equal true false
    69 printflush null
    70 print "[gold]Looking for suitable unit type:[]"
    71 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-69 instructions):
 
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
     6 label *label2
-    * op equal *tmp0 .DOME null
-    * jump *label4 equal *tmp0 false
+    7 jump *label4 notEqual .DOME null
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
 
    55 sensor .DOME_Y .DOME @y
    56 label *label19
    57 sensor *tmp7 switch1 @enabled
-    * op equal *tmp8 *tmp7 false
-    * jump *label21 equal *tmp8 false
+   58 jump *label21 notEqual *tmp7 false
    59 print "[coral]Activate switch to begin supplying overdrive dome..."
    60 print "\n"
    61 printflush message1
 
    75 set :areUnitsAvailable:needed 0
    76 ubind :areUnitsAvailable:type
    77 set :areUnitsAvailable:firstUnit @unit
-    * op notEqual *tmp11 :areUnitsAvailable:firstUnit null
-    * jump *label27 equal *tmp11 false
+   78 jump *label27 equal :areUnitsAvailable:firstUnit null
    79 # "Function: inline def needsFourUnits(in unit)"
    80 set :needsFourUnits:unit @unit
    81 op sub *tmp14 .DOME_X .CORE_X
 
   103 op or *tmp26 *tmp23 *tmp25
   104 jump *label35 equal *tmp26 false
   105 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * op greaterThanEq *tmp28 :areUnitsAvailable:free :areUnitsAvailable:needed
-    * jump *label37 equal *tmp28 false
+  106 jump *label37 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   107 set *tmp10 true
   108 jump *label26 always
   109 jump *label38 always
 
   132 print ","
   133 print " free: "
   134 print :areUnitsAvailable:free
-    * op greaterThan *tmp36 :areUnitsAvailable:needed 0
-    * jump *label41 equal *tmp36 false
+  135 jump *label41 lessThanEq :areUnitsAvailable:needed 0
   136 print ", needed: "
   137 print :areUnitsAvailable:needed
   138 jump *label42 always
 
   170 multilabel *label52 (m:marker1)
   171 jump *label53 always
   172 label *label45
-    * op notEqual *tmp40 :chooseUnitType:type UNIT_TYPE
-    * jump *label54 equal *tmp40 false
+  173 jump *label54 equal :chooseUnitType:type UNIT_TYPE
   174 # "Function: inline def areUnitsAvailable(in type, in output)"
   175 set :areUnitsAvailable.1:type :chooseUnitType:type
   176 set :areUnitsAvailable.1:output true
 
   179 set :areUnitsAvailable.1:needed 0
   180 ubind :areUnitsAvailable.1:type
   181 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp43 :areUnitsAvailable.1:firstUnit null
-    * jump *label57 equal *tmp43 false
+  182 jump *label57 equal :areUnitsAvailable.1:firstUnit null
   183 # "Function: inline def needsFourUnits(in unit)"
   184 set :needsFourUnits.1:unit @unit
   185 op sub *tmp46 .DOME_X .CORE_X
 
   207 op or *tmp58 *tmp55 *tmp57
   208 jump *label65 equal *tmp58 false
   209 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * op greaterThanEq *tmp60 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
-    * jump *label67 equal *tmp60 false
+  210 jump *label67 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   211 set *tmp42 true
   212 jump *label56 always
   213 jump *label68 always
 
   236 print ","
   237 print " free: "
   238 print :areUnitsAvailable.1:free
-    * op greaterThan *tmp68 :areUnitsAvailable.1:needed 0
-    * jump *label71 equal *tmp68 false
+  239 jump *label71 lessThanEq :areUnitsAvailable.1:needed 0
   240 print ", needed: "
   241 print :areUnitsAvailable.1:needed
   242 jump *label72 always
 
   282 set :rebindUnits:count 0
   283 ubind .TYPE
   284 set :rebindUnits:firstUnit @unit
-    * op equal *tmp72 :rebindUnits:firstUnit null
-    * jump *label76 equal *tmp72 false
+  285 jump *label76 notEqual :rebindUnits:firstUnit null
   286 end
   287 jump *label77 always
   288 label *label76
   289 label *label77
   290 label *label78
   291 sensor *tmp74 @unit @controller
-    * op equal *tmp75 *tmp74 @this
-    * jump *label81 equal *tmp75 false
+  292 jump *label81 notEqual *tmp74 @this
   293 op add :rebindUnits:count :rebindUnits:count 1
   294 ucontrol flag 1
   295 set .UNIT_S2 .UNIT_P2
   296 set .UNIT_P2 .UNIT_S1
   297 set .UNIT_S1 .UNIT_P1
   298 set .UNIT_P1 @unit
-    * op notEqual *tmp79 .UNIT_S2 null
-    * jump *label83 equal *tmp79 false
+  299 jump *label83 equal .UNIT_S2 null
   300 jump *label80 always
   301 jump *label84 always
   302 label *label83
 
   318 set :acquireUnit:currentUnit .UNIT_S1
   319 # "Function: inline def rebindUnit(in currentUnit)"
   320 set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * op notEqual *tmp87 :rebindUnit:currentUnit null
-    * jump *label87 equal *tmp87 false
+  321 jump *label87 equal :rebindUnit:currentUnit null
   322 ubind :rebindUnit:currentUnit
   323 sensor *tmp89 @unit @dead
   324 op equal *tmp90 *tmp89 0
 
   335 label *label88
   336 ubind .TYPE
   337 set :rebindUnit:firstUnit @unit
-    * op notEqual *tmp95 :rebindUnit:firstUnit null
-    * jump *label91 equal *tmp95 false
+  338 jump *label91 equal :rebindUnit:firstUnit null
   339 label *label93
   340 sensor *tmp97 @unit @controlled
-    * op equal *tmp98 *tmp97 0
-    * jump *label96 equal *tmp98 false
+  341 jump *label96 notEqual *tmp97 0
   342 jump *label86 always
   343 jump *label97 always
   344 label *label96
 
   366 set :acquireUnit.1:currentUnit .UNIT_P1
   367 # "Function: inline def rebindUnit(in currentUnit)"
   368 set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * op notEqual *tmp106 :rebindUnit.1:currentUnit null
-    * jump *label100 equal *tmp106 false
+  369 jump *label100 equal :rebindUnit.1:currentUnit null
   370 ubind :rebindUnit.1:currentUnit
   371 sensor *tmp108 @unit @dead
   372 op equal *tmp109 *tmp108 0
 
   383 label *label101
   384 ubind .TYPE
   385 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp114 :rebindUnit.1:firstUnit null
-    * jump *label104 equal *tmp114 false
+  386 jump *label104 equal :rebindUnit.1:firstUnit null
   387 label *label106
   388 sensor *tmp116 @unit @controlled
-    * op equal *tmp117 *tmp116 0
-    * jump *label109 equal *tmp117 false
+  389 jump *label109 notEqual *tmp116 0
   390 jump *label99 always
   391 jump *label110 always
   392 label *label109
 
   455 set :acquireUnit.2:currentUnit .UNIT_S2
   456 # "Function: inline def rebindUnit(in currentUnit)"
   457 set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * op notEqual *tmp145 :rebindUnit.2:currentUnit null
-    * jump *label121 equal *tmp145 false
+  458 jump *label121 equal :rebindUnit.2:currentUnit null
   459 ubind :rebindUnit.2:currentUnit
   460 sensor *tmp147 @unit @dead
   461 op equal *tmp148 *tmp147 0
 
   472 label *label122
   473 ubind .TYPE
   474 set :rebindUnit.2:firstUnit @unit
-    * op notEqual *tmp153 :rebindUnit.2:firstUnit null
-    * jump *label125 equal *tmp153 false
+  475 jump *label125 equal :rebindUnit.2:firstUnit null
   476 label *label127
   477 sensor *tmp155 @unit @controlled
-    * op equal *tmp156 *tmp155 0
-    * jump *label130 equal *tmp156 false
+  478 jump *label130 notEqual *tmp155 0
   479 jump *label120 always
   480 jump *label131 always
   481 label *label130
 
   503 set :acquireUnit.3:currentUnit .UNIT_P2
   504 # "Function: inline def rebindUnit(in currentUnit)"
   505 set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * op notEqual *tmp164 :rebindUnit.3:currentUnit null
-    * jump *label134 equal *tmp164 false
+  506 jump *label134 equal :rebindUnit.3:currentUnit null
   507 ubind :rebindUnit.3:currentUnit
   508 sensor *tmp166 @unit @dead
   509 op equal *tmp167 *tmp166 0
 
   520 label *label135
   521 ubind .TYPE
   522 set :rebindUnit.3:firstUnit @unit
-    * op notEqual *tmp172 :rebindUnit.3:firstUnit null
-    * jump *label138 equal *tmp172 false
+  523 jump *label138 equal :rebindUnit.3:firstUnit null
   524 label *label140
   525 sensor *tmp174 @unit @controlled
-    * op equal *tmp175 *tmp174 0
-    * jump *label143 equal *tmp175 false
+  526 jump *label143 notEqual *tmp174 0
   527 jump *label133 always
   528 jump *label144 always
   529 label *label143
 
   623 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   624 print :printDomeStatus:text
   625 sensor :printDomeStatus:level .DOME :printDomeStatus:item
-    * op greaterThan *tmp206 :printDomeStatus:level 3
-    * jump *label155 equal *tmp206 false
+  626 jump *label155 lessThanEq :printDomeStatus:level 3
   627 print "  dome:  [green]"
   628 print :printDomeStatus:level
   629 print "["
 
   645 set :processUnit:supply .SUPPLY_S_FIRST
   646 # "Function: inline def rebindUnit(in currentUnit)"
   647 set :rebindUnit.4:currentUnit :processUnit:unit
-    * op notEqual *tmp209 :rebindUnit.4:currentUnit null
-    * jump *label159 equal *tmp209 false
+  648 jump *label159 equal :rebindUnit.4:currentUnit null
   649 ubind :rebindUnit.4:currentUnit
   650 sensor *tmp211 @unit @dead
   651 op equal *tmp212 *tmp211 0
 
   662 label *label160
   663 ubind .TYPE
   664 set :rebindUnit.4:firstUnit @unit
-    * op notEqual *tmp217 :rebindUnit.4:firstUnit null
-    * jump *label163 equal *tmp217 false
+  665 jump *label163 equal :rebindUnit.4:firstUnit null
   666 label *label165
   667 sensor *tmp219 @unit @controlled
-    * op equal *tmp220 *tmp219 0
-    * jump *label168 equal *tmp220 false
+  668 jump *label168 notEqual *tmp219 0
   669 jump *label158 always
   670 jump *label169 always
   671 label *label168
 
   691 op or *tmp229 *tmp227 *tmp228
   692 jump *label170 equal *tmp229 false
   693 sensor *tmp231 @unit @firstItem
-    * op equal *tmp232 *tmp231 :processUnit:item
-    * jump *label172 equal *tmp232 false
+  694 jump *label172 notEqual *tmp231 :processUnit:item
   695 set :processUnit:state 3
   696 jump *label173 always
   697 label *label172
   698 sensor *tmp234 @unit @totalItems
-    * op equal *tmp235 *tmp234 0
-    * jump *label174 equal *tmp235 false
+  699 jump *label174 notEqual *tmp234 0
   700 set :processUnit:state 2
   701 jump *label175 always
   702 label *label174
 
   713 jump *label171 always
   714 label *label170
   715 label *label171
-    * op equal *tmp239 :processUnit:state 2
-    * jump *label178 equal *tmp239 false
+  716 jump *label178 notEqual :processUnit:state 2
   717 ucontrol within .CORE_X .CORE_Y 8 *tmp241
   718 jump *label180 equal *tmp241 false
   719 ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
   720 sensor *tmp243 @unit @totalItems
-    * op greaterThanEq *tmp244 *tmp243 .UNIT_CAPACITY
-    * jump *label182 equal *tmp244 false
+  721 jump *label182 lessThan *tmp243 .UNIT_CAPACITY
   722 ucontrol approach .DOME_X .DOME_Y 6
   723 set :processUnit:state 3
   724 jump *label183 always
 
   740 jump *label179 always
   741 label *label178
   742 label *label179
-    * op equal *tmp253 :processUnit:state 3
-    * jump *label184 equal *tmp253 false
+  743 jump *label184 notEqual :processUnit:state 3
   744 ucontrol within .DOME_X .DOME_Y 8 *tmp255
   745 jump *label186 equal *tmp255 false
   746 jump *label188 equal :processUnit:supply false
 
   752 set .MSG ", waiting\n"
   753 label *label189
   754 sensor *tmp258 @unit @totalItems
-    * op lessThanEq *tmp259 *tmp258 0
-    * jump *label190 equal *tmp259 false
+  755 jump *label190 greaterThan *tmp258 0
   756 ucontrol approach .CORE_X .CORE_Y 6
   757 set :processUnit:state 2
   758 jump *label191 always
 
   784 print *tmp268
   785 print "["
   786 print "]"
-    * op greaterThanEq *tmp269 :processUnit:distance 0
-    * jump *label192 equal *tmp269 false
+  787 jump *label192 lessThan :processUnit:distance 0
   788 print .MSG
   789 print :processUnit:distance
   790 print "["
 
   806 set :processUnit.1:supply *tmp273
   807 # "Function: inline def rebindUnit(in currentUnit)"
   808 set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * op notEqual *tmp275 :rebindUnit.5:currentUnit null
-    * jump *label198 equal *tmp275 false
+  809 jump *label198 equal :rebindUnit.5:currentUnit null
   810 ubind :rebindUnit.5:currentUnit
   811 sensor *tmp277 @unit @dead
   812 op equal *tmp278 *tmp277 0
 
   823 label *label199
   824 ubind .TYPE
   825 set :rebindUnit.5:firstUnit @unit
-    * op notEqual *tmp283 :rebindUnit.5:firstUnit null
-    * jump *label202 equal *tmp283 false
+  826 jump *label202 equal :rebindUnit.5:firstUnit null
   827 label *label204
   828 sensor *tmp285 @unit @controlled
-    * op equal *tmp286 *tmp285 0
-    * jump *label207 equal *tmp286 false
+  829 jump *label207 notEqual *tmp285 0
   830 jump *label197 always
   831 jump *label208 always
   832 label *label207
 
   852 op or *tmp295 *tmp293 *tmp294
   853 jump *label209 equal *tmp295 false
   854 sensor *tmp297 @unit @firstItem
-    * op equal *tmp298 *tmp297 :processUnit.1:item
-    * jump *label211 equal *tmp298 false
+  855 jump *label211 notEqual *tmp297 :processUnit.1:item
   856 set :processUnit.1:state 3
   857 jump *label212 always
   858 label *label211
   859 sensor *tmp300 @unit @totalItems
-    * op equal *tmp301 *tmp300 0
-    * jump *label213 equal *tmp301 false
+  860 jump *label213 notEqual *tmp300 0
   861 set :processUnit.1:state 2
   862 jump *label214 always
   863 label *label213
 
   874 jump *label210 always
   875 label *label209
   876 label *label210
-    * op equal *tmp305 :processUnit.1:state 2
-    * jump *label217 equal *tmp305 false
+  877 jump *label217 notEqual :processUnit.1:state 2
   878 ucontrol within .CORE_X .CORE_Y 8 *tmp307
   879 jump *label219 equal *tmp307 false
   880 ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
   881 sensor *tmp309 @unit @totalItems
-    * op greaterThanEq *tmp310 *tmp309 .UNIT_CAPACITY
-    * jump *label221 equal *tmp310 false
+  882 jump *label221 lessThan *tmp309 .UNIT_CAPACITY
   883 ucontrol approach .DOME_X .DOME_Y 6
   884 set :processUnit.1:state 3
   885 jump *label222 always
 
   901 jump *label218 always
   902 label *label217
   903 label *label218
-    * op equal *tmp319 :processUnit.1:state 3
-    * jump *label223 equal *tmp319 false
+  904 jump *label223 notEqual :processUnit.1:state 3
   905 ucontrol within .DOME_X .DOME_Y 8 *tmp321
   906 jump *label225 equal *tmp321 false
   907 jump *label227 equal :processUnit.1:supply false
 
   913 set .MSG ", waiting\n"
   914 label *label228
   915 sensor *tmp324 @unit @totalItems
-    * op lessThanEq *tmp325 *tmp324 0
-    * jump *label229 equal *tmp325 false
+  916 jump *label229 greaterThan *tmp324 0
   917 ucontrol approach .CORE_X .CORE_Y 6
   918 set :processUnit.1:state 2
   919 jump *label230 always
 
   945 print *tmp334
   946 print "["
   947 print "]"
-    * op greaterThanEq *tmp335 :processUnit.1:distance 0
-    * jump *label231 equal *tmp335 false
+  948 jump *label231 lessThan :processUnit.1:distance 0
   949 print .MSG
   950 print :processUnit.1:distance
   951 print "["
 
   975 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   976 print :printDomeStatus.1:text
   977 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
-    * op greaterThan *tmp344 :printDomeStatus.1:level 3
-    * jump *label236 equal *tmp344 false
+  978 jump *label236 lessThanEq :printDomeStatus.1:level 3
   979 print "  dome:  [green]"
   980 print :printDomeStatus.1:level
   981 print "["
 
   997 set :processUnit.2:supply .SUPPLY_P_FIRST
   998 # "Function: inline def rebindUnit(in currentUnit)"
   999 set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * op notEqual *tmp347 :rebindUnit.6:currentUnit null
-    * jump *label240 equal *tmp347 false
+ 1000 jump *label240 equal :rebindUnit.6:currentUnit null
  1001 ubind :rebindUnit.6:currentUnit
  1002 sensor *tmp349 @unit @dead
  1003 op equal *tmp350 *tmp349 0
 
  1014 label *label241
  1015 ubind .TYPE
  1016 set :rebindUnit.6:firstUnit @unit
-    * op notEqual *tmp355 :rebindUnit.6:firstUnit null
-    * jump *label244 equal *tmp355 false
+ 1017 jump *label244 equal :rebindUnit.6:firstUnit null
  1018 label *label246
  1019 sensor *tmp357 @unit @controlled
-    * op equal *tmp358 *tmp357 0
-    * jump *label249 equal *tmp358 false
+ 1020 jump *label249 notEqual *tmp357 0
  1021 jump *label239 always
  1022 jump *label250 always
  1023 label *label249
 
  1043 op or *tmp367 *tmp365 *tmp366
  1044 jump *label251 equal *tmp367 false
  1045 sensor *tmp369 @unit @firstItem
-    * op equal *tmp370 *tmp369 :processUnit.2:item
-    * jump *label253 equal *tmp370 false
+ 1046 jump *label253 notEqual *tmp369 :processUnit.2:item
  1047 set :processUnit.2:state 3
  1048 jump *label254 always
  1049 label *label253
  1050 sensor *tmp372 @unit @totalItems
-    * op equal *tmp373 *tmp372 0
-    * jump *label255 equal *tmp373 false
+ 1051 jump *label255 notEqual *tmp372 0
  1052 set :processUnit.2:state 2
  1053 jump *label256 always
  1054 label *label255
 
  1065 jump *label252 always
  1066 label *label251
  1067 label *label252
-    * op equal *tmp377 :processUnit.2:state 2
-    * jump *label259 equal *tmp377 false
+ 1068 jump *label259 notEqual :processUnit.2:state 2
  1069 ucontrol within .CORE_X .CORE_Y 8 *tmp379
  1070 jump *label261 equal *tmp379 false
  1071 ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
  1072 sensor *tmp381 @unit @totalItems
-    * op greaterThanEq *tmp382 *tmp381 .UNIT_CAPACITY
-    * jump *label263 equal *tmp382 false
+ 1073 jump *label263 lessThan *tmp381 .UNIT_CAPACITY
  1074 ucontrol approach .DOME_X .DOME_Y 6
  1075 set :processUnit.2:state 3
  1076 jump *label264 always
 
  1092 jump *label260 always
  1093 label *label259
  1094 label *label260
-    * op equal *tmp391 :processUnit.2:state 3
-    * jump *label265 equal *tmp391 false
+ 1095 jump *label265 notEqual :processUnit.2:state 3
  1096 ucontrol within .DOME_X .DOME_Y 8 *tmp393
  1097 jump *label267 equal *tmp393 false
  1098 jump *label269 equal :processUnit.2:supply false
 
  1104 set .MSG ", waiting\n"
  1105 label *label270
  1106 sensor *tmp396 @unit @totalItems
-    * op lessThanEq *tmp397 *tmp396 0
-    * jump *label271 equal *tmp397 false
+ 1107 jump *label271 greaterThan *tmp396 0
  1108 ucontrol approach .CORE_X .CORE_Y 6
  1109 set :processUnit.2:state 2
  1110 jump *label272 always
 
  1136 print *tmp406
  1137 print "["
  1138 print "]"
-    * op greaterThanEq *tmp407 :processUnit.2:distance 0
-    * jump *label273 equal *tmp407 false
+ 1139 jump *label273 lessThan :processUnit.2:distance 0
  1140 print .MSG
  1141 print :processUnit.2:distance
  1142 print "["
 
  1158 set :processUnit.3:supply *tmp411
  1159 # "Function: inline def rebindUnit(in currentUnit)"
  1160 set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * op notEqual *tmp413 :rebindUnit.7:currentUnit null
-    * jump *label279 equal *tmp413 false
+ 1161 jump *label279 equal :rebindUnit.7:currentUnit null
  1162 ubind :rebindUnit.7:currentUnit
  1163 sensor *tmp415 @unit @dead
  1164 op equal *tmp416 *tmp415 0
 
  1175 label *label280
  1176 ubind .TYPE
  1177 set :rebindUnit.7:firstUnit @unit
-    * op notEqual *tmp421 :rebindUnit.7:firstUnit null
-    * jump *label283 equal *tmp421 false
+ 1178 jump *label283 equal :rebindUnit.7:firstUnit null
  1179 label *label285
  1180 sensor *tmp423 @unit @controlled
-    * op equal *tmp424 *tmp423 0
-    * jump *label288 equal *tmp424 false
+ 1181 jump *label288 notEqual *tmp423 0
  1182 jump *label278 always
  1183 jump *label289 always
  1184 label *label288
 
  1204 op or *tmp433 *tmp431 *tmp432
  1205 jump *label290 equal *tmp433 false
  1206 sensor *tmp435 @unit @firstItem
-    * op equal *tmp436 *tmp435 :processUnit.3:item
-    * jump *label292 equal *tmp436 false
+ 1207 jump *label292 notEqual *tmp435 :processUnit.3:item
  1208 set :processUnit.3:state 3
  1209 jump *label293 always
  1210 label *label292
  1211 sensor *tmp438 @unit @totalItems
-    * op equal *tmp439 *tmp438 0
-    * jump *label294 equal *tmp439 false
+ 1212 jump *label294 notEqual *tmp438 0
  1213 set :processUnit.3:state 2
  1214 jump *label295 always
  1215 label *label294
 
  1226 jump *label291 always
  1227 label *label290
  1228 label *label291
-    * op equal *tmp443 :processUnit.3:state 2
-    * jump *label298 equal *tmp443 false
+ 1229 jump *label298 notEqual :processUnit.3:state 2
  1230 ucontrol within .CORE_X .CORE_Y 8 *tmp445
  1231 jump *label300 equal *tmp445 false
  1232 ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
  1233 sensor *tmp447 @unit @totalItems
-    * op greaterThanEq *tmp448 *tmp447 .UNIT_CAPACITY
-    * jump *label302 equal *tmp448 false
+ 1234 jump *label302 lessThan *tmp447 .UNIT_CAPACITY
  1235 ucontrol approach .DOME_X .DOME_Y 6
  1236 set :processUnit.3:state 3
  1237 jump *label303 always
 
  1253 jump *label299 always
  1254 label *label298
  1255 label *label299
-    * op equal *tmp457 :processUnit.3:state 3
-    * jump *label304 equal *tmp457 false
+ 1256 jump *label304 notEqual :processUnit.3:state 3
  1257 ucontrol within .DOME_X .DOME_Y 8 *tmp459
  1258 jump *label306 equal *tmp459 false
  1259 jump *label308 equal :processUnit.3:supply false
 
  1265 set .MSG ", waiting\n"
  1266 label *label309
  1267 sensor *tmp462 @unit @totalItems
-    * op lessThanEq *tmp463 *tmp462 0
-    * jump *label310 equal *tmp463 false
+ 1268 jump *label310 greaterThan *tmp462 0
  1269 ucontrol approach .CORE_X .CORE_Y 6
  1270 set :processUnit.3:state 2
  1271 jump *label311 always
 
  1297 print *tmp472
  1298 print "["
  1299 print "]"
-    * op greaterThanEq *tmp473 :processUnit.3:distance 0
-    * jump *label312 equal *tmp473 false
+ 1300 jump *label312 lessThan :processUnit.3:distance 0
  1301 print .MSG
  1302 print :processUnit.3:distance
  1303 print "["
 
  1342 set :areUnitsAvailable.2:needed 0
  1343 ubind :areUnitsAvailable.2:type
  1344 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp488 :areUnitsAvailable.2:firstUnit null
-    * jump *label319 equal *tmp488 false
+ 1345 jump *label319 equal :areUnitsAvailable.2:firstUnit null
  1346 # "Function: inline def needsFourUnits(in unit)"
  1347 set :needsFourUnits.3:unit @unit
  1348 op sub *tmp491 .DOME_X .CORE_X
 
  1370 op or *tmp503 *tmp500 *tmp502
  1371 jump *label327 equal *tmp503 false
  1372 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * op greaterThanEq *tmp505 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
-    * jump *label329 equal *tmp505 false
+ 1373 jump *label329 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1374 set *tmp487 true
  1375 jump *label318 always
  1376 jump *label330 always
 
  1399 print ","
  1400 print " free: "
  1401 print :areUnitsAvailable.2:free
-    * op greaterThan *tmp513 :areUnitsAvailable.2:needed 0
-    * jump *label333 equal *tmp513 false
+ 1402 jump *label333 lessThanEq :areUnitsAvailable.2:needed 0
  1403 print ", needed: "
  1404 print :areUnitsAvailable.2:needed
  1405 jump *label334 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-81 instructions):
 
    37 call *label0 :locateCore*retaddr :locateCore*retval
    38 jump *label17 equal :locateCore*retval false
    39 jump *label1 always
-    * jump *label18 always
    40 label *label17
    41 label *label18
    42 label *label9
 
   105 jump *label37 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   106 set *tmp10 true
   107 jump *label26 always
-    * jump *label38 always
   108 label *label37
   109 label *label38
   110 jump *label36 always
 
   119 op land *tmp34 *tmp31 *tmp33
   120 jump *label32 notEqual *tmp34 false
   121 label *label34
-    * jump *label28 always
   122 label *label27
   123 label *label28
   124 jump *label39 equal :areUnitsAvailable:output false
 
   132 jump *label41 lessThanEq :areUnitsAvailable:needed 0
   133 print ", needed: "
   134 print :areUnitsAvailable:needed
-    * jump *label42 always
   135 label *label41
   136 label *label42
   137 print "\n"
-    * jump *label40 always
   138 label *label39
   139 label *label40
   140 set *tmp10 false
 
   144 jump *label43 equal *tmp10 false
   145 set *tmp9 UNIT_TYPE
   146 jump *label22 always
-    * jump *label44 always
   147 label *label43
   148 label *label44
   149 set :chooseUnitType:type @flare
 
   204 jump *label67 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   205 set *tmp42 true
   206 jump *label56 always
-    * jump *label68 always
   207 label *label67
   208 label *label68
   209 jump *label66 always
 
   218 op land *tmp66 *tmp63 *tmp65
   219 jump *label62 notEqual *tmp66 false
   220 label *label64
-    * jump *label58 always
   221 label *label57
   222 label *label58
   223 jump *label69 equal :areUnitsAvailable.1:output false
 
   231 jump *label71 lessThanEq :areUnitsAvailable.1:needed 0
   232 print ", needed: "
   233 print :areUnitsAvailable.1:needed
-    * jump *label72 always
   234 label *label71
   235 label *label72
   236 print "\n"
-    * jump *label70 always
   237 label *label69
   238 label *label70
   239 set *tmp42 false
 
   244 printflush null
   245 set *tmp9 :chooseUnitType:type
   246 jump *label22 always
-    * jump *label74 always
   247 label *label73
   248 label *label74
-    * jump *label55 always
   249 label *label54
   250 label *label55
   251 label *label46
 
   272 set :rebindUnits:firstUnit @unit
   273 jump *label76 notEqual :rebindUnits:firstUnit null
   274 end
-    * jump *label77 always
   275 label *label76
   276 label *label77
   277 label *label78
 
   285 set .UNIT_P1 @unit
   286 jump *label83 equal .UNIT_S2 null
   287 jump *label80 always
-    * jump *label84 always
   288 label *label83
   289 label *label84
-    * jump *label82 always
   290 label *label81
   291 label *label82
   292 ubind .TYPE
 
   297 op land *tmp84 *tmp81 *tmp83
   298 jump *label78 notEqual *tmp84 false
   299 label *label80
-    * jump *label75 always
   300 label *label75
   301 # "Function: inline def acquireUnit(in currentUnit)"
   302 set :acquireUnit:currentUnit .UNIT_S1
 
   311 op land *tmp93 *tmp90 *tmp92
   312 jump *label89 equal *tmp93 false
   313 jump *label86 always
-    * jump *label90 always
   314 label *label89
   315 label *label90
-    * jump *label88 always
   316 label *label87
   317 label *label88
   318 ubind .TYPE
 
   322 sensor *tmp97 @unit @controlled
   323 jump *label96 notEqual *tmp97 0
   324 jump *label86 always
-    * jump *label97 always
   325 label *label96
   326 label *label97
   327 ubind .TYPE
 
   332 op land *tmp103 *tmp100 *tmp102
   333 jump *label93 notEqual *tmp103 false
   334 label *label95
-    * jump *label92 always
   335 label *label91
   336 label *label92
   337 end
 
   355 op land *tmp112 *tmp109 *tmp111
   356 jump *label102 equal *tmp112 false
   357 jump *label99 always
-    * jump *label103 always
   358 label *label102
   359 label *label103
-    * jump *label101 always
   360 label *label100
   361 label *label101
   362 ubind .TYPE
 
   366 sensor *tmp116 @unit @controlled
   367 jump *label109 notEqual *tmp116 0
   368 jump *label99 always
-    * jump *label110 always
   369 label *label109
   370 label *label110
   371 ubind .TYPE
 
   376 op land *tmp122 *tmp119 *tmp121
   377 jump *label106 notEqual *tmp122 false
   378 label *label108
-    * jump *label105 always
   379 label *label104
   380 label *label105
   381 end
 
   401 label *label113
   402 set .UNIT_S1 :swap:a
   403 set .UNIT_P1 :swap:b
-    * jump *label112 always
   404 label *label111
   405 label *label112
   406 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   409 op strictEqual *tmp132 .SPEED null
   410 jump *label114 equal *tmp132 false
   411 stop
-    * jump *label115 always
   412 label *label114
   413 label *label115
   414 # "Function: inline def needsFourUnits(in unit)"
 
   438 op land *tmp151 *tmp148 *tmp150
   439 jump *label123 equal *tmp151 false
   440 jump *label120 always
-    * jump *label124 always
   441 label *label123
   442 label *label124
-    * jump *label122 always
   443 label *label121
   444 label *label122
   445 ubind .TYPE
 
   449 sensor *tmp155 @unit @controlled
   450 jump *label130 notEqual *tmp155 0
   451 jump *label120 always
-    * jump *label131 always
   452 label *label130
   453 label *label131
   454 ubind .TYPE
 
   459 op land *tmp161 *tmp158 *tmp160
   460 jump *label127 notEqual *tmp161 false
   461 label *label129
-    * jump *label126 always
   462 label *label125
   463 label *label126
   464 end
 
   482 op land *tmp170 *tmp167 *tmp169
   483 jump *label136 equal *tmp170 false
   484 jump *label133 always
-    * jump *label137 always
   485 label *label136
   486 label *label137
-    * jump *label135 always
   487 label *label134
   488 label *label135
   489 ubind .TYPE
 
   493 sensor *tmp174 @unit @controlled
   494 jump *label143 notEqual *tmp174 0
   495 jump *label133 always
-    * jump *label144 always
   496 label *label143
   497 label *label144
   498 ubind .TYPE
 
   503 op land *tmp180 *tmp177 *tmp179
   504 jump *label140 notEqual *tmp180 false
   505 label *label142
-    * jump *label139 always
   506 label *label138
   507 label *label139
   508 end
 
   528 label *label147
   529 set .UNIT_S1 :swap.1:a
   530 set .UNIT_P2 :swap.1:b
-    * jump *label146 always
   531 label *label145
   532 label *label146
   533 sensor *tmp187 .UNIT_S2 @firstItem
 
   545 label *label150
   546 set .UNIT_S2 :swap.2:a
   547 set .UNIT_P2 :swap.2:b
-    * jump *label149 always
   548 label *label148
   549 label *label149
   550 set .GROUP1 "unit  1"
 
   618 op land *tmp215 *tmp212 *tmp214
   619 jump *label161 equal *tmp215 false
   620 jump *label158 always
-    * jump *label162 always
   621 label *label161
   622 label *label162
-    * jump *label160 always
   623 label *label159
   624 label *label160
   625 ubind .TYPE
 
   629 sensor *tmp219 @unit @controlled
   630 jump *label168 notEqual *tmp219 0
   631 jump *label158 always
-    * jump *label169 always
   632 label *label168
   633 label *label169
   634 ubind .TYPE
 
   639 op land *tmp225 *tmp222 *tmp224
   640 jump *label165 notEqual *tmp225 false
   641 label *label167
-    * jump *label164 always
   642 label *label163
   643 label *label164
   644 end
 
   665 ucontrol within .CORE_X .CORE_Y 8 *tmp237
   666 jump *label176 equal *tmp237 false
   667 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label177 always
   668 label *label176
   669 label *label177
   670 label *label175
   671 label *label173
-    * jump *label171 always
   672 label *label170
   673 label *label171
   674 jump *label178 notEqual :processUnit:state 2
 
   695 op idiv *tmp251 *tmp250 .SPEED_TENTHS
   696 op div :processUnit:distance *tmp251 10
   697 label *label181
-    * jump *label179 always
   698 label *label178
   699 label *label179
   700 jump *label184 notEqual :processUnit:state 3
 
   712 jump *label190 greaterThan *tmp258 0
   713 ucontrol approach .CORE_X .CORE_Y 6
   714 set :processUnit:state 2
-    * jump *label191 always
   715 label *label190
   716 label *label191
   717 jump *label187 always
 
   726 op idiv *tmp266 *tmp265 .SPEED_TENTHS
   727 op div :processUnit:distance *tmp266 10
   728 label *label187
-    * jump *label185 always
   729 label *label184
   730 label *label185
   731 ucontrol flag :processUnit:state
 
   770 op land *tmp281 *tmp278 *tmp280
   771 jump *label200 equal *tmp281 false
   772 jump *label197 always
-    * jump *label201 always
   773 label *label200
   774 label *label201
-    * jump *label199 always
   775 label *label198
   776 label *label199
   777 ubind .TYPE
 
   781 sensor *tmp285 @unit @controlled
   782 jump *label207 notEqual *tmp285 0
   783 jump *label197 always
-    * jump *label208 always
   784 label *label207
   785 label *label208
   786 ubind .TYPE
 
   791 op land *tmp291 *tmp288 *tmp290
   792 jump *label204 notEqual *tmp291 false
   793 label *label206
-    * jump *label203 always
   794 label *label202
   795 label *label203
   796 end
 
   817 ucontrol within .CORE_X .CORE_Y 8 *tmp303
   818 jump *label215 equal *tmp303 false
   819 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label216 always
   820 label *label215
   821 label *label216
   822 label *label214
   823 label *label212
-    * jump *label210 always
   824 label *label209
   825 label *label210
   826 jump *label217 notEqual :processUnit.1:state 2
 
   847 op idiv *tmp317 *tmp316 .SPEED_TENTHS
   848 op div :processUnit.1:distance *tmp317 10
   849 label *label220
-    * jump *label218 always
   850 label *label217
   851 label *label218
   852 jump *label223 notEqual :processUnit.1:state 3
 
   864 jump *label229 greaterThan *tmp324 0
   865 ucontrol approach .CORE_X .CORE_Y 6
   866 set :processUnit.1:state 2
-    * jump *label230 always
   867 label *label229
   868 label *label230
   869 jump *label226 always
 
   878 op idiv *tmp332 *tmp331 .SPEED_TENTHS
   879 op div :processUnit.1:distance *tmp332 10
   880 label *label226
-    * jump *label224 always
   881 label *label223
   882 label *label224
   883 ucontrol flag :processUnit.1:state
 
   913 op equal *tmp338 *tmp341 0
   914 label *label234
   915 set .SUPPLY_S_FIRST *tmp338
-    * jump *label195 always
   916 label *label194
   917 label *label195
   918 # "Function: inline void printDomeStatus(in item, in text)"
 
   951 op land *tmp353 *tmp350 *tmp352
   952 jump *label242 equal *tmp353 false
   953 jump *label239 always
-    * jump *label243 always
   954 label *label242
   955 label *label243
-    * jump *label241 always
   956 label *label240
   957 label *label241
   958 ubind .TYPE
 
   962 sensor *tmp357 @unit @controlled
   963 jump *label249 notEqual *tmp357 0
   964 jump *label239 always
-    * jump *label250 always
   965 label *label249
   966 label *label250
   967 ubind .TYPE
 
   972 op land *tmp363 *tmp360 *tmp362
   973 jump *label246 notEqual *tmp363 false
   974 label *label248
-    * jump *label245 always
   975 label *label244
   976 label *label245
   977 end
 
   998 ucontrol within .CORE_X .CORE_Y 8 *tmp375
   999 jump *label257 equal *tmp375 false
  1000 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label258 always
  1001 label *label257
  1002 label *label258
  1003 label *label256
  1004 label *label254
-    * jump *label252 always
  1005 label *label251
  1006 label *label252
  1007 jump *label259 notEqual :processUnit.2:state 2
 
  1028 op idiv *tmp389 *tmp388 .SPEED_TENTHS
  1029 op div :processUnit.2:distance *tmp389 10
  1030 label *label262
-    * jump *label260 always
  1031 label *label259
  1032 label *label260
  1033 jump *label265 notEqual :processUnit.2:state 3
 
  1045 jump *label271 greaterThan *tmp396 0
  1046 ucontrol approach .CORE_X .CORE_Y 6
  1047 set :processUnit.2:state 2
-    * jump *label272 always
  1048 label *label271
  1049 label *label272
  1050 jump *label268 always
 
  1059 op idiv *tmp404 *tmp403 .SPEED_TENTHS
  1060 op div :processUnit.2:distance *tmp404 10
  1061 label *label268
-    * jump *label266 always
  1062 label *label265
  1063 label *label266
  1064 ucontrol flag :processUnit.2:state
 
  1103 op land *tmp419 *tmp416 *tmp418
  1104 jump *label281 equal *tmp419 false
  1105 jump *label278 always
-    * jump *label282 always
  1106 label *label281
  1107 label *label282
-    * jump *label280 always
  1108 label *label279
  1109 label *label280
  1110 ubind .TYPE
 
  1114 sensor *tmp423 @unit @controlled
  1115 jump *label288 notEqual *tmp423 0
  1116 jump *label278 always
-    * jump *label289 always
  1117 label *label288
  1118 label *label289
  1119 ubind .TYPE
 
  1124 op land *tmp429 *tmp426 *tmp428
  1125 jump *label285 notEqual *tmp429 false
  1126 label *label287
-    * jump *label284 always
  1127 label *label283
  1128 label *label284
  1129 end
 
  1150 ucontrol within .CORE_X .CORE_Y 8 *tmp441
  1151 jump *label296 equal *tmp441 false
  1152 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label297 always
  1153 label *label296
  1154 label *label297
  1155 label *label295
  1156 label *label293
-    * jump *label291 always
  1157 label *label290
  1158 label *label291
  1159 jump *label298 notEqual :processUnit.3:state 2
 
  1180 op idiv *tmp455 *tmp454 .SPEED_TENTHS
  1181 op div :processUnit.3:distance *tmp455 10
  1182 label *label301
-    * jump *label299 always
  1183 label *label298
  1184 label *label299
  1185 jump *label304 notEqual :processUnit.3:state 3
 
  1197 jump *label310 greaterThan *tmp462 0
  1198 ucontrol approach .CORE_X .CORE_Y 6
  1199 set :processUnit.3:state 2
-    * jump *label311 always
  1200 label *label310
  1201 label *label311
  1202 jump *label307 always
 
  1211 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1212 op div :processUnit.3:distance *tmp470 10
  1213 label *label307
-    * jump *label305 always
  1214 label *label304
  1215 label *label305
  1216 ucontrol flag :processUnit.3:state
 
  1246 op equal *tmp476 *tmp479 0
  1247 label *label315
  1248 set .SUPPLY_P_FIRST *tmp476
-    * jump *label276 always
  1249 label *label275
  1250 label *label276
  1251 op sub *tmp481 @time :start
 
  1299 jump *label329 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1300 set *tmp487 true
  1301 jump *label318 always
-    * jump *label330 always
  1302 label *label329
  1303 label *label330
  1304 jump *label328 always
 
  1313 op land *tmp511 *tmp508 *tmp510
  1314 jump *label324 notEqual *tmp511 false
  1315 label *label326
-    * jump *label320 always
  1316 label *label319
  1317 label *label320
  1318 jump *label331 equal :areUnitsAvailable.2:output false
 
  1326 jump *label333 lessThanEq :areUnitsAvailable.2:needed 0
  1327 print ", needed: "
  1328 print :areUnitsAvailable.2:needed
-    * jump *label334 always
  1329 label *label333
  1330 label *label334
  1331 print "\n"
-    * jump *label332 always
  1332 label *label331
  1333 label *label332
  1334 set *tmp487 false
 
  1337 label *label318
  1338 jump *label335 equal *tmp487 false
  1339 end
-    * jump *label336 always
  1340 label *label335
  1341 label *label336
  1342 op add :unitCheck @time 5000
-    * jump *label317 always
  1343 label *label316
  1344 label *label317
  1345 label *label152
 
  1356 op or *tmp521 *tmp518 *tmp520
  1357 jump *label338 equal *tmp521 false
  1358 ulocate building core false @copper 0 0 0 .CORE
-    * jump *label339 always
  1359 label *label338
  1360 label *label339
  1361 set :locateCore*retval .CORE

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-11 instructions):
 
    72 set :areUnitsAvailable:free 0
    73 set :areUnitsAvailable:occupied 0
    74 set :areUnitsAvailable:needed 0
-    * ubind :areUnitsAvailable:type
+   75 ubind UNIT_TYPE
    76 set :areUnitsAvailable:firstUnit @unit
    77 jump *label27 equal :areUnitsAvailable:firstUnit null
    78 # "Function: inline def needsFourUnits(in unit)"
 
    85 op div :needsFourUnits:travel_time *tmp17 *tmp18
    86 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    87 jump *label29 always
-    * set *tmp13 null
    88 label *label29
    89 jump *label30 equal *tmp13 false
    90 set *tmp21 4
 
   101 op or *tmp26 *tmp23 *tmp25
   102 jump *label35 equal *tmp26 false
   103 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label37 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
+  104 jump *label37 lessThan :areUnitsAvailable:free *tmp21
   105 set *tmp10 true
   106 jump *label26 always
   107 label *label37
 
   110 label *label35
   111 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   112 label *label36
-    * ubind :areUnitsAvailable:type
+  113 ubind UNIT_TYPE
   114 label *label33
   115 op notEqual *tmp31 @unit :areUnitsAvailable:firstUnit
   116 sensor *tmp32 :areUnitsAvailable:firstUnit @dead
 
   120 label *label34
   121 label *label27
   122 label *label28
-    * jump *label39 equal :areUnitsAvailable:output false
-    * print :areUnitsAvailable:type
+  123 jump *label39 equal true false
+  124 print UNIT_TYPE
   125 print ":"
   126 print " occupied: "
   127 print :areUnitsAvailable:occupied
 
   138 label *label40
   139 set *tmp10 false
   140 jump *label26 always
-    * set *tmp10 null
   141 label *label26
   142 jump *label43 equal *tmp10 false
   143 set *tmp9 UNIT_TYPE
 
   169 set :areUnitsAvailable.1:free 0
   170 set :areUnitsAvailable.1:occupied 0
   171 set :areUnitsAvailable.1:needed 0
-    * ubind :areUnitsAvailable.1:type
+  172 ubind :chooseUnitType:type
   173 set :areUnitsAvailable.1:firstUnit @unit
   174 jump *label57 equal :areUnitsAvailable.1:firstUnit null
   175 # "Function: inline def needsFourUnits(in unit)"
 
   182 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   183 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   184 jump *label59 always
-    * set *tmp45 null
   185 label *label59
   186 jump *label60 equal *tmp45 false
   187 set *tmp53 4
 
   198 op or *tmp58 *tmp55 *tmp57
   199 jump *label65 equal *tmp58 false
   200 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label67 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  201 jump *label67 lessThan :areUnitsAvailable.1:free *tmp53
   202 set *tmp42 true
   203 jump *label56 always
   204 label *label67
 
   207 label *label65
   208 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   209 label *label66
-    * ubind :areUnitsAvailable.1:type
+  210 ubind :chooseUnitType:type
   211 label *label63
   212 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   213 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   217 label *label64
   218 label *label57
   219 label *label58
-    * jump *label69 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  220 jump *label69 equal true false
+  221 print :chooseUnitType:type
   222 print ":"
   223 print " occupied: "
   224 print :areUnitsAvailable.1:occupied
 
   235 label *label70
   236 set *tmp42 false
   237 jump *label56 always
-    * set *tmp42 null
   238 label *label56
   239 jump *label73 equal *tmp42 false
   240 printflush null
 
   260 printflush message1
   261 # "Function: inline def rebindUnits()"
   262 set .UNIT_P2 null
-    * set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P1 .UNIT_S2
-    * set .UNIT_S1 .UNIT_P1
+  263 set .UNIT_S2 null
+  264 set .UNIT_P1 .UNIT_P2
+  265 set .UNIT_S1 .UNIT_S2
   266 set :rebindUnits:count 0
-    * ubind .TYPE
+  267 ubind *tmp9
   268 set :rebindUnits:firstUnit @unit
   269 jump *label76 notEqual :rebindUnits:firstUnit null
   270 end
 
   285 label *label84
   286 label *label81
   287 label *label82
-    * ubind .TYPE
+  288 ubind *tmp9
   289 label *label79
   290 op notEqual *tmp81 @unit :rebindUnits:firstUnit
   291 sensor *tmp82 :rebindUnits:firstUnit @dead
 
   297 # "Function: inline def acquireUnit(in currentUnit)"
   298 set :acquireUnit:currentUnit .UNIT_S1
   299 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * jump *label87 equal :rebindUnit:currentUnit null
-    * ubind :rebindUnit:currentUnit
+  300 set :rebindUnit:currentUnit .UNIT_S1
+  301 jump *label87 equal :acquireUnit:currentUnit null
+  302 ubind :acquireUnit:currentUnit
   303 sensor *tmp89 @unit @dead
   304 op equal *tmp90 *tmp89 0
   305 sensor *tmp91 @unit @controller
 
   311 label *label90
   312 label *label87
   313 label *label88
-    * ubind .TYPE
+  314 ubind *tmp9
   315 set :rebindUnit:firstUnit @unit
   316 jump *label91 equal :rebindUnit:firstUnit null
   317 label *label93
 
   320 jump *label86 always
   321 label *label96
   322 label *label97
-    * ubind .TYPE
+  323 ubind *tmp9
   324 label *label94
   325 op notEqual *tmp100 @unit :rebindUnit:firstUnit
   326 sensor *tmp101 :rebindUnit:firstUnit @dead
 
   335 ucontrol flag 1
   336 set *tmp85 @unit
   337 jump *label85 always
-    * set *tmp85 null
   338 label *label85
   339 set .UNIT_S1 *tmp85
   340 # "Function: inline def acquireUnit(in currentUnit)"
   341 set :acquireUnit.1:currentUnit .UNIT_P1
   342 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * jump *label100 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  343 set :rebindUnit.1:currentUnit .UNIT_P1
+  344 jump *label100 equal :acquireUnit.1:currentUnit null
+  345 ubind :acquireUnit.1:currentUnit
   346 sensor *tmp108 @unit @dead
   347 op equal *tmp109 *tmp108 0
   348 sensor *tmp110 @unit @controller
 
   354 label *label103
   355 label *label100
   356 label *label101
-    * ubind .TYPE
+  357 ubind *tmp9
   358 set :rebindUnit.1:firstUnit @unit
   359 jump *label104 equal :rebindUnit.1:firstUnit null
   360 label *label106
 
   363 jump *label99 always
   364 label *label109
   365 label *label110
-    * ubind .TYPE
+  366 ubind *tmp9
   367 label *label107
   368 op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
   369 sensor *tmp120 :rebindUnit.1:firstUnit @dead
 
   378 ucontrol flag 1
   379 set *tmp104 @unit
   380 jump *label98 always
-    * set *tmp104 null
   381 label *label98
   382 set .UNIT_P1 *tmp104
-    * sensor *tmp123 .UNIT_S1 @firstItem
+  383 sensor *tmp123 *tmp85 @firstItem
   384 op equal *tmp124 *tmp123 @phase-fabric
-    * sensor *tmp125 .UNIT_P1 @firstItem
+  385 sensor *tmp125 *tmp104 @firstItem
   386 op equal *tmp126 *tmp125 @silicon
   387 op or *tmp127 *tmp124 *tmp126
   388 jump *label111 equal *tmp127 false
   389 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:a .UNIT_S1
-    * set :swap:b .UNIT_P1
-    * set :swap:t :swap:a
-    * set :swap:a :swap:b
+  390 set :swap:a *tmp85
+  391 set :swap:b *tmp104
+  392 set :swap:t .UNIT_S1
+  393 set :swap:a .UNIT_P1
   394 set :swap:b :swap:t
   395 label *label113
   396 set .UNIT_S1 :swap:a
-    * set .UNIT_P1 :swap:b
+  397 set .UNIT_P1 :swap:t
   398 label *label111
   399 label *label112
   400 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   411 op sub *tmp136 .DOME_Y .CORE_Y
   412 op len *tmp137 *tmp135 *tmp136
   413 op mul *tmp138 2 *tmp137
-    * sensor *tmp139 :needsFourUnits.2:unit @speed
-    * op div :needsFourUnits.2:travel_time *tmp138 *tmp139
+  414 sensor *tmp139 .UNIT_S1 @speed
+  415 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   416 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   417 jump *label116 always
-    * set *tmp134 null
   418 label *label116
   419 set .FOUR_UNITS *tmp134
-    * jump *label117 equal .FOUR_UNITS false
+  420 jump *label117 equal *tmp134 false
   421 # "Function: inline def acquireUnit(in currentUnit)"
   422 set :acquireUnit.2:currentUnit .UNIT_S2
   423 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * jump *label121 equal :rebindUnit.2:currentUnit null
-    * ubind :rebindUnit.2:currentUnit
+  424 set :rebindUnit.2:currentUnit .UNIT_S2
+  425 jump *label121 equal :acquireUnit.2:currentUnit null
+  426 ubind :acquireUnit.2:currentUnit
   427 sensor *tmp147 @unit @dead
   428 op equal *tmp148 *tmp147 0
   429 sensor *tmp149 @unit @controller
 
   435 label *label124
   436 label *label121
   437 label *label122
-    * ubind .TYPE
+  438 ubind *tmp9
   439 set :rebindUnit.2:firstUnit @unit
   440 jump *label125 equal :rebindUnit.2:firstUnit null
   441 label *label127
 
   444 jump *label120 always
   445 label *label130
   446 label *label131
-    * ubind .TYPE
+  447 ubind *tmp9
   448 label *label128
   449 op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
   450 sensor *tmp159 :rebindUnit.2:firstUnit @dead
 
   459 ucontrol flag 1
   460 set *tmp143 @unit
   461 jump *label119 always
-    * set *tmp143 null
   462 label *label119
   463 set .UNIT_S2 *tmp143
   464 # "Function: inline def acquireUnit(in currentUnit)"
   465 set :acquireUnit.3:currentUnit .UNIT_P2
   466 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * jump *label134 equal :rebindUnit.3:currentUnit null
-    * ubind :rebindUnit.3:currentUnit
+  467 set :rebindUnit.3:currentUnit .UNIT_P2
+  468 jump *label134 equal :acquireUnit.3:currentUnit null
+  469 ubind :acquireUnit.3:currentUnit
   470 sensor *tmp166 @unit @dead
   471 op equal *tmp167 *tmp166 0
   472 sensor *tmp168 @unit @controller
 
   478 label *label137
   479 label *label134
   480 label *label135
-    * ubind .TYPE
+  481 ubind *tmp9
   482 set :rebindUnit.3:firstUnit @unit
   483 jump *label138 equal :rebindUnit.3:firstUnit null
   484 label *label140
 
   487 jump *label133 always
   488 label *label143
   489 label *label144
-    * ubind .TYPE
+  490 ubind *tmp9
   491 label *label141
   492 op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
   493 sensor *tmp178 :rebindUnit.3:firstUnit @dead
 
   502 ucontrol flag 1
   503 set *tmp162 @unit
   504 jump *label132 always
-    * set *tmp162 null
   505 label *label132
   506 set .UNIT_P2 *tmp162
   507 sensor *tmp181 .UNIT_S1 @firstItem
   508 op equal *tmp182 *tmp181 @phase-fabric
-    * sensor *tmp183 .UNIT_P2 @firstItem
+  509 sensor *tmp183 *tmp162 @firstItem
   510 op notEqual *tmp184 *tmp183 @phase-fabric
   511 op land *tmp185 *tmp182 *tmp184
   512 jump *label145 equal *tmp185 false
   513 # "Function: inline void swap(in out a, in out b)"
   514 set :swap.1:a .UNIT_S1
-    * set :swap.1:b .UNIT_P2
-    * set :swap.1:t :swap.1:a
-    * set :swap.1:a :swap.1:b
+  515 set :swap.1:b *tmp162
+  516 set :swap.1:t .UNIT_S1
+  517 set :swap.1:a .UNIT_P2
   518 set :swap.1:b :swap.1:t
   519 label *label147
   520 set .UNIT_S1 :swap.1:a
-    * set .UNIT_P2 :swap.1:b
+  521 set .UNIT_P2 :swap.1:t
   522 label *label145
   523 label *label146
-    * sensor *tmp187 .UNIT_S2 @firstItem
+  524 sensor *tmp187 *tmp143 @firstItem
   525 op equal *tmp188 *tmp187 @phase-fabric
   526 sensor *tmp189 .UNIT_P2 @firstItem
   527 op equal *tmp190 *tmp189 @silicon
   528 op or *tmp191 *tmp188 *tmp190
   529 jump *label148 equal *tmp191 false
   530 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:a .UNIT_S2
+  531 set :swap.2:a *tmp143
   532 set :swap.2:b .UNIT_P2
-    * set :swap.2:t :swap.2:a
-    * set :swap.2:a :swap.2:b
+  533 set :swap.2:t .UNIT_S2
+  534 set :swap.2:a .UNIT_P2
   535 set :swap.2:b :swap.2:t
   536 label *label150
   537 set .UNIT_S2 :swap.2:a
-    * set .UNIT_P2 :swap.2:b
+  538 set .UNIT_P2 :swap.2:t
   539 label *label148
   540 label *label149
   541 set .GROUP1 "unit  1"
 
   550 set .UNIT_P2 null
   551 set .GROUP1 "unit"
   552 label *label118
-    * op equal *tmp193 .FOUR_UNITS false
+  553 op equal *tmp193 *tmp134 false
   554 sensor *tmp194 .UNIT_S1 @totalItems
   555 sensor *tmp195 .UNIT_S2 @totalItems
   556 op lessThan *tmp196 *tmp194 *tmp195
   557 op or .SUPPLY_S_FIRST *tmp193 *tmp196
-    * op equal *tmp198 .FOUR_UNITS false
+  558 op equal *tmp198 *tmp134 false
   559 sensor *tmp199 .UNIT_P1 @totalItems
   560 sensor *tmp200 .UNIT_P2 @totalItems
   561 op lessThan *tmp201 *tmp199 *tmp200
-    * op or .SUPPLY_P_FIRST *tmp198 *tmp201
+  562 op or .SUPPLY_P_FIRST *tmp193 *tmp201
   563 op add :unitCheck @time 5000
   564 label *label151
   565 sensor *tmp204 switch1 @enabled
 
   569 print "\n"
   570 print "\n"
   571 print "Unit type: [green]"
-    * print .TYPE
+  572 print *tmp9
   573 print "["
   574 print "]"
   575 print "\n"
   576 # "Function: inline void printDomeStatus(in item, in text)"
   577 set :printDomeStatus:item @silicon
   578 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
-    * print :printDomeStatus:text
-    * sensor :printDomeStatus:level .DOME :printDomeStatus:item
+  579 print "\n[green]Silicon[] status:\n"
+  580 sensor :printDomeStatus:level .DOME @silicon
   581 jump *label155 lessThanEq :printDomeStatus:level 3
   582 print "  dome:  [green]"
   583 print :printDomeStatus:level
 
   599 set :processUnit:group .GROUP1
   600 set :processUnit:supply .SUPPLY_S_FIRST
   601 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit :processUnit:unit
-    * jump *label159 equal :rebindUnit.4:currentUnit null
-    * ubind :rebindUnit.4:currentUnit
+  602 set :rebindUnit.4:currentUnit .UNIT_S1
+  603 jump *label159 equal :processUnit:unit null
+  604 ubind :processUnit:unit
   605 sensor *tmp211 @unit @dead
   606 op equal *tmp212 *tmp211 0
   607 sensor *tmp213 @unit @controller
 
   613 label *label162
   614 label *label159
   615 label *label160
-    * ubind .TYPE
+  616 ubind *tmp9
   617 set :rebindUnit.4:firstUnit @unit
   618 jump *label163 equal :rebindUnit.4:firstUnit null
   619 label *label165
 
   622 jump *label158 always
   623 label *label168
   624 label *label169
-    * ubind .TYPE
+  625 ubind *tmp9
   626 label *label166
   627 op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
   628 sensor *tmp223 :rebindUnit.4:firstUnit @dead
 
   642 op or *tmp229 *tmp227 *tmp228
   643 jump *label170 equal *tmp229 false
   644 sensor *tmp231 @unit @firstItem
-    * jump *label172 notEqual *tmp231 :processUnit:item
+  645 jump *label172 notEqual *tmp231 @silicon
   646 set :processUnit:state 3
   647 jump *label173 always
   648 label *label172
 
   665 jump *label178 notEqual :processUnit:state 2
   666 ucontrol within .CORE_X .CORE_Y 8 *tmp241
   667 jump *label180 equal *tmp241 false
-    * ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
+  668 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   669 sensor *tmp243 @unit @totalItems
   670 jump *label182 lessThan *tmp243 .UNIT_CAPACITY
   671 ucontrol approach .DOME_X .DOME_Y 6
 
   691 jump *label184 notEqual :processUnit:state 3
   692 ucontrol within .DOME_X .DOME_Y 8 *tmp255
   693 jump *label186 equal *tmp255 false
-    * jump *label188 equal :processUnit:supply false
+  694 jump *label188 equal .SUPPLY_S_FIRST false
   695 ucontrol itemDrop .DOME .UNIT_CAPACITY
   696 set .MSG ", supplying\n"
   697 jump *label189 always
 
   722 ucontrol flag :processUnit:state
   723 sensor *tmp268 @unit @totalItems
   724 print "  "
-    * print :processUnit:group
+  725 print .GROUP1
   726 print ":"
   727 print " ["
-    * print :processUnit:color
+  728 print "gold"
   729 print "]"
   730 print *tmp268
   731 print "["
 
   743 set :processUnit:unit @unit
   744 label *label157
   745 set .UNIT_S1 :processUnit:unit
-    * jump *label194 equal .FOUR_UNITS false
+  746 jump *label194 equal *tmp134 false
   747 op equal *tmp273 .SUPPLY_S_FIRST false
   748 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   749 set :processUnit.1:unit .UNIT_S2
 
   751 set :processUnit.1:group .GROUP2
   752 set :processUnit.1:supply *tmp273
   753 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * jump *label198 equal :rebindUnit.5:currentUnit null
-    * ubind :rebindUnit.5:currentUnit
+  754 set :rebindUnit.5:currentUnit .UNIT_S2
+  755 jump *label198 equal :processUnit.1:unit null
+  756 ubind :processUnit.1:unit
   757 sensor *tmp277 @unit @dead
   758 op equal *tmp278 *tmp277 0
   759 sensor *tmp279 @unit @controller
 
   765 label *label201
   766 label *label198
   767 label *label199
-    * ubind .TYPE
+  768 ubind *tmp9
   769 set :rebindUnit.5:firstUnit @unit
   770 jump *label202 equal :rebindUnit.5:firstUnit null
   771 label *label204
 
   774 jump *label197 always
   775 label *label207
   776 label *label208
-    * ubind .TYPE
+  777 ubind *tmp9
   778 label *label205
   779 op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
   780 sensor *tmp289 :rebindUnit.5:firstUnit @dead
 
   794 op or *tmp295 *tmp293 *tmp294
   795 jump *label209 equal *tmp295 false
   796 sensor *tmp297 @unit @firstItem
-    * jump *label211 notEqual *tmp297 :processUnit.1:item
+  797 jump *label211 notEqual *tmp297 @silicon
   798 set :processUnit.1:state 3
   799 jump *label212 always
   800 label *label211
 
   817 jump *label217 notEqual :processUnit.1:state 2
   818 ucontrol within .CORE_X .CORE_Y 8 *tmp307
   819 jump *label219 equal *tmp307 false
-    * ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
+  820 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   821 sensor *tmp309 @unit @totalItems
   822 jump *label221 lessThan *tmp309 .UNIT_CAPACITY
   823 ucontrol approach .DOME_X .DOME_Y 6
 
   843 jump *label223 notEqual :processUnit.1:state 3
   844 ucontrol within .DOME_X .DOME_Y 8 *tmp321
   845 jump *label225 equal *tmp321 false
-    * jump *label227 equal :processUnit.1:supply false
+  846 jump *label227 equal *tmp273 false
   847 ucontrol itemDrop .DOME .UNIT_CAPACITY
   848 set .MSG ", supplying\n"
   849 jump *label228 always
 
   874 ucontrol flag :processUnit.1:state
   875 sensor *tmp334 @unit @totalItems
   876 print "  "
-    * print :processUnit.1:group
+  877 print .GROUP2
   878 print ":"
   879 print " ["
-    * print :processUnit.1:color
+  880 print "gold"
   881 print "]"
   882 print *tmp334
   883 print "["
 
   896 label *label196
   897 set .UNIT_S2 :processUnit.1:unit
   898 jump *label233 equal .SUPPLY_S_FIRST false
-    * sensor *tmp339 .UNIT_S1 @totalItems
+  899 sensor *tmp339 :processUnit:unit @totalItems
   900 op greaterThan *tmp338 *tmp339 0
   901 jump *label234 always
   902 label *label233
-    * sensor *tmp341 .UNIT_S2 @totalItems
+  903 sensor *tmp341 :processUnit.1:unit @totalItems
   904 op equal *tmp338 *tmp341 0
   905 label *label234
   906 set .SUPPLY_S_FIRST *tmp338
 
   909 # "Function: inline void printDomeStatus(in item, in text)"
   910 set :printDomeStatus.1:item @phase-fabric
   911 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
-    * print :printDomeStatus.1:text
-    * sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
+  912 print "\n[green]Phase fabric[] status:\n"
+  913 sensor :printDomeStatus.1:level .DOME @phase-fabric
   914 jump *label236 lessThanEq :printDomeStatus.1:level 3
   915 print "  dome:  [green]"
   916 print :printDomeStatus.1:level
 
   932 set :processUnit.2:group .GROUP1
   933 set :processUnit.2:supply .SUPPLY_P_FIRST
   934 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * jump *label240 equal :rebindUnit.6:currentUnit null
-    * ubind :rebindUnit.6:currentUnit
+  935 set :rebindUnit.6:currentUnit .UNIT_P1
+  936 jump *label240 equal :processUnit.2:unit null
+  937 ubind :processUnit.2:unit
   938 sensor *tmp349 @unit @dead
   939 op equal *tmp350 *tmp349 0
   940 sensor *tmp351 @unit @controller
 
   946 label *label243
   947 label *label240
   948 label *label241
-    * ubind .TYPE
+  949 ubind *tmp9
   950 set :rebindUnit.6:firstUnit @unit
   951 jump *label244 equal :rebindUnit.6:firstUnit null
   952 label *label246
 
   955 jump *label239 always
   956 label *label249
   957 label *label250
-    * ubind .TYPE
+  958 ubind *tmp9
   959 label *label247
   960 op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
   961 sensor *tmp361 :rebindUnit.6:firstUnit @dead
 
   975 op or *tmp367 *tmp365 *tmp366
   976 jump *label251 equal *tmp367 false
   977 sensor *tmp369 @unit @firstItem
-    * jump *label253 notEqual *tmp369 :processUnit.2:item
+  978 jump *label253 notEqual *tmp369 @phase-fabric
   979 set :processUnit.2:state 3
   980 jump *label254 always
   981 label *label253
 
   998 jump *label259 notEqual :processUnit.2:state 2
   999 ucontrol within .CORE_X .CORE_Y 8 *tmp379
  1000 jump *label261 equal *tmp379 false
-    * ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
+ 1001 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1002 sensor *tmp381 @unit @totalItems
  1003 jump *label263 lessThan *tmp381 .UNIT_CAPACITY
  1004 ucontrol approach .DOME_X .DOME_Y 6
 
  1024 jump *label265 notEqual :processUnit.2:state 3
  1025 ucontrol within .DOME_X .DOME_Y 8 *tmp393
  1026 jump *label267 equal *tmp393 false
-    * jump *label269 equal :processUnit.2:supply false
+ 1027 jump *label269 equal .SUPPLY_P_FIRST false
  1028 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1029 set .MSG ", supplying\n"
  1030 jump *label270 always
 
  1055 ucontrol flag :processUnit.2:state
  1056 sensor *tmp406 @unit @totalItems
  1057 print "  "
-    * print :processUnit.2:group
+ 1058 print .GROUP1
  1059 print ":"
  1060 print " ["
-    * print :processUnit.2:color
+ 1061 print "gold"
  1062 print "]"
  1063 print *tmp406
  1064 print "["
 
  1076 set :processUnit.2:unit @unit
  1077 label *label238
  1078 set .UNIT_P1 :processUnit.2:unit
-    * jump *label275 equal .FOUR_UNITS false
+ 1079 jump *label275 equal *tmp134 false
  1080 op equal *tmp411 .SUPPLY_P_FIRST false
  1081 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
  1082 set :processUnit.3:unit .UNIT_P2
 
  1084 set :processUnit.3:group .GROUP2
  1085 set :processUnit.3:supply *tmp411
  1086 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * jump *label279 equal :rebindUnit.7:currentUnit null
-    * ubind :rebindUnit.7:currentUnit
+ 1087 set :rebindUnit.7:currentUnit .UNIT_P2
+ 1088 jump *label279 equal :processUnit.3:unit null
+ 1089 ubind :processUnit.3:unit
  1090 sensor *tmp415 @unit @dead
  1091 op equal *tmp416 *tmp415 0
  1092 sensor *tmp417 @unit @controller
 
  1098 label *label282
  1099 label *label279
  1100 label *label280
-    * ubind .TYPE
+ 1101 ubind *tmp9
  1102 set :rebindUnit.7:firstUnit @unit
  1103 jump *label283 equal :rebindUnit.7:firstUnit null
  1104 label *label285
 
  1107 jump *label278 always
  1108 label *label288
  1109 label *label289
-    * ubind .TYPE
+ 1110 ubind *tmp9
  1111 label *label286
  1112 op notEqual *tmp426 @unit :rebindUnit.7:firstUnit
  1113 sensor *tmp427 :rebindUnit.7:firstUnit @dead
 
  1127 op or *tmp433 *tmp431 *tmp432
  1128 jump *label290 equal *tmp433 false
  1129 sensor *tmp435 @unit @firstItem
-    * jump *label292 notEqual *tmp435 :processUnit.3:item
+ 1130 jump *label292 notEqual *tmp435 @phase-fabric
  1131 set :processUnit.3:state 3
  1132 jump *label293 always
  1133 label *label292
 
  1150 jump *label298 notEqual :processUnit.3:state 2
  1151 ucontrol within .CORE_X .CORE_Y 8 *tmp445
  1152 jump *label300 equal *tmp445 false
-    * ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
+ 1153 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1154 sensor *tmp447 @unit @totalItems
  1155 jump *label302 lessThan *tmp447 .UNIT_CAPACITY
  1156 ucontrol approach .DOME_X .DOME_Y 6
 
  1176 jump *label304 notEqual :processUnit.3:state 3
  1177 ucontrol within .DOME_X .DOME_Y 8 *tmp459
  1178 jump *label306 equal *tmp459 false
-    * jump *label308 equal :processUnit.3:supply false
+ 1179 jump *label308 equal *tmp411 false
  1180 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1181 set .MSG ", supplying\n"
  1182 jump *label309 always
 
  1207 ucontrol flag :processUnit.3:state
  1208 sensor *tmp472 @unit @totalItems
  1209 print "  "
-    * print :processUnit.3:group
+ 1210 print .GROUP2
  1211 print ":"
  1212 print " ["
-    * print :processUnit.3:color
+ 1213 print "gold"
  1214 print "]"
  1215 print *tmp472
  1216 print "["
 
  1229 label *label277
  1230 set .UNIT_P2 :processUnit.3:unit
  1231 jump *label314 equal .SUPPLY_P_FIRST false
-    * sensor *tmp477 .UNIT_P1 @totalItems
+ 1232 sensor *tmp477 :processUnit.2:unit @totalItems
  1233 op greaterThan *tmp476 *tmp477 0
  1234 jump *label315 always
  1235 label *label314
-    * sensor *tmp479 .UNIT_P2 @totalItems
+ 1236 sensor *tmp479 :processUnit.3:unit @totalItems
  1237 op equal *tmp476 *tmp479 0
  1238 label *label315
  1239 set .SUPPLY_P_FIRST *tmp476
 
  1247 print " "
  1248 print "ms"
  1249 printflush message1
-    * op notEqual *tmp483 .TYPE UNIT_TYPE
+ 1250 op notEqual *tmp483 *tmp9 UNIT_TYPE
  1251 op greaterThan *tmp484 :unitCheck @time
  1252 op land *tmp485 *tmp483 *tmp484
  1253 jump *label316 equal *tmp485 false
 
  1257 set :areUnitsAvailable.2:free 0
  1258 set :areUnitsAvailable.2:occupied 0
  1259 set :areUnitsAvailable.2:needed 0
-    * ubind :areUnitsAvailable.2:type
+ 1260 ubind UNIT_TYPE
  1261 set :areUnitsAvailable.2:firstUnit @unit
  1262 jump *label319 equal :areUnitsAvailable.2:firstUnit null
  1263 # "Function: inline def needsFourUnits(in unit)"
  1264 set :needsFourUnits.3:unit @unit
  1265 op sub *tmp491 .DOME_X .CORE_X
  1266 op sub *tmp492 .DOME_Y .CORE_Y
-    * op len *tmp493 *tmp491 *tmp492
-    * op mul *tmp494 2 *tmp493
+ 1267 op len *tmp493 *tmp135 *tmp136
+ 1268 op mul *tmp494 2 *tmp137
  1269 sensor *tmp495 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp494 *tmp495
+ 1270 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1271 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1272 jump *label321 always
-    * set *tmp490 null
  1273 label *label321
  1274 jump *label322 equal *tmp490 false
  1275 set *tmp498 4
 
  1286 op or *tmp503 *tmp500 *tmp502
  1287 jump *label327 equal *tmp503 false
  1288 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label329 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1289 jump *label329 lessThan :areUnitsAvailable.2:free *tmp498
  1290 set *tmp487 true
  1291 jump *label318 always
  1292 label *label329
 
  1295 label *label327
  1296 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1297 label *label328
-    * ubind :areUnitsAvailable.2:type
+ 1298 ubind UNIT_TYPE
  1299 label *label325
  1300 op notEqual *tmp508 @unit :areUnitsAvailable.2:firstUnit
  1301 sensor *tmp509 :areUnitsAvailable.2:firstUnit @dead
 
  1305 label *label326
  1306 label *label319
  1307 label *label320
-    * jump *label331 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+ 1308 jump *label331 equal false false
+ 1309 print UNIT_TYPE
  1310 print ":"
  1311 print " occupied: "
  1312 print :areUnitsAvailable.2:occupied
 
  1323 label *label332
  1324 set *tmp487 false
  1325 jump *label318 always
-    * set *tmp487 null
  1326 label *label318
  1327 jump *label335 equal *tmp487 false
  1328 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-46 instructions):
 
    67 print "[gold]Looking for suitable unit type:[]"
    68 print "\n"
    69 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable:type UNIT_TYPE
-    * set :areUnitsAvailable:output true
    70 set :areUnitsAvailable:free 0
    71 set :areUnitsAvailable:occupied 0
    72 set :areUnitsAvailable:needed 0
 
   162 label *label45
   163 jump *label54 equal :chooseUnitType:type UNIT_TYPE
   164 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:type :chooseUnitType:type
-    * set :areUnitsAvailable.1:output true
   165 set :areUnitsAvailable.1:free 0
   166 set :areUnitsAvailable.1:occupied 0
   167 set :areUnitsAvailable.1:needed 0
 
   257 # "Function: inline def rebindUnits()"
   258 set .UNIT_P2 null
   259 set .UNIT_S2 null
-    * set .UNIT_P1 .UNIT_P2
-    * set .UNIT_S1 .UNIT_S2
+  260 set .UNIT_P1 null
+  261 set .UNIT_S1 null
   262 set :rebindUnits:count 0
   263 ubind *tmp9
   264 set :rebindUnits:firstUnit @unit
 
   293 # "Function: inline def acquireUnit(in currentUnit)"
   294 set :acquireUnit:currentUnit .UNIT_S1
   295 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit:currentUnit .UNIT_S1
-    * jump *label87 equal :acquireUnit:currentUnit null
-    * ubind :acquireUnit:currentUnit
+  296 jump *label87 equal .UNIT_S1 null
+  297 ubind .UNIT_S1
   298 sensor *tmp89 @unit @dead
   299 op equal *tmp90 *tmp89 0
   300 sensor *tmp91 @unit @controller
 
   335 # "Function: inline def acquireUnit(in currentUnit)"
   336 set :acquireUnit.1:currentUnit .UNIT_P1
   337 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit .UNIT_P1
-    * jump *label100 equal :acquireUnit.1:currentUnit null
-    * ubind :acquireUnit.1:currentUnit
+  338 jump *label100 equal .UNIT_P1 null
+  339 ubind .UNIT_P1
   340 sensor *tmp108 @unit @dead
   341 op equal *tmp109 *tmp108 0
   342 sensor *tmp110 @unit @controller
 
   381 op or *tmp127 *tmp124 *tmp126
   382 jump *label111 equal *tmp127 false
   383 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:a *tmp85
-    * set :swap:b *tmp104
-    * set :swap:t .UNIT_S1
-    * set :swap:a .UNIT_P1
-    * set :swap:b :swap:t
+  384 set :swap:t *tmp85
+  385 set :swap:a *tmp104
+  386 set :swap:b .UNIT_S1
   387 label *label113
-    * set .UNIT_S1 :swap:a
+  388 set .UNIT_S1 .UNIT_P1
   389 set .UNIT_P1 :swap:t
   390 label *label111
   391 label *label112
 
   398 label *label114
   399 label *label115
   400 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.2:unit .UNIT_S1
   401 op sub *tmp135 .DOME_X .CORE_X
   402 op sub *tmp136 .DOME_Y .CORE_Y
   403 op len *tmp137 *tmp135 *tmp136
 
   412 # "Function: inline def acquireUnit(in currentUnit)"
   413 set :acquireUnit.2:currentUnit .UNIT_S2
   414 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit .UNIT_S2
-    * jump *label121 equal :acquireUnit.2:currentUnit null
-    * ubind :acquireUnit.2:currentUnit
+  415 jump *label121 equal .UNIT_S2 null
+  416 ubind .UNIT_S2
   417 sensor *tmp147 @unit @dead
   418 op equal *tmp148 *tmp147 0
   419 sensor *tmp149 @unit @controller
 
   454 # "Function: inline def acquireUnit(in currentUnit)"
   455 set :acquireUnit.3:currentUnit .UNIT_P2
   456 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit .UNIT_P2
-    * jump *label134 equal :acquireUnit.3:currentUnit null
-    * ubind :acquireUnit.3:currentUnit
+  457 jump *label134 equal .UNIT_P2 null
+  458 ubind .UNIT_P2
   459 sensor *tmp166 @unit @dead
   460 op equal *tmp167 *tmp166 0
   461 sensor *tmp168 @unit @controller
 
   500 op land *tmp185 *tmp182 *tmp184
   501 jump *label145 equal *tmp185 false
   502 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.1:a .UNIT_S1
-    * set :swap.1:b *tmp162
   503 set :swap.1:t .UNIT_S1
-    * set :swap.1:a .UNIT_P2
-    * set :swap.1:b :swap.1:t
+  504 set :swap.1:a *tmp162
+  505 set :swap.1:b .UNIT_S1
   506 label *label147
-    * set .UNIT_S1 :swap.1:a
+  507 set .UNIT_S1 .UNIT_P2
   508 set .UNIT_P2 :swap.1:t
   509 label *label145
   510 label *label146
 
   515 op or *tmp191 *tmp188 *tmp190
   516 jump *label148 equal *tmp191 false
   517 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:a *tmp143
-    * set :swap.2:b .UNIT_P2
-    * set :swap.2:t .UNIT_S2
+  518 set :swap.2:t *tmp143
   519 set :swap.2:a .UNIT_P2
-    * set :swap.2:b :swap.2:t
+  520 set :swap.2:b .UNIT_S2
   521 label *label150
-    * set .UNIT_S2 :swap.2:a
+  522 set .UNIT_S2 .UNIT_P2
   523 set .UNIT_P2 :swap.2:t
   524 label *label148
   525 label *label149
 
   540 sensor *tmp195 .UNIT_S2 @totalItems
   541 op lessThan *tmp196 *tmp194 *tmp195
   542 op or .SUPPLY_S_FIRST *tmp193 *tmp196
-    * op equal *tmp198 *tmp134 false
   543 sensor *tmp199 .UNIT_P1 @totalItems
   544 sensor *tmp200 .UNIT_P2 @totalItems
   545 op lessThan *tmp201 *tmp199 *tmp200
 
   558 print "]"
   559 print "\n"
   560 # "Function: inline void printDomeStatus(in item, in text)"
-    * set :printDomeStatus:item @silicon
-    * set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   561 print "\n[green]Silicon[] status:\n"
   562 sensor :printDomeStatus:level .DOME @silicon
   563 jump *label155 lessThanEq :printDomeStatus:level 3
 
   577 label *label154
   578 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   579 set :processUnit:unit .UNIT_S1
-    * set :processUnit:item @silicon
-    * set :processUnit:group .GROUP1
-    * set :processUnit:supply .SUPPLY_S_FIRST
   580 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit .UNIT_S1
-    * jump *label159 equal :processUnit:unit null
-    * ubind :processUnit:unit
+  581 jump *label159 equal .UNIT_S1 null
+  582 ubind .UNIT_S1
   583 sensor *tmp211 @unit @dead
   584 op equal *tmp212 *tmp211 0
   585 sensor *tmp213 @unit @controller
 
   614 label *label158
   615 sensor :processUnit:state @unit @flag
   616 set :processUnit:distance -1
-    * set :processUnit:color "gold"
   617 op lessThan *tmp227 :processUnit:state 2
   618 op greaterThan *tmp228 :processUnit:state 3
   619 op or *tmp229 *tmp227 *tmp228
 
   724 op equal *tmp273 .SUPPLY_S_FIRST false
   725 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   726 set :processUnit.1:unit .UNIT_S2
-    * set :processUnit.1:item @silicon
-    * set :processUnit.1:group .GROUP2
-    * set :processUnit.1:supply *tmp273
   727 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit .UNIT_S2
-    * jump *label198 equal :processUnit.1:unit null
-    * ubind :processUnit.1:unit
+  728 jump *label198 equal .UNIT_S2 null
+  729 ubind .UNIT_S2
   730 sensor *tmp277 @unit @dead
   731 op equal *tmp278 *tmp277 0
   732 sensor *tmp279 @unit @controller
 
   761 label *label197
   762 sensor :processUnit.1:state @unit @flag
   763 set :processUnit.1:distance -1
-    * set :processUnit.1:color "gold"
   764 op lessThan *tmp293 :processUnit.1:state 2
   765 op greaterThan *tmp294 :processUnit.1:state 3
   766 op or *tmp295 *tmp293 *tmp294
 
   879 label *label194
   880 label *label195
   881 # "Function: inline void printDomeStatus(in item, in text)"
-    * set :printDomeStatus.1:item @phase-fabric
-    * set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   882 print "\n[green]Phase fabric[] status:\n"
   883 sensor :printDomeStatus.1:level .DOME @phase-fabric
   884 jump *label236 lessThanEq :printDomeStatus.1:level 3
 
   898 label *label235
   899 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   900 set :processUnit.2:unit .UNIT_P1
-    * set :processUnit.2:item @phase-fabric
-    * set :processUnit.2:group .GROUP1
-    * set :processUnit.2:supply .SUPPLY_P_FIRST
   901 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit .UNIT_P1
-    * jump *label240 equal :processUnit.2:unit null
-    * ubind :processUnit.2:unit
+  902 jump *label240 equal .UNIT_P1 null
+  903 ubind .UNIT_P1
   904 sensor *tmp349 @unit @dead
   905 op equal *tmp350 *tmp349 0
   906 sensor *tmp351 @unit @controller
 
   935 label *label239
   936 sensor :processUnit.2:state @unit @flag
   937 set :processUnit.2:distance -1
-    * set :processUnit.2:color "gold"
   938 op lessThan *tmp365 :processUnit.2:state 2
   939 op greaterThan *tmp366 :processUnit.2:state 3
   940 op or *tmp367 *tmp365 *tmp366
 
  1045 op equal *tmp411 .SUPPLY_P_FIRST false
  1046 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
  1047 set :processUnit.3:unit .UNIT_P2
-    * set :processUnit.3:item @phase-fabric
-    * set :processUnit.3:group .GROUP2
-    * set :processUnit.3:supply *tmp411
  1048 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit .UNIT_P2
-    * jump *label279 equal :processUnit.3:unit null
-    * ubind :processUnit.3:unit
+ 1049 jump *label279 equal .UNIT_P2 null
+ 1050 ubind .UNIT_P2
  1051 sensor *tmp415 @unit @dead
  1052 op equal *tmp416 *tmp415 0
  1053 sensor *tmp417 @unit @controller
 
  1082 label *label278
  1083 sensor :processUnit.3:state @unit @flag
  1084 set :processUnit.3:distance -1
-    * set :processUnit.3:color "gold"
  1085 op lessThan *tmp431 :processUnit.3:state 2
  1086 op greaterThan *tmp432 :processUnit.3:state 3
  1087 op or *tmp433 *tmp431 *tmp432
 
  1212 op land *tmp485 *tmp483 *tmp484
  1213 jump *label316 equal *tmp485 false
  1214 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
  1215 set :areUnitsAvailable.2:free 0
  1216 set :areUnitsAvailable.2:occupied 0
  1217 set :areUnitsAvailable.2:needed 0
 
  1220 jump *label319 equal :areUnitsAvailable.2:firstUnit null
  1221 # "Function: inline def needsFourUnits(in unit)"
  1222 set :needsFourUnits.3:unit @unit
-    * op sub *tmp491 .DOME_X .CORE_X
-    * op sub *tmp492 .DOME_Y .CORE_Y
-    * op len *tmp493 *tmp135 *tmp136
-    * op mul *tmp494 2 *tmp137
  1223 sensor *tmp495 :needsFourUnits.3:unit @speed
  1224 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1225 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   291 label *label80
   292 label *label75
   293 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit:currentUnit .UNIT_S1
   294 # "Function: inline def rebindUnit(in currentUnit)"
   295 jump *label87 equal .UNIT_S1 null
   296 ubind .UNIT_S1
 
   332 label *label85
   333 set .UNIT_S1 *tmp85
   334 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.1:currentUnit .UNIT_P1
   335 # "Function: inline def rebindUnit(in currentUnit)"
   336 jump *label100 equal .UNIT_P1 null
   337 ubind .UNIT_P1
 
   380 jump *label111 equal *tmp127 false
   381 # "Function: inline void swap(in out a, in out b)"
   382 set :swap:t *tmp85
-    * set :swap:a *tmp104
-    * set :swap:b .UNIT_S1
+  383 set :swap:b *tmp85
   384 label *label113
-    * set .UNIT_S1 .UNIT_P1
-    * set .UNIT_P1 :swap:t
+  385 set .UNIT_S1 *tmp104
+  386 set .UNIT_P1 *tmp85
   387 label *label111
   388 label *label112
   389 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   407 set .FOUR_UNITS *tmp134
   408 jump *label117 equal *tmp134 false
   409 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.2:currentUnit .UNIT_S2
   410 # "Function: inline def rebindUnit(in currentUnit)"
   411 jump *label121 equal .UNIT_S2 null
   412 ubind .UNIT_S2
 
   448 label *label119
   449 set .UNIT_S2 *tmp143
   450 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.3:currentUnit .UNIT_P2
   451 # "Function: inline def rebindUnit(in currentUnit)"
   452 jump *label134 equal .UNIT_P2 null
   453 ubind .UNIT_P2
 
   496 jump *label145 equal *tmp185 false
   497 # "Function: inline void swap(in out a, in out b)"
   498 set :swap.1:t .UNIT_S1
-    * set :swap.1:a *tmp162
-    * set :swap.1:b .UNIT_S1
   499 label *label147
-    * set .UNIT_S1 .UNIT_P2
+  500 set .UNIT_S1 *tmp162
   501 set .UNIT_P2 :swap.1:t
   502 label *label145
   503 label *label146
 
   509 jump *label148 equal *tmp191 false
   510 # "Function: inline void swap(in out a, in out b)"
   511 set :swap.2:t *tmp143
-    * set :swap.2:a .UNIT_P2
-    * set :swap.2:b .UNIT_S2
+  512 set :swap.2:b *tmp143
   513 label *label150
   514 set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P2 :swap.2:t
+  515 set .UNIT_P2 *tmp143
   516 label *label148
   517 label *label149
   518 set .GROUP1 "unit  1"
 
   568 label *label156
   569 label *label154
   570 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit:unit .UNIT_S1
   571 # "Function: inline def rebindUnit(in currentUnit)"
   572 jump *label159 equal .UNIT_S1 null
   573 ubind .UNIT_S1
 
   714 jump *label194 equal *tmp134 false
   715 op equal *tmp273 .SUPPLY_S_FIRST false
   716 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.1:unit .UNIT_S2
   717 # "Function: inline def rebindUnit(in currentUnit)"
   718 jump *label198 equal .UNIT_S2 null
   719 ubind .UNIT_S2
 
   887 label *label237
   888 label *label235
   889 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.2:unit .UNIT_P1
   890 # "Function: inline def rebindUnit(in currentUnit)"
   891 jump *label240 equal .UNIT_P1 null
   892 ubind .UNIT_P1
 
  1033 jump *label275 equal *tmp134 false
  1034 op equal *tmp411 .SUPPLY_P_FIRST false
  1035 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.3:unit .UNIT_P2
  1036 # "Function: inline def rebindUnit(in currentUnit)"
  1037 jump *label279 equal .UNIT_P2 null
  1038 ubind .UNIT_P2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-4 instructions):
 
   379 op or *tmp127 *tmp124 *tmp126
   380 jump *label111 equal *tmp127 false
   381 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:t *tmp85
-    * set :swap:b *tmp85
   382 label *label113
   383 set .UNIT_S1 *tmp104
   384 set .UNIT_P1 *tmp85
 
   506 op or *tmp191 *tmp188 *tmp190
   507 jump *label148 equal *tmp191 false
   508 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:t *tmp143
-    * set :swap.2:b *tmp143
   509 label *label150
   510 set .UNIT_S2 .UNIT_P2
   511 set .UNIT_P2 *tmp143

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     5 set .DOME dome1
     6 label *label2
     7 jump *label4 notEqual .DOME null
+    8 label *label340
     9 print "[gold]Waiting for an overdrive dome to be connected..."
    10 printflush message1
    11 set .DOME dome1
    12 label *label3
-    * jump *label2 always
+   13 jump *label340 equal .DOME null
    14 label *label4
    15 print "[gold]Locating core..."
    16 printflush message1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-11 instructions):
 
    85 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    86 jump *label29 always
    87 label *label29
-    * jump *label30 equal *tmp13 false
-    * set *tmp21 4
-    * jump *label31 always
+   88 select *tmp21 notEqual *tmp13 false 4 2
    89 label *label30
-    * set *tmp21 2
    90 label *label31
    91 set :areUnitsAvailable:needed *tmp21
    92 label *label32
 
   177 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   178 jump *label59 always
   179 label *label59
-    * jump *label60 equal *tmp45 false
-    * set *tmp53 4
-    * jump *label61 always
+  180 select *tmp53 notEqual *tmp45 false 4 2
   181 label *label60
-    * set *tmp53 2
   182 label *label61
   183 set :areUnitsAvailable.1:needed *tmp53
   184 label *label62
 
   850 set .UNIT_S2 :processUnit.1:unit
   851 jump *label233 equal .SUPPLY_S_FIRST false
   852 sensor *tmp339 :processUnit:unit @totalItems
-    * op greaterThan *tmp338 *tmp339 0
+  853 op greaterThan .SUPPLY_S_FIRST *tmp339 0
   854 jump *label234 always
   855 label *label233
   856 sensor *tmp341 :processUnit.1:unit @totalItems
-    * op equal *tmp338 *tmp341 0
+  857 op equal .SUPPLY_S_FIRST *tmp341 0
   858 label *label234
-    * set .SUPPLY_S_FIRST *tmp338
   859 label *label194
   860 label *label195
   861 # "Function: inline void printDomeStatus(in item, in text)"
 
  1168 set .UNIT_P2 :processUnit.3:unit
  1169 jump *label314 equal .SUPPLY_P_FIRST false
  1170 sensor *tmp477 :processUnit.2:unit @totalItems
-    * op greaterThan *tmp476 *tmp477 0
+ 1171 op greaterThan .SUPPLY_P_FIRST *tmp477 0
  1172 jump *label315 always
  1173 label *label314
  1174 sensor *tmp479 :processUnit.3:unit @totalItems
-    * op equal *tmp476 *tmp479 0
+ 1175 op equal .SUPPLY_P_FIRST *tmp479 0
  1176 label *label315
-    * set .SUPPLY_P_FIRST *tmp476
  1177 label *label275
  1178 label *label276
  1179 op sub *tmp481 @time :start
 
  1202 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1203 jump *label321 always
  1204 label *label321
-    * jump *label322 equal *tmp490 false
-    * set *tmp498 4
-    * jump *label323 always
+ 1205 select *tmp498 notEqual *tmp490 false 4 2
  1206 label *label322
-    * set *tmp498 2
  1207 label *label323
  1208 set :areUnitsAvailable.2:needed *tmp498
  1209 label *label324

Modifications by Unroll iteration loop at line 169:9 (+9 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * set :locateDomeAndCore:type @flare
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label11 (m:marker0)
-    * set :locateDomeAndCore:type @poly
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label12 (m:marker0)
-    * set :locateDomeAndCore:type @mega
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label13 (m:marker0)
-    * set :locateDomeAndCore:type @mono
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label15 (m:marker0)
-    * jump *label16 always
-    * label *label8
-    * set :locateCore:type :locateDomeAndCore:type
-    * call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label17 equal :locateCore*retval false
-    * jump *label1 always
-    * label *label17
-    * label *label18
-    * label *label9
-    * multijump *tmp1 0 0 (m:marker0)
-    * multilabel *label14 (m:marker0)
-    * label *label16
-    * label *label10
+   19 set :locateDomeAndCore:type @flare
+   20 op add *tmp1 @counter 1
+   21 label *label341
+   22 set :locateCore:type :locateDomeAndCore:type
+   23 call *label0 :locateCore*retaddr :locateCore*retval
+   24 jump *label342 equal :locateCore*retval false
+   25 jump *label1 always
+   26 label *label342
+   27 label *label343
+   28 label *label344
+   29 set :locateDomeAndCore:type @poly
+   30 op add *tmp1 @counter 1
+   31 label *label347
+   32 set :locateCore:type :locateDomeAndCore:type
+   33 call *label0 :locateCore*retaddr :locateCore*retval
+   34 jump *label348 equal :locateCore*retval false
+   35 jump *label1 always
+   36 label *label348
+   37 label *label349
+   38 label *label350
+   39 set :locateDomeAndCore:type @mega
+   40 op add *tmp1 @counter 1
+   41 label *label353
+   42 set :locateCore:type :locateDomeAndCore:type
+   43 call *label0 :locateCore*retaddr :locateCore*retval
+   44 jump *label354 equal :locateCore*retval false
+   45 jump *label1 always
+   46 label *label354
+   47 label *label355
+   48 label *label356
+   49 set :locateDomeAndCore:type @mono
+   50 op add *tmp1 @counter 1
+   51 label *label359
+   52 set :locateCore:type :locateDomeAndCore:type
+   53 call *label0 :locateCore*retaddr :locateCore*retval
+   54 jump *label360 equal :locateCore*retval false
+   55 jump *label1 always
+   56 label *label360
+   57 label *label361
+   58 label *label362
+   59 label *label16
+   60 label *label10
    61 label *label6
    62 jump *label5 always
    63 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-4 instructions):
 
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
     6 label *label2
-    * jump *label4 notEqual .DOME null
+    7 jump *label4 notEqual dome1 null
     8 label *label340
     9 print "[gold]Waiting for an overdrive dome to be connected..."
    10 printflush message1
    11 set .DOME dome1
    12 label *label3
-    * jump *label340 equal .DOME null
+   13 jump *label340 equal dome1 null
    14 label *label4
    15 print "[gold]Locating core..."
    16 printflush message1
    17 set .CORE null
    18 label *label5
    19 set :locateDomeAndCore:type @flare
-    * op add *tmp1 @counter 1
    20 label *label341
-    * set :locateCore:type :locateDomeAndCore:type
+   21 set :locateCore:type @flare
    22 call *label0 :locateCore*retaddr :locateCore*retval
    23 jump *label342 equal :locateCore*retval false
    24 jump *label1 always
 
    26 label *label343
    27 label *label344
    28 set :locateDomeAndCore:type @poly
-    * op add *tmp1 @counter 1
    29 label *label347
-    * set :locateCore:type :locateDomeAndCore:type
+   30 set :locateCore:type @poly
    31 call *label0 :locateCore*retaddr :locateCore*retval
    32 jump *label348 equal :locateCore*retval false
    33 jump *label1 always
 
    35 label *label349
    36 label *label350
    37 set :locateDomeAndCore:type @mega
-    * op add *tmp1 @counter 1
    38 label *label353
-    * set :locateCore:type :locateDomeAndCore:type
+   39 set :locateCore:type @mega
    40 call *label0 :locateCore*retaddr :locateCore*retval
    41 jump *label354 equal :locateCore*retval false
    42 jump *label1 always
 
    44 label *label355
    45 label *label356
    46 set :locateDomeAndCore:type @mono
-    * op add *tmp1 @counter 1
    47 label *label359
-    * set :locateCore:type :locateDomeAndCore:type
+   48 set :locateCore:type @mono
    49 call *label0 :locateCore*retaddr :locateCore*retval
    50 jump *label360 equal :locateCore*retval false
    51 jump *label1 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * set :locateDomeAndCore:type @flare
    19 label *label341
    20 set :locateCore:type @flare
    21 call *label0 :locateCore*retaddr :locateCore*retval
 
    24 label *label342
    25 label *label343
    26 label *label344
-    * set :locateDomeAndCore:type @poly
    27 label *label347
    28 set :locateCore:type @poly
    29 call *label0 :locateCore*retaddr :locateCore*retval
 
    32 label *label348
    33 label *label349
    34 label *label350
-    * set :locateDomeAndCore:type @mega
    35 label *label353
    36 set :locateCore:type @mega
    37 call *label0 :locateCore*retaddr :locateCore*retval
 
    40 label *label354
    41 label *label355
    42 label *label356
-    * set :locateDomeAndCore:type @mono
    43 label *label359
    44 set :locateCore:type @mono
    45 call *label0 :locateCore*retaddr :locateCore*retval

Modifications by Replicate loop condition at line 54:5 (+1 instructions):
 
    61 label *label19
    62 sensor *tmp7 switch1 @enabled
    63 jump *label21 notEqual *tmp7 false
+   64 label *label367
    65 print "[coral]Activate switch to begin supplying overdrive dome..."
    66 print "\n"
    67 printflush message1
    68 label *label20
-    * jump *label19 always
+   69 sensor *tmp7 switch1 @enabled
+   70 jump *label367 equal *tmp7 false
    71 label *label21
    72 # "Function: inline def chooseUnitType()"
    73 label *label23

Modifications by Replicate loop condition at line 119:5 (+1 instructions):
 
   538 label *label151
   539 sensor *tmp204 switch1 @enabled
   540 jump *label153 equal *tmp204 false
+  541 label *label368
   542 set :start @time
   543 print " === [gold]Supplying Overdrive Dome[] === "
   544 print "\n"
 
  1268 label *label316
  1269 label *label317
  1270 label *label152
-    * jump *label151 always
+ 1271 sensor *tmp204 switch1 @enabled
+ 1272 jump *label368 notEqual *tmp204 false
  1273 label *label153
  1274 end
  1275 label *label0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
   123 label *label34
   124 label *label27
   125 label *label28
-    * jump *label39 equal true false
   126 print UNIT_TYPE
   127 print ":"
   128 print " occupied: "
 
   214 label *label64
   215 label *label57
   216 label *label58
-    * jump *label69 equal true false
   217 print :chooseUnitType:type
   218 print ":"
   219 print " occupied: "
 
  1239 label *label326
  1240 label *label319
  1241 label *label320
-    * jump *label331 equal false false
+ 1242 jump *label331 always
  1243 print UNIT_TYPE
  1244 print ":"
  1245 print " occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-11 instructions):
 
    90 sensor *tmp18 :needsFourUnits:unit @speed
    91 op div :needsFourUnits:travel_time *tmp17 *tmp18
    92 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
-    * jump *label29 always
    93 label *label29
    94 select *tmp21 notEqual *tmp13 false 4 2
    95 label *label30
 
   138 label *label39
   139 label *label40
   140 set *tmp10 false
-    * jump *label26 always
   141 label *label26
   142 jump *label43 equal *tmp10 false
   143 set *tmp9 UNIT_TYPE
 
   179 sensor *tmp50 :needsFourUnits.1:unit @speed
   180 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   181 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * jump *label59 always
   182 label *label59
   183 select *tmp53 notEqual *tmp45 false 4 2
   184 label *label60
 
   227 label *label69
   228 label *label70
   229 set *tmp42 false
-    * jump *label56 always
   230 label *label56
   231 jump *label73 equal *tmp42 false
   232 printflush null
 
   324 label *label86
   325 ucontrol flag 1
   326 set *tmp85 @unit
-    * jump *label85 always
   327 label *label85
   328 set .UNIT_S1 *tmp85
   329 # "Function: inline def acquireUnit(in currentUnit)"
 
   364 label *label99
   365 ucontrol flag 1
   366 set *tmp104 @unit
-    * jump *label98 always
   367 label *label98
   368 set .UNIT_P1 *tmp104
   369 sensor *tmp123 *tmp85 @firstItem
 
   394 sensor *tmp139 .UNIT_S1 @speed
   395 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   396 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
-    * jump *label116 always
   397 label *label116
   398 set .FOUR_UNITS *tmp134
   399 jump *label117 equal *tmp134 false
 
   435 label *label120
   436 ucontrol flag 1
   437 set *tmp143 @unit
-    * jump *label119 always
   438 label *label119
   439 set .UNIT_S2 *tmp143
   440 # "Function: inline def acquireUnit(in currentUnit)"
 
   475 label *label133
   476 ucontrol flag 1
   477 set *tmp162 @unit
-    * jump *label132 always
   478 label *label132
   479 set .UNIT_P2 *tmp162
   480 sensor *tmp181 .UNIT_S1 @firstItem
 
  1197 sensor *tmp495 :needsFourUnits.3:unit @speed
  1198 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1199 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
-    * jump *label321 always
  1200 label *label321
  1201 select *tmp498 notEqual *tmp490 false 4 2
  1202 label *label322
 
  1246 label *label331
  1247 label *label332
  1248 set *tmp487 false
-    * jump *label318 always
  1249 label *label318
  1250 jump *label335 equal *tmp487 false
  1251 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-2 instructions):
 
  1188 # "Function: inline def areUnitsAvailable(in type, in output)"
  1189 set :areUnitsAvailable.2:free 0
  1190 set :areUnitsAvailable.2:occupied 0
-    * set :areUnitsAvailable.2:needed 0
  1191 ubind UNIT_TYPE
  1192 set :areUnitsAvailable.2:firstUnit @unit
  1193 jump *label319 equal :areUnitsAvailable.2:firstUnit null
 
  1200 select *tmp498 notEqual *tmp490 false 4 2
  1201 label *label322
  1202 label *label323
-    * set :areUnitsAvailable.2:needed *tmp498
  1203 label *label324
  1204 sensor *tmp499 @unit @controlled
  1205 op equal *tmp500 *tmp499 0

Modifications by Unroll iteration loop at line 201:9 (+147 instructions):
 
   144 jump *label22 always
   145 label *label43
   146 label *label44
-    * set :chooseUnitType:type @flare
-    * op add *tmp39 @counter 1
-    * jump *label45 always
-    * multilabel *label48 (m:marker1)
-    * set :chooseUnitType:type @poly
-    * op add *tmp39 @counter 1
-    * jump *label45 always
-    * multilabel *label49 (m:marker1)
-    * set :chooseUnitType:type @mega
-    * op add *tmp39 @counter 1
-    * jump *label45 always
-    * multilabel *label50 (m:marker1)
-    * set :chooseUnitType:type @mono
-    * op add *tmp39 @counter 1
-    * jump *label45 always
-    * multilabel *label52 (m:marker1)
-    * jump *label53 always
-    * label *label45
-    * jump *label54 equal :chooseUnitType:type UNIT_TYPE
-    * # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:free 0
-    * set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label57 equal :areUnitsAvailable.1:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp46 .DOME_X .CORE_X
-    * op sub *tmp47 .DOME_Y .CORE_Y
-    * op len *tmp48 *tmp46 *tmp47
-    * op mul *tmp49 2 *tmp48
-    * sensor *tmp50 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * label *label59
-    * select *tmp53 notEqual *tmp45 false 4 2
-    * label *label60
-    * label *label61
-    * set :areUnitsAvailable.1:needed *tmp53
-    * label *label62
-    * sensor *tmp54 @unit @controlled
-    * op equal *tmp55 *tmp54 0
-    * sensor *tmp56 @unit @controller
-    * op equal *tmp57 *tmp56 @this
-    * op or *tmp58 *tmp55 *tmp57
-    * jump *label65 equal *tmp58 false
-    * op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label67 lessThan :areUnitsAvailable.1:free *tmp53
-    * set *tmp42 true
-    * jump *label56 always
-    * label *label67
-    * label *label68
-    * jump *label66 always
-    * label *label65
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label66
-    * ubind :chooseUnitType:type
-    * label *label63
-    * op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp65 *tmp64 0
-    * op land *tmp66 *tmp63 *tmp65
-    * jump *label62 notEqual *tmp66 false
-    * label *label64
-    * label *label57
-    * label *label58
-    * print :chooseUnitType:type
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.1:free
-    * jump *label71 lessThanEq :areUnitsAvailable.1:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.1:needed
-    * label *label71
-    * label *label72
-    * print "\n"
-    * label *label69
-    * label *label70
-    * set *tmp42 false
-    * label *label56
-    * jump *label73 equal *tmp42 false
-    * printflush null
-    * set *tmp9 :chooseUnitType:type
-    * jump *label22 always
-    * label *label73
-    * label *label74
-    * label *label54
-    * label *label55
-    * label *label46
-    * multijump *tmp39 0 0 (m:marker1)
-    * multilabel *label51 (m:marker1)
-    * label *label53
-    * label *label47
+  147 set :chooseUnitType:type @flare
+  148 op add *tmp39 @counter 1
+  149 label *label369
+  150 jump *label389 equal :chooseUnitType:type UNIT_TYPE
+  151 # "Function: inline def areUnitsAvailable(in type, in output)"
+  152 set :areUnitsAvailable.1:free 0
+  153 set :areUnitsAvailable.1:occupied 0
+  154 set :areUnitsAvailable.1:needed 0
+  155 ubind :chooseUnitType:type
+  156 set :areUnitsAvailable.1:firstUnit @unit
+  157 jump *label380 equal :areUnitsAvailable.1:firstUnit null
+  158 # "Function: inline def needsFourUnits(in unit)"
+  159 set :needsFourUnits.1:unit @unit
+  160 op sub *tmp46 .DOME_X .CORE_X
+  161 op sub *tmp47 .DOME_Y .CORE_Y
+  162 op len *tmp48 *tmp46 *tmp47
+  163 op mul *tmp49 2 *tmp48
+  164 sensor *tmp50 :needsFourUnits.1:unit @speed
+  165 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  166 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  167 label *label370
+  168 select *tmp53 notEqual *tmp45 false 4 2
+  169 label *label371
+  170 label *label372
+  171 set :areUnitsAvailable.1:needed *tmp53
+  172 label *label373
+  173 sensor *tmp54 @unit @controlled
+  174 op equal *tmp55 *tmp54 0
+  175 sensor *tmp56 @unit @controller
+  176 op equal *tmp57 *tmp56 @this
+  177 op or *tmp58 *tmp55 *tmp57
+  178 jump *label376 equal *tmp58 false
+  179 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  180 jump *label374 lessThan :areUnitsAvailable.1:free *tmp53
+  181 set *tmp42 true
+  182 jump *label386 always
+  183 label *label374
+  184 label *label375
+  185 jump *label377 always
+  186 label *label376
+  187 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  188 label *label377
+  189 ubind :chooseUnitType:type
+  190 label *label378
+  191 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  192 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  193 op equal *tmp65 *tmp64 0
+  194 op land *tmp66 *tmp63 *tmp65
+  195 jump *label373 notEqual *tmp66 false
+  196 label *label379
+  197 label *label380
+  198 label *label381
+  199 print :chooseUnitType:type
+  200 print ":"
+  201 print " occupied: "
+  202 print :areUnitsAvailable.1:occupied
+  203 print ","
+  204 print " free: "
+  205 print :areUnitsAvailable.1:free
+  206 jump *label382 lessThanEq :areUnitsAvailable.1:needed 0
+  207 print ", needed: "
+  208 print :areUnitsAvailable.1:needed
+  209 label *label382
+  210 label *label383
+  211 print "\n"
+  212 label *label384
+  213 label *label385
+  214 set *tmp42 false
+  215 label *label386
+  216 jump *label387 equal *tmp42 false
+  217 printflush null
+  218 set *tmp9 :chooseUnitType:type
+  219 jump *label22 always
+  220 label *label387
+  221 label *label388
+  222 label *label389
+  223 label *label390
+  224 label *label391
+  225 set :chooseUnitType:type @poly
+  226 op add *tmp39 @counter 1
+  227 label *label394
+  228 jump *label414 equal :chooseUnitType:type UNIT_TYPE
+  229 # "Function: inline def areUnitsAvailable(in type, in output)"
+  230 set :areUnitsAvailable.1:free 0
+  231 set :areUnitsAvailable.1:occupied 0
+  232 set :areUnitsAvailable.1:needed 0
+  233 ubind :chooseUnitType:type
+  234 set :areUnitsAvailable.1:firstUnit @unit
+  235 jump *label405 equal :areUnitsAvailable.1:firstUnit null
+  236 # "Function: inline def needsFourUnits(in unit)"
+  237 set :needsFourUnits.1:unit @unit
+  238 op sub *tmp46 .DOME_X .CORE_X
+  239 op sub *tmp47 .DOME_Y .CORE_Y
+  240 op len *tmp48 *tmp46 *tmp47
+  241 op mul *tmp49 2 *tmp48
+  242 sensor *tmp50 :needsFourUnits.1:unit @speed
+  243 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  244 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  245 label *label395
+  246 select *tmp53 notEqual *tmp45 false 4 2
+  247 label *label396
+  248 label *label397
+  249 set :areUnitsAvailable.1:needed *tmp53
+  250 label *label398
+  251 sensor *tmp54 @unit @controlled
+  252 op equal *tmp55 *tmp54 0
+  253 sensor *tmp56 @unit @controller
+  254 op equal *tmp57 *tmp56 @this
+  255 op or *tmp58 *tmp55 *tmp57
+  256 jump *label401 equal *tmp58 false
+  257 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  258 jump *label399 lessThan :areUnitsAvailable.1:free *tmp53
+  259 set *tmp42 true
+  260 jump *label411 always
+  261 label *label399
+  262 label *label400
+  263 jump *label402 always
+  264 label *label401
+  265 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  266 label *label402
+  267 ubind :chooseUnitType:type
+  268 label *label403
+  269 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  270 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  271 op equal *tmp65 *tmp64 0
+  272 op land *tmp66 *tmp63 *tmp65
+  273 jump *label398 notEqual *tmp66 false
+  274 label *label404
+  275 label *label405
+  276 label *label406
+  277 print :chooseUnitType:type
+  278 print ":"
+  279 print " occupied: "
+  280 print :areUnitsAvailable.1:occupied
+  281 print ","
+  282 print " free: "
+  283 print :areUnitsAvailable.1:free
+  284 jump *label407 lessThanEq :areUnitsAvailable.1:needed 0
+  285 print ", needed: "
+  286 print :areUnitsAvailable.1:needed
+  287 label *label407
+  288 label *label408
+  289 print "\n"
+  290 label *label409
+  291 label *label410
+  292 set *tmp42 false
+  293 label *label411
+  294 jump *label412 equal *tmp42 false
+  295 printflush null
+  296 set *tmp9 :chooseUnitType:type
+  297 jump *label22 always
+  298 label *label412
+  299 label *label413
+  300 label *label414
+  301 label *label415
+  302 label *label416
+  303 set :chooseUnitType:type @mega
+  304 op add *tmp39 @counter 1
+  305 label *label419
+  306 jump *label439 equal :chooseUnitType:type UNIT_TYPE
+  307 # "Function: inline def areUnitsAvailable(in type, in output)"
+  308 set :areUnitsAvailable.1:free 0
+  309 set :areUnitsAvailable.1:occupied 0
+  310 set :areUnitsAvailable.1:needed 0
+  311 ubind :chooseUnitType:type
+  312 set :areUnitsAvailable.1:firstUnit @unit
+  313 jump *label430 equal :areUnitsAvailable.1:firstUnit null
+  314 # "Function: inline def needsFourUnits(in unit)"
+  315 set :needsFourUnits.1:unit @unit
+  316 op sub *tmp46 .DOME_X .CORE_X
+  317 op sub *tmp47 .DOME_Y .CORE_Y
+  318 op len *tmp48 *tmp46 *tmp47
+  319 op mul *tmp49 2 *tmp48
+  320 sensor *tmp50 :needsFourUnits.1:unit @speed
+  321 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  322 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  323 label *label420
+  324 select *tmp53 notEqual *tmp45 false 4 2
+  325 label *label421
+  326 label *label422
+  327 set :areUnitsAvailable.1:needed *tmp53
+  328 label *label423
+  329 sensor *tmp54 @unit @controlled
+  330 op equal *tmp55 *tmp54 0
+  331 sensor *tmp56 @unit @controller
+  332 op equal *tmp57 *tmp56 @this
+  333 op or *tmp58 *tmp55 *tmp57
+  334 jump *label426 equal *tmp58 false
+  335 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  336 jump *label424 lessThan :areUnitsAvailable.1:free *tmp53
+  337 set *tmp42 true
+  338 jump *label436 always
+  339 label *label424
+  340 label *label425
+  341 jump *label427 always
+  342 label *label426
+  343 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  344 label *label427
+  345 ubind :chooseUnitType:type
+  346 label *label428
+  347 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  348 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  349 op equal *tmp65 *tmp64 0
+  350 op land *tmp66 *tmp63 *tmp65
+  351 jump *label423 notEqual *tmp66 false
+  352 label *label429
+  353 label *label430
+  354 label *label431
+  355 print :chooseUnitType:type
+  356 print ":"
+  357 print " occupied: "
+  358 print :areUnitsAvailable.1:occupied
+  359 print ","
+  360 print " free: "
+  361 print :areUnitsAvailable.1:free
+  362 jump *label432 lessThanEq :areUnitsAvailable.1:needed 0
+  363 print ", needed: "
+  364 print :areUnitsAvailable.1:needed
+  365 label *label432
+  366 label *label433
+  367 print "\n"
+  368 label *label434
+  369 label *label435
+  370 set *tmp42 false
+  371 label *label436
+  372 jump *label437 equal *tmp42 false
+  373 printflush null
+  374 set *tmp9 :chooseUnitType:type
+  375 jump *label22 always
+  376 label *label437
+  377 label *label438
+  378 label *label439
+  379 label *label440
+  380 label *label441
+  381 set :chooseUnitType:type @mono
+  382 op add *tmp39 @counter 1
+  383 label *label444
+  384 jump *label464 equal :chooseUnitType:type UNIT_TYPE
+  385 # "Function: inline def areUnitsAvailable(in type, in output)"
+  386 set :areUnitsAvailable.1:free 0
+  387 set :areUnitsAvailable.1:occupied 0
+  388 set :areUnitsAvailable.1:needed 0
+  389 ubind :chooseUnitType:type
+  390 set :areUnitsAvailable.1:firstUnit @unit
+  391 jump *label455 equal :areUnitsAvailable.1:firstUnit null
+  392 # "Function: inline def needsFourUnits(in unit)"
+  393 set :needsFourUnits.1:unit @unit
+  394 op sub *tmp46 .DOME_X .CORE_X
+  395 op sub *tmp47 .DOME_Y .CORE_Y
+  396 op len *tmp48 *tmp46 *tmp47
+  397 op mul *tmp49 2 *tmp48
+  398 sensor *tmp50 :needsFourUnits.1:unit @speed
+  399 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  400 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  401 label *label445
+  402 select *tmp53 notEqual *tmp45 false 4 2
+  403 label *label446
+  404 label *label447
+  405 set :areUnitsAvailable.1:needed *tmp53
+  406 label *label448
+  407 sensor *tmp54 @unit @controlled
+  408 op equal *tmp55 *tmp54 0
+  409 sensor *tmp56 @unit @controller
+  410 op equal *tmp57 *tmp56 @this
+  411 op or *tmp58 *tmp55 *tmp57
+  412 jump *label451 equal *tmp58 false
+  413 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  414 jump *label449 lessThan :areUnitsAvailable.1:free *tmp53
+  415 set *tmp42 true
+  416 jump *label461 always
+  417 label *label449
+  418 label *label450
+  419 jump *label452 always
+  420 label *label451
+  421 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  422 label *label452
+  423 ubind :chooseUnitType:type
+  424 label *label453
+  425 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  426 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  427 op equal *tmp65 *tmp64 0
+  428 op land *tmp66 *tmp63 *tmp65
+  429 jump *label448 notEqual *tmp66 false
+  430 label *label454
+  431 label *label455
+  432 label *label456
+  433 print :chooseUnitType:type
+  434 print ":"
+  435 print " occupied: "
+  436 print :areUnitsAvailable.1:occupied
+  437 print ","
+  438 print " free: "
+  439 print :areUnitsAvailable.1:free
+  440 jump *label457 lessThanEq :areUnitsAvailable.1:needed 0
+  441 print ", needed: "
+  442 print :areUnitsAvailable.1:needed
+  443 label *label457
+  444 label *label458
+  445 print "\n"
+  446 label *label459
+  447 label *label460
+  448 set *tmp42 false
+  449 label *label461
+  450 jump *label462 equal *tmp42 false
+  451 printflush null
+  452 set *tmp9 :chooseUnitType:type
+  453 jump *label22 always
+  454 label *label462
+  455 label *label463
+  456 label *label464
+  457 label *label465
+  458 label *label466
+  459 label *label53
+  460 label *label47
   461 printflush message1
   462 label *label24
   463 jump *label23 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-4 instructions):
 
   145 label *label43
   146 label *label44
   147 set :chooseUnitType:type @flare
-    * op add *tmp39 @counter 1
   148 label *label369
-    * jump *label389 equal :chooseUnitType:type UNIT_TYPE
+  149 jump *label389 equal @flare UNIT_TYPE
   150 # "Function: inline def areUnitsAvailable(in type, in output)"
   151 set :areUnitsAvailable.1:free 0
   152 set :areUnitsAvailable.1:occupied 0
   153 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  154 ubind @flare
   155 set :areUnitsAvailable.1:firstUnit @unit
   156 jump *label380 equal :areUnitsAvailable.1:firstUnit null
   157 # "Function: inline def needsFourUnits(in unit)"
 
   185 label *label376
   186 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   187 label *label377
-    * ubind :chooseUnitType:type
+  188 ubind @flare
   189 label *label378
   190 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   191 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   195 label *label379
   196 label *label380
   197 label *label381
-    * print :chooseUnitType:type
+  198 print @flare
   199 print ":"
   200 print " occupied: "
   201 print :areUnitsAvailable.1:occupied
 
   214 label *label386
   215 jump *label387 equal *tmp42 false
   216 printflush null
-    * set *tmp9 :chooseUnitType:type
+  217 set *tmp9 @flare
   218 jump *label22 always
   219 label *label387
   220 label *label388
 
   222 label *label390
   223 label *label391
   224 set :chooseUnitType:type @poly
-    * op add *tmp39 @counter 1
   225 label *label394
-    * jump *label414 equal :chooseUnitType:type UNIT_TYPE
+  226 jump *label414 equal @poly UNIT_TYPE
   227 # "Function: inline def areUnitsAvailable(in type, in output)"
   228 set :areUnitsAvailable.1:free 0
   229 set :areUnitsAvailable.1:occupied 0
   230 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  231 ubind @poly
   232 set :areUnitsAvailable.1:firstUnit @unit
   233 jump *label405 equal :areUnitsAvailable.1:firstUnit null
   234 # "Function: inline def needsFourUnits(in unit)"
 
   262 label *label401
   263 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   264 label *label402
-    * ubind :chooseUnitType:type
+  265 ubind @poly
   266 label *label403
   267 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   268 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   272 label *label404
   273 label *label405
   274 label *label406
-    * print :chooseUnitType:type
+  275 print @poly
   276 print ":"
   277 print " occupied: "
   278 print :areUnitsAvailable.1:occupied
 
   291 label *label411
   292 jump *label412 equal *tmp42 false
   293 printflush null
-    * set *tmp9 :chooseUnitType:type
+  294 set *tmp9 @poly
   295 jump *label22 always
   296 label *label412
   297 label *label413
 
   299 label *label415
   300 label *label416
   301 set :chooseUnitType:type @mega
-    * op add *tmp39 @counter 1
   302 label *label419
-    * jump *label439 equal :chooseUnitType:type UNIT_TYPE
+  303 jump *label439 equal @mega UNIT_TYPE
   304 # "Function: inline def areUnitsAvailable(in type, in output)"
   305 set :areUnitsAvailable.1:free 0
   306 set :areUnitsAvailable.1:occupied 0
   307 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  308 ubind @mega
   309 set :areUnitsAvailable.1:firstUnit @unit
   310 jump *label430 equal :areUnitsAvailable.1:firstUnit null
   311 # "Function: inline def needsFourUnits(in unit)"
 
   339 label *label426
   340 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   341 label *label427
-    * ubind :chooseUnitType:type
+  342 ubind @mega
   343 label *label428
   344 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   345 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   349 label *label429
   350 label *label430
   351 label *label431
-    * print :chooseUnitType:type
+  352 print @mega
   353 print ":"
   354 print " occupied: "
   355 print :areUnitsAvailable.1:occupied
 
   368 label *label436
   369 jump *label437 equal *tmp42 false
   370 printflush null
-    * set *tmp9 :chooseUnitType:type
+  371 set *tmp9 @mega
   372 jump *label22 always
   373 label *label437
   374 label *label438
 
   376 label *label440
   377 label *label441
   378 set :chooseUnitType:type @mono
-    * op add *tmp39 @counter 1
   379 label *label444
-    * jump *label464 equal :chooseUnitType:type UNIT_TYPE
+  380 jump *label464 equal @mono UNIT_TYPE
   381 # "Function: inline def areUnitsAvailable(in type, in output)"
   382 set :areUnitsAvailable.1:free 0
   383 set :areUnitsAvailable.1:occupied 0
   384 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  385 ubind @mono
   386 set :areUnitsAvailable.1:firstUnit @unit
   387 jump *label455 equal :areUnitsAvailable.1:firstUnit null
   388 # "Function: inline def needsFourUnits(in unit)"
 
   416 label *label451
   417 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   418 label *label452
-    * ubind :chooseUnitType:type
+  419 ubind @mono
   420 label *label453
   421 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   422 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   426 label *label454
   427 label *label455
   428 label *label456
-    * print :chooseUnitType:type
+  429 print @mono
   430 print ":"
   431 print " occupied: "
   432 print :areUnitsAvailable.1:occupied
 
   445 label *label461
   446 jump *label462 equal *tmp42 false
   447 printflush null
-    * set *tmp9 :chooseUnitType:type
+  448 set *tmp9 @mono
   449 jump *label22 always
   450 label *label462
   451 label *label463

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-4 instructions):
 
   144 jump *label22 always
   145 label *label43
   146 label *label44
-    * set :chooseUnitType:type @flare
   147 label *label369
   148 jump *label389 equal @flare UNIT_TYPE
   149 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   220 label *label389
   221 label *label390
   222 label *label391
-    * set :chooseUnitType:type @poly
   223 label *label394
   224 jump *label414 equal @poly UNIT_TYPE
   225 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   296 label *label414
   297 label *label415
   298 label *label416
-    * set :chooseUnitType:type @mega
   299 label *label419
   300 jump *label439 equal @mega UNIT_TYPE
   301 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   372 label *label439
   373 label *label440
   374 label *label441
-    * set :chooseUnitType:type @mono
   375 label *label444
   376 jump *label464 equal @mono UNIT_TYPE
   377 # "Function: inline def areUnitsAvailable(in type, in output)"

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     3 remark "Do not modify anything below this line."
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
-    * label *label2
     6 jump *label4 notEqual dome1 null
     7 label *label340
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
-    * label *label3
    11 jump *label340 equal dome1 null
    12 label *label4
    13 print "[gold]Locating core..."
    14 printflush message1
    15 set .CORE null
    16 label *label5
-    * label *label341
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
    19 jump *label342 equal :locateCore*retval false
    20 jump *label1 always
    21 label *label342
-    * label *label343
-    * label *label344
-    * label *label347
    22 set :locateCore:type @poly
    23 call *label0 :locateCore*retaddr :locateCore*retval
    24 jump *label348 equal :locateCore*retval false
    25 jump *label1 always
    26 label *label348
-    * label *label349
-    * label *label350
-    * label *label353
    27 set :locateCore:type @mega
    28 call *label0 :locateCore*retaddr :locateCore*retval
    29 jump *label354 equal :locateCore*retval false
    30 jump *label1 always
    31 label *label354
-    * label *label355
-    * label *label356
-    * label *label359
    32 set :locateCore:type @mono
    33 call *label0 :locateCore*retaddr :locateCore*retval
    34 jump *label360 equal :locateCore*retval false
    35 jump *label1 always
    36 label *label360
-    * label *label361
-    * label *label362
-    * label *label16
-    * label *label10
-    * label *label6
    37 jump *label5 always
-    * label *label7
    38 label *label1
    39 sensor .CORE_X .CORE @x
    40 sensor .CORE_Y .CORE @y
    41 sensor .DOME_X .DOME @x
    42 sensor .DOME_Y .DOME @y
-    * label *label19
    43 sensor *tmp7 switch1 @enabled
    44 jump *label21 notEqual *tmp7 false
    45 label *label367
    46 print "[coral]Activate switch to begin supplying overdrive dome..."
    47 print "\n"
    48 printflush message1
-    * label *label20
    49 sensor *tmp7 switch1 @enabled
    50 jump *label367 equal *tmp7 false
    51 label *label21
 
    70 sensor *tmp18 :needsFourUnits:unit @speed
    71 op div :needsFourUnits:travel_time *tmp17 *tmp18
    72 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
-    * label *label29
    73 select *tmp21 notEqual *tmp13 false 4 2
-    * label *label30
-    * label *label31
    74 set :areUnitsAvailable:needed *tmp21
    75 label *label32
    76 sensor *tmp22 @unit @controlled
 
    84 set *tmp10 true
    85 jump *label26 always
    86 label *label37
-    * label *label38
    87 jump *label36 always
    88 label *label35
    89 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    90 label *label36
    91 ubind UNIT_TYPE
-    * label *label33
    92 op notEqual *tmp31 @unit :areUnitsAvailable:firstUnit
    93 sensor *tmp32 :areUnitsAvailable:firstUnit @dead
    94 op equal *tmp33 *tmp32 0
    95 op land *tmp34 *tmp31 *tmp33
    96 jump *label32 notEqual *tmp34 false
-    * label *label34
    97 label *label27
-    * label *label28
    98 print UNIT_TYPE
    99 print ":"
   100 print " occupied: "
 
   106 print ", needed: "
   107 print :areUnitsAvailable:needed
   108 label *label41
-    * label *label42
   109 print "\n"
-    * label *label39
-    * label *label40
   110 set *tmp10 false
   111 label *label26
   112 jump *label43 equal *tmp10 false
   113 set *tmp9 UNIT_TYPE
   114 jump *label22 always
   115 label *label43
-    * label *label44
-    * label *label369
   116 jump *label389 equal @flare UNIT_TYPE
   117 # "Function: inline def areUnitsAvailable(in type, in output)"
   118 set :areUnitsAvailable.1:free 0
 
   130 sensor *tmp50 :needsFourUnits.1:unit @speed
   131 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   132 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * label *label370
   133 select *tmp53 notEqual *tmp45 false 4 2
-    * label *label371
-    * label *label372
   134 set :areUnitsAvailable.1:needed *tmp53
   135 label *label373
   136 sensor *tmp54 @unit @controlled
 
   144 set *tmp42 true
   145 jump *label386 always
   146 label *label374
-    * label *label375
   147 jump *label377 always
   148 label *label376
   149 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   150 label *label377
   151 ubind @flare
-    * label *label378
   152 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   153 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
   154 op equal *tmp65 *tmp64 0
   155 op land *tmp66 *tmp63 *tmp65
   156 jump *label373 notEqual *tmp66 false
-    * label *label379
   157 label *label380
-    * label *label381
   158 print @flare
   159 print ":"
   160 print " occupied: "
 
   166 print ", needed: "
   167 print :areUnitsAvailable.1:needed
   168 label *label382
-    * label *label383
   169 print "\n"
-    * label *label384
-    * label *label385
   170 set *tmp42 false
   171 label *label386
   172 jump *label387 equal *tmp42 false
 
   174 set *tmp9 @flare
   175 jump *label22 always
   176 label *label387
-    * label *label388
   177 label *label389
-    * label *label390
-    * label *label391
-    * label *label394
   178 jump *label414 equal @poly UNIT_TYPE
   179 # "Function: inline def areUnitsAvailable(in type, in output)"
   180 set :areUnitsAvailable.1:free 0
 
   192 sensor *tmp50 :needsFourUnits.1:unit @speed
   193 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   194 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * label *label395
   195 select *tmp53 notEqual *tmp45 false 4 2
-    * label *label396
-    * label *label397
   196 set :areUnitsAvailable.1:needed *tmp53
   197 label *label398
   198 sensor *tmp54 @unit @controlled
 
   206 set *tmp42 true
   207 jump *label411 always
   208 label *label399
-    * label *label400
   209 jump *label402 always
   210 label *label401
   211 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   212 label *label402
   213 ubind @poly
-    * label *label403
   214 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   215 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
   216 op equal *tmp65 *tmp64 0
   217 op land *tmp66 *tmp63 *tmp65
   218 jump *label398 notEqual *tmp66 false
-    * label *label404
   219 label *label405
-    * label *label406
   220 print @poly
   221 print ":"
   222 print " occupied: "
 
   228 print ", needed: "
   229 print :areUnitsAvailable.1:needed
   230 label *label407
-    * label *label408
   231 print "\n"
-    * label *label409
-    * label *label410
   232 set *tmp42 false
   233 label *label411
   234 jump *label412 equal *tmp42 false
 
   236 set *tmp9 @poly
   237 jump *label22 always
   238 label *label412
-    * label *label413
   239 label *label414
-    * label *label415
-    * label *label416
-    * label *label419
   240 jump *label439 equal @mega UNIT_TYPE
   241 # "Function: inline def areUnitsAvailable(in type, in output)"
   242 set :areUnitsAvailable.1:free 0
 
   254 sensor *tmp50 :needsFourUnits.1:unit @speed
   255 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   256 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * label *label420
   257 select *tmp53 notEqual *tmp45 false 4 2
-    * label *label421
-    * label *label422
   258 set :areUnitsAvailable.1:needed *tmp53
   259 label *label423
   260 sensor *tmp54 @unit @controlled
 
   268 set *tmp42 true
   269 jump *label436 always
   270 label *label424
-    * label *label425
   271 jump *label427 always
   272 label *label426
   273 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   274 label *label427
   275 ubind @mega
-    * label *label428
   276 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   277 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
   278 op equal *tmp65 *tmp64 0
   279 op land *tmp66 *tmp63 *tmp65
   280 jump *label423 notEqual *tmp66 false
-    * label *label429
   281 label *label430
-    * label *label431
   282 print @mega
   283 print ":"
   284 print " occupied: "
 
   290 print ", needed: "
   291 print :areUnitsAvailable.1:needed
   292 label *label432
-    * label *label433
   293 print "\n"
-    * label *label434
-    * label *label435
   294 set *tmp42 false
   295 label *label436
   296 jump *label437 equal *tmp42 false
 
   298 set *tmp9 @mega
   299 jump *label22 always
   300 label *label437
-    * label *label438
   301 label *label439
-    * label *label440
-    * label *label441
-    * label *label444
   302 jump *label464 equal @mono UNIT_TYPE
   303 # "Function: inline def areUnitsAvailable(in type, in output)"
   304 set :areUnitsAvailable.1:free 0
 
   316 sensor *tmp50 :needsFourUnits.1:unit @speed
   317 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   318 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * label *label445
   319 select *tmp53 notEqual *tmp45 false 4 2
-    * label *label446
-    * label *label447
   320 set :areUnitsAvailable.1:needed *tmp53
   321 label *label448
   322 sensor *tmp54 @unit @controlled
 
   330 set *tmp42 true
   331 jump *label461 always
   332 label *label449
-    * label *label450
   333 jump *label452 always
   334 label *label451
   335 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   336 label *label452
   337 ubind @mono
-    * label *label453
   338 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   339 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
   340 op equal *tmp65 *tmp64 0
   341 op land *tmp66 *tmp63 *tmp65
   342 jump *label448 notEqual *tmp66 false
-    * label *label454
   343 label *label455
-    * label *label456
   344 print @mono
   345 print ":"
   346 print " occupied: "
 
   352 print ", needed: "
   353 print :areUnitsAvailable.1:needed
   354 label *label457
-    * label *label458
   355 print "\n"
-    * label *label459
-    * label *label460
   356 set *tmp42 false
   357 label *label461
   358 jump *label462 equal *tmp42 false
 
   360 set *tmp9 @mono
   361 jump *label22 always
   362 label *label462
-    * label *label463
   363 label *label464
-    * label *label465
-    * label *label466
-    * label *label53
-    * label *label47
   364 printflush message1
-    * label *label24
   365 jump *label23 always
-    * label *label25
   366 set *tmp9 null
   367 label *label22
   368 set .TYPE *tmp9
 
   379 jump *label76 notEqual :rebindUnits:firstUnit null
   380 end
   381 label *label76
-    * label *label77
   382 label *label78
   383 sensor *tmp74 @unit @controller
   384 jump *label81 notEqual *tmp74 @this
 
   391 jump *label83 equal .UNIT_S2 null
   392 jump *label80 always
   393 label *label83
-    * label *label84
   394 label *label81
-    * label *label82
   395 ubind *tmp9
-    * label *label79
   396 op notEqual *tmp81 @unit :rebindUnits:firstUnit
   397 sensor *tmp82 :rebindUnits:firstUnit @dead
   398 op equal *tmp83 *tmp82 0
   399 op land *tmp84 *tmp81 *tmp83
   400 jump *label78 notEqual *tmp84 false
   401 label *label80
-    * label *label75
   402 # "Function: inline def acquireUnit(in currentUnit)"
   403 # "Function: inline def rebindUnit(in currentUnit)"
   404 jump *label87 equal .UNIT_S1 null
 
   411 jump *label89 equal *tmp93 false
   412 jump *label86 always
   413 label *label89
-    * label *label90
   414 label *label87
-    * label *label88
   415 ubind *tmp9
   416 set :rebindUnit:firstUnit @unit
   417 jump *label91 equal :rebindUnit:firstUnit null
 
   420 jump *label96 notEqual *tmp97 0
   421 jump *label86 always
   422 label *label96
-    * label *label97
   423 ubind *tmp9
-    * label *label94
   424 op notEqual *tmp100 @unit :rebindUnit:firstUnit
   425 sensor *tmp101 :rebindUnit:firstUnit @dead
   426 op equal *tmp102 *tmp101 0
   427 op land *tmp103 *tmp100 *tmp102
   428 jump *label93 notEqual *tmp103 false
-    * label *label95
   429 label *label91
-    * label *label92
   430 end
   431 label *label86
   432 ucontrol flag 1
   433 set *tmp85 @unit
-    * label *label85
   434 set .UNIT_S1 *tmp85
   435 # "Function: inline def acquireUnit(in currentUnit)"
   436 # "Function: inline def rebindUnit(in currentUnit)"
 
   444 jump *label102 equal *tmp112 false
   445 jump *label99 always
   446 label *label102
-    * label *label103
   447 label *label100
-    * label *label101
   448 ubind *tmp9
   449 set :rebindUnit.1:firstUnit @unit
   450 jump *label104 equal :rebindUnit.1:firstUnit null
 
   453 jump *label109 notEqual *tmp116 0
   454 jump *label99 always
   455 label *label109
-    * label *label110
   456 ubind *tmp9
-    * label *label107
   457 op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
   458 sensor *tmp120 :rebindUnit.1:firstUnit @dead
   459 op equal *tmp121 *tmp120 0
   460 op land *tmp122 *tmp119 *tmp121
   461 jump *label106 notEqual *tmp122 false
-    * label *label108
   462 label *label104
-    * label *label105
   463 end
   464 label *label99
   465 ucontrol flag 1
   466 set *tmp104 @unit
-    * label *label98
   467 set .UNIT_P1 *tmp104
   468 sensor *tmp123 *tmp85 @firstItem
   469 op equal *tmp124 *tmp123 @phase-fabric
 
   472 op or *tmp127 *tmp124 *tmp126
   473 jump *label111 equal *tmp127 false
   474 # "Function: inline void swap(in out a, in out b)"
-    * label *label113
   475 set .UNIT_S1 *tmp104
   476 set .UNIT_P1 *tmp85
   477 label *label111
-    * label *label112
   478 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
   479 sensor .SPEED .UNIT_S1 @speed
   480 op div .SPEED_TENTHS .SPEED 10
 
   482 jump *label114 equal *tmp132 false
   483 stop
   484 label *label114
-    * label *label115
   485 # "Function: inline def needsFourUnits(in unit)"
   486 op sub *tmp135 .DOME_X .CORE_X
   487 op sub *tmp136 .DOME_Y .CORE_Y
 
   490 sensor *tmp139 .UNIT_S1 @speed
   491 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   492 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
-    * label *label116
   493 set .FOUR_UNITS *tmp134
   494 jump *label117 equal *tmp134 false
   495 # "Function: inline def acquireUnit(in currentUnit)"
 
   504 jump *label123 equal *tmp151 false
   505 jump *label120 always
   506 label *label123
-    * label *label124
   507 label *label121
-    * label *label122
   508 ubind *tmp9
   509 set :rebindUnit.2:firstUnit @unit
   510 jump *label125 equal :rebindUnit.2:firstUnit null
 
   513 jump *label130 notEqual *tmp155 0
   514 jump *label120 always
   515 label *label130
-    * label *label131
   516 ubind *tmp9
-    * label *label128
   517 op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
   518 sensor *tmp159 :rebindUnit.2:firstUnit @dead
   519 op equal *tmp160 *tmp159 0
   520 op land *tmp161 *tmp158 *tmp160
   521 jump *label127 notEqual *tmp161 false
-    * label *label129
   522 label *label125
-    * label *label126
   523 end
   524 label *label120
   525 ucontrol flag 1
   526 set *tmp143 @unit
-    * label *label119
   527 set .UNIT_S2 *tmp143
   528 # "Function: inline def acquireUnit(in currentUnit)"
   529 # "Function: inline def rebindUnit(in currentUnit)"
 
   537 jump *label136 equal *tmp170 false
   538 jump *label133 always
   539 label *label136
-    * label *label137
   540 label *label134
-    * label *label135
   541 ubind *tmp9
   542 set :rebindUnit.3:firstUnit @unit
   543 jump *label138 equal :rebindUnit.3:firstUnit null
 
   546 jump *label143 notEqual *tmp174 0
   547 jump *label133 always
   548 label *label143
-    * label *label144
   549 ubind *tmp9
-    * label *label141
   550 op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
   551 sensor *tmp178 :rebindUnit.3:firstUnit @dead
   552 op equal *tmp179 *tmp178 0
   553 op land *tmp180 *tmp177 *tmp179
   554 jump *label140 notEqual *tmp180 false
-    * label *label142
   555 label *label138
-    * label *label139
   556 end
   557 label *label133
   558 ucontrol flag 1
   559 set *tmp162 @unit
-    * label *label132
   560 set .UNIT_P2 *tmp162
   561 sensor *tmp181 .UNIT_S1 @firstItem
   562 op equal *tmp182 *tmp181 @phase-fabric
 
   566 jump *label145 equal *tmp185 false
   567 # "Function: inline void swap(in out a, in out b)"
   568 set :swap.1:t .UNIT_S1
-    * label *label147
   569 set .UNIT_S1 *tmp162
   570 set .UNIT_P2 :swap.1:t
   571 label *label145
-    * label *label146
   572 sensor *tmp187 *tmp143 @firstItem
   573 op equal *tmp188 *tmp187 @phase-fabric
   574 sensor *tmp189 .UNIT_P2 @firstItem
 
   576 op or *tmp191 *tmp188 *tmp190
   577 jump *label148 equal *tmp191 false
   578 # "Function: inline void swap(in out a, in out b)"
-    * label *label150
   579 set .UNIT_S2 .UNIT_P2
   580 set .UNIT_P2 *tmp143
   581 label *label148
-    * label *label149
   582 set .GROUP1 "unit  1"
   583 set .GROUP2 "unit 2"
   584 jump *label118 always
 
   601 op lessThan *tmp201 *tmp199 *tmp200
   602 op or .SUPPLY_P_FIRST *tmp193 *tmp201
   603 op add :unitCheck @time 5000
-    * label *label151
   604 sensor *tmp204 switch1 @enabled
   605 jump *label153 equal *tmp204 false
   606 label *label368
 
   630 print "]"
   631 print "\n"
   632 label *label156
-    * label *label154
   633 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   634 # "Function: inline def rebindUnit(in currentUnit)"
   635 jump *label159 equal .UNIT_S1 null
 
   642 jump *label161 equal *tmp215 false
   643 jump *label158 always
   644 label *label161
-    * label *label162
   645 label *label159
-    * label *label160
   646 ubind *tmp9
   647 set :rebindUnit.4:firstUnit @unit
   648 jump *label163 equal :rebindUnit.4:firstUnit null
 
   651 jump *label168 notEqual *tmp219 0
   652 jump *label158 always
   653 label *label168
-    * label *label169
   654 ubind *tmp9
-    * label *label166
   655 op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
   656 sensor *tmp223 :rebindUnit.4:firstUnit @dead
   657 op equal *tmp224 *tmp223 0
   658 op land *tmp225 *tmp222 *tmp224
   659 jump *label165 notEqual *tmp225 false
-    * label *label167
   660 label *label163
-    * label *label164
   661 end
   662 label *label158
   663 sensor :processUnit:state @unit @flag
 
   682 jump *label176 equal *tmp237 false
   683 ucontrol itemDrop .CORE .UNIT_CAPACITY
   684 label *label176
-    * label *label177
   685 label *label175
   686 label *label173
   687 label *label170
-    * label *label171
   688 jump *label178 notEqual :processUnit:state 2
   689 ucontrol within .CORE_X .CORE_Y 8 *tmp241
   690 jump *label180 equal *tmp241 false
 
   710 op div :processUnit:distance *tmp251 10
   711 label *label181
   712 label *label178
-    * label *label179
   713 jump *label184 notEqual :processUnit:state 3
   714 ucontrol within .DOME_X .DOME_Y 8 *tmp255
   715 jump *label186 equal *tmp255 false
 
   726 ucontrol approach .CORE_X .CORE_Y 6
   727 set :processUnit:state 2
   728 label *label190
-    * label *label191
   729 jump *label187 always
   730 label *label186
   731 ucontrol approach .DOME_X .DOME_Y 6
 
   739 op div :processUnit:distance *tmp266 10
   740 label *label187
   741 label *label184
-    * label *label185
   742 ucontrol flag :processUnit:state
   743 sensor *tmp268 @unit @totalItems
   744 print "  "
 
   761 print .MSG
   762 label *label193
   763 set :processUnit:unit @unit
-    * label *label157
   764 set .UNIT_S1 :processUnit:unit
   765 jump *label194 equal *tmp134 false
   766 op equal *tmp273 .SUPPLY_S_FIRST false
 
   776 jump *label200 equal *tmp281 false
   777 jump *label197 always
   778 label *label200
-    * label *label201
   779 label *label198
-    * label *label199
   780 ubind *tmp9
   781 set :rebindUnit.5:firstUnit @unit
   782 jump *label202 equal :rebindUnit.5:firstUnit null
 
   785 jump *label207 notEqual *tmp285 0
   786 jump *label197 always
   787 label *label207
-    * label *label208
   788 ubind *tmp9
-    * label *label205
   789 op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
   790 sensor *tmp289 :rebindUnit.5:firstUnit @dead
   791 op equal *tmp290 *tmp289 0
   792 op land *tmp291 *tmp288 *tmp290
   793 jump *label204 notEqual *tmp291 false
-    * label *label206
   794 label *label202
-    * label *label203
   795 end
   796 label *label197
   797 sensor :processUnit.1:state @unit @flag
 
   816 jump *label215 equal *tmp303 false
   817 ucontrol itemDrop .CORE .UNIT_CAPACITY
   818 label *label215
-    * label *label216
   819 label *label214
   820 label *label212
   821 label *label209
-    * label *label210
   822 jump *label217 notEqual :processUnit.1:state 2
   823 ucontrol within .CORE_X .CORE_Y 8 *tmp307
   824 jump *label219 equal *tmp307 false
 
   844 op div :processUnit.1:distance *tmp317 10
   845 label *label220
   846 label *label217
-    * label *label218
   847 jump *label223 notEqual :processUnit.1:state 3
   848 ucontrol within .DOME_X .DOME_Y 8 *tmp321
   849 jump *label225 equal *tmp321 false
 
   860 ucontrol approach .CORE_X .CORE_Y 6
   861 set :processUnit.1:state 2
   862 label *label229
-    * label *label230
   863 jump *label226 always
   864 label *label225
   865 ucontrol approach .DOME_X .DOME_Y 6
 
   873 op div :processUnit.1:distance *tmp332 10
   874 label *label226
   875 label *label223
-    * label *label224
   876 ucontrol flag :processUnit.1:state
   877 sensor *tmp334 @unit @totalItems
   878 print "  "
 
   895 print .MSG
   896 label *label232
   897 set :processUnit.1:unit @unit
-    * label *label196
   898 set .UNIT_S2 :processUnit.1:unit
   899 jump *label233 equal .SUPPLY_S_FIRST false
   900 sensor *tmp339 :processUnit:unit @totalItems
 
   905 op equal .SUPPLY_S_FIRST *tmp341 0
   906 label *label234
   907 label *label194
-    * label *label195
   908 # "Function: inline void printDomeStatus(in item, in text)"
   909 print "\n[green]Phase fabric[] status:\n"
   910 sensor :printDomeStatus.1:level .DOME @phase-fabric
 
   922 print "]"
   923 print "\n"
   924 label *label237
-    * label *label235
   925 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   926 # "Function: inline def rebindUnit(in currentUnit)"
   927 jump *label240 equal .UNIT_P1 null
 
   934 jump *label242 equal *tmp353 false
   935 jump *label239 always
   936 label *label242
-    * label *label243
   937 label *label240
-    * label *label241
   938 ubind *tmp9
   939 set :rebindUnit.6:firstUnit @unit
   940 jump *label244 equal :rebindUnit.6:firstUnit null
 
   943 jump *label249 notEqual *tmp357 0
   944 jump *label239 always
   945 label *label249
-    * label *label250
   946 ubind *tmp9
-    * label *label247
   947 op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
   948 sensor *tmp361 :rebindUnit.6:firstUnit @dead
   949 op equal *tmp362 *tmp361 0
   950 op land *tmp363 *tmp360 *tmp362
   951 jump *label246 notEqual *tmp363 false
-    * label *label248
   952 label *label244
-    * label *label245
   953 end
   954 label *label239
   955 sensor :processUnit.2:state @unit @flag
 
   974 jump *label257 equal *tmp375 false
   975 ucontrol itemDrop .CORE .UNIT_CAPACITY
   976 label *label257
-    * label *label258
   977 label *label256
   978 label *label254
   979 label *label251
-    * label *label252
   980 jump *label259 notEqual :processUnit.2:state 2
   981 ucontrol within .CORE_X .CORE_Y 8 *tmp379
   982 jump *label261 equal *tmp379 false
 
  1002 op div :processUnit.2:distance *tmp389 10
  1003 label *label262
  1004 label *label259
-    * label *label260
  1005 jump *label265 notEqual :processUnit.2:state 3
  1006 ucontrol within .DOME_X .DOME_Y 8 *tmp393
  1007 jump *label267 equal *tmp393 false
 
  1018 ucontrol approach .CORE_X .CORE_Y 6
  1019 set :processUnit.2:state 2
  1020 label *label271
-    * label *label272
  1021 jump *label268 always
  1022 label *label267
  1023 ucontrol approach .DOME_X .DOME_Y 6
 
  1031 op div :processUnit.2:distance *tmp404 10
  1032 label *label268
  1033 label *label265
-    * label *label266
  1034 ucontrol flag :processUnit.2:state
  1035 sensor *tmp406 @unit @totalItems
  1036 print "  "
 
  1053 print .MSG
  1054 label *label274
  1055 set :processUnit.2:unit @unit
-    * label *label238
  1056 set .UNIT_P1 :processUnit.2:unit
  1057 jump *label275 equal *tmp134 false
  1058 op equal *tmp411 .SUPPLY_P_FIRST false
 
  1068 jump *label281 equal *tmp419 false
  1069 jump *label278 always
  1070 label *label281
-    * label *label282
  1071 label *label279
-    * label *label280
  1072 ubind *tmp9
  1073 set :rebindUnit.7:firstUnit @unit
  1074 jump *label283 equal :rebindUnit.7:firstUnit null
 
  1077 jump *label288 notEqual *tmp423 0
  1078 jump *label278 always
  1079 label *label288
-    * label *label289
  1080 ubind *tmp9
-    * label *label286
  1081 op notEqual *tmp426 @unit :rebindUnit.7:firstUnit
  1082 sensor *tmp427 :rebindUnit.7:firstUnit @dead
  1083 op equal *tmp428 *tmp427 0
  1084 op land *tmp429 *tmp426 *tmp428
  1085 jump *label285 notEqual *tmp429 false
-    * label *label287
  1086 label *label283
-    * label *label284
  1087 end
  1088 label *label278
  1089 sensor :processUnit.3:state @unit @flag
 
  1108 jump *label296 equal *tmp441 false
  1109 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1110 label *label296
-    * label *label297
  1111 label *label295
  1112 label *label293
  1113 label *label290
-    * label *label291
  1114 jump *label298 notEqual :processUnit.3:state 2
  1115 ucontrol within .CORE_X .CORE_Y 8 *tmp445
  1116 jump *label300 equal *tmp445 false
 
  1136 op div :processUnit.3:distance *tmp455 10
  1137 label *label301
  1138 label *label298
-    * label *label299
  1139 jump *label304 notEqual :processUnit.3:state 3
  1140 ucontrol within .DOME_X .DOME_Y 8 *tmp459
  1141 jump *label306 equal *tmp459 false
 
  1152 ucontrol approach .CORE_X .CORE_Y 6
  1153 set :processUnit.3:state 2
  1154 label *label310
-    * label *label311
  1155 jump *label307 always
  1156 label *label306
  1157 ucontrol approach .DOME_X .DOME_Y 6
 
  1165 op div :processUnit.3:distance *tmp470 10
  1166 label *label307
  1167 label *label304
-    * label *label305
  1168 ucontrol flag :processUnit.3:state
  1169 sensor *tmp472 @unit @totalItems
  1170 print "  "
 
  1187 print .MSG
  1188 label *label313
  1189 set :processUnit.3:unit @unit
-    * label *label277
  1190 set .UNIT_P2 :processUnit.3:unit
  1191 jump *label314 equal .SUPPLY_P_FIRST false
  1192 sensor *tmp477 :processUnit.2:unit @totalItems
 
  1197 op equal .SUPPLY_P_FIRST *tmp479 0
  1198 label *label315
  1199 label *label275
-    * label *label276
  1200 op sub *tmp481 @time :start
  1201 op floor *tmp482 *tmp481
  1202 print "\n"
 
  1220 sensor *tmp495 :needsFourUnits.3:unit @speed
  1221 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1222 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
-    * label *label321
  1223 select *tmp498 notEqual *tmp490 false 4 2
-    * label *label322
-    * label *label323
  1224 label *label324
  1225 sensor *tmp499 @unit @controlled
  1226 op equal *tmp500 *tmp499 0
 
  1233 set *tmp487 true
  1234 jump *label318 always
  1235 label *label329
-    * label *label330
  1236 jump *label328 always
  1237 label *label327
  1238 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1239 label *label328
  1240 ubind UNIT_TYPE
-    * label *label325
  1241 op notEqual *tmp508 @unit :areUnitsAvailable.2:firstUnit
  1242 sensor *tmp509 :areUnitsAvailable.2:firstUnit @dead
  1243 op equal *tmp510 *tmp509 0
  1244 op land *tmp511 *tmp508 *tmp510
  1245 jump *label324 notEqual *tmp511 false
-    * label *label326
  1246 label *label319
-    * label *label320
  1247 jump *label331 always
  1248 print UNIT_TYPE
  1249 print ":"
 
  1256 print ", needed: "
  1257 print :areUnitsAvailable.2:needed
  1258 label *label333
-    * label *label334
  1259 print "\n"
  1260 label *label331
-    * label *label332
  1261 set *tmp487 false
  1262 label *label318
  1263 jump *label335 equal *tmp487 false
  1264 end
  1265 label *label335
-    * label *label336
  1266 op add :unitCheck @time 5000
  1267 label *label316
-    * label *label317
-    * label *label152
  1268 sensor *tmp204 switch1 @enabled
  1269 jump *label368 notEqual *tmp204 false
  1270 label *label153
 
  1280 jump *label338 equal *tmp521 false
  1281 ulocate building core false @copper 0 0 0 .CORE
  1282 label *label338
-    * label *label339
  1283 set :locateCore*retval .CORE
-    * label *label337
  1284 return :locateCore*retaddr
  1285 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-21 instructions):
 
    16 label *label5
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label342 equal :locateCore*retval false
-    * jump *label1 always
+   19 jump *label1 notEqual :locateCore*retval false
    20 label *label342
    21 set :locateCore:type @poly
    22 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label348 equal :locateCore*retval false
-    * jump *label1 always
+   23 jump *label1 notEqual :locateCore*retval false
    24 label *label348
    25 set :locateCore:type @mega
    26 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label354 equal :locateCore*retval false
-    * jump *label1 always
+   27 jump *label1 notEqual :locateCore*retval false
    28 label *label354
    29 set :locateCore:type @mono
    30 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label360 equal :locateCore*retval false
-    * jump *label1 always
+   31 jump *label1 notEqual :locateCore*retval false
    32 label *label360
    33 jump *label5 always
    34 label *label1
 
   384 set .UNIT_P2 .UNIT_S1
   385 set .UNIT_S1 .UNIT_P1
   386 set .UNIT_P1 @unit
-    * jump *label83 equal .UNIT_S2 null
-    * jump *label80 always
+  387 jump *label80 notEqual .UNIT_S2 null
   388 label *label83
   389 label *label81
   390 ubind *tmp9
 
   403 sensor *tmp91 @unit @controller
   404 op equal *tmp92 *tmp91 @this
   405 op land *tmp93 *tmp90 *tmp92
-    * jump *label89 equal *tmp93 false
-    * jump *label86 always
+  406 jump *label86 notEqual *tmp93 false
   407 label *label89
   408 label *label87
   409 ubind *tmp9
 
   411 jump *label91 equal :rebindUnit:firstUnit null
   412 label *label93
   413 sensor *tmp97 @unit @controlled
-    * jump *label96 notEqual *tmp97 0
-    * jump *label86 always
+  414 jump *label86 equal *tmp97 0
   415 label *label96
   416 ubind *tmp9
   417 op notEqual *tmp100 @unit :rebindUnit:firstUnit
 
   434 sensor *tmp110 @unit @controller
   435 op equal *tmp111 *tmp110 @this
   436 op land *tmp112 *tmp109 *tmp111
-    * jump *label102 equal *tmp112 false
-    * jump *label99 always
+  437 jump *label99 notEqual *tmp112 false
   438 label *label102
   439 label *label100
   440 ubind *tmp9
 
   442 jump *label104 equal :rebindUnit.1:firstUnit null
   443 label *label106
   444 sensor *tmp116 @unit @controlled
-    * jump *label109 notEqual *tmp116 0
-    * jump *label99 always
+  445 jump *label99 equal *tmp116 0
   446 label *label109
   447 ubind *tmp9
   448 op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
 
   492 sensor *tmp149 @unit @controller
   493 op equal *tmp150 *tmp149 @this
   494 op land *tmp151 *tmp148 *tmp150
-    * jump *label123 equal *tmp151 false
-    * jump *label120 always
+  495 jump *label120 notEqual *tmp151 false
   496 label *label123
   497 label *label121
   498 ubind *tmp9
 
   500 jump *label125 equal :rebindUnit.2:firstUnit null
   501 label *label127
   502 sensor *tmp155 @unit @controlled
-    * jump *label130 notEqual *tmp155 0
-    * jump *label120 always
+  503 jump *label120 equal *tmp155 0
   504 label *label130
   505 ubind *tmp9
   506 op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
 
   523 sensor *tmp168 @unit @controller
   524 op equal *tmp169 *tmp168 @this
   525 op land *tmp170 *tmp167 *tmp169
-    * jump *label136 equal *tmp170 false
-    * jump *label133 always
+  526 jump *label133 notEqual *tmp170 false
   527 label *label136
   528 label *label134
   529 ubind *tmp9
 
   531 jump *label138 equal :rebindUnit.3:firstUnit null
   532 label *label140
   533 sensor *tmp174 @unit @controlled
-    * jump *label143 notEqual *tmp174 0
-    * jump *label133 always
+  534 jump *label133 equal *tmp174 0
   535 label *label143
   536 ubind *tmp9
   537 op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
 
   626 sensor *tmp213 @unit @controller
   627 op equal *tmp214 *tmp213 @this
   628 op land *tmp215 *tmp212 *tmp214
-    * jump *label161 equal *tmp215 false
-    * jump *label158 always
+  629 jump *label158 notEqual *tmp215 false
   630 label *label161
   631 label *label159
   632 ubind *tmp9
 
   634 jump *label163 equal :rebindUnit.4:firstUnit null
   635 label *label165
   636 sensor *tmp219 @unit @controlled
-    * jump *label168 notEqual *tmp219 0
-    * jump *label158 always
+  637 jump *label158 equal *tmp219 0
   638 label *label168
   639 ubind *tmp9
   640 op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
 
   758 sensor *tmp279 @unit @controller
   759 op equal *tmp280 *tmp279 @this
   760 op land *tmp281 *tmp278 *tmp280
-    * jump *label200 equal *tmp281 false
-    * jump *label197 always
+  761 jump *label197 notEqual *tmp281 false
   762 label *label200
   763 label *label198
   764 ubind *tmp9
 
   766 jump *label202 equal :rebindUnit.5:firstUnit null
   767 label *label204
   768 sensor *tmp285 @unit @controlled
-    * jump *label207 notEqual *tmp285 0
-    * jump *label197 always
+  769 jump *label197 equal *tmp285 0
   770 label *label207
   771 ubind *tmp9
   772 op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
 
   914 sensor *tmp351 @unit @controller
   915 op equal *tmp352 *tmp351 @this
   916 op land *tmp353 *tmp350 *tmp352
-    * jump *label242 equal *tmp353 false
-    * jump *label239 always
+  917 jump *label239 notEqual *tmp353 false
   918 label *label242
   919 label *label240
   920 ubind *tmp9
 
   922 jump *label244 equal :rebindUnit.6:firstUnit null
   923 label *label246
   924 sensor *tmp357 @unit @controlled
-    * jump *label249 notEqual *tmp357 0
-    * jump *label239 always
+  925 jump *label239 equal *tmp357 0
   926 label *label249
   927 ubind *tmp9
   928 op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
 
  1046 sensor *tmp417 @unit @controller
  1047 op equal *tmp418 *tmp417 @this
  1048 op land *tmp419 *tmp416 *tmp418
-    * jump *label281 equal *tmp419 false
-    * jump *label278 always
+ 1049 jump *label278 notEqual *tmp419 false
  1050 label *label281
  1051 label *label279
  1052 ubind *tmp9
 
  1054 jump *label283 equal :rebindUnit.7:firstUnit null
  1055 label *label285
  1056 sensor *tmp423 @unit @controlled
-    * jump *label288 notEqual *tmp423 0
-    * jump *label278 always
+ 1057 jump *label278 equal *tmp423 0
  1058 label *label288
  1059 ubind *tmp9
  1060 op notEqual *tmp426 @unit :rebindUnit.7:firstUnit

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
    19 jump *label1 notEqual :locateCore*retval false
-    * label *label342
    20 set :locateCore:type @poly
    21 call *label0 :locateCore*retaddr :locateCore*retval
    22 jump *label1 notEqual :locateCore*retval false
-    * label *label348
    23 set :locateCore:type @mega
    24 call *label0 :locateCore*retaddr :locateCore*retval
    25 jump *label1 notEqual :locateCore*retval false
-    * label *label354
    26 set :locateCore:type @mono
    27 call *label0 :locateCore*retaddr :locateCore*retval
    28 jump *label1 notEqual :locateCore*retval false
-    * label *label360
    29 jump *label5 always
    30 label *label1
    31 sensor .CORE_X .CORE @x
 
   381 set .UNIT_S1 .UNIT_P1
   382 set .UNIT_P1 @unit
   383 jump *label80 notEqual .UNIT_S2 null
-    * label *label83
   384 label *label81
   385 ubind *tmp9
   386 op notEqual *tmp81 @unit :rebindUnits:firstUnit
 
   399 op equal *tmp92 *tmp91 @this
   400 op land *tmp93 *tmp90 *tmp92
   401 jump *label86 notEqual *tmp93 false
-    * label *label89
   402 label *label87
   403 ubind *tmp9
   404 set :rebindUnit:firstUnit @unit
 
   406 label *label93
   407 sensor *tmp97 @unit @controlled
   408 jump *label86 equal *tmp97 0
-    * label *label96
   409 ubind *tmp9
   410 op notEqual *tmp100 @unit :rebindUnit:firstUnit
   411 sensor *tmp101 :rebindUnit:firstUnit @dead
 
   428 op equal *tmp111 *tmp110 @this
   429 op land *tmp112 *tmp109 *tmp111
   430 jump *label99 notEqual *tmp112 false
-    * label *label102
   431 label *label100
   432 ubind *tmp9
   433 set :rebindUnit.1:firstUnit @unit
 
   435 label *label106
   436 sensor *tmp116 @unit @controlled
   437 jump *label99 equal *tmp116 0
-    * label *label109
   438 ubind *tmp9
   439 op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
   440 sensor *tmp120 :rebindUnit.1:firstUnit @dead
 
   484 op equal *tmp150 *tmp149 @this
   485 op land *tmp151 *tmp148 *tmp150
   486 jump *label120 notEqual *tmp151 false
-    * label *label123
   487 label *label121
   488 ubind *tmp9
   489 set :rebindUnit.2:firstUnit @unit
 
   491 label *label127
   492 sensor *tmp155 @unit @controlled
   493 jump *label120 equal *tmp155 0
-    * label *label130
   494 ubind *tmp9
   495 op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
   496 sensor *tmp159 :rebindUnit.2:firstUnit @dead
 
   513 op equal *tmp169 *tmp168 @this
   514 op land *tmp170 *tmp167 *tmp169
   515 jump *label133 notEqual *tmp170 false
-    * label *label136
   516 label *label134
   517 ubind *tmp9
   518 set :rebindUnit.3:firstUnit @unit
 
   520 label *label140
   521 sensor *tmp174 @unit @controlled
   522 jump *label133 equal *tmp174 0
-    * label *label143
   523 ubind *tmp9
   524 op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
   525 sensor *tmp178 :rebindUnit.3:firstUnit @dead
 
   614 op equal *tmp214 *tmp213 @this
   615 op land *tmp215 *tmp212 *tmp214
   616 jump *label158 notEqual *tmp215 false
-    * label *label161
   617 label *label159
   618 ubind *tmp9
   619 set :rebindUnit.4:firstUnit @unit
 
   621 label *label165
   622 sensor *tmp219 @unit @controlled
   623 jump *label158 equal *tmp219 0
-    * label *label168
   624 ubind *tmp9
   625 op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
   626 sensor *tmp223 :rebindUnit.4:firstUnit @dead
 
   744 op equal *tmp280 *tmp279 @this
   745 op land *tmp281 *tmp278 *tmp280
   746 jump *label197 notEqual *tmp281 false
-    * label *label200
   747 label *label198
   748 ubind *tmp9
   749 set :rebindUnit.5:firstUnit @unit
 
   751 label *label204
   752 sensor *tmp285 @unit @controlled
   753 jump *label197 equal *tmp285 0
-    * label *label207
   754 ubind *tmp9
   755 op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
   756 sensor *tmp289 :rebindUnit.5:firstUnit @dead
 
   898 op equal *tmp352 *tmp351 @this
   899 op land *tmp353 *tmp350 *tmp352
   900 jump *label239 notEqual *tmp353 false
-    * label *label242
   901 label *label240
   902 ubind *tmp9
   903 set :rebindUnit.6:firstUnit @unit
 
   905 label *label246
   906 sensor *tmp357 @unit @controlled
   907 jump *label239 equal *tmp357 0
-    * label *label249
   908 ubind *tmp9
   909 op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
   910 sensor *tmp361 :rebindUnit.6:firstUnit @dead
 
  1028 op equal *tmp418 *tmp417 @this
  1029 op land *tmp419 *tmp416 *tmp418
  1030 jump *label278 notEqual *tmp419 false
-    * label *label281
  1031 label *label279
  1032 ubind *tmp9
  1033 set :rebindUnit.7:firstUnit @unit
 
  1035 label *label285
  1036 sensor *tmp423 @unit @controlled
  1037 jump *label278 equal *tmp423 0
-    * label *label288
  1038 ubind *tmp9
  1039 op notEqual *tmp426 @unit :rebindUnit.7:firstUnit
  1040 sensor *tmp427 :rebindUnit.7:firstUnit @dead

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @flare
 
    73 op or *tmp26 *tmp23 *tmp25
    74 jump *label35 equal *tmp26 false
    75 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label37 lessThan :areUnitsAvailable:free *tmp21
+   76 jump *label36 lessThan :areUnitsAvailable:free *tmp21
    77 set *tmp10 true
    78 jump *label26 always
    79 label *label37
 
   133 op or *tmp58 *tmp55 *tmp57
   134 jump *label376 equal *tmp58 false
   135 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label374 lessThan :areUnitsAvailable.1:free *tmp53
+  136 jump *label377 lessThan :areUnitsAvailable.1:free *tmp53
   137 set *tmp42 true
   138 jump *label386 always
   139 label *label374
 
   195 op or *tmp58 *tmp55 *tmp57
   196 jump *label401 equal *tmp58 false
   197 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label399 lessThan :areUnitsAvailable.1:free *tmp53
+  198 jump *label402 lessThan :areUnitsAvailable.1:free *tmp53
   199 set *tmp42 true
   200 jump *label411 always
   201 label *label399
 
   257 op or *tmp58 *tmp55 *tmp57
   258 jump *label426 equal *tmp58 false
   259 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label424 lessThan :areUnitsAvailable.1:free *tmp53
+  260 jump *label427 lessThan :areUnitsAvailable.1:free *tmp53
   261 set *tmp42 true
   262 jump *label436 always
   263 label *label424
 
   319 op or *tmp58 *tmp55 *tmp57
   320 jump *label451 equal *tmp58 false
   321 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label449 lessThan :areUnitsAvailable.1:free *tmp53
+  322 jump *label452 lessThan :areUnitsAvailable.1:free *tmp53
   323 set *tmp42 true
   324 jump *label461 always
   325 label *label449
 
   403 label *label87
   404 ubind *tmp9
   405 set :rebindUnit:firstUnit @unit
-    * jump *label91 equal :rebindUnit:firstUnit null
+  406 jump __start__ equal :rebindUnit:firstUnit null
   407 label *label93
   408 sensor *tmp97 @unit @controlled
   409 jump *label86 equal *tmp97 0
 
   432 label *label100
   433 ubind *tmp9
   434 set :rebindUnit.1:firstUnit @unit
-    * jump *label104 equal :rebindUnit.1:firstUnit null
+  435 jump __start__ equal :rebindUnit.1:firstUnit null
   436 label *label106
   437 sensor *tmp116 @unit @controlled
   438 jump *label99 equal *tmp116 0
 
   488 label *label121
   489 ubind *tmp9
   490 set :rebindUnit.2:firstUnit @unit
-    * jump *label125 equal :rebindUnit.2:firstUnit null
+  491 jump __start__ equal :rebindUnit.2:firstUnit null
   492 label *label127
   493 sensor *tmp155 @unit @controlled
   494 jump *label120 equal *tmp155 0
 
   517 label *label134
   518 ubind *tmp9
   519 set :rebindUnit.3:firstUnit @unit
-    * jump *label138 equal :rebindUnit.3:firstUnit null
+  520 jump __start__ equal :rebindUnit.3:firstUnit null
   521 label *label140
   522 sensor *tmp174 @unit @controlled
   523 jump *label133 equal *tmp174 0
 
   577 op or .SUPPLY_P_FIRST *tmp193 *tmp201
   578 op add :unitCheck @time 5000
   579 sensor *tmp204 switch1 @enabled
-    * jump *label153 equal *tmp204 false
+  580 jump __start__ equal *tmp204 false
   581 label *label368
   582 set :start @time
   583 print " === [gold]Supplying Overdrive Dome[] === "
 
   618 label *label159
   619 ubind *tmp9
   620 set :rebindUnit.4:firstUnit @unit
-    * jump *label163 equal :rebindUnit.4:firstUnit null
+  621 jump __start__ equal :rebindUnit.4:firstUnit null
   622 label *label165
   623 sensor *tmp219 @unit @controlled
   624 jump *label158 equal *tmp219 0
 
   664 jump *label182 lessThan *tmp243 .UNIT_CAPACITY
   665 ucontrol approach .DOME_X .DOME_Y 6
   666 set :processUnit:state 3
-    * jump *label183 always
+  667 jump *label181 always
   668 label *label182
   669 set .MSG ", loading\n"
   670 label *label183
 
   693 set .MSG ", waiting\n"
   694 label *label189
   695 sensor *tmp258 @unit @totalItems
-    * jump *label190 greaterThan *tmp258 0
+  696 jump *label187 greaterThan *tmp258 0
   697 ucontrol approach .CORE_X .CORE_Y 6
   698 set :processUnit:state 2
   699 label *label190
 
   748 label *label198
   749 ubind *tmp9
   750 set :rebindUnit.5:firstUnit @unit
-    * jump *label202 equal :rebindUnit.5:firstUnit null
+  751 jump __start__ equal :rebindUnit.5:firstUnit null
   752 label *label204
   753 sensor *tmp285 @unit @controlled
   754 jump *label197 equal *tmp285 0
 
   794 jump *label221 lessThan *tmp309 .UNIT_CAPACITY
   795 ucontrol approach .DOME_X .DOME_Y 6
   796 set :processUnit.1:state 3
-    * jump *label222 always
+  797 jump *label220 always
   798 label *label221
   799 set .MSG ", loading\n"
   800 label *label222
 
   823 set .MSG ", waiting\n"
   824 label *label228
   825 sensor *tmp324 @unit @totalItems
-    * jump *label229 greaterThan *tmp324 0
+  826 jump *label226 greaterThan *tmp324 0
   827 ucontrol approach .CORE_X .CORE_Y 6
   828 set :processUnit.1:state 2
   829 label *label229
 
   902 label *label240
   903 ubind *tmp9
   904 set :rebindUnit.6:firstUnit @unit
-    * jump *label244 equal :rebindUnit.6:firstUnit null
+  905 jump __start__ equal :rebindUnit.6:firstUnit null
   906 label *label246
   907 sensor *tmp357 @unit @controlled
   908 jump *label239 equal *tmp357 0
 
   948 jump *label263 lessThan *tmp381 .UNIT_CAPACITY
   949 ucontrol approach .DOME_X .DOME_Y 6
   950 set :processUnit.2:state 3
-    * jump *label264 always
+  951 jump *label262 always
   952 label *label263
   953 set .MSG ", loading\n"
   954 label *label264
 
   977 set .MSG ", waiting\n"
   978 label *label270
   979 sensor *tmp396 @unit @totalItems
-    * jump *label271 greaterThan *tmp396 0
+  980 jump *label268 greaterThan *tmp396 0
   981 ucontrol approach .CORE_X .CORE_Y 6
   982 set :processUnit.2:state 2
   983 label *label271
 
  1032 label *label279
  1033 ubind *tmp9
  1034 set :rebindUnit.7:firstUnit @unit
-    * jump *label283 equal :rebindUnit.7:firstUnit null
+ 1035 jump __start__ equal :rebindUnit.7:firstUnit null
  1036 label *label285
  1037 sensor *tmp423 @unit @controlled
  1038 jump *label278 equal *tmp423 0
 
  1078 jump *label302 lessThan *tmp447 .UNIT_CAPACITY
  1079 ucontrol approach .DOME_X .DOME_Y 6
  1080 set :processUnit.3:state 3
-    * jump *label303 always
+ 1081 jump *label301 always
  1082 label *label302
  1083 set .MSG ", loading\n"
  1084 label *label303
 
  1107 set .MSG ", waiting\n"
  1108 label *label309
  1109 sensor *tmp462 @unit @totalItems
-    * jump *label310 greaterThan *tmp462 0
+ 1110 jump *label307 greaterThan *tmp462 0
  1111 ucontrol approach .CORE_X .CORE_Y 6
  1112 set :processUnit.3:state 2
  1113 label *label310
 
  1173 set :areUnitsAvailable.2:occupied 0
  1174 ubind UNIT_TYPE
  1175 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label319 equal :areUnitsAvailable.2:firstUnit null
+ 1176 jump *label331 equal :areUnitsAvailable.2:firstUnit null
  1177 # "Function: inline def needsFourUnits(in unit)"
  1178 set :needsFourUnits.3:unit @unit
  1179 sensor *tmp495 :needsFourUnits.3:unit @speed
 
  1188 op or *tmp503 *tmp500 *tmp502
  1189 jump *label327 equal *tmp503 false
  1190 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label329 lessThan :areUnitsAvailable.2:free *tmp498
+ 1191 jump *label328 lessThan :areUnitsAvailable.2:free *tmp498
  1192 set *tmp487 true
  1193 jump *label318 always
  1194 label *label329

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-19 instructions):
 
    76 jump *label36 lessThan :areUnitsAvailable:free *tmp21
    77 set *tmp10 true
    78 jump *label26 always
-    * label *label37
-    * jump *label36 always
    79 label *label35
    80 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    81 label *label36
 
   134 jump *label377 lessThan :areUnitsAvailable.1:free *tmp53
   135 set *tmp42 true
   136 jump *label386 always
-    * label *label374
-    * jump *label377 always
   137 label *label376
   138 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   139 label *label377
 
   194 jump *label402 lessThan :areUnitsAvailable.1:free *tmp53
   195 set *tmp42 true
   196 jump *label411 always
-    * label *label399
-    * jump *label402 always
   197 label *label401
   198 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   199 label *label402
 
   254 jump *label427 lessThan :areUnitsAvailable.1:free *tmp53
   255 set *tmp42 true
   256 jump *label436 always
-    * label *label424
-    * jump *label427 always
   257 label *label426
   258 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   259 label *label427
 
   314 jump *label452 lessThan :areUnitsAvailable.1:free *tmp53
   315 set *tmp42 true
   316 jump *label461 always
-    * label *label449
-    * jump *label452 always
   317 label *label451
   318 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   319 label *label452
 
   346 label *label464
   347 printflush message1
   348 jump *label23 always
-    * set *tmp9 null
   349 label *label22
   350 set .TYPE *tmp9
   351 print "[gold]Binding units..."
 
   402 op equal *tmp102 *tmp101 0
   403 op land *tmp103 *tmp100 *tmp102
   404 jump *label93 notEqual *tmp103 false
-    * label *label91
   405 end
   406 label *label86
   407 ucontrol flag 1
 
   430 op equal *tmp121 *tmp120 0
   431 op land *tmp122 *tmp119 *tmp121
   432 jump *label106 notEqual *tmp122 false
-    * label *label104
   433 end
   434 label *label99
   435 ucontrol flag 1
 
   485 op equal *tmp160 *tmp159 0
   486 op land *tmp161 *tmp158 *tmp160
   487 jump *label127 notEqual *tmp161 false
-    * label *label125
   488 end
   489 label *label120
   490 ucontrol flag 1
 
   513 op equal *tmp179 *tmp178 0
   514 op land *tmp180 *tmp177 *tmp179
   515 jump *label140 notEqual *tmp180 false
-    * label *label138
   516 end
   517 label *label133
   518 ucontrol flag 1
 
   613 op equal *tmp224 *tmp223 0
   614 op land *tmp225 *tmp222 *tmp224
   615 jump *label165 notEqual *tmp225 false
-    * label *label163
   616 end
   617 label *label158
   618 sensor :processUnit:state @unit @flag
 
   651 jump *label181 always
   652 label *label182
   653 set .MSG ", loading\n"
-    * label *label183
   654 jump *label181 always
   655 label *label180
   656 ucontrol approach .CORE_X .CORE_Y 6
 
   679 jump *label187 greaterThan *tmp258 0
   680 ucontrol approach .CORE_X .CORE_Y 6
   681 set :processUnit:state 2
-    * label *label190
   682 jump *label187 always
   683 label *label186
   684 ucontrol approach .DOME_X .DOME_Y 6
 
   740 op equal *tmp290 *tmp289 0
   741 op land *tmp291 *tmp288 *tmp290
   742 jump *label204 notEqual *tmp291 false
-    * label *label202
   743 end
   744 label *label197
   745 sensor :processUnit.1:state @unit @flag
 
   778 jump *label220 always
   779 label *label221
   780 set .MSG ", loading\n"
-    * label *label222
   781 jump *label220 always
   782 label *label219
   783 ucontrol approach .CORE_X .CORE_Y 6
 
   806 jump *label226 greaterThan *tmp324 0
   807 ucontrol approach .CORE_X .CORE_Y 6
   808 set :processUnit.1:state 2
-    * label *label229
   809 jump *label226 always
   810 label *label225
   811 ucontrol approach .DOME_X .DOME_Y 6
 
   891 op equal *tmp362 *tmp361 0
   892 op land *tmp363 *tmp360 *tmp362
   893 jump *label246 notEqual *tmp363 false
-    * label *label244
   894 end
   895 label *label239
   896 sensor :processUnit.2:state @unit @flag
 
   929 jump *label262 always
   930 label *label263
   931 set .MSG ", loading\n"
-    * label *label264
   932 jump *label262 always
   933 label *label261
   934 ucontrol approach .CORE_X .CORE_Y 6
 
   957 jump *label268 greaterThan *tmp396 0
   958 ucontrol approach .CORE_X .CORE_Y 6
   959 set :processUnit.2:state 2
-    * label *label271
   960 jump *label268 always
   961 label *label267
   962 ucontrol approach .DOME_X .DOME_Y 6
 
  1018 op equal *tmp428 *tmp427 0
  1019 op land *tmp429 *tmp426 *tmp428
  1020 jump *label285 notEqual *tmp429 false
-    * label *label283
  1021 end
  1022 label *label278
  1023 sensor :processUnit.3:state @unit @flag
 
  1056 jump *label301 always
  1057 label *label302
  1058 set .MSG ", loading\n"
-    * label *label303
  1059 jump *label301 always
  1060 label *label300
  1061 ucontrol approach .CORE_X .CORE_Y 6
 
  1084 jump *label307 greaterThan *tmp462 0
  1085 ucontrol approach .CORE_X .CORE_Y 6
  1086 set :processUnit.3:state 2
-    * label *label310
  1087 jump *label307 always
  1088 label *label306
  1089 ucontrol approach .DOME_X .DOME_Y 6
 
  1164 jump *label328 lessThan :areUnitsAvailable.2:free *tmp498
  1165 set *tmp487 true
  1166 jump *label318 always
-    * label *label329
-    * jump *label328 always
  1167 label *label327
  1168 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1169 label *label328
 
  1173 op equal *tmp510 *tmp509 0
  1174 op land *tmp511 *tmp508 *tmp510
  1175 jump *label324 notEqual *tmp511 false
-    * label *label319
  1176 jump *label331 always
-    * print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.2:free
-    * jump *label333 lessThanEq :areUnitsAvailable.2:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.2:needed
-    * label *label333
-    * print "\n"
  1177 label *label331
  1178 set *tmp487 false
  1179 label *label318
 
  1184 label *label316
  1185 sensor *tmp204 switch1 @enabled
  1186 jump *label368 notEqual *tmp204 false
-    * label *label153
  1187 end
  1188 label *label0
  1189 # "Function: noinline def locateCore(in type)"
 
  1198 label *label338
  1199 set :locateCore*retval .CORE
  1200 return :locateCore*retaddr
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1 (-3 instructions):
 
   347 printflush message1
   348 jump *label23 always
   349 label *label22
-    * set .TYPE *tmp9
   350 print "[gold]Binding units..."
   351 printflush message1
   352 # "Function: inline def rebindUnits()"
 
   456 op sub *tmp136 .DOME_Y .CORE_Y
   457 op len *tmp137 *tmp135 *tmp136
   458 op mul *tmp138 2 *tmp137
-    * sensor *tmp139 .UNIT_S1 @speed
   459 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   460 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
-    * set .FOUR_UNITS *tmp134
   461 jump *label117 equal *tmp134 false
   462 # "Function: inline def acquireUnit(in currentUnit)"
   463 # "Function: inline def rebindUnit(in currentUnit)"

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
  1170 op equal *tmp510 *tmp509 0
  1171 op land *tmp511 *tmp508 *tmp510
  1172 jump *label324 notEqual *tmp511 false
-    * jump *label331 always
  1173 label *label331
  1174 set *tmp487 false
  1175 label *label318

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-1 instructions):
 
    26 jump *label1 notEqual :locateCore*retval false
    27 set :locateCore:type @mono
    28 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label1 notEqual :locateCore*retval false
-    * jump *label5 always
+   29 jump *label5 equal :locateCore*retval false
    30 label *label1
    31 sensor .CORE_X .CORE @x
    32 sensor .CORE_Y .CORE @y

Modifications by Final phase, Print Merging, iteration 1 (-75 instructions):
 
    35 sensor *tmp7 switch1 @enabled
    36 jump *label21 notEqual *tmp7 false
    37 label *label367
-    * print "[coral]Activate switch to begin supplying overdrive dome..."
-    * print "\n"
+   38 print "[coral]Activate switch to begin supplying overdrive dome...\n"
    39 printflush message1
    40 sensor *tmp7 switch1 @enabled
    41 jump *label367 equal *tmp7 false
 
    43 # "Function: inline def chooseUnitType()"
    44 label *label23
    45 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   46 print "[gold]Looking for suitable unit type:[]\n"
    47 # "Function: inline def areUnitsAvailable(in type, in output)"
    48 set :areUnitsAvailable:free 0
    49 set :areUnitsAvailable:occupied 0
 
    84 jump *label32 notEqual *tmp34 false
    85 label *label27
    86 print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable:occupied
-    * print ","
-    * print " free: "
+   87 print ": occupied: {0}, free: "
+   88 format :areUnitsAvailable:occupied
    89 print :areUnitsAvailable:free
    90 jump *label41 lessThanEq :areUnitsAvailable:needed 0
    91 print ", needed: "
 
   138 op land *tmp66 *tmp63 *tmp65
   139 jump *label373 notEqual *tmp66 false
   140 label *label380
-    * print @flare
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  141 print "flare: occupied: {0}, free: "
+  142 format :areUnitsAvailable.1:occupied
   143 print :areUnitsAvailable.1:free
   144 jump *label382 lessThanEq :areUnitsAvailable.1:needed 0
   145 print ", needed: "
 
   194 op land *tmp66 *tmp63 *tmp65
   195 jump *label398 notEqual *tmp66 false
   196 label *label405
-    * print @poly
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  197 print "poly: occupied: {0}, free: "
+  198 format :areUnitsAvailable.1:occupied
   199 print :areUnitsAvailable.1:free
   200 jump *label407 lessThanEq :areUnitsAvailable.1:needed 0
   201 print ", needed: "
 
   250 op land *tmp66 *tmp63 *tmp65
   251 jump *label423 notEqual *tmp66 false
   252 label *label430
-    * print @mega
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  253 print "mega: occupied: {0}, free: "
+  254 format :areUnitsAvailable.1:occupied
   255 print :areUnitsAvailable.1:free
   256 jump *label432 lessThanEq :areUnitsAvailable.1:needed 0
   257 print ", needed: "
 
   306 op land *tmp66 *tmp63 *tmp65
   307 jump *label448 notEqual *tmp66 false
   308 label *label455
-    * print @mono
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  309 print "mono: occupied: {0}, free: "
+  310 format :areUnitsAvailable.1:occupied
   311 print :areUnitsAvailable.1:free
   312 jump *label457 lessThanEq :areUnitsAvailable.1:needed 0
   313 print ", needed: "
 
   540 jump __start__ equal *tmp204 false
   541 label *label368
   542 set :start @time
-    * print " === [gold]Supplying Overdrive Dome[] === "
-    * print "\n"
-    * print "\n"
-    * print "Unit type: [green]"
-    * print *tmp9
-    * print "["
-    * print "]"
-    * print "\n"
+  543 print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
+  544 format *tmp9
   545 # "Function: inline void printDomeStatus(in item, in text)"
-    * print "\n[green]Silicon[] status:\n"
   546 sensor :printDomeStatus:level .DOME @silicon
   547 jump *label155 lessThanEq :printDomeStatus:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  548 print "  dome:  [green]{0}[]\n"
+  549 format :printDomeStatus:level
   550 jump *label156 always
   551 label *label155
-    * print "  dome:  [coral]"
-    * print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  552 print "  dome:  [coral]{0}[]\n"
+  553 format :printDomeStatus:level
   554 label *label156
   555 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   556 # "Function: inline def rebindUnit(in currentUnit)"
 
   656 label *label184
   657 ucontrol flag :processUnit:state
   658 sensor *tmp268 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp268
-    * print "["
-    * print "]"
+  659 print "  {0}: [gold]{0}[]"
+  660 format .GROUP1
+  661 format *tmp268
   662 jump *label192 lessThan :processUnit:distance 0
   663 print .MSG
   664 print :processUnit:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  665 print "[] sec\n"
   666 jump *label193 always
   667 label *label192
   668 print .MSG
 
   775 label *label223
   776 ucontrol flag :processUnit.1:state
   777 sensor *tmp334 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp334
-    * print "["
-    * print "]"
+  778 print "  {0}: [gold]{0}[]"
+  779 format .GROUP2
+  780 format *tmp334
   781 jump *label231 lessThan :processUnit.1:distance 0
   782 print .MSG
   783 print :processUnit.1:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  784 print "[] sec\n"
   785 jump *label232 always
   786 label *label231
   787 print .MSG
 
   801 print "\n[green]Phase fabric[] status:\n"
   802 sensor :printDomeStatus.1:level .DOME @phase-fabric
   803 jump *label236 lessThanEq :printDomeStatus.1:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  804 print "  dome:  [green]{0}[]\n"
+  805 format :printDomeStatus.1:level
   806 jump *label237 always
   807 label *label236
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  808 print "  dome:  [coral]{0}[]\n"
+  809 format :printDomeStatus.1:level
   810 label *label237
   811 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   812 # "Function: inline def rebindUnit(in currentUnit)"
 
   912 label *label265
   913 ucontrol flag :processUnit.2:state
   914 sensor *tmp406 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp406
-    * print "["
-    * print "]"
+  915 print "  {0}: [gold]{0}[]"
+  916 format .GROUP1
+  917 format *tmp406
   918 jump *label273 lessThan :processUnit.2:distance 0
   919 print .MSG
   920 print :processUnit.2:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  921 print "[] sec\n"
   922 jump *label274 always
   923 label *label273
   924 print .MSG
 
  1031 label *label304
  1032 ucontrol flag :processUnit.3:state
  1033 sensor *tmp472 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp472
-    * print "["
-    * print "]"
+ 1034 print "  {0}: [gold]{0}[]"
+ 1035 format .GROUP2
+ 1036 format *tmp472
  1037 jump *label312 lessThan :processUnit.3:distance 0
  1038 print .MSG
  1039 print :processUnit.3:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1040 print "[] sec\n"
  1041 jump *label313 always
  1042 label *label312
  1043 print .MSG
 
  1055 label *label275
  1056 op sub *tmp481 @time :start
  1057 op floor *tmp482 *tmp481
-    * print "\n"
-    * print "[lightgray]Loop time: "
-    * print *tmp482
-    * print " "
-    * print "ms"
+ 1058 print "\n[lightgray]Loop time: {0} ms"
+ 1059 format *tmp482
  1060 printflush message1
  1061 op notEqual *tmp483 *tmp9 UNIT_TYPE
  1062 op greaterThan *tmp484 :unitCheck @time

Final code before resolving virtual instructions:

label __start__
remark "This is the preferred unit type to use for bringing in supplies."
remark "If no units of this type exist, we'll try using other types."
set UNIT_TYPE @flare
remark "Do not modify anything below this line."
# "Function: inline void locateDomeAndCore()"
set .DOME dome1
jump *label4 notEqual dome1 null
label *label340
print "[gold]Waiting for an overdrive dome to be connected..."
printflush message1
set .DOME dome1
jump *label340 equal dome1 null
label *label4
print "[gold]Locating core..."
printflush message1
set .CORE null
label *label5
set :locateCore:type @flare
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @poly
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @mega
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @mono
call *label0 :locateCore*retaddr :locateCore*retval
jump *label5 equal :locateCore*retval false
label *label1
sensor .CORE_X .CORE @x
sensor .CORE_Y .CORE @y
sensor .DOME_X .DOME @x
sensor .DOME_Y .DOME @y
sensor *tmp7 switch1 @enabled
jump *label21 notEqual *tmp7 false
label *label367
print "[coral]Activate switch to begin supplying overdrive dome...\n"
printflush message1
sensor *tmp7 switch1 @enabled
jump *label367 equal *tmp7 false
label *label21
# "Function: inline def chooseUnitType()"
label *label23
printflush null
print "[gold]Looking for suitable unit type:[]\n"
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable:free 0
set :areUnitsAvailable:occupied 0
set :areUnitsAvailable:needed 0
ubind UNIT_TYPE
set :areUnitsAvailable:firstUnit @unit
jump *label27 equal :areUnitsAvailable:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits:unit @unit
op sub *tmp14 .DOME_X .CORE_X
op sub *tmp15 .DOME_Y .CORE_Y
op len *tmp16 *tmp14 *tmp15
op mul *tmp17 2 *tmp16
sensor *tmp18 :needsFourUnits:unit @speed
op div :needsFourUnits:travel_time *tmp17 *tmp18
op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
select *tmp21 notEqual *tmp13 false 4 2
set :areUnitsAvailable:needed *tmp21
label *label32
sensor *tmp22 @unit @controlled
op equal *tmp23 *tmp22 0
sensor *tmp24 @unit @controller
op equal *tmp25 *tmp24 @this
op or *tmp26 *tmp23 *tmp25
jump *label35 equal *tmp26 false
op add :areUnitsAvailable:free :areUnitsAvailable:free 1
jump *label36 lessThan :areUnitsAvailable:free *tmp21
set *tmp10 true
jump *label26 always
label *label35
op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
label *label36
ubind UNIT_TYPE
op notEqual *tmp31 @unit :areUnitsAvailable:firstUnit
sensor *tmp32 :areUnitsAvailable:firstUnit @dead
op equal *tmp33 *tmp32 0
op land *tmp34 *tmp31 *tmp33
jump *label32 notEqual *tmp34 false
label *label27
print UNIT_TYPE
print ": occupied: {0}, free: "
format :areUnitsAvailable:occupied
print :areUnitsAvailable:free
jump *label41 lessThanEq :areUnitsAvailable:needed 0
print ", needed: "
print :areUnitsAvailable:needed
label *label41
print "\n"
set *tmp10 false
label *label26
jump *label43 equal *tmp10 false
set *tmp9 UNIT_TYPE
jump *label22 always
label *label43
jump *label389 equal @flare UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @flare
set :areUnitsAvailable.1:firstUnit @unit
jump *label380 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp46 .DOME_X .CORE_X
op sub *tmp47 .DOME_Y .CORE_Y
op len *tmp48 *tmp46 *tmp47
op mul *tmp49 2 *tmp48
sensor *tmp50 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp49 *tmp50
op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
select *tmp53 notEqual *tmp45 false 4 2
set :areUnitsAvailable.1:needed *tmp53
label *label373
sensor *tmp54 @unit @controlled
op equal *tmp55 *tmp54 0
sensor *tmp56 @unit @controller
op equal *tmp57 *tmp56 @this
op or *tmp58 *tmp55 *tmp57
jump *label376 equal *tmp58 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label377 lessThan :areUnitsAvailable.1:free *tmp53
set *tmp42 true
jump *label386 always
label *label376
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label377
ubind @flare
op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp65 *tmp64 0
op land *tmp66 *tmp63 *tmp65
jump *label373 notEqual *tmp66 false
label *label380
print "flare: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label382 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label382
print "\n"
set *tmp42 false
label *label386
jump *label387 equal *tmp42 false
printflush null
set *tmp9 @flare
jump *label22 always
label *label387
label *label389
jump *label414 equal @poly UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @poly
set :areUnitsAvailable.1:firstUnit @unit
jump *label405 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp46 .DOME_X .CORE_X
op sub *tmp47 .DOME_Y .CORE_Y
op len *tmp48 *tmp46 *tmp47
op mul *tmp49 2 *tmp48
sensor *tmp50 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp49 *tmp50
op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
select *tmp53 notEqual *tmp45 false 4 2
set :areUnitsAvailable.1:needed *tmp53
label *label398
sensor *tmp54 @unit @controlled
op equal *tmp55 *tmp54 0
sensor *tmp56 @unit @controller
op equal *tmp57 *tmp56 @this
op or *tmp58 *tmp55 *tmp57
jump *label401 equal *tmp58 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label402 lessThan :areUnitsAvailable.1:free *tmp53
set *tmp42 true
jump *label411 always
label *label401
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label402
ubind @poly
op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp65 *tmp64 0
op land *tmp66 *tmp63 *tmp65
jump *label398 notEqual *tmp66 false
label *label405
print "poly: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label407 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label407
print "\n"
set *tmp42 false
label *label411
jump *label412 equal *tmp42 false
printflush null
set *tmp9 @poly
jump *label22 always
label *label412
label *label414
jump *label439 equal @mega UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mega
set :areUnitsAvailable.1:firstUnit @unit
jump *label430 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp46 .DOME_X .CORE_X
op sub *tmp47 .DOME_Y .CORE_Y
op len *tmp48 *tmp46 *tmp47
op mul *tmp49 2 *tmp48
sensor *tmp50 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp49 *tmp50
op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
select *tmp53 notEqual *tmp45 false 4 2
set :areUnitsAvailable.1:needed *tmp53
label *label423
sensor *tmp54 @unit @controlled
op equal *tmp55 *tmp54 0
sensor *tmp56 @unit @controller
op equal *tmp57 *tmp56 @this
op or *tmp58 *tmp55 *tmp57
jump *label426 equal *tmp58 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label427 lessThan :areUnitsAvailable.1:free *tmp53
set *tmp42 true
jump *label436 always
label *label426
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label427
ubind @mega
op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp65 *tmp64 0
op land *tmp66 *tmp63 *tmp65
jump *label423 notEqual *tmp66 false
label *label430
print "mega: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label432 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label432
print "\n"
set *tmp42 false
label *label436
jump *label437 equal *tmp42 false
printflush null
set *tmp9 @mega
jump *label22 always
label *label437
label *label439
jump *label464 equal @mono UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mono
set :areUnitsAvailable.1:firstUnit @unit
jump *label455 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp46 .DOME_X .CORE_X
op sub *tmp47 .DOME_Y .CORE_Y
op len *tmp48 *tmp46 *tmp47
op mul *tmp49 2 *tmp48
sensor *tmp50 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp49 *tmp50
op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
select *tmp53 notEqual *tmp45 false 4 2
set :areUnitsAvailable.1:needed *tmp53
label *label448
sensor *tmp54 @unit @controlled
op equal *tmp55 *tmp54 0
sensor *tmp56 @unit @controller
op equal *tmp57 *tmp56 @this
op or *tmp58 *tmp55 *tmp57
jump *label451 equal *tmp58 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label452 lessThan :areUnitsAvailable.1:free *tmp53
set *tmp42 true
jump *label461 always
label *label451
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label452
ubind @mono
op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp65 *tmp64 0
op land *tmp66 *tmp63 *tmp65
jump *label448 notEqual *tmp66 false
label *label455
print "mono: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label457 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label457
print "\n"
set *tmp42 false
label *label461
jump *label462 equal *tmp42 false
printflush null
set *tmp9 @mono
jump *label22 always
label *label462
label *label464
printflush message1
jump *label23 always
label *label22
print "[gold]Binding units..."
printflush message1
# "Function: inline def rebindUnits()"
set .UNIT_P2 null
set .UNIT_S2 null
set .UNIT_P1 null
set .UNIT_S1 null
set :rebindUnits:count 0
ubind *tmp9
set :rebindUnits:firstUnit @unit
jump *label76 notEqual :rebindUnits:firstUnit null
end
label *label76
label *label78
sensor *tmp74 @unit @controller
jump *label81 notEqual *tmp74 @this
op add :rebindUnits:count :rebindUnits:count 1
ucontrol flag 1
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 .UNIT_P1
set .UNIT_P1 @unit
jump *label80 notEqual .UNIT_S2 null
label *label81
ubind *tmp9
op notEqual *tmp81 @unit :rebindUnits:firstUnit
sensor *tmp82 :rebindUnits:firstUnit @dead
op equal *tmp83 *tmp82 0
op land *tmp84 *tmp81 *tmp83
jump *label78 notEqual *tmp84 false
label *label80
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label87 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp89 @unit @dead
op equal *tmp90 *tmp89 0
sensor *tmp91 @unit @controller
op equal *tmp92 *tmp91 @this
op land *tmp93 *tmp90 *tmp92
jump *label86 notEqual *tmp93 false
label *label87
ubind *tmp9
set :rebindUnit:firstUnit @unit
jump __start__ equal :rebindUnit:firstUnit null
label *label93
sensor *tmp97 @unit @controlled
jump *label86 equal *tmp97 0
ubind *tmp9
op notEqual *tmp100 @unit :rebindUnit:firstUnit
sensor *tmp101 :rebindUnit:firstUnit @dead
op equal *tmp102 *tmp101 0
op land *tmp103 *tmp100 *tmp102
jump *label93 notEqual *tmp103 false
end
label *label86
ucontrol flag 1
set *tmp85 @unit
set .UNIT_S1 *tmp85
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label100 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp108 @unit @dead
op equal *tmp109 *tmp108 0
sensor *tmp110 @unit @controller
op equal *tmp111 *tmp110 @this
op land *tmp112 *tmp109 *tmp111
jump *label99 notEqual *tmp112 false
label *label100
ubind *tmp9
set :rebindUnit.1:firstUnit @unit
jump __start__ equal :rebindUnit.1:firstUnit null
label *label106
sensor *tmp116 @unit @controlled
jump *label99 equal *tmp116 0
ubind *tmp9
op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
sensor *tmp120 :rebindUnit.1:firstUnit @dead
op equal *tmp121 *tmp120 0
op land *tmp122 *tmp119 *tmp121
jump *label106 notEqual *tmp122 false
end
label *label99
ucontrol flag 1
set *tmp104 @unit
set .UNIT_P1 *tmp104
sensor *tmp123 *tmp85 @firstItem
op equal *tmp124 *tmp123 @phase-fabric
sensor *tmp125 *tmp104 @firstItem
op equal *tmp126 *tmp125 @silicon
op or *tmp127 *tmp124 *tmp126
jump *label111 equal *tmp127 false
# "Function: inline void swap(in out a, in out b)"
set .UNIT_S1 *tmp104
set .UNIT_P1 *tmp85
label *label111
sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
sensor .SPEED .UNIT_S1 @speed
op div .SPEED_TENTHS .SPEED 10
op strictEqual *tmp132 .SPEED null
jump *label114 equal *tmp132 false
stop
label *label114
# "Function: inline def needsFourUnits(in unit)"
op sub *tmp135 .DOME_X .CORE_X
op sub *tmp136 .DOME_Y .CORE_Y
op len *tmp137 *tmp135 *tmp136
op mul *tmp138 2 *tmp137
op div :needsFourUnits.2:travel_time *tmp138 .SPEED
op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
jump *label117 equal *tmp134 false
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label121 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp147 @unit @dead
op equal *tmp148 *tmp147 0
sensor *tmp149 @unit @controller
op equal *tmp150 *tmp149 @this
op land *tmp151 *tmp148 *tmp150
jump *label120 notEqual *tmp151 false
label *label121
ubind *tmp9
set :rebindUnit.2:firstUnit @unit
jump __start__ equal :rebindUnit.2:firstUnit null
label *label127
sensor *tmp155 @unit @controlled
jump *label120 equal *tmp155 0
ubind *tmp9
op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
sensor *tmp159 :rebindUnit.2:firstUnit @dead
op equal *tmp160 *tmp159 0
op land *tmp161 *tmp158 *tmp160
jump *label127 notEqual *tmp161 false
end
label *label120
ucontrol flag 1
set *tmp143 @unit
set .UNIT_S2 *tmp143
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label134 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp166 @unit @dead
op equal *tmp167 *tmp166 0
sensor *tmp168 @unit @controller
op equal *tmp169 *tmp168 @this
op land *tmp170 *tmp167 *tmp169
jump *label133 notEqual *tmp170 false
label *label134
ubind *tmp9
set :rebindUnit.3:firstUnit @unit
jump __start__ equal :rebindUnit.3:firstUnit null
label *label140
sensor *tmp174 @unit @controlled
jump *label133 equal *tmp174 0
ubind *tmp9
op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
sensor *tmp178 :rebindUnit.3:firstUnit @dead
op equal *tmp179 *tmp178 0
op land *tmp180 *tmp177 *tmp179
jump *label140 notEqual *tmp180 false
end
label *label133
ucontrol flag 1
set *tmp162 @unit
set .UNIT_P2 *tmp162
sensor *tmp181 .UNIT_S1 @firstItem
op equal *tmp182 *tmp181 @phase-fabric
sensor *tmp183 *tmp162 @firstItem
op notEqual *tmp184 *tmp183 @phase-fabric
op land *tmp185 *tmp182 *tmp184
jump *label145 equal *tmp185 false
# "Function: inline void swap(in out a, in out b)"
set :swap.1:t .UNIT_S1
set .UNIT_S1 *tmp162
set .UNIT_P2 :swap.1:t
label *label145
sensor *tmp187 *tmp143 @firstItem
op equal *tmp188 *tmp187 @phase-fabric
sensor *tmp189 .UNIT_P2 @firstItem
op equal *tmp190 *tmp189 @silicon
op or *tmp191 *tmp188 *tmp190
jump *label148 equal *tmp191 false
# "Function: inline void swap(in out a, in out b)"
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 *tmp143
label *label148
set .GROUP1 "unit  1"
set .GROUP2 "unit 2"
jump *label118 always
label *label117
ubind .UNIT_S2
ucontrol unbind
set .UNIT_S2 null
ubind .UNIT_P2
ucontrol unbind
set .UNIT_P2 null
set .GROUP1 "unit"
label *label118
op equal *tmp193 *tmp134 false
sensor *tmp194 .UNIT_S1 @totalItems
sensor *tmp195 .UNIT_S2 @totalItems
op lessThan *tmp196 *tmp194 *tmp195
op or .SUPPLY_S_FIRST *tmp193 *tmp196
sensor *tmp199 .UNIT_P1 @totalItems
sensor *tmp200 .UNIT_P2 @totalItems
op lessThan *tmp201 *tmp199 *tmp200
op or .SUPPLY_P_FIRST *tmp193 *tmp201
op add :unitCheck @time 5000
sensor *tmp204 switch1 @enabled
jump __start__ equal *tmp204 false
label *label368
set :start @time
print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
format *tmp9
# "Function: inline void printDomeStatus(in item, in text)"
sensor :printDomeStatus:level .DOME @silicon
jump *label155 lessThanEq :printDomeStatus:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus:level
jump *label156 always
label *label155
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus:level
label *label156
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label159 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp211 @unit @dead
op equal *tmp212 *tmp211 0
sensor *tmp213 @unit @controller
op equal *tmp214 *tmp213 @this
op land *tmp215 *tmp212 *tmp214
jump *label158 notEqual *tmp215 false
label *label159
ubind *tmp9
set :rebindUnit.4:firstUnit @unit
jump __start__ equal :rebindUnit.4:firstUnit null
label *label165
sensor *tmp219 @unit @controlled
jump *label158 equal *tmp219 0
ubind *tmp9
op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
sensor *tmp223 :rebindUnit.4:firstUnit @dead
op equal *tmp224 *tmp223 0
op land *tmp225 *tmp222 *tmp224
jump *label165 notEqual *tmp225 false
end
label *label158
sensor :processUnit:state @unit @flag
set :processUnit:distance -1
op lessThan *tmp227 :processUnit:state 2
op greaterThan *tmp228 :processUnit:state 3
op or *tmp229 *tmp227 *tmp228
jump *label170 equal *tmp229 false
sensor *tmp231 @unit @firstItem
jump *label172 notEqual *tmp231 @silicon
set :processUnit:state 3
jump *label173 always
label *label172
sensor *tmp234 @unit @totalItems
jump *label174 notEqual *tmp234 0
set :processUnit:state 2
jump *label175 always
label *label174
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp237
jump *label176 equal *tmp237 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label176
label *label175
label *label173
label *label170
jump *label178 notEqual :processUnit:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp241
jump *label180 equal *tmp241 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp243 @unit @totalItems
jump *label182 lessThan *tmp243 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit:state 3
jump *label181 always
label *label182
set .MSG ", loading\n"
jump *label181 always
label *label180
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp246 @unit @x
op sub *tmp247 .CORE_X *tmp246
sensor *tmp248 @unit @y
op sub *tmp249 .CORE_Y *tmp248
op len *tmp250 *tmp247 *tmp249
op idiv *tmp251 *tmp250 .SPEED_TENTHS
op div :processUnit:distance *tmp251 10
label *label181
label *label178
jump *label184 notEqual :processUnit:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp255
jump *label186 equal *tmp255 false
jump *label188 equal .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label189 always
label *label188
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label189
sensor *tmp258 @unit @totalItems
jump *label187 greaterThan *tmp258 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit:state 2
jump *label187 always
label *label186
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp261 @unit @x
op sub *tmp262 .DOME_X *tmp261
sensor *tmp263 @unit @y
op sub *tmp264 .DOME_Y *tmp263
op len *tmp265 *tmp262 *tmp264
op idiv *tmp266 *tmp265 .SPEED_TENTHS
op div :processUnit:distance *tmp266 10
label *label187
label *label184
ucontrol flag :processUnit:state
sensor *tmp268 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp268
jump *label192 lessThan :processUnit:distance 0
print .MSG
print :processUnit:distance
print "[] sec\n"
jump *label193 always
label *label192
print .MSG
label *label193
set :processUnit:unit @unit
set .UNIT_S1 :processUnit:unit
jump *label194 equal *tmp134 false
op equal *tmp273 .SUPPLY_S_FIRST false
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label198 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp277 @unit @dead
op equal *tmp278 *tmp277 0
sensor *tmp279 @unit @controller
op equal *tmp280 *tmp279 @this
op land *tmp281 *tmp278 *tmp280
jump *label197 notEqual *tmp281 false
label *label198
ubind *tmp9
set :rebindUnit.5:firstUnit @unit
jump __start__ equal :rebindUnit.5:firstUnit null
label *label204
sensor *tmp285 @unit @controlled
jump *label197 equal *tmp285 0
ubind *tmp9
op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
sensor *tmp289 :rebindUnit.5:firstUnit @dead
op equal *tmp290 *tmp289 0
op land *tmp291 *tmp288 *tmp290
jump *label204 notEqual *tmp291 false
end
label *label197
sensor :processUnit.1:state @unit @flag
set :processUnit.1:distance -1
op lessThan *tmp293 :processUnit.1:state 2
op greaterThan *tmp294 :processUnit.1:state 3
op or *tmp295 *tmp293 *tmp294
jump *label209 equal *tmp295 false
sensor *tmp297 @unit @firstItem
jump *label211 notEqual *tmp297 @silicon
set :processUnit.1:state 3
jump *label212 always
label *label211
sensor *tmp300 @unit @totalItems
jump *label213 notEqual *tmp300 0
set :processUnit.1:state 2
jump *label214 always
label *label213
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp303
jump *label215 equal *tmp303 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label215
label *label214
label *label212
label *label209
jump *label217 notEqual :processUnit.1:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp307
jump *label219 equal *tmp307 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp309 @unit @totalItems
jump *label221 lessThan *tmp309 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:state 3
jump *label220 always
label *label221
set .MSG ", loading\n"
jump *label220 always
label *label219
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp312 @unit @x
op sub *tmp313 .CORE_X *tmp312
sensor *tmp314 @unit @y
op sub *tmp315 .CORE_Y *tmp314
op len *tmp316 *tmp313 *tmp315
op idiv *tmp317 *tmp316 .SPEED_TENTHS
op div :processUnit.1:distance *tmp317 10
label *label220
label *label217
jump *label223 notEqual :processUnit.1:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp321
jump *label225 equal *tmp321 false
jump *label227 equal *tmp273 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label228 always
label *label227
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label228
sensor *tmp324 @unit @totalItems
jump *label226 greaterThan *tmp324 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:state 2
jump *label226 always
label *label225
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp327 @unit @x
op sub *tmp328 .DOME_X *tmp327
sensor *tmp329 @unit @y
op sub *tmp330 .DOME_Y *tmp329
op len *tmp331 *tmp328 *tmp330
op idiv *tmp332 *tmp331 .SPEED_TENTHS
op div :processUnit.1:distance *tmp332 10
label *label226
label *label223
ucontrol flag :processUnit.1:state
sensor *tmp334 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp334
jump *label231 lessThan :processUnit.1:distance 0
print .MSG
print :processUnit.1:distance
print "[] sec\n"
jump *label232 always
label *label231
print .MSG
label *label232
set :processUnit.1:unit @unit
set .UNIT_S2 :processUnit.1:unit
jump *label233 equal .SUPPLY_S_FIRST false
sensor *tmp339 :processUnit:unit @totalItems
op greaterThan .SUPPLY_S_FIRST *tmp339 0
jump *label234 always
label *label233
sensor *tmp341 :processUnit.1:unit @totalItems
op equal .SUPPLY_S_FIRST *tmp341 0
label *label234
label *label194
# "Function: inline void printDomeStatus(in item, in text)"
print "\n[green]Phase fabric[] status:\n"
sensor :printDomeStatus.1:level .DOME @phase-fabric
jump *label236 lessThanEq :printDomeStatus.1:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.1:level
jump *label237 always
label *label236
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.1:level
label *label237
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label240 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp349 @unit @dead
op equal *tmp350 *tmp349 0
sensor *tmp351 @unit @controller
op equal *tmp352 *tmp351 @this
op land *tmp353 *tmp350 *tmp352
jump *label239 notEqual *tmp353 false
label *label240
ubind *tmp9
set :rebindUnit.6:firstUnit @unit
jump __start__ equal :rebindUnit.6:firstUnit null
label *label246
sensor *tmp357 @unit @controlled
jump *label239 equal *tmp357 0
ubind *tmp9
op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
sensor *tmp361 :rebindUnit.6:firstUnit @dead
op equal *tmp362 *tmp361 0
op land *tmp363 *tmp360 *tmp362
jump *label246 notEqual *tmp363 false
end
label *label239
sensor :processUnit.2:state @unit @flag
set :processUnit.2:distance -1
op lessThan *tmp365 :processUnit.2:state 2
op greaterThan *tmp366 :processUnit.2:state 3
op or *tmp367 *tmp365 *tmp366
jump *label251 equal *tmp367 false
sensor *tmp369 @unit @firstItem
jump *label253 notEqual *tmp369 @phase-fabric
set :processUnit.2:state 3
jump *label254 always
label *label253
sensor *tmp372 @unit @totalItems
jump *label255 notEqual *tmp372 0
set :processUnit.2:state 2
jump *label256 always
label *label255
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp375
jump *label257 equal *tmp375 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label257
label *label256
label *label254
label *label251
jump *label259 notEqual :processUnit.2:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp379
jump *label261 equal *tmp379 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp381 @unit @totalItems
jump *label263 lessThan *tmp381 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:state 3
jump *label262 always
label *label263
set .MSG ", loading\n"
jump *label262 always
label *label261
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp384 @unit @x
op sub *tmp385 .CORE_X *tmp384
sensor *tmp386 @unit @y
op sub *tmp387 .CORE_Y *tmp386
op len *tmp388 *tmp385 *tmp387
op idiv *tmp389 *tmp388 .SPEED_TENTHS
op div :processUnit.2:distance *tmp389 10
label *label262
label *label259
jump *label265 notEqual :processUnit.2:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp393
jump *label267 equal *tmp393 false
jump *label269 equal .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label270 always
label *label269
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label270
sensor *tmp396 @unit @totalItems
jump *label268 greaterThan *tmp396 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:state 2
jump *label268 always
label *label267
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp399 @unit @x
op sub *tmp400 .DOME_X *tmp399
sensor *tmp401 @unit @y
op sub *tmp402 .DOME_Y *tmp401
op len *tmp403 *tmp400 *tmp402
op idiv *tmp404 *tmp403 .SPEED_TENTHS
op div :processUnit.2:distance *tmp404 10
label *label268
label *label265
ucontrol flag :processUnit.2:state
sensor *tmp406 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp406
jump *label273 lessThan :processUnit.2:distance 0
print .MSG
print :processUnit.2:distance
print "[] sec\n"
jump *label274 always
label *label273
print .MSG
label *label274
set :processUnit.2:unit @unit
set .UNIT_P1 :processUnit.2:unit
jump *label275 equal *tmp134 false
op equal *tmp411 .SUPPLY_P_FIRST false
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label279 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp415 @unit @dead
op equal *tmp416 *tmp415 0
sensor *tmp417 @unit @controller
op equal *tmp418 *tmp417 @this
op land *tmp419 *tmp416 *tmp418
jump *label278 notEqual *tmp419 false
label *label279
ubind *tmp9
set :rebindUnit.7:firstUnit @unit
jump __start__ equal :rebindUnit.7:firstUnit null
label *label285
sensor *tmp423 @unit @controlled
jump *label278 equal *tmp423 0
ubind *tmp9
op notEqual *tmp426 @unit :rebindUnit.7:firstUnit
sensor *tmp427 :rebindUnit.7:firstUnit @dead
op equal *tmp428 *tmp427 0
op land *tmp429 *tmp426 *tmp428
jump *label285 notEqual *tmp429 false
end
label *label278
sensor :processUnit.3:state @unit @flag
set :processUnit.3:distance -1
op lessThan *tmp431 :processUnit.3:state 2
op greaterThan *tmp432 :processUnit.3:state 3
op or *tmp433 *tmp431 *tmp432
jump *label290 equal *tmp433 false
sensor *tmp435 @unit @firstItem
jump *label292 notEqual *tmp435 @phase-fabric
set :processUnit.3:state 3
jump *label293 always
label *label292
sensor *tmp438 @unit @totalItems
jump *label294 notEqual *tmp438 0
set :processUnit.3:state 2
jump *label295 always
label *label294
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp441
jump *label296 equal *tmp441 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label296
label *label295
label *label293
label *label290
jump *label298 notEqual :processUnit.3:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp445
jump *label300 equal *tmp445 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp447 @unit @totalItems
jump *label302 lessThan *tmp447 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:state 3
jump *label301 always
label *label302
set .MSG ", loading\n"
jump *label301 always
label *label300
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp450 @unit @x
op sub *tmp451 .CORE_X *tmp450
sensor *tmp452 @unit @y
op sub *tmp453 .CORE_Y *tmp452
op len *tmp454 *tmp451 *tmp453
op idiv *tmp455 *tmp454 .SPEED_TENTHS
op div :processUnit.3:distance *tmp455 10
label *label301
label *label298
jump *label304 notEqual :processUnit.3:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp459
jump *label306 equal *tmp459 false
jump *label308 equal *tmp411 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label309 always
label *label308
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label309
sensor *tmp462 @unit @totalItems
jump *label307 greaterThan *tmp462 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:state 2
jump *label307 always
label *label306
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp465 @unit @x
op sub *tmp466 .DOME_X *tmp465
sensor *tmp467 @unit @y
op sub *tmp468 .DOME_Y *tmp467
op len *tmp469 *tmp466 *tmp468
op idiv *tmp470 *tmp469 .SPEED_TENTHS
op div :processUnit.3:distance *tmp470 10
label *label307
label *label304
ucontrol flag :processUnit.3:state
sensor *tmp472 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp472
jump *label312 lessThan :processUnit.3:distance 0
print .MSG
print :processUnit.3:distance
print "[] sec\n"
jump *label313 always
label *label312
print .MSG
label *label313
set :processUnit.3:unit @unit
set .UNIT_P2 :processUnit.3:unit
jump *label314 equal .SUPPLY_P_FIRST false
sensor *tmp477 :processUnit.2:unit @totalItems
op greaterThan .SUPPLY_P_FIRST *tmp477 0
jump *label315 always
label *label314
sensor *tmp479 :processUnit.3:unit @totalItems
op equal .SUPPLY_P_FIRST *tmp479 0
label *label315
label *label275
op sub *tmp481 @time :start
op floor *tmp482 *tmp481
print "\n[lightgray]Loop time: {0} ms"
format *tmp482
printflush message1
op notEqual *tmp483 *tmp9 UNIT_TYPE
op greaterThan *tmp484 :unitCheck @time
op land *tmp485 *tmp483 *tmp484
jump *label316 equal *tmp485 false
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.2:free 0
set :areUnitsAvailable.2:occupied 0
ubind UNIT_TYPE
set :areUnitsAvailable.2:firstUnit @unit
jump *label331 equal :areUnitsAvailable.2:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.3:unit @unit
sensor *tmp495 :needsFourUnits.3:unit @speed
op div :needsFourUnits.3:travel_time *tmp138 *tmp495
op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
select *tmp498 notEqual *tmp490 false 4 2
label *label324
sensor *tmp499 @unit @controlled
op equal *tmp500 *tmp499 0
sensor *tmp501 @unit @controller
op equal *tmp502 *tmp501 @this
op or *tmp503 *tmp500 *tmp502
jump *label327 equal *tmp503 false
op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
jump *label328 lessThan :areUnitsAvailable.2:free *tmp498
set *tmp487 true
jump *label318 always
label *label327
op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
label *label328
ubind UNIT_TYPE
op notEqual *tmp508 @unit :areUnitsAvailable.2:firstUnit
sensor *tmp509 :areUnitsAvailable.2:firstUnit @dead
op equal *tmp510 *tmp509 0
op land *tmp511 *tmp508 *tmp510
jump *label324 notEqual *tmp511 false
label *label331
set *tmp487 false
label *label318
jump *label335 equal *tmp487 false
end
label *label335
op add :unitCheck @time 5000
label *label316
sensor *tmp204 switch1 @enabled
jump *label368 notEqual *tmp204 false
end
label *label0
# "Function: noinline def locateCore(in type)"
ubind :locateCore:type
sensor *tmp517 @unit @controlled
op equal *tmp518 *tmp517 0
sensor *tmp519 @unit @controller
op equal *tmp520 *tmp519 @this
op or *tmp521 *tmp518 *tmp520
jump *label338 equal *tmp521 false
ulocate building core false @copper 0 0 0 .CORE
label *label338
set :locateCore*retval .CORE
return :locateCore*retaddr
