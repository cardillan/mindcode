  1480 instructions before optimizations.
    41 instructions eliminated by Temp Variables Elimination (2 passes, 6 iterations).
   259 instructions eliminated by Dead Code Elimination (2 passes, 9 iterations).
     7 instructions eliminated by Jump Normalization (2 passes, 6 iterations).
   121 instructions eliminated by Jump Optimization (6 iterations).
   103 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
    13 instructions eliminated by If Expression Optimization (4 iterations).
    84 instructions eliminated by Data Flow Optimization (4 passes, 16 iterations).
     2 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
   149 instructions added by Loop Unrolling (7 iterations).
     2 loops unrolled by Loop Unrolling.
    46 instructions eliminated by Jump Straightening (3 passes, 6 iterations).
    33 instructions updated by Jump Threading.
    19 instructions eliminated by Unreachable Code Elimination (3 iterations).
    75 instructions eliminated by Print Merging.
   863 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 236):
    Replicate loop condition at line 54:5                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000
  * Unroll iteration loop at line 169:9                          size    +5, benefit      375.0, efficiency     75.000 (+3 instructions)
    Unroll iteration loop at line 201:9                          size  +185, benefit      375.0, efficiency      2.027

Pass 1: speed optimization selection (cost limit 233):
  * Replicate loop condition at line 54:5                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000
    Unroll iteration loop at line 201:9                          size  +185, benefit      375.0, efficiency      2.027

Pass 1: speed optimization selection (cost limit 232):
  * Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Unroll iteration loop at line 201:9                          size  +185, benefit      375.0, efficiency      2.027

Pass 1: speed optimization selection (cost limit 231):
  * Unroll iteration loop at line 201:9                          size  +185, benefit      375.0, efficiency      2.027 (+138 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-173 instructions):
 
    36 call *label0 :locateCore*retaddr :locateCore*retval
    37 jump *label15 equal :locateCore*retval false
    38 jump *label1 always
-    * set *tmp2 null
    39 jump *label16 always
    40 label *label15
-    * set *tmp2 null
    41 label *label16
    42 label *label9
    43 multijump *tmp1 0 0 (m:marker0)
 
   122 label *label39
   123 set *tmp28 null
   124 label *label40
-    * set *tmp26 *tmp28
   125 jump *label36 always
   126 label *label35
   127 set *tmp29 :areUnitsAvailable:occupied
   128 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
-    * set *tmp26 *tmp29
   129 label *label36
   130 ubind :areUnitsAvailable:type
   131 label *label33
 
   137 jump *label34 equal *tmp32 false
   138 jump *label32 always
   139 label *label34
-    * set *tmp12 null
   140 jump *label28 always
   141 label *label27
-    * set *tmp12 null
   142 label *label28
   143 jump *label42 equal :areUnitsAvailable:output false
   144 print :areUnitsAvailable:type
 
   152 jump *label44 equal *tmp34 false
   153 print ", needed: "
   154 print :areUnitsAvailable:needed
-    * set *tmp35 null
   155 jump *label45 always
   156 label *label44
-    * set *tmp35 null
   157 label *label45
   158 print "\n"
-    * set *tmp33 null
   159 jump *label43 always
   160 label *label42
-    * set *tmp33 null
   161 label *label43
   162 set *tmp10 false
   163 jump *label26 always
 
   166 jump *label24 equal *tmp10 false
   167 set *tmp9 UNIT_TYPE
   168 jump *label20 always
-    * set *tmp36 null
   169 jump *label25 always
   170 label *label24
-    * set *tmp36 null
   171 label *label25
   172 set :chooseUnitType:type @flare
   173 op add *tmp37 @counter 1
 
   237 label *label70
   238 set *tmp58 null
   239 label *label71
-    * set *tmp56 *tmp58
   240 jump *label67 always
   241 label *label66
   242 set *tmp59 :areUnitsAvailable.1:occupied
   243 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp56 *tmp59
   244 label *label67
   245 ubind :areUnitsAvailable.1:type
   246 label *label64
 
   252 jump *label65 equal *tmp62 false
   253 jump *label63 always
   254 label *label65
-    * set *tmp42 null
   255 jump *label59 always
   256 label *label58
-    * set *tmp42 null
   257 label *label59
   258 jump *label73 equal :areUnitsAvailable.1:output false
   259 print :areUnitsAvailable.1:type
 
   267 jump *label75 equal *tmp64 false
   268 print ", needed: "
   269 print :areUnitsAvailable.1:needed
-    * set *tmp65 null
   270 jump *label76 always
   271 label *label75
-    * set *tmp65 null
   272 label *label76
   273 print "\n"
-    * set *tmp63 null
   274 jump *label74 always
   275 label *label73
-    * set *tmp63 null
   276 label *label74
   277 set *tmp40 false
   278 jump *label57 always
 
   287 label *label55
   288 set *tmp66 null
   289 label *label56
-    * set *tmp39 *tmp66
   290 jump *label54 always
   291 label *label53
-    * set *tmp39 null
   292 label *label54
   293 label *label47
   294 multijump *tmp37 0 0 (m:marker1)
 
   314 op equal *tmp68 :rebindUnits:firstUnit null
   315 jump *label78 equal *tmp68 false
   316 end
-    * set *tmp69 null
   317 jump *label79 always
   318 label *label78
-    * set *tmp69 null
   319 label *label79
   320 label *label80
   321 sensor *tmp70 @unit @controller
   322 op equal *tmp71 *tmp70 @this
   323 jump *label83 equal *tmp71 false
-    * set *tmp73 :rebindUnits:count
   324 op add :rebindUnits:count :rebindUnits:count 1
   325 ucontrol flag 1
   326 set .UNIT_S2 .UNIT_P2
 
   336 label *label85
   337 set *tmp76 null
   338 label *label86
-    * set *tmp72 *tmp76
   339 jump *label84 always
   340 label *label83
-    * set *tmp72 null
   341 label *label84
   342 ubind .TYPE
   343 label *label81
 
   349 jump *label82 equal *tmp79 false
   350 jump *label80 always
   351 label *label82
-    * set *tmp67 :rebindUnits:count
   352 jump *label77 always
-    * set *tmp67 null
   353 label *label77
   354 # "Function: inline def acquireUnit(in currentUnit)"
   355 set :acquireUnit:currentUnit .UNIT_S1
 
   364 op equal *tmp87 *tmp86 @this
   365 op land *tmp88 *tmp85 *tmp87
   366 jump *label92 equal *tmp88 false
-    * set *tmp81 :rebindUnit:currentUnit
   367 jump *label89 always
   368 set *tmp89 null
   369 jump *label93 always
   370 label *label92
   371 set *tmp89 null
   372 label *label93
-    * set *tmp83 *tmp89
   373 jump *label91 always
   374 label *label90
-    * set *tmp83 null
   375 label *label91
   376 ubind .TYPE
   377 set :rebindUnit:firstUnit @unit
 
   381 sensor *tmp92 @unit @controlled
   382 op equal *tmp93 *tmp92 0
   383 jump *label99 equal *tmp93 false
-    * set *tmp81 @unit
   384 jump *label89 always
-    * set *tmp94 null
   385 jump *label100 always
   386 label *label99
-    * set *tmp94 null
   387 label *label100
   388 ubind .TYPE
   389 label *label97
 
   395 jump *label98 equal *tmp97 false
   396 jump *label96 always
   397 label *label98
-    * set *tmp91 null
   398 jump *label95 always
   399 label *label94
-    * set *tmp91 null
   400 label *label95
   401 end
-    * set *tmp81 null
   402 label *label89
   403 ucontrol flag 1
   404 set *tmp80 @unit
 
   419 op equal *tmp105 *tmp104 @this
   420 op land *tmp106 *tmp103 *tmp105
   421 jump *label106 equal *tmp106 false
-    * set *tmp99 :rebindUnit.1:currentUnit
   422 jump *label103 always
   423 set *tmp107 null
   424 jump *label107 always
   425 label *label106
   426 set *tmp107 null
   427 label *label107
-    * set *tmp101 *tmp107
   428 jump *label105 always
   429 label *label104
-    * set *tmp101 null
   430 label *label105
   431 ubind .TYPE
   432 set :rebindUnit.1:firstUnit @unit
 
   436 sensor *tmp110 @unit @controlled
   437 op equal *tmp111 *tmp110 0
   438 jump *label113 equal *tmp111 false
-    * set *tmp99 @unit
   439 jump *label103 always
-    * set *tmp112 null
   440 jump *label114 always
   441 label *label113
-    * set *tmp112 null
   442 label *label114
   443 ubind .TYPE
   444 label *label111
 
   450 jump *label112 equal *tmp115 false
   451 jump *label110 always
   452 label *label112
-    * set *tmp109 null
   453 jump *label109 always
   454 label *label108
-    * set *tmp109 null
   455 label *label109
   456 end
-    * set *tmp99 null
   457 label *label103
   458 ucontrol flag 1
   459 set *tmp98 @unit
 
   479 label *label120
   480 set .UNIT_S1 :swap:a
   481 set .UNIT_P1 :swap:b
-    * set *tmp120 null
   482 jump *label117 always
   483 label *label116
-    * set *tmp120 null
   484 label *label117
   485 sensor *tmp121 .UNIT_S1 @itemCapacity
   486 set .UNIT_CAPACITY *tmp121
 
   491 op strictEqual *tmp124 .SPEED null
   492 jump *label121 equal *tmp124 false
   493 stop
-    * set *tmp125 null
   494 jump *label122 always
   495 label *label121
-    * set *tmp125 null
   496 label *label122
   497 # "Function: inline def needsFourUnits(in unit)"
   498 set :needsFourUnits.2:unit .UNIT_S1
 
   523 op equal *tmp142 *tmp141 @this
   524 op land *tmp143 *tmp140 *tmp142
   525 jump *label130 equal *tmp143 false
-    * set *tmp136 :rebindUnit.2:currentUnit
   526 jump *label127 always
   527 set *tmp144 null
   528 jump *label131 always
   529 label *label130
   530 set *tmp144 null
   531 label *label131
-    * set *tmp138 *tmp144
   532 jump *label129 always
   533 label *label128
-    * set *tmp138 null
   534 label *label129
   535 ubind .TYPE
   536 set :rebindUnit.2:firstUnit @unit
 
   540 sensor *tmp147 @unit @controlled
   541 op equal *tmp148 *tmp147 0
   542 jump *label137 equal *tmp148 false
-    * set *tmp136 @unit
   543 jump *label127 always
-    * set *tmp149 null
   544 jump *label138 always
   545 label *label137
-    * set *tmp149 null
   546 label *label138
   547 ubind .TYPE
   548 label *label135
 
   554 jump *label136 equal *tmp152 false
   555 jump *label134 always
   556 label *label136
-    * set *tmp146 null
   557 jump *label133 always
   558 label *label132
-    * set *tmp146 null
   559 label *label133
   560 end
-    * set *tmp136 null
   561 label *label127
   562 ucontrol flag 1
   563 set *tmp135 @unit
 
   578 op equal *tmp160 *tmp159 @this
   579 op land *tmp161 *tmp158 *tmp160
   580 jump *label144 equal *tmp161 false
-    * set *tmp154 :rebindUnit.3:currentUnit
   581 jump *label141 always
   582 set *tmp162 null
   583 jump *label145 always
   584 label *label144
   585 set *tmp162 null
   586 label *label145
-    * set *tmp156 *tmp162
   587 jump *label143 always
   588 label *label142
-    * set *tmp156 null
   589 label *label143
   590 ubind .TYPE
   591 set :rebindUnit.3:firstUnit @unit
 
   595 sensor *tmp165 @unit @controlled
   596 op equal *tmp166 *tmp165 0
   597 jump *label151 equal *tmp166 false
-    * set *tmp154 @unit
   598 jump *label141 always
-    * set *tmp167 null
   599 jump *label152 always
   600 label *label151
-    * set *tmp167 null
   601 label *label152
   602 ubind .TYPE
   603 label *label149
 
   609 jump *label150 equal *tmp170 false
   610 jump *label148 always
   611 label *label150
-    * set *tmp164 null
   612 jump *label147 always
   613 label *label146
-    * set *tmp164 null
   614 label *label147
   615 end
-    * set *tmp154 null
   616 label *label141
   617 ucontrol flag 1
   618 set *tmp153 @unit
 
   638 label *label158
   639 set .UNIT_S1 :swap.1:a
   640 set .UNIT_P2 :swap.1:b
-    * set *tmp175 null
   641 jump *label155 always
   642 label *label154
-    * set *tmp175 null
   643 label *label155
   644 sensor *tmp176 .UNIT_S2 @firstItem
   645 op equal *tmp177 *tmp176 @phase-fabric
 
   659 label *label163
   660 set .UNIT_S2 :swap.2:a
   661 set .UNIT_P2 :swap.2:b
-    * set *tmp180 null
   662 jump *label160 always
   663 label *label159
-    * set *tmp180 null
   664 label *label160
   665 set .GROUP1 "unit  1"
   666 set .GROUP2 "unit 2"
-    * set *tmp134 .GROUP2
   667 jump *label125 always
   668 label *label124
   669 ubind .UNIT_S2
 
   673 ucontrol unbind
   674 set .UNIT_P2 null
   675 set .GROUP1 "unit"
-    * set *tmp134 .GROUP1
   676 label *label125
   677 op equal *tmp181 .FOUR_UNITS false
   678 jump *label166 notEqual *tmp181 false
 
   731 print "["
   732 print "]"
   733 print "\n"
-    * set *tmp195 null
   734 jump *label177 always
   735 label *label176
   736 print "  dome:  [coral]"
 
   738 print "["
   739 print "]"
   740 print "\n"
-    * set *tmp195 null
   741 label *label177
   742 label *label175
   743 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
 
   756 op equal *tmp202 *tmp201 @this
   757 op land *tmp203 *tmp200 *tmp202
   758 jump *label182 equal *tmp203 false
-    * set *tmp196 :rebindUnit.4:currentUnit
   759 jump *label179 always
   760 set *tmp204 null
   761 jump *label183 always
   762 label *label182
   763 set *tmp204 null
   764 label *label183
-    * set *tmp198 *tmp204
   765 jump *label181 always
   766 label *label180
-    * set *tmp198 null
   767 label *label181
   768 ubind .TYPE
   769 set :rebindUnit.4:firstUnit @unit
 
   773 sensor *tmp207 @unit @controlled
   774 op equal *tmp208 *tmp207 0
   775 jump *label189 equal *tmp208 false
-    * set *tmp196 @unit
   776 jump *label179 always
-    * set *tmp209 null
   777 jump *label190 always
   778 label *label189
-    * set *tmp209 null
   779 label *label190
   780 ubind .TYPE
   781 label *label187
 
   787 jump *label188 equal *tmp212 false
   788 jump *label186 always
   789 label *label188
-    * set *tmp206 null
   790 jump *label185 always
   791 label *label184
-    * set *tmp206 null
   792 label *label185
   793 end
-    * set *tmp196 null
   794 label *label179
   795 sensor *tmp213 @unit @flag
   796 set :processUnit:state *tmp213
 
   831 label *label199
   832 set *tmp219 *tmp222
   833 label *label197
-    * set *tmp216 *tmp219
   834 jump *label193 always
   835 label *label192
-    * set *tmp216 null
   836 label *label193
   837 op equal *tmp225 :processUnit:state 2
   838 jump *label202 equal *tmp225 false
 
   865 set :processUnit:distance *tmp238
   866 set *tmp228 :processUnit:distance
   867 label *label205
-    * set *tmp226 *tmp228
   868 jump *label203 always
   869 label *label202
-    * set *tmp226 null
   870 label *label203
   871 op equal *tmp239 :processUnit:state 3
   872 jump *label208 equal *tmp239 false
 
   875 jump *label212 equal :processUnit:supply false
   876 ucontrol itemDrop .DOME .UNIT_CAPACITY
   877 set .MSG ", supplying\n"
-    * set *tmp243 .MSG
   878 jump *label213 always
   879 label *label212
   880 ucontrol approach .DOME_X .DOME_Y 6
   881 set .MSG ", waiting\n"
-    * set *tmp243 .MSG
   882 label *label213
   883 sensor *tmp244 @unit @totalItems
   884 op lessThanEq *tmp245 *tmp244 0
 
   905 set :processUnit:distance *tmp253
   906 set *tmp242 :processUnit:distance
   907 label *label211
-    * set *tmp240 *tmp242
   908 jump *label209 always
   909 label *label208
-    * set *tmp240 null
   910 label *label209
   911 ucontrol flag :processUnit:state
   912 sensor *tmp254 @unit @totalItems
 
   926 print "["
   927 print "] sec"
   928 print "\n"
-    * set *tmp256 null
   929 jump *label217 always
   930 label *label216
   931 print .MSG
-    * set *tmp256 .MSG
   932 label *label217
   933 set *tmp257 @unit
   934 set :processUnit:unit *tmp257
 
   952 op equal *tmp266 *tmp265 @this
   953 op land *tmp267 *tmp264 *tmp266
   954 jump *label224 equal *tmp267 false
-    * set *tmp260 :rebindUnit.5:currentUnit
   955 jump *label221 always
   956 set *tmp268 null
   957 jump *label225 always
   958 label *label224
   959 set *tmp268 null
   960 label *label225
-    * set *tmp262 *tmp268
   961 jump *label223 always
   962 label *label222
-    * set *tmp262 null
   963 label *label223
   964 ubind .TYPE
   965 set :rebindUnit.5:firstUnit @unit
 
   969 sensor *tmp271 @unit @controlled
   970 op equal *tmp272 *tmp271 0
   971 jump *label231 equal *tmp272 false
-    * set *tmp260 @unit
   972 jump *label221 always
-    * set *tmp273 null
   973 jump *label232 always
   974 label *label231
-    * set *tmp273 null
   975 label *label232
   976 ubind .TYPE
   977 label *label229
 
   983 jump *label230 equal *tmp276 false
   984 jump *label228 always
   985 label *label230
-    * set *tmp270 null
   986 jump *label227 always
   987 label *label226
-    * set *tmp270 null
   988 label *label227
   989 end
-    * set *tmp260 null
   990 label *label221
   991 sensor *tmp277 @unit @flag
   992 set :processUnit.1:state *tmp277
 
  1027 label *label241
  1028 set *tmp283 *tmp286
  1029 label *label239
-    * set *tmp280 *tmp283
  1030 jump *label235 always
  1031 label *label234
-    * set *tmp280 null
  1032 label *label235
  1033 op equal *tmp289 :processUnit.1:state 2
  1034 jump *label244 equal *tmp289 false
 
  1061 set :processUnit.1:distance *tmp302
  1062 set *tmp292 :processUnit.1:distance
  1063 label *label247
-    * set *tmp290 *tmp292
  1064 jump *label245 always
  1065 label *label244
-    * set *tmp290 null
  1066 label *label245
  1067 op equal *tmp303 :processUnit.1:state 3
  1068 jump *label250 equal *tmp303 false
 
  1071 jump *label254 equal :processUnit.1:supply false
  1072 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1073 set .MSG ", supplying\n"
-    * set *tmp307 .MSG
  1074 jump *label255 always
  1075 label *label254
  1076 ucontrol approach .DOME_X .DOME_Y 6
  1077 set .MSG ", waiting\n"
-    * set *tmp307 .MSG
  1078 label *label255
  1079 sensor *tmp308 @unit @totalItems
  1080 op lessThanEq *tmp309 *tmp308 0
 
  1101 set :processUnit.1:distance *tmp317
  1102 set *tmp306 :processUnit.1:distance
  1103 label *label253
-    * set *tmp304 *tmp306
  1104 jump *label251 always
  1105 label *label250
-    * set *tmp304 null
  1106 label *label251
  1107 ucontrol flag :processUnit.1:state
  1108 sensor *tmp318 @unit @totalItems
 
  1122 print "["
  1123 print "] sec"
  1124 print "\n"
-    * set *tmp320 null
  1125 jump *label259 always
  1126 label *label258
  1127 print .MSG
-    * set *tmp320 .MSG
  1128 label *label259
  1129 set *tmp321 @unit
  1130 set :processUnit.1:unit *tmp321
 
  1141 set *tmp322 *tmp326
  1142 label *label261
  1143 set .SUPPLY_S_FIRST *tmp322
-    * set *tmp258 .SUPPLY_S_FIRST
  1144 jump *label219 always
  1145 label *label218
-    * set *tmp258 null
  1146 label *label219
  1147 # "Function: inline void printDomeStatus(in item, in text)"
  1148 set :printDomeStatus.1:item @phase-fabric
 
  1157 print "["
  1158 print "]"
  1159 print "\n"
-    * set *tmp329 null
  1160 jump *label264 always
  1161 label *label263
  1162 print "  dome:  [coral]"
 
  1164 print "["
  1165 print "]"
  1166 print "\n"
-    * set *tmp329 null
  1167 label *label264
  1168 label *label262
  1169 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
 
  1182 op equal *tmp336 *tmp335 @this
  1183 op land *tmp337 *tmp334 *tmp336
  1184 jump *label269 equal *tmp337 false
-    * set *tmp330 :rebindUnit.6:currentUnit
  1185 jump *label266 always
  1186 set *tmp338 null
  1187 jump *label270 always
  1188 label *label269
  1189 set *tmp338 null
  1190 label *label270
-    * set *tmp332 *tmp338
  1191 jump *label268 always
  1192 label *label267
-    * set *tmp332 null
  1193 label *label268
  1194 ubind .TYPE
  1195 set :rebindUnit.6:firstUnit @unit
 
  1199 sensor *tmp341 @unit @controlled
  1200 op equal *tmp342 *tmp341 0
  1201 jump *label276 equal *tmp342 false
-    * set *tmp330 @unit
  1202 jump *label266 always
-    * set *tmp343 null
  1203 jump *label277 always
  1204 label *label276
-    * set *tmp343 null
  1205 label *label277
  1206 ubind .TYPE
  1207 label *label274
 
  1213 jump *label275 equal *tmp346 false
  1214 jump *label273 always
  1215 label *label275
-    * set *tmp340 null
  1216 jump *label272 always
  1217 label *label271
-    * set *tmp340 null
  1218 label *label272
  1219 end
-    * set *tmp330 null
  1220 label *label266
  1221 sensor *tmp347 @unit @flag
  1222 set :processUnit.2:state *tmp347
 
  1257 label *label286
  1258 set *tmp353 *tmp356
  1259 label *label284
-    * set *tmp350 *tmp353
  1260 jump *label280 always
  1261 label *label279
-    * set *tmp350 null
  1262 label *label280
  1263 op equal *tmp359 :processUnit.2:state 2
  1264 jump *label289 equal *tmp359 false
 
  1291 set :processUnit.2:distance *tmp372
  1292 set *tmp362 :processUnit.2:distance
  1293 label *label292
-    * set *tmp360 *tmp362
  1294 jump *label290 always
  1295 label *label289
-    * set *tmp360 null
  1296 label *label290
  1297 op equal *tmp373 :processUnit.2:state 3
  1298 jump *label295 equal *tmp373 false
 
  1301 jump *label299 equal :processUnit.2:supply false
  1302 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1303 set .MSG ", supplying\n"
-    * set *tmp377 .MSG
  1304 jump *label300 always
  1305 label *label299
  1306 ucontrol approach .DOME_X .DOME_Y 6
  1307 set .MSG ", waiting\n"
-    * set *tmp377 .MSG
  1308 label *label300
  1309 sensor *tmp378 @unit @totalItems
  1310 op lessThanEq *tmp379 *tmp378 0
 
  1331 set :processUnit.2:distance *tmp387
  1332 set *tmp376 :processUnit.2:distance
  1333 label *label298
-    * set *tmp374 *tmp376
  1334 jump *label296 always
  1335 label *label295
-    * set *tmp374 null
  1336 label *label296
  1337 ucontrol flag :processUnit.2:state
  1338 sensor *tmp388 @unit @totalItems
 
  1352 print "["
  1353 print "] sec"
  1354 print "\n"
-    * set *tmp390 null
  1355 jump *label304 always
  1356 label *label303
  1357 print .MSG
-    * set *tmp390 .MSG
  1358 label *label304
  1359 set *tmp391 @unit
  1360 set :processUnit.2:unit *tmp391
 
  1378 op equal *tmp400 *tmp399 @this
  1379 op land *tmp401 *tmp398 *tmp400
  1380 jump *label311 equal *tmp401 false
-    * set *tmp394 :rebindUnit.7:currentUnit
  1381 jump *label308 always
  1382 set *tmp402 null
  1383 jump *label312 always
  1384 label *label311
  1385 set *tmp402 null
  1386 label *label312
-    * set *tmp396 *tmp402
  1387 jump *label310 always
  1388 label *label309
-    * set *tmp396 null
  1389 label *label310
  1390 ubind .TYPE
  1391 set :rebindUnit.7:firstUnit @unit
 
  1395 sensor *tmp405 @unit @controlled
  1396 op equal *tmp406 *tmp405 0
  1397 jump *label318 equal *tmp406 false
-    * set *tmp394 @unit
  1398 jump *label308 always
-    * set *tmp407 null
  1399 jump *label319 always
  1400 label *label318
-    * set *tmp407 null
  1401 label *label319
  1402 ubind .TYPE
  1403 label *label316
 
  1409 jump *label317 equal *tmp410 false
  1410 jump *label315 always
  1411 label *label317
-    * set *tmp404 null
  1412 jump *label314 always
  1413 label *label313
-    * set *tmp404 null
  1414 label *label314
  1415 end
-    * set *tmp394 null
  1416 label *label308
  1417 sensor *tmp411 @unit @flag
  1418 set :processUnit.3:state *tmp411
 
  1453 label *label328
  1454 set *tmp417 *tmp420
  1455 label *label326
-    * set *tmp414 *tmp417
  1456 jump *label322 always
  1457 label *label321
-    * set *tmp414 null
  1458 label *label322
  1459 op equal *tmp423 :processUnit.3:state 2
  1460 jump *label331 equal *tmp423 false
 
  1487 set :processUnit.3:distance *tmp436
  1488 set *tmp426 :processUnit.3:distance
  1489 label *label334
-    * set *tmp424 *tmp426
  1490 jump *label332 always
  1491 label *label331
-    * set *tmp424 null
  1492 label *label332
  1493 op equal *tmp437 :processUnit.3:state 3
  1494 jump *label337 equal *tmp437 false
 
  1497 jump *label341 equal :processUnit.3:supply false
  1498 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1499 set .MSG ", supplying\n"
-    * set *tmp441 .MSG
  1500 jump *label342 always
  1501 label *label341
  1502 ucontrol approach .DOME_X .DOME_Y 6
  1503 set .MSG ", waiting\n"
-    * set *tmp441 .MSG
  1504 label *label342
  1505 sensor *tmp442 @unit @totalItems
  1506 op lessThanEq *tmp443 *tmp442 0
 
  1527 set :processUnit.3:distance *tmp451
  1528 set *tmp440 :processUnit.3:distance
  1529 label *label340
-    * set *tmp438 *tmp440
  1530 jump *label338 always
  1531 label *label337
-    * set *tmp438 null
  1532 label *label338
  1533 ucontrol flag :processUnit.3:state
  1534 sensor *tmp452 @unit @totalItems
 
  1548 print "["
  1549 print "] sec"
  1550 print "\n"
-    * set *tmp454 null
  1551 jump *label346 always
  1552 label *label345
  1553 print .MSG
-    * set *tmp454 .MSG
  1554 label *label346
  1555 set *tmp455 @unit
  1556 set :processUnit.3:unit *tmp455
 
  1567 set *tmp456 *tmp460
  1568 label *label348
  1569 set .SUPPLY_P_FIRST *tmp456
-    * set *tmp392 .SUPPLY_P_FIRST
  1570 jump *label306 always
  1571 label *label305
-    * set *tmp392 null
  1572 label *label306
  1573 op sub *tmp461 @time :start
  1574 op floor *tmp462 *tmp461
 
  1636 label *label368
  1637 set *tmp484 null
  1638 label *label369
-    * set *tmp482 *tmp484
  1639 jump *label365 always
  1640 label *label364
  1641 set *tmp485 :areUnitsAvailable.2:occupied
  1642 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp482 *tmp485
  1643 label *label365
  1644 ubind :areUnitsAvailable.2:type
  1645 label *label362
 
  1651 jump *label363 equal *tmp488 false
  1652 jump *label361 always
  1653 label *label363
-    * set *tmp468 null
  1654 jump *label357 always
  1655 label *label356
-    * set *tmp468 null
  1656 label *label357
  1657 jump *label371 equal :areUnitsAvailable.2:output false
  1658 print :areUnitsAvailable.2:type
 
  1666 jump *label373 equal *tmp490 false
  1667 print ", needed: "
  1668 print :areUnitsAvailable.2:needed
-    * set *tmp491 null
  1669 jump *label374 always
  1670 label *label373
-    * set *tmp491 null
  1671 label *label374
  1672 print "\n"
-    * set *tmp489 null
  1673 jump *label372 always
  1674 label *label371
-    * set *tmp489 null
  1675 label *label372
  1676 set *tmp466 false
  1677 jump *label355 always
 
  1679 label *label355
  1680 jump *label353 equal *tmp466 false
  1681 end
-    * set *tmp492 null
  1682 jump *label354 always
  1683 label *label353
-    * set *tmp492 null
  1684 label *label354
  1685 op add *tmp493 @time 5000
  1686 set :unitCheck *tmp493
-    * set *tmp465 :unitCheck
  1687 jump *label350 always
  1688 label *label349
-    * set *tmp465 null
  1689 label *label350
  1690 label *label173
  1691 jump *label172 always
 
  1705 label *label378
  1706 ulocate building core false @copper *tmp500 *tmp501 *tmp502 *tmp499
  1707 set .CORE *tmp499
-    * set *tmp498 .CORE
  1708 jump *label377 always
  1709 label *label376
-    * set *tmp498 null
  1710 label *label377
  1711 set :locateCore*retval .CORE
  1712 label *label375

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-53 instructions):
 
   117 jump *label39 equal *tmp27 false
   118 set *tmp10 true
   119 jump *label26 always
-    * set *tmp28 null
   120 jump *label40 always
   121 label *label39
-    * set *tmp28 null
   122 label *label40
   123 jump *label36 always
   124 label *label35
-    * set *tmp29 :areUnitsAvailable:occupied
   125 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   126 label *label36
   127 ubind :areUnitsAvailable:type
 
   229 jump *label70 equal *tmp57 false
   230 set *tmp40 true
   231 jump *label57 always
-    * set *tmp58 null
   232 jump *label71 always
   233 label *label70
-    * set *tmp58 null
   234 label *label71
   235 jump *label67 always
   236 label *label66
-    * set *tmp59 :areUnitsAvailable.1:occupied
   237 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   238 label *label67
   239 ubind :areUnitsAvailable.1:type
 
   276 printflush null
   277 set *tmp9 :chooseUnitType:type
   278 jump *label20 always
-    * set *tmp66 null
   279 jump *label56 always
   280 label *label55
-    * set *tmp66 null
   281 label *label56
   282 jump *label54 always
   283 label *label53
 
   323 op notEqual *tmp75 .UNIT_S2 null
   324 jump *label85 equal *tmp75 false
   325 jump *label82 always
-    * set *tmp76 null
   326 jump *label86 always
   327 label *label85
-    * set *tmp76 null
   328 label *label86
   329 jump *label84 always
   330 label *label83
 
   355 op land *tmp88 *tmp85 *tmp87
   356 jump *label92 equal *tmp88 false
   357 jump *label89 always
-    * set *tmp89 null
   358 jump *label93 always
   359 label *label92
-    * set *tmp89 null
   360 label *label93
   361 jump *label91 always
   362 label *label90
 
   408 op land *tmp106 *tmp103 *tmp105
   409 jump *label106 equal *tmp106 false
   410 jump *label103 always
-    * set *tmp107 null
   411 jump *label107 always
   412 label *label106
-    * set *tmp107 null
   413 label *label107
   414 jump *label105 always
   415 label *label104
 
   510 op land *tmp143 *tmp140 *tmp142
   511 jump *label130 equal *tmp143 false
   512 jump *label127 always
-    * set *tmp144 null
   513 jump *label131 always
   514 label *label130
-    * set *tmp144 null
   515 label *label131
   516 jump *label129 always
   517 label *label128
 
   563 op land *tmp161 *tmp158 *tmp160
   564 jump *label144 equal *tmp161 false
   565 jump *label141 always
-    * set *tmp162 null
   566 jump *label145 always
   567 label *label144
-    * set *tmp162 null
   568 label *label145
   569 jump *label143 always
   570 label *label142
 
   739 op land *tmp203 *tmp200 *tmp202
   740 jump *label182 equal *tmp203 false
   741 jump *label179 always
-    * set *tmp204 null
   742 jump *label183 always
   743 label *label182
-    * set *tmp204 null
   744 label *label183
   745 jump *label181 always
   746 label *label180
 
   787 op equal *tmp218 *tmp217 :processUnit:item
   788 jump *label196 equal *tmp218 false
   789 set :processUnit:state 3
-    * set *tmp219 :processUnit:state
   790 jump *label197 always
   791 label *label196
   792 sensor *tmp220 @unit @totalItems
 
   808 label *label201
   809 set *tmp222 *tmp224
   810 label *label199
-    * set *tmp219 *tmp222
   811 label *label197
   812 jump *label193 always
   813 label *label192
 
   828 set .MSG ", loading\n"
   829 set *tmp231 .MSG
   830 label *label207
-    * set *tmp228 *tmp231
   831 jump *label205 always
   832 label *label204
   833 ucontrol approach .CORE_X .CORE_Y 6
 
   840 op idiv *tmp237 *tmp236 .SPEED_TENTHS
   841 op div *tmp238 *tmp237 10
   842 set :processUnit:distance *tmp238
-    * set *tmp228 :processUnit:distance
   843 label *label205
   844 jump *label203 always
   845 label *label202
 
   866 label *label214
   867 set *tmp246 null
   868 label *label215
-    * set *tmp242 *tmp246
   869 jump *label211 always
   870 label *label210
   871 ucontrol approach .DOME_X .DOME_Y 6
 
   878 op idiv *tmp252 *tmp251 .SPEED_TENTHS
   879 op div *tmp253 *tmp252 10
   880 set :processUnit:distance *tmp253
-    * set *tmp242 :processUnit:distance
   881 label *label211
   882 jump *label209 always
   883 label *label208
 
   927 op land *tmp267 *tmp264 *tmp266
   928 jump *label224 equal *tmp267 false
   929 jump *label221 always
-    * set *tmp268 null
   930 jump *label225 always
   931 label *label224
-    * set *tmp268 null
   932 label *label225
   933 jump *label223 always
   934 label *label222
 
   975 op equal *tmp282 *tmp281 :processUnit.1:item
   976 jump *label238 equal *tmp282 false
   977 set :processUnit.1:state 3
-    * set *tmp283 :processUnit.1:state
   978 jump *label239 always
   979 label *label238
   980 sensor *tmp284 @unit @totalItems
 
   996 label *label243
   997 set *tmp286 *tmp288
   998 label *label241
-    * set *tmp283 *tmp286
   999 label *label239
  1000 jump *label235 always
  1001 label *label234
 
  1016 set .MSG ", loading\n"
  1017 set *tmp295 .MSG
  1018 label *label249
-    * set *tmp292 *tmp295
  1019 jump *label247 always
  1020 label *label246
  1021 ucontrol approach .CORE_X .CORE_Y 6
 
  1028 op idiv *tmp301 *tmp300 .SPEED_TENTHS
  1029 op div *tmp302 *tmp301 10
  1030 set :processUnit.1:distance *tmp302
-    * set *tmp292 :processUnit.1:distance
  1031 label *label247
  1032 jump *label245 always
  1033 label *label244
 
  1054 label *label256
  1055 set *tmp310 null
  1056 label *label257
-    * set *tmp306 *tmp310
  1057 jump *label253 always
  1058 label *label252
  1059 ucontrol approach .DOME_X .DOME_Y 6
 
  1066 op idiv *tmp316 *tmp315 .SPEED_TENTHS
  1067 op div *tmp317 *tmp316 10
  1068 set :processUnit.1:distance *tmp317
-    * set *tmp306 :processUnit.1:distance
  1069 label *label253
  1070 jump *label251 always
  1071 label *label250
 
  1149 op land *tmp337 *tmp334 *tmp336
  1150 jump *label269 equal *tmp337 false
  1151 jump *label266 always
-    * set *tmp338 null
  1152 jump *label270 always
  1153 label *label269
-    * set *tmp338 null
  1154 label *label270
  1155 jump *label268 always
  1156 label *label267
 
  1197 op equal *tmp352 *tmp351 :processUnit.2:item
  1198 jump *label283 equal *tmp352 false
  1199 set :processUnit.2:state 3
-    * set *tmp353 :processUnit.2:state
  1200 jump *label284 always
  1201 label *label283
  1202 sensor *tmp354 @unit @totalItems
 
  1218 label *label288
  1219 set *tmp356 *tmp358
  1220 label *label286
-    * set *tmp353 *tmp356
  1221 label *label284
  1222 jump *label280 always
  1223 label *label279
 
  1238 set .MSG ", loading\n"
  1239 set *tmp365 .MSG
  1240 label *label294
-    * set *tmp362 *tmp365
  1241 jump *label292 always
  1242 label *label291
  1243 ucontrol approach .CORE_X .CORE_Y 6
 
  1250 op idiv *tmp371 *tmp370 .SPEED_TENTHS
  1251 op div *tmp372 *tmp371 10
  1252 set :processUnit.2:distance *tmp372
-    * set *tmp362 :processUnit.2:distance
  1253 label *label292
  1254 jump *label290 always
  1255 label *label289
 
  1276 label *label301
  1277 set *tmp380 null
  1278 label *label302
-    * set *tmp376 *tmp380
  1279 jump *label298 always
  1280 label *label297
  1281 ucontrol approach .DOME_X .DOME_Y 6
 
  1288 op idiv *tmp386 *tmp385 .SPEED_TENTHS
  1289 op div *tmp387 *tmp386 10
  1290 set :processUnit.2:distance *tmp387
-    * set *tmp376 :processUnit.2:distance
  1291 label *label298
  1292 jump *label296 always
  1293 label *label295
 
  1337 op land *tmp401 *tmp398 *tmp400
  1338 jump *label311 equal *tmp401 false
  1339 jump *label308 always
-    * set *tmp402 null
  1340 jump *label312 always
  1341 label *label311
-    * set *tmp402 null
  1342 label *label312
  1343 jump *label310 always
  1344 label *label309
 
  1385 op equal *tmp416 *tmp415 :processUnit.3:item
  1386 jump *label325 equal *tmp416 false
  1387 set :processUnit.3:state 3
-    * set *tmp417 :processUnit.3:state
  1388 jump *label326 always
  1389 label *label325
  1390 sensor *tmp418 @unit @totalItems
 
  1406 label *label330
  1407 set *tmp420 *tmp422
  1408 label *label328
-    * set *tmp417 *tmp420
  1409 label *label326
  1410 jump *label322 always
  1411 label *label321
 
  1426 set .MSG ", loading\n"
  1427 set *tmp429 .MSG
  1428 label *label336
-    * set *tmp426 *tmp429
  1429 jump *label334 always
  1430 label *label333
  1431 ucontrol approach .CORE_X .CORE_Y 6
 
  1438 op idiv *tmp435 *tmp434 .SPEED_TENTHS
  1439 op div *tmp436 *tmp435 10
  1440 set :processUnit.3:distance *tmp436
-    * set *tmp426 :processUnit.3:distance
  1441 label *label334
  1442 jump *label332 always
  1443 label *label331
 
  1464 label *label343
  1465 set *tmp444 null
  1466 label *label344
-    * set *tmp440 *tmp444
  1467 jump *label340 always
  1468 label *label339
  1469 ucontrol approach .DOME_X .DOME_Y 6
 
  1476 op idiv *tmp450 *tmp449 .SPEED_TENTHS
  1477 op div *tmp451 *tmp450 10
  1478 set :processUnit.3:distance *tmp451
-    * set *tmp440 :processUnit.3:distance
  1479 label *label340
  1480 jump *label338 always
  1481 label *label337
 
  1581 jump *label368 equal *tmp483 false
  1582 set *tmp466 true
  1583 jump *label355 always
-    * set *tmp484 null
  1584 jump *label369 always
  1585 label *label368
-    * set *tmp484 null
  1586 label *label369
  1587 jump *label365 always
  1588 label *label364
-    * set *tmp485 :areUnitsAvailable.2:occupied
  1589 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1590 label *label365
  1591 ubind :areUnitsAvailable.2:type

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-24 instructions):
 
   793 op equal *tmp221 *tmp220 0
   794 jump *label198 equal *tmp221 false
   795 set :processUnit:state 2
-    * set *tmp222 :processUnit:state
   796 jump *label199 always
   797 label *label198
   798 set .MSG ", initializing\n"
 
   805 label *label200
   806 set *tmp224 null
   807 label *label201
-    * set *tmp222 *tmp224
   808 label *label199
   809 label *label197
   810 jump *label193 always
 
   820 jump *label206 equal *tmp230 false
   821 ucontrol approach .DOME_X .DOME_Y 6
   822 set :processUnit:state 3
-    * set *tmp231 :processUnit:state
   823 jump *label207 always
   824 label *label206
   825 set .MSG ", loading\n"
-    * set *tmp231 .MSG
   826 label *label207
   827 jump *label205 always
   828 label *label204
 
   857 jump *label214 equal *tmp245 false
   858 ucontrol approach .CORE_X .CORE_Y 6
   859 set :processUnit:state 2
-    * set *tmp246 :processUnit:state
   860 jump *label215 always
   861 label *label214
-    * set *tmp246 null
   862 label *label215
   863 jump *label211 always
   864 label *label210
 
   975 op equal *tmp285 *tmp284 0
   976 jump *label240 equal *tmp285 false
   977 set :processUnit.1:state 2
-    * set *tmp286 :processUnit.1:state
   978 jump *label241 always
   979 label *label240
   980 set .MSG ", initializing\n"
 
   987 label *label242
   988 set *tmp288 null
   989 label *label243
-    * set *tmp286 *tmp288
   990 label *label241
   991 label *label239
   992 jump *label235 always
 
  1002 jump *label248 equal *tmp294 false
  1003 ucontrol approach .DOME_X .DOME_Y 6
  1004 set :processUnit.1:state 3
-    * set *tmp295 :processUnit.1:state
  1005 jump *label249 always
  1006 label *label248
  1007 set .MSG ", loading\n"
-    * set *tmp295 .MSG
  1008 label *label249
  1009 jump *label247 always
  1010 label *label246
 
  1039 jump *label256 equal *tmp309 false
  1040 ucontrol approach .CORE_X .CORE_Y 6
  1041 set :processUnit.1:state 2
-    * set *tmp310 :processUnit.1:state
  1042 jump *label257 always
  1043 label *label256
-    * set *tmp310 null
  1044 label *label257
  1045 jump *label253 always
  1046 label *label252
 
  1191 op equal *tmp355 *tmp354 0
  1192 jump *label285 equal *tmp355 false
  1193 set :processUnit.2:state 2
-    * set *tmp356 :processUnit.2:state
  1194 jump *label286 always
  1195 label *label285
  1196 set .MSG ", initializing\n"
 
  1203 label *label287
  1204 set *tmp358 null
  1205 label *label288
-    * set *tmp356 *tmp358
  1206 label *label286
  1207 label *label284
  1208 jump *label280 always
 
  1218 jump *label293 equal *tmp364 false
  1219 ucontrol approach .DOME_X .DOME_Y 6
  1220 set :processUnit.2:state 3
-    * set *tmp365 :processUnit.2:state
  1221 jump *label294 always
  1222 label *label293
  1223 set .MSG ", loading\n"
-    * set *tmp365 .MSG
  1224 label *label294
  1225 jump *label292 always
  1226 label *label291
 
  1255 jump *label301 equal *tmp379 false
  1256 ucontrol approach .CORE_X .CORE_Y 6
  1257 set :processUnit.2:state 2
-    * set *tmp380 :processUnit.2:state
  1258 jump *label302 always
  1259 label *label301
-    * set *tmp380 null
  1260 label *label302
  1261 jump *label298 always
  1262 label *label297
 
  1373 op equal *tmp419 *tmp418 0
  1374 jump *label327 equal *tmp419 false
  1375 set :processUnit.3:state 2
-    * set *tmp420 :processUnit.3:state
  1376 jump *label328 always
  1377 label *label327
  1378 set .MSG ", initializing\n"
 
  1385 label *label329
  1386 set *tmp422 null
  1387 label *label330
-    * set *tmp420 *tmp422
  1388 label *label328
  1389 label *label326
  1390 jump *label322 always
 
  1400 jump *label335 equal *tmp428 false
  1401 ucontrol approach .DOME_X .DOME_Y 6
  1402 set :processUnit.3:state 3
-    * set *tmp429 :processUnit.3:state
  1403 jump *label336 always
  1404 label *label335
  1405 set .MSG ", loading\n"
-    * set *tmp429 .MSG
  1406 label *label336
  1407 jump *label334 always
  1408 label *label333
 
  1437 jump *label343 equal *tmp443 false
  1438 ucontrol approach .CORE_X .CORE_Y 6
  1439 set :processUnit.3:state 2
-    * set *tmp444 :processUnit.3:state
  1440 jump *label344 always
  1441 label *label343
-    * set *tmp444 null
  1442 label *label344
  1443 jump *label340 always
  1444 label *label339

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
   800 ucontrol within .CORE_X .CORE_Y 8 *tmp223
   801 jump *label200 equal *tmp223 false
   802 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp224 null
   803 jump *label201 always
   804 label *label200
-    * set *tmp224 null
   805 label *label201
   806 label *label199
   807 label *label197
 
   980 ucontrol within .CORE_X .CORE_Y 8 *tmp287
   981 jump *label242 equal *tmp287 false
   982 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp288 null
   983 jump *label243 always
   984 label *label242
-    * set *tmp288 null
   985 label *label243
   986 label *label241
   987 label *label239
 
  1194 ucontrol within .CORE_X .CORE_Y 8 *tmp357
  1195 jump *label287 equal *tmp357 false
  1196 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp358 null
  1197 jump *label288 always
  1198 label *label287
-    * set *tmp358 null
  1199 label *label288
  1200 label *label286
  1201 label *label284
 
  1374 ucontrol within .CORE_X .CORE_Y 8 *tmp421
  1375 jump *label329 equal *tmp421 false
  1376 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp422 null
  1377 jump *label330 always
  1378 label *label329
-    * set *tmp422 null
  1379 label *label330
  1380 label *label328
  1381 label *label326

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-41 instructions):
 
    47 jump *label5 always
    48 label *label7
    49 label *label1
-    * sensor *tmp3 .CORE @x
-    * set .CORE_X *tmp3
-    * sensor *tmp4 .CORE @y
-    * set .CORE_Y *tmp4
-    * sensor *tmp5 .DOME @x
-    * set .DOME_X *tmp5
-    * sensor *tmp6 .DOME @y
-    * set .DOME_Y *tmp6
+   50 sensor .CORE_X .CORE @x
+   51 sensor .CORE_Y .CORE @y
+   52 sensor .DOME_X .DOME @x
+   53 sensor .DOME_Y .DOME @y
    54 label *label17
    55 sensor *tmp7 switch1 @enabled
    56 op equal *tmp8 *tmp7 false
 
    84 op len *tmp16 *tmp14 *tmp15
    85 op mul *tmp17 2 *tmp16
    86 sensor *tmp18 :needsFourUnits:unit @speed
-    * op div *tmp19 *tmp17 *tmp18
-    * set :needsFourUnits:travel_time *tmp19
-    * op greaterThanEq *tmp20 :needsFourUnits:travel_time 47
-    * set *tmp13 *tmp20
+   87 op div :needsFourUnits:travel_time *tmp17 *tmp18
+   88 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    89 jump *label31 always
    90 set *tmp13 null
    91 label *label31
 
   194 op len *tmp46 *tmp44 *tmp45
   195 op mul *tmp47 2 *tmp46
   196 sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div *tmp49 *tmp47 *tmp48
-    * set :needsFourUnits.1:travel_time *tmp49
-    * op greaterThanEq *tmp50 :needsFourUnits.1:travel_time 47
-    * set *tmp43 *tmp50
+  197 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  198 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   199 jump *label62 always
   200 set *tmp43 null
   201 label *label62
 
   310 set .UNIT_S2 .UNIT_P2
   311 set .UNIT_P2 .UNIT_S1
   312 set .UNIT_S1 .UNIT_P1
-    * set *tmp74 @unit
-    * set .UNIT_P1 *tmp74
+  313 set .UNIT_P1 @unit
   314 op notEqual *tmp75 .UNIT_S2 null
   315 jump *label85 equal *tmp75 false
   316 jump *label82 always
 
   459 jump *label117 always
   460 label *label116
   461 label *label117
-    * sensor *tmp121 .UNIT_S1 @itemCapacity
-    * set .UNIT_CAPACITY *tmp121
-    * sensor *tmp122 .UNIT_S1 @speed
-    * set .SPEED *tmp122
-    * op div *tmp123 .SPEED 10
-    * set .SPEED_TENTHS *tmp123
+  462 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
+  463 sensor .SPEED .UNIT_S1 @speed
+  464 op div .SPEED_TENTHS .SPEED 10
   465 op strictEqual *tmp124 .SPEED null
   466 jump *label121 equal *tmp124 false
   467 stop
 
   475 op len *tmp129 *tmp127 *tmp128
   476 op mul *tmp130 2 *tmp129
   477 sensor *tmp131 :needsFourUnits.2:unit @speed
-    * op div *tmp132 *tmp130 *tmp131
-    * set :needsFourUnits.2:travel_time *tmp132
-    * op greaterThanEq *tmp133 :needsFourUnits.2:travel_time 47
-    * set *tmp126 *tmp133
+  478 op div :needsFourUnits.2:travel_time *tmp130 *tmp131
+  479 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   480 jump *label123 always
   481 set *tmp126 null
   482 label *label123
 
   672 set *tmp190 false
   673 label *label169
   674 set .SUPPLY_P_FIRST *tmp190
-    * op add *tmp191 @time 5000
-    * set :unitCheck *tmp191
+  675 op add :unitCheck @time 5000
   676 label *label172
   677 sensor *tmp192 switch1 @enabled
   678 jump *label174 equal *tmp192 false
 
   689 set :printDomeStatus:item @silicon
   690 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   691 print :printDomeStatus:text
-    * sensor *tmp193 .DOME :printDomeStatus:item
-    * set :printDomeStatus:level *tmp193
+  692 sensor :printDomeStatus:level .DOME :printDomeStatus:item
   693 op greaterThan *tmp194 :printDomeStatus:level 3
   694 jump *label176 equal *tmp194 false
   695 print "  dome:  [green]"
 
   756 label *label185
   757 end
   758 label *label179
-    * sensor *tmp213 @unit @flag
-    * set :processUnit:state *tmp213
+  759 sensor :processUnit:state @unit @flag
   760 set :processUnit:distance -1
   761 set :processUnit:color "gold"
   762 op lessThan *tmp214 :processUnit:state 2
 
   815 op sub *tmp235 .CORE_Y *tmp234
   816 op len *tmp236 *tmp233 *tmp235
   817 op idiv *tmp237 *tmp236 .SPEED_TENTHS
-    * op div *tmp238 *tmp237 10
-    * set :processUnit:distance *tmp238
+  818 op div :processUnit:distance *tmp237 10
   819 label *label205
   820 jump *label203 always
   821 label *label202
 
   850 op sub *tmp250 .DOME_Y *tmp249
   851 op len *tmp251 *tmp248 *tmp250
   852 op idiv *tmp252 *tmp251 .SPEED_TENTHS
-    * op div *tmp253 *tmp252 10
-    * set :processUnit:distance *tmp253
+  853 op div :processUnit:distance *tmp252 10
   854 label *label211
   855 jump *label209 always
   856 label *label208
 
   877 label *label216
   878 print .MSG
   879 label *label217
-    * set *tmp257 @unit
-    * set :processUnit:unit *tmp257
+  880 set :processUnit:unit @unit
   881 label *label178
   882 set .UNIT_S1 :processUnit:unit
   883 jump *label218 equal .FOUR_UNITS false
 
   932 label *label227
   933 end
   934 label *label221
-    * sensor *tmp277 @unit @flag
-    * set :processUnit.1:state *tmp277
+  935 sensor :processUnit.1:state @unit @flag
   936 set :processUnit.1:distance -1
   937 set :processUnit.1:color "gold"
   938 op lessThan *tmp278 :processUnit.1:state 2
 
   991 op sub *tmp299 .CORE_Y *tmp298
   992 op len *tmp300 *tmp297 *tmp299
   993 op idiv *tmp301 *tmp300 .SPEED_TENTHS
-    * op div *tmp302 *tmp301 10
-    * set :processUnit.1:distance *tmp302
+  994 op div :processUnit.1:distance *tmp301 10
   995 label *label247
   996 jump *label245 always
   997 label *label244
 
  1026 op sub *tmp314 .DOME_Y *tmp313
  1027 op len *tmp315 *tmp312 *tmp314
  1028 op idiv *tmp316 *tmp315 .SPEED_TENTHS
-    * op div *tmp317 *tmp316 10
-    * set :processUnit.1:distance *tmp317
+ 1029 op div :processUnit.1:distance *tmp316 10
  1030 label *label253
  1031 jump *label251 always
  1032 label *label250
 
  1053 label *label258
  1054 print .MSG
  1055 label *label259
-    * set *tmp321 @unit
-    * set :processUnit.1:unit *tmp321
+ 1056 set :processUnit.1:unit @unit
  1057 label *label220
  1058 set .UNIT_S2 :processUnit.1:unit
  1059 jump *label260 equal .SUPPLY_S_FIRST false
  1060 sensor *tmp323 .UNIT_S1 @totalItems
-    * op greaterThan *tmp324 *tmp323 0
-    * set *tmp322 *tmp324
+ 1061 op greaterThan *tmp322 *tmp323 0
  1062 jump *label261 always
  1063 label *label260
  1064 sensor *tmp325 .UNIT_S2 @totalItems
-    * op equal *tmp326 *tmp325 0
-    * set *tmp322 *tmp326
+ 1065 op equal *tmp322 *tmp325 0
  1066 label *label261
  1067 set .SUPPLY_S_FIRST *tmp322
  1068 jump *label219 always
 
  1072 set :printDomeStatus.1:item @phase-fabric
  1073 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
  1074 print :printDomeStatus.1:text
-    * sensor *tmp327 .DOME :printDomeStatus.1:item
-    * set :printDomeStatus.1:level *tmp327
+ 1075 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
  1076 op greaterThan *tmp328 :printDomeStatus.1:level 3
  1077 jump *label263 equal *tmp328 false
  1078 print "  dome:  [green]"
 
  1139 label *label272
  1140 end
  1141 label *label266
-    * sensor *tmp347 @unit @flag
-    * set :processUnit.2:state *tmp347
+ 1142 sensor :processUnit.2:state @unit @flag
  1143 set :processUnit.2:distance -1
  1144 set :processUnit.2:color "gold"
  1145 op lessThan *tmp348 :processUnit.2:state 2
 
  1198 op sub *tmp369 .CORE_Y *tmp368
  1199 op len *tmp370 *tmp367 *tmp369
  1200 op idiv *tmp371 *tmp370 .SPEED_TENTHS
-    * op div *tmp372 *tmp371 10
-    * set :processUnit.2:distance *tmp372
+ 1201 op div :processUnit.2:distance *tmp371 10
  1202 label *label292
  1203 jump *label290 always
  1204 label *label289
 
  1233 op sub *tmp384 .DOME_Y *tmp383
  1234 op len *tmp385 *tmp382 *tmp384
  1235 op idiv *tmp386 *tmp385 .SPEED_TENTHS
-    * op div *tmp387 *tmp386 10
-    * set :processUnit.2:distance *tmp387
+ 1236 op div :processUnit.2:distance *tmp386 10
  1237 label *label298
  1238 jump *label296 always
  1239 label *label295
 
  1260 label *label303
  1261 print .MSG
  1262 label *label304
-    * set *tmp391 @unit
-    * set :processUnit.2:unit *tmp391
+ 1263 set :processUnit.2:unit @unit
  1264 label *label265
  1265 set .UNIT_P1 :processUnit.2:unit
  1266 jump *label305 equal .FOUR_UNITS false
 
  1315 label *label314
  1316 end
  1317 label *label308
-    * sensor *tmp411 @unit @flag
-    * set :processUnit.3:state *tmp411
+ 1318 sensor :processUnit.3:state @unit @flag
  1319 set :processUnit.3:distance -1
  1320 set :processUnit.3:color "gold"
  1321 op lessThan *tmp412 :processUnit.3:state 2
 
  1374 op sub *tmp433 .CORE_Y *tmp432
  1375 op len *tmp434 *tmp431 *tmp433
  1376 op idiv *tmp435 *tmp434 .SPEED_TENTHS
-    * op div *tmp436 *tmp435 10
-    * set :processUnit.3:distance *tmp436
+ 1377 op div :processUnit.3:distance *tmp435 10
  1378 label *label334
  1379 jump *label332 always
  1380 label *label331
 
  1409 op sub *tmp448 .DOME_Y *tmp447
  1410 op len *tmp449 *tmp446 *tmp448
  1411 op idiv *tmp450 *tmp449 .SPEED_TENTHS
-    * op div *tmp451 *tmp450 10
-    * set :processUnit.3:distance *tmp451
+ 1412 op div :processUnit.3:distance *tmp450 10
  1413 label *label340
  1414 jump *label338 always
  1415 label *label337
 
  1436 label *label345
  1437 print .MSG
  1438 label *label346
-    * set *tmp455 @unit
-    * set :processUnit.3:unit *tmp455
+ 1439 set :processUnit.3:unit @unit
  1440 label *label307
  1441 set .UNIT_P2 :processUnit.3:unit
  1442 jump *label347 equal .SUPPLY_P_FIRST false
  1443 sensor *tmp457 .UNIT_P1 @totalItems
-    * op greaterThan *tmp458 *tmp457 0
-    * set *tmp456 *tmp458
+ 1444 op greaterThan *tmp456 *tmp457 0
  1445 jump *label348 always
  1446 label *label347
  1447 sensor *tmp459 .UNIT_P2 @totalItems
-    * op equal *tmp460 *tmp459 0
-    * set *tmp456 *tmp460
+ 1448 op equal *tmp456 *tmp459 0
  1449 label *label348
  1450 set .SUPPLY_P_FIRST *tmp456
  1451 jump *label306 always
 
  1483 op len *tmp472 *tmp470 *tmp471
  1484 op mul *tmp473 2 *tmp472
  1485 sensor *tmp474 :needsFourUnits.3:unit @speed
-    * op div *tmp475 *tmp473 *tmp474
-    * set :needsFourUnits.3:travel_time *tmp475
-    * op greaterThanEq *tmp476 :needsFourUnits.3:travel_time 47
-    * set *tmp469 *tmp476
+ 1486 op div :needsFourUnits.3:travel_time *tmp473 *tmp474
+ 1487 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
  1488 jump *label360 always
  1489 set *tmp469 null
  1490 label *label360
 
  1558 jump *label354 always
  1559 label *label353
  1560 label *label354
-    * op add *tmp493 @time 5000
-    * set :unitCheck *tmp493
+ 1561 op add :unitCheck @time 5000
  1562 jump *label350 always
  1563 label *label349
  1564 label *label350
 
  1578 jump *label378 notEqual *tmp497 false
  1579 jump *label376 always
  1580 label *label378
-    * ulocate building core false @copper *tmp500 *tmp501 *tmp502 *tmp499
-    * set .CORE *tmp499
+ 1581 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1582 jump *label377 always
  1583 label *label376
  1584 label *label377

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * jump *label7 equal true false
    19 set :locateDomeAndCore:type @flare
    20 op add *tmp1 @counter 1
    21 jump *label8 always
 
    62 label *label19
    63 # "Function: inline def chooseUnitType()"
    64 label *label21
-    * jump *label23 equal true false
    65 printflush null
    66 print "[gold]Looking for suitable unit type:[]"
    67 print "\n"

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-24 instructions):
 
   101 label *label38
   102 sensor *tmp24 @unit @controller
   103 op equal *tmp25 *tmp24 @this
-    * jump *label37 notEqual *tmp25 false
-    * jump *label35 always
+  104 jump *label35 equal *tmp25 false
   105 label *label37
   106 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
   107 op greaterThanEq *tmp27 :areUnitsAvailable:free :areUnitsAvailable:needed
 
   122 label *label41
   123 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
   124 op equal *tmp32 *tmp31 0
-    * jump *label34 equal *tmp32 false
-    * jump *label32 always
+  125 jump *label32 notEqual *tmp32 false
   126 label *label34
   127 jump *label28 always
   128 label *label27
 
   209 label *label69
   210 sensor *tmp54 @unit @controller
   211 op equal *tmp55 *tmp54 @this
-    * jump *label68 notEqual *tmp55 false
-    * jump *label66 always
+  212 jump *label66 equal *tmp55 false
   213 label *label68
   214 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
   215 op greaterThanEq *tmp57 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
 
   230 label *label72
   231 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   232 op equal *tmp62 *tmp61 0
-    * jump *label65 equal *tmp62 false
-    * jump *label63 always
+  233 jump *label63 notEqual *tmp62 false
   234 label *label65
   235 jump *label59 always
   236 label *label58
 
   321 label *label87
   322 sensor *tmp78 :rebindUnits:firstUnit @dead
   323 op equal *tmp79 *tmp78 0
-    * jump *label82 equal *tmp79 false
-    * jump *label80 always
+  324 jump *label80 notEqual *tmp79 false
   325 label *label82
   326 jump *label77 always
   327 label *label77
 
   364 label *label101
   365 sensor *tmp96 :rebindUnit:firstUnit @dead
   366 op equal *tmp97 *tmp96 0
-    * jump *label98 equal *tmp97 false
-    * jump *label96 always
+  367 jump *label96 notEqual *tmp97 false
   368 label *label98
   369 jump *label95 always
   370 label *label94
 
   416 label *label115
   417 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   418 op equal *tmp115 *tmp114 0
-    * jump *label112 equal *tmp115 false
-    * jump *label110 always
+  419 jump *label110 notEqual *tmp115 false
   420 label *label112
   421 jump *label109 always
   422 label *label108
 
   435 label *label119
   436 sensor *tmp118 .UNIT_P1 @firstItem
   437 op equal *tmp119 *tmp118 @silicon
-    * jump *label118 notEqual *tmp119 false
-    * jump *label116 always
+  438 jump *label116 equal *tmp119 false
   439 label *label118
   440 # "Function: inline void swap(in out a, in out b)"
   441 set :swap:a .UNIT_S1
 
   511 label *label139
   512 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   513 op equal *tmp152 *tmp151 0
-    * jump *label136 equal *tmp152 false
-    * jump *label134 always
+  514 jump *label134 notEqual *tmp152 false
   515 label *label136
   516 jump *label133 always
   517 label *label132
 
   563 label *label153
   564 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   565 op equal *tmp170 *tmp169 0
-    * jump *label150 equal *tmp170 false
-    * jump *label148 always
+  566 jump *label148 notEqual *tmp170 false
   567 label *label150
   568 jump *label147 always
   569 label *label146
 
   603 label *label162
   604 sensor *tmp178 .UNIT_P2 @firstItem
   605 op equal *tmp179 *tmp178 @silicon
-    * jump *label161 notEqual *tmp179 false
-    * jump *label159 always
+  606 jump *label159 equal *tmp179 false
   607 label *label161
   608 # "Function: inline void swap(in out a, in out b)"
   609 set :swap.2:a .UNIT_S2
 
   635 sensor *tmp182 .UNIT_S1 @totalItems
   636 sensor *tmp183 .UNIT_S2 @totalItems
   637 op lessThan *tmp184 *tmp182 *tmp183
-    * jump *label166 notEqual *tmp184 false
-    * jump *label164 always
+  638 jump *label164 equal *tmp184 false
   639 label *label166
   640 set *tmp185 true
   641 jump *label165 always
 
   649 sensor *tmp187 .UNIT_P1 @totalItems
   650 sensor *tmp188 .UNIT_P2 @totalItems
   651 op lessThan *tmp189 *tmp187 *tmp188
-    * jump *label170 notEqual *tmp189 false
-    * jump *label168 always
+  652 jump *label168 equal *tmp189 false
   653 label *label170
   654 set *tmp190 true
   655 jump *label169 always
 
   733 label *label191
   734 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   735 op equal *tmp212 *tmp211 0
-    * jump *label188 equal *tmp212 false
-    * jump *label186 always
+  736 jump *label186 notEqual *tmp212 false
   737 label *label188
   738 jump *label185 always
   739 label *label184
 
   747 jump *label194 notEqual *tmp214 false
   748 label *label195
   749 op greaterThan *tmp215 :processUnit:state 3
-    * jump *label194 notEqual *tmp215 false
-    * jump *label192 always
+  750 jump *label192 equal *tmp215 false
   751 label *label194
   752 sensor *tmp217 @unit @firstItem
   753 op equal *tmp218 *tmp217 :processUnit:item
 
   907 label *label233
   908 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   909 op equal *tmp276 *tmp275 0
-    * jump *label230 equal *tmp276 false
-    * jump *label228 always
+  910 jump *label228 notEqual *tmp276 false
   911 label *label230
   912 jump *label227 always
   913 label *label226
 
   921 jump *label236 notEqual *tmp278 false
   922 label *label237
   923 op greaterThan *tmp279 :processUnit.1:state 3
-    * jump *label236 notEqual *tmp279 false
-    * jump *label234 always
+  924 jump *label234 equal *tmp279 false
   925 label *label236
   926 sensor *tmp281 @unit @firstItem
   927 op equal *tmp282 *tmp281 :processUnit.1:item
 
  1112 label *label278
  1113 sensor *tmp345 :rebindUnit.6:firstUnit @dead
  1114 op equal *tmp346 *tmp345 0
-    * jump *label275 equal *tmp346 false
-    * jump *label273 always
+ 1115 jump *label273 notEqual *tmp346 false
  1116 label *label275
  1117 jump *label272 always
  1118 label *label271
 
  1126 jump *label281 notEqual *tmp348 false
  1127 label *label282
  1128 op greaterThan *tmp349 :processUnit.2:state 3
-    * jump *label281 notEqual *tmp349 false
-    * jump *label279 always
+ 1129 jump *label279 equal *tmp349 false
  1130 label *label281
  1131 sensor *tmp351 @unit @firstItem
  1132 op equal *tmp352 *tmp351 :processUnit.2:item
 
  1286 label *label320
  1287 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1288 op equal *tmp410 *tmp409 0
-    * jump *label317 equal *tmp410 false
-    * jump *label315 always
+ 1289 jump *label315 notEqual *tmp410 false
  1290 label *label317
  1291 jump *label314 always
  1292 label *label313
 
  1300 jump *label323 notEqual *tmp412 false
  1301 label *label324
  1302 op greaterThan *tmp413 :processUnit.3:state 3
-    * jump *label323 notEqual *tmp413 false
-    * jump *label321 always
+ 1303 jump *label321 equal *tmp413 false
  1304 label *label323
  1305 sensor *tmp415 @unit @firstItem
  1306 op equal *tmp416 *tmp415 :processUnit.3:item
 
  1479 label *label367
  1480 sensor *tmp480 @unit @controller
  1481 op equal *tmp481 *tmp480 @this
-    * jump *label366 notEqual *tmp481 false
-    * jump *label364 always
+ 1482 jump *label364 equal *tmp481 false
  1483 label *label366
  1484 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
  1485 op greaterThanEq *tmp483 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
 
  1500 label *label370
  1501 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1502 op equal *tmp488 *tmp487 0
-    * jump *label363 equal *tmp488 false
-    * jump *label361 always
+ 1503 jump *label361 notEqual *tmp488 false
  1504 label *label363
  1505 jump *label357 always
  1506 label *label356
 
  1550 label *label379
  1551 sensor *tmp496 @unit @controller
  1552 op equal *tmp497 *tmp496 @this
-    * jump *label378 notEqual *tmp497 false
-    * jump *label376 always
+ 1553 jump *label376 equal *tmp497 false
  1554 label *label378
  1555 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1556 jump *label377 always

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-121 instructions):
 
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
     6 label *label2
-    * op equal *tmp0 .DOME null
-    * jump *label4 equal *tmp0 false
+    7 jump *label4 notEqual .DOME null
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
 
    51 sensor .DOME_Y .DOME @y
    52 label *label17
    53 sensor *tmp7 switch1 @enabled
-    * op equal *tmp8 *tmp7 false
-    * jump *label19 equal *tmp8 false
+   54 jump *label19 notEqual *tmp7 false
    55 print "[coral]Activate switch to begin supplying overdrive dome..."
    56 print "\n"
    57 printflush message1
 
    71 set :areUnitsAvailable:needed 0
    72 ubind :areUnitsAvailable:type
    73 set :areUnitsAvailable:firstUnit @unit
-    * op notEqual *tmp11 :areUnitsAvailable:firstUnit null
-    * jump *label27 equal *tmp11 false
+   74 jump *label27 equal :areUnitsAvailable:firstUnit null
    75 # "Function: inline def needsFourUnits(in unit)"
    76 set :needsFourUnits:unit @unit
    77 op sub *tmp14 .DOME_X .CORE_X
 
    93 set :areUnitsAvailable:needed *tmp21
    94 label *label32
    95 sensor *tmp22 @unit @controlled
-    * op equal *tmp23 *tmp22 0
-    * jump *label37 notEqual *tmp23 false
+   96 jump *label37 equal *tmp22 0
    97 label *label38
    98 sensor *tmp24 @unit @controller
-    * op equal *tmp25 *tmp24 @this
-    * jump *label35 equal *tmp25 false
+   99 jump *label35 notEqual *tmp24 @this
   100 label *label37
   101 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * op greaterThanEq *tmp27 :areUnitsAvailable:free :areUnitsAvailable:needed
-    * jump *label39 equal *tmp27 false
+  102 jump *label39 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   103 set *tmp10 true
   104 jump *label26 always
   105 jump *label40 always
 
   111 label *label36
   112 ubind :areUnitsAvailable:type
   113 label *label33
-    * op notEqual *tmp30 @unit :areUnitsAvailable:firstUnit
-    * jump *label34 equal *tmp30 false
+  114 jump *label34 equal @unit :areUnitsAvailable:firstUnit
   115 label *label41
   116 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
-    * op equal *tmp32 *tmp31 0
-    * jump *label32 notEqual *tmp32 false
+  117 jump *label32 equal *tmp31 0
   118 label *label34
   119 jump *label28 always
   120 label *label27
 
   127 print ","
   128 print " free: "
   129 print :areUnitsAvailable:free
-    * op greaterThan *tmp34 :areUnitsAvailable:needed 0
-    * jump *label44 equal *tmp34 false
+  130 jump *label44 lessThanEq :areUnitsAvailable:needed 0
   131 print ", needed: "
   132 print :areUnitsAvailable:needed
   133 jump *label45 always
 
   162 set :chooseUnitType:type @mono
   163 set *tmp37 null
   164 label *label46
-    * op notEqual *tmp38 :chooseUnitType:type UNIT_TYPE
-    * jump *label53 equal *tmp38 false
+  165 jump *label53 equal :chooseUnitType:type UNIT_TYPE
   166 # "Function: inline def areUnitsAvailable(in type, in output)"
   167 set :areUnitsAvailable.1:type :chooseUnitType:type
   168 set :areUnitsAvailable.1:output true
 
   171 set :areUnitsAvailable.1:needed 0
   172 ubind :areUnitsAvailable.1:type
   173 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp41 :areUnitsAvailable.1:firstUnit null
-    * jump *label58 equal *tmp41 false
+  174 jump *label58 equal :areUnitsAvailable.1:firstUnit null
   175 # "Function: inline def needsFourUnits(in unit)"
   176 set :needsFourUnits.1:unit @unit
   177 op sub *tmp44 .DOME_X .CORE_X
 
   193 set :areUnitsAvailable.1:needed *tmp51
   194 label *label63
   195 sensor *tmp52 @unit @controlled
-    * op equal *tmp53 *tmp52 0
-    * jump *label68 notEqual *tmp53 false
+  196 jump *label68 equal *tmp52 0
   197 label *label69
   198 sensor *tmp54 @unit @controller
-    * op equal *tmp55 *tmp54 @this
-    * jump *label66 equal *tmp55 false
+  199 jump *label66 notEqual *tmp54 @this
   200 label *label68
   201 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * op greaterThanEq *tmp57 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
-    * jump *label70 equal *tmp57 false
+  202 jump *label70 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   203 set *tmp40 true
   204 jump *label57 always
   205 jump *label71 always
 
   211 label *label67
   212 ubind :areUnitsAvailable.1:type
   213 label *label64
-    * op notEqual *tmp60 @unit :areUnitsAvailable.1:firstUnit
-    * jump *label65 equal *tmp60 false
+  214 jump *label65 equal @unit :areUnitsAvailable.1:firstUnit
   215 label *label72
   216 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp62 *tmp61 0
-    * jump *label63 notEqual *tmp62 false
+  217 jump *label63 equal *tmp61 0
   218 label *label65
   219 jump *label59 always
   220 label *label58
 
   227 print ","
   228 print " free: "
   229 print :areUnitsAvailable.1:free
-    * op greaterThan *tmp64 :areUnitsAvailable.1:needed 0
-    * jump *label75 equal *tmp64 false
+  230 jump *label75 lessThanEq :areUnitsAvailable.1:needed 0
   231 print ", needed: "
   232 print :areUnitsAvailable.1:needed
   233 jump *label76 always
 
   272 set :rebindUnits:count 0
   273 ubind .TYPE
   274 set :rebindUnits:firstUnit @unit
-    * op equal *tmp68 :rebindUnits:firstUnit null
-    * jump *label78 equal *tmp68 false
+  275 jump *label78 notEqual :rebindUnits:firstUnit null
   276 end
   277 jump *label79 always
   278 label *label78
   279 label *label79
   280 label *label80
   281 sensor *tmp70 @unit @controller
-    * op equal *tmp71 *tmp70 @this
-    * jump *label83 equal *tmp71 false
+  282 jump *label83 notEqual *tmp70 @this
   283 op add :rebindUnits:count :rebindUnits:count 1
   284 ucontrol flag 1
   285 set .UNIT_S2 .UNIT_P2
   286 set .UNIT_P2 .UNIT_S1
   287 set .UNIT_S1 .UNIT_P1
   288 set .UNIT_P1 @unit
-    * op notEqual *tmp75 .UNIT_S2 null
-    * jump *label85 equal *tmp75 false
+  289 jump *label85 equal .UNIT_S2 null
   290 jump *label82 always
   291 jump *label86 always
   292 label *label85
 
   296 label *label84
   297 ubind .TYPE
   298 label *label81
-    * op notEqual *tmp77 @unit :rebindUnits:firstUnit
-    * jump *label82 equal *tmp77 false
+  299 jump *label82 equal @unit :rebindUnits:firstUnit
   300 label *label87
   301 sensor *tmp78 :rebindUnits:firstUnit @dead
-    * op equal *tmp79 *tmp78 0
-    * jump *label80 notEqual *tmp79 false
+  302 jump *label80 equal *tmp78 0
   303 label *label82
   304 jump *label77 always
   305 label *label77
 
   307 set :acquireUnit:currentUnit .UNIT_S1
   308 # "Function: inline def rebindUnit(in currentUnit)"
   309 set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * op notEqual *tmp82 :rebindUnit:currentUnit null
-    * jump *label90 equal *tmp82 false
+  310 jump *label90 equal :rebindUnit:currentUnit null
   311 ubind :rebindUnit:currentUnit
   312 sensor *tmp84 @unit @dead
   313 op equal *tmp85 *tmp84 0
 
   324 label *label91
   325 ubind .TYPE
   326 set :rebindUnit:firstUnit @unit
-    * op notEqual *tmp90 :rebindUnit:firstUnit null
-    * jump *label94 equal *tmp90 false
+  327 jump *label94 equal :rebindUnit:firstUnit null
   328 label *label96
   329 sensor *tmp92 @unit @controlled
-    * op equal *tmp93 *tmp92 0
-    * jump *label99 equal *tmp93 false
+  330 jump *label99 notEqual *tmp92 0
   331 jump *label89 always
   332 jump *label100 always
   333 label *label99
   334 label *label100
   335 ubind .TYPE
   336 label *label97
-    * op notEqual *tmp95 @unit :rebindUnit:firstUnit
-    * jump *label98 equal *tmp95 false
+  337 jump *label98 equal @unit :rebindUnit:firstUnit
   338 label *label101
   339 sensor *tmp96 :rebindUnit:firstUnit @dead
-    * op equal *tmp97 *tmp96 0
-    * jump *label96 notEqual *tmp97 false
+  340 jump *label96 equal *tmp96 0
   341 label *label98
   342 jump *label95 always
   343 label *label94
 
   354 set :acquireUnit.1:currentUnit .UNIT_P1
   355 # "Function: inline def rebindUnit(in currentUnit)"
   356 set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * op notEqual *tmp100 :rebindUnit.1:currentUnit null
-    * jump *label104 equal *tmp100 false
+  357 jump *label104 equal :rebindUnit.1:currentUnit null
   358 ubind :rebindUnit.1:currentUnit
   359 sensor *tmp102 @unit @dead
   360 op equal *tmp103 *tmp102 0
 
   371 label *label105
   372 ubind .TYPE
   373 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp108 :rebindUnit.1:firstUnit null
-    * jump *label108 equal *tmp108 false
+  374 jump *label108 equal :rebindUnit.1:firstUnit null
   375 label *label110
   376 sensor *tmp110 @unit @controlled
-    * op equal *tmp111 *tmp110 0
-    * jump *label113 equal *tmp111 false
+  377 jump *label113 notEqual *tmp110 0
   378 jump *label103 always
   379 jump *label114 always
   380 label *label113
   381 label *label114
   382 ubind .TYPE
   383 label *label111
-    * op notEqual *tmp113 @unit :rebindUnit.1:firstUnit
-    * jump *label112 equal *tmp113 false
+  384 jump *label112 equal @unit :rebindUnit.1:firstUnit
   385 label *label115
   386 sensor *tmp114 :rebindUnit.1:firstUnit @dead
-    * op equal *tmp115 *tmp114 0
-    * jump *label110 notEqual *tmp115 false
+  387 jump *label110 equal *tmp114 0
   388 label *label112
   389 jump *label109 always
   390 label *label108
 
   398 label *label102
   399 set .UNIT_P1 *tmp98
   400 sensor *tmp116 .UNIT_S1 @firstItem
-    * op equal *tmp117 *tmp116 @phase-fabric
-    * jump *label118 notEqual *tmp117 false
+  401 jump *label118 equal *tmp116 @phase-fabric
   402 label *label119
   403 sensor *tmp118 .UNIT_P1 @firstItem
-    * op equal *tmp119 *tmp118 @silicon
-    * jump *label116 equal *tmp119 false
+  404 jump *label116 notEqual *tmp118 @silicon
   405 label *label118
   406 # "Function: inline void swap(in out a, in out b)"
   407 set :swap:a .UNIT_S1
 
   442 set :acquireUnit.2:currentUnit .UNIT_S2
   443 # "Function: inline def rebindUnit(in currentUnit)"
   444 set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * op notEqual *tmp137 :rebindUnit.2:currentUnit null
-    * jump *label128 equal *tmp137 false
+  445 jump *label128 equal :rebindUnit.2:currentUnit null
   446 ubind :rebindUnit.2:currentUnit
   447 sensor *tmp139 @unit @dead
   448 op equal *tmp140 *tmp139 0
 
   459 label *label129
   460 ubind .TYPE
   461 set :rebindUnit.2:firstUnit @unit
-    * op notEqual *tmp145 :rebindUnit.2:firstUnit null
-    * jump *label132 equal *tmp145 false
+  462 jump *label132 equal :rebindUnit.2:firstUnit null
   463 label *label134
   464 sensor *tmp147 @unit @controlled
-    * op equal *tmp148 *tmp147 0
-    * jump *label137 equal *tmp148 false
+  465 jump *label137 notEqual *tmp147 0
   466 jump *label127 always
   467 jump *label138 always
   468 label *label137
   469 label *label138
   470 ubind .TYPE
   471 label *label135
-    * op notEqual *tmp150 @unit :rebindUnit.2:firstUnit
-    * jump *label136 equal *tmp150 false
+  472 jump *label136 equal @unit :rebindUnit.2:firstUnit
   473 label *label139
   474 sensor *tmp151 :rebindUnit.2:firstUnit @dead
-    * op equal *tmp152 *tmp151 0
-    * jump *label134 notEqual *tmp152 false
+  475 jump *label134 equal *tmp151 0
   476 label *label136
   477 jump *label133 always
   478 label *label132
 
   489 set :acquireUnit.3:currentUnit .UNIT_P2
   490 # "Function: inline def rebindUnit(in currentUnit)"
   491 set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * op notEqual *tmp155 :rebindUnit.3:currentUnit null
-    * jump *label142 equal *tmp155 false
+  492 jump *label142 equal :rebindUnit.3:currentUnit null
   493 ubind :rebindUnit.3:currentUnit
   494 sensor *tmp157 @unit @dead
   495 op equal *tmp158 *tmp157 0
 
   506 label *label143
   507 ubind .TYPE
   508 set :rebindUnit.3:firstUnit @unit
-    * op notEqual *tmp163 :rebindUnit.3:firstUnit null
-    * jump *label146 equal *tmp163 false
+  509 jump *label146 equal :rebindUnit.3:firstUnit null
   510 label *label148
   511 sensor *tmp165 @unit @controlled
-    * op equal *tmp166 *tmp165 0
-    * jump *label151 equal *tmp166 false
+  512 jump *label151 notEqual *tmp165 0
   513 jump *label141 always
   514 jump *label152 always
   515 label *label151
   516 label *label152
   517 ubind .TYPE
   518 label *label149
-    * op notEqual *tmp168 @unit :rebindUnit.3:firstUnit
-    * jump *label150 equal *tmp168 false
+  519 jump *label150 equal @unit :rebindUnit.3:firstUnit
   520 label *label153
   521 sensor *tmp169 :rebindUnit.3:firstUnit @dead
-    * op equal *tmp170 *tmp169 0
-    * jump *label148 notEqual *tmp170 false
+  522 jump *label148 equal *tmp169 0
   523 label *label150
   524 jump *label147 always
   525 label *label146
 
   533 label *label140
   534 set .UNIT_P2 *tmp153
   535 sensor *tmp171 .UNIT_S1 @firstItem
-    * op equal *tmp172 *tmp171 @phase-fabric
-    * jump *label154 equal *tmp172 false
+  536 jump *label154 notEqual *tmp171 @phase-fabric
   537 label *label157
   538 sensor *tmp173 .UNIT_P2 @firstItem
-    * op notEqual *tmp174 *tmp173 @phase-fabric
-    * jump *label154 equal *tmp174 false
+  539 jump *label154 equal *tmp173 @phase-fabric
   540 jump *label156 always
   541 label *label156
   542 # "Function: inline void swap(in out a, in out b)"
 
   552 label *label154
   553 label *label155
   554 sensor *tmp176 .UNIT_S2 @firstItem
-    * op equal *tmp177 *tmp176 @phase-fabric
-    * jump *label161 notEqual *tmp177 false
+  555 jump *label161 equal *tmp176 @phase-fabric
   556 label *label162
   557 sensor *tmp178 .UNIT_P2 @firstItem
-    * op equal *tmp179 *tmp178 @silicon
-    * jump *label159 equal *tmp179 false
+  558 jump *label159 notEqual *tmp178 @silicon
   559 label *label161
   560 # "Function: inline void swap(in out a, in out b)"
   561 set :swap.2:a .UNIT_S2
 
   581 set .UNIT_P2 null
   582 set .GROUP1 "unit"
   583 label *label125
-    * op equal *tmp181 .FOUR_UNITS false
-    * jump *label166 notEqual *tmp181 false
+  584 jump *label166 equal .FOUR_UNITS false
   585 label *label167
   586 sensor *tmp182 .UNIT_S1 @totalItems
   587 sensor *tmp183 .UNIT_S2 @totalItems
-    * op lessThan *tmp184 *tmp182 *tmp183
-    * jump *label164 equal *tmp184 false
+  588 jump *label164 greaterThanEq *tmp182 *tmp183
   589 label *label166
   590 set *tmp185 true
   591 jump *label165 always
 
   593 set *tmp185 false
   594 label *label165
   595 set .SUPPLY_S_FIRST *tmp185
-    * op equal *tmp186 .FOUR_UNITS false
-    * jump *label170 notEqual *tmp186 false
+  596 jump *label170 equal .FOUR_UNITS false
   597 label *label171
   598 sensor *tmp187 .UNIT_P1 @totalItems
   599 sensor *tmp188 .UNIT_P2 @totalItems
-    * op lessThan *tmp189 *tmp187 *tmp188
-    * jump *label168 equal *tmp189 false
+  600 jump *label168 greaterThanEq *tmp187 *tmp188
   601 label *label170
   602 set *tmp190 true
   603 jump *label169 always
 
   623 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   624 print :printDomeStatus:text
   625 sensor :printDomeStatus:level .DOME :printDomeStatus:item
-    * op greaterThan *tmp194 :printDomeStatus:level 3
-    * jump *label176 equal *tmp194 false
+  626 jump *label176 lessThanEq :printDomeStatus:level 3
   627 print "  dome:  [green]"
   628 print :printDomeStatus:level
   629 print "["
 
   645 set :processUnit:supply .SUPPLY_S_FIRST
   646 # "Function: inline def rebindUnit(in currentUnit)"
   647 set :rebindUnit.4:currentUnit :processUnit:unit
-    * op notEqual *tmp197 :rebindUnit.4:currentUnit null
-    * jump *label180 equal *tmp197 false
+  648 jump *label180 equal :rebindUnit.4:currentUnit null
   649 ubind :rebindUnit.4:currentUnit
   650 sensor *tmp199 @unit @dead
   651 op equal *tmp200 *tmp199 0
 
   662 label *label181
   663 ubind .TYPE
   664 set :rebindUnit.4:firstUnit @unit
-    * op notEqual *tmp205 :rebindUnit.4:firstUnit null
-    * jump *label184 equal *tmp205 false
+  665 jump *label184 equal :rebindUnit.4:firstUnit null
   666 label *label186
   667 sensor *tmp207 @unit @controlled
-    * op equal *tmp208 *tmp207 0
-    * jump *label189 equal *tmp208 false
+  668 jump *label189 notEqual *tmp207 0
   669 jump *label179 always
   670 jump *label190 always
   671 label *label189
   672 label *label190
   673 ubind .TYPE
   674 label *label187
-    * op notEqual *tmp210 @unit :rebindUnit.4:firstUnit
-    * jump *label188 equal *tmp210 false
+  675 jump *label188 equal @unit :rebindUnit.4:firstUnit
   676 label *label191
   677 sensor *tmp211 :rebindUnit.4:firstUnit @dead
-    * op equal *tmp212 *tmp211 0
-    * jump *label186 notEqual *tmp212 false
+  678 jump *label186 equal *tmp211 0
   679 label *label188
   680 jump *label185 always
   681 label *label184
 
   685 sensor :processUnit:state @unit @flag
   686 set :processUnit:distance -1
   687 set :processUnit:color "gold"
-    * op lessThan *tmp214 :processUnit:state 2
-    * jump *label194 notEqual *tmp214 false
+  688 jump *label194 lessThan :processUnit:state 2
   689 label *label195
-    * op greaterThan *tmp215 :processUnit:state 3
-    * jump *label192 equal *tmp215 false
+  690 jump *label192 lessThanEq :processUnit:state 3
   691 label *label194
   692 sensor *tmp217 @unit @firstItem
-    * op equal *tmp218 *tmp217 :processUnit:item
-    * jump *label196 equal *tmp218 false
+  693 jump *label196 notEqual *tmp217 :processUnit:item
   694 set :processUnit:state 3
   695 jump *label197 always
   696 label *label196
   697 sensor *tmp220 @unit @totalItems
-    * op equal *tmp221 *tmp220 0
-    * jump *label198 equal *tmp221 false
+  698 jump *label198 notEqual *tmp220 0
   699 set :processUnit:state 2
   700 jump *label199 always
   701 label *label198
 
   712 jump *label193 always
   713 label *label192
   714 label *label193
-    * op equal *tmp225 :processUnit:state 2
-    * jump *label202 equal *tmp225 false
+  715 jump *label202 notEqual :processUnit:state 2
   716 ucontrol within .CORE_X .CORE_Y 8 *tmp227
   717 jump *label204 equal *tmp227 false
   718 ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
   719 sensor *tmp229 @unit @totalItems
-    * op greaterThanEq *tmp230 *tmp229 .UNIT_CAPACITY
-    * jump *label206 equal *tmp230 false
+  720 jump *label206 lessThan *tmp229 .UNIT_CAPACITY
   721 ucontrol approach .DOME_X .DOME_Y 6
   722 set :processUnit:state 3
   723 jump *label207 always
 
   739 jump *label203 always
   740 label *label202
   741 label *label203
-    * op equal *tmp239 :processUnit:state 3
-    * jump *label208 equal *tmp239 false
+  742 jump *label208 notEqual :processUnit:state 3
   743 ucontrol within .DOME_X .DOME_Y 8 *tmp241
   744 jump *label210 equal *tmp241 false
   745 jump *label212 equal :processUnit:supply false
 
   751 set .MSG ", waiting\n"
   752 label *label213
   753 sensor *tmp244 @unit @totalItems
-    * op lessThanEq *tmp245 *tmp244 0
-    * jump *label214 equal *tmp245 false
+  754 jump *label214 greaterThan *tmp244 0
   755 ucontrol approach .CORE_X .CORE_Y 6
   756 set :processUnit:state 2
   757 jump *label215 always
 
   783 print *tmp254
   784 print "["
   785 print "]"
-    * op greaterThanEq *tmp255 :processUnit:distance 0
-    * jump *label216 equal *tmp255 false
+  786 jump *label216 lessThan :processUnit:distance 0
   787 print .MSG
   788 print :processUnit:distance
   789 print "["
 
   805 set :processUnit.1:supply *tmp259
   806 # "Function: inline def rebindUnit(in currentUnit)"
   807 set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * op notEqual *tmp261 :rebindUnit.5:currentUnit null
-    * jump *label222 equal *tmp261 false
+  808 jump *label222 equal :rebindUnit.5:currentUnit null
   809 ubind :rebindUnit.5:currentUnit
   810 sensor *tmp263 @unit @dead
   811 op equal *tmp264 *tmp263 0
 
   822 label *label223
   823 ubind .TYPE
   824 set :rebindUnit.5:firstUnit @unit
-    * op notEqual *tmp269 :rebindUnit.5:firstUnit null
-    * jump *label226 equal *tmp269 false
+  825 jump *label226 equal :rebindUnit.5:firstUnit null
   826 label *label228
   827 sensor *tmp271 @unit @controlled
-    * op equal *tmp272 *tmp271 0
-    * jump *label231 equal *tmp272 false
+  828 jump *label231 notEqual *tmp271 0
   829 jump *label221 always
   830 jump *label232 always
   831 label *label231
   832 label *label232
   833 ubind .TYPE
   834 label *label229
-    * op notEqual *tmp274 @unit :rebindUnit.5:firstUnit
-    * jump *label230 equal *tmp274 false
+  835 jump *label230 equal @unit :rebindUnit.5:firstUnit
   836 label *label233
   837 sensor *tmp275 :rebindUnit.5:firstUnit @dead
-    * op equal *tmp276 *tmp275 0
-    * jump *label228 notEqual *tmp276 false
+  838 jump *label228 equal *tmp275 0
   839 label *label230
   840 jump *label227 always
   841 label *label226
 
   845 sensor :processUnit.1:state @unit @flag
   846 set :processUnit.1:distance -1
   847 set :processUnit.1:color "gold"
-    * op lessThan *tmp278 :processUnit.1:state 2
-    * jump *label236 notEqual *tmp278 false
+  848 jump *label236 lessThan :processUnit.1:state 2
   849 label *label237
-    * op greaterThan *tmp279 :processUnit.1:state 3
-    * jump *label234 equal *tmp279 false
+  850 jump *label234 lessThanEq :processUnit.1:state 3
   851 label *label236
   852 sensor *tmp281 @unit @firstItem
-    * op equal *tmp282 *tmp281 :processUnit.1:item
-    * jump *label238 equal *tmp282 false
+  853 jump *label238 notEqual *tmp281 :processUnit.1:item
   854 set :processUnit.1:state 3
   855 jump *label239 always
   856 label *label238
   857 sensor *tmp284 @unit @totalItems
-    * op equal *tmp285 *tmp284 0
-    * jump *label240 equal *tmp285 false
+  858 jump *label240 notEqual *tmp284 0
   859 set :processUnit.1:state 2
   860 jump *label241 always
   861 label *label240
 
   872 jump *label235 always
   873 label *label234
   874 label *label235
-    * op equal *tmp289 :processUnit.1:state 2
-    * jump *label244 equal *tmp289 false
+  875 jump *label244 notEqual :processUnit.1:state 2
   876 ucontrol within .CORE_X .CORE_Y 8 *tmp291
   877 jump *label246 equal *tmp291 false
   878 ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
   879 sensor *tmp293 @unit @totalItems
-    * op greaterThanEq *tmp294 *tmp293 .UNIT_CAPACITY
-    * jump *label248 equal *tmp294 false
+  880 jump *label248 lessThan *tmp293 .UNIT_CAPACITY
   881 ucontrol approach .DOME_X .DOME_Y 6
   882 set :processUnit.1:state 3
   883 jump *label249 always
 
   899 jump *label245 always
   900 label *label244
   901 label *label245
-    * op equal *tmp303 :processUnit.1:state 3
-    * jump *label250 equal *tmp303 false
+  902 jump *label250 notEqual :processUnit.1:state 3
   903 ucontrol within .DOME_X .DOME_Y 8 *tmp305
   904 jump *label252 equal *tmp305 false
   905 jump *label254 equal :processUnit.1:supply false
 
   911 set .MSG ", waiting\n"
   912 label *label255
   913 sensor *tmp308 @unit @totalItems
-    * op lessThanEq *tmp309 *tmp308 0
-    * jump *label256 equal *tmp309 false
+  914 jump *label256 greaterThan *tmp308 0
   915 ucontrol approach .CORE_X .CORE_Y 6
   916 set :processUnit.1:state 2
   917 jump *label257 always
 
   943 print *tmp318
   944 print "["
   945 print "]"
-    * op greaterThanEq *tmp319 :processUnit.1:distance 0
-    * jump *label258 equal *tmp319 false
+  946 jump *label258 lessThan :processUnit.1:distance 0
   947 print .MSG
   948 print :processUnit.1:distance
   949 print "["
 
   973 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   974 print :printDomeStatus.1:text
   975 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
-    * op greaterThan *tmp328 :printDomeStatus.1:level 3
-    * jump *label263 equal *tmp328 false
+  976 jump *label263 lessThanEq :printDomeStatus.1:level 3
   977 print "  dome:  [green]"
   978 print :printDomeStatus.1:level
   979 print "["
 
   995 set :processUnit.2:supply .SUPPLY_P_FIRST
   996 # "Function: inline def rebindUnit(in currentUnit)"
   997 set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * op notEqual *tmp331 :rebindUnit.6:currentUnit null
-    * jump *label267 equal *tmp331 false
+  998 jump *label267 equal :rebindUnit.6:currentUnit null
   999 ubind :rebindUnit.6:currentUnit
  1000 sensor *tmp333 @unit @dead
  1001 op equal *tmp334 *tmp333 0
 
  1012 label *label268
  1013 ubind .TYPE
  1014 set :rebindUnit.6:firstUnit @unit
-    * op notEqual *tmp339 :rebindUnit.6:firstUnit null
-    * jump *label271 equal *tmp339 false
+ 1015 jump *label271 equal :rebindUnit.6:firstUnit null
  1016 label *label273
  1017 sensor *tmp341 @unit @controlled
-    * op equal *tmp342 *tmp341 0
-    * jump *label276 equal *tmp342 false
+ 1018 jump *label276 notEqual *tmp341 0
  1019 jump *label266 always
  1020 jump *label277 always
  1021 label *label276
  1022 label *label277
  1023 ubind .TYPE
  1024 label *label274
-    * op notEqual *tmp344 @unit :rebindUnit.6:firstUnit
-    * jump *label275 equal *tmp344 false
+ 1025 jump *label275 equal @unit :rebindUnit.6:firstUnit
  1026 label *label278
  1027 sensor *tmp345 :rebindUnit.6:firstUnit @dead
-    * op equal *tmp346 *tmp345 0
-    * jump *label273 notEqual *tmp346 false
+ 1028 jump *label273 equal *tmp345 0
  1029 label *label275
  1030 jump *label272 always
  1031 label *label271
 
  1035 sensor :processUnit.2:state @unit @flag
  1036 set :processUnit.2:distance -1
  1037 set :processUnit.2:color "gold"
-    * op lessThan *tmp348 :processUnit.2:state 2
-    * jump *label281 notEqual *tmp348 false
+ 1038 jump *label281 lessThan :processUnit.2:state 2
  1039 label *label282
-    * op greaterThan *tmp349 :processUnit.2:state 3
-    * jump *label279 equal *tmp349 false
+ 1040 jump *label279 lessThanEq :processUnit.2:state 3
  1041 label *label281
  1042 sensor *tmp351 @unit @firstItem
-    * op equal *tmp352 *tmp351 :processUnit.2:item
-    * jump *label283 equal *tmp352 false
+ 1043 jump *label283 notEqual *tmp351 :processUnit.2:item
  1044 set :processUnit.2:state 3
  1045 jump *label284 always
  1046 label *label283
  1047 sensor *tmp354 @unit @totalItems
-    * op equal *tmp355 *tmp354 0
-    * jump *label285 equal *tmp355 false
+ 1048 jump *label285 notEqual *tmp354 0
  1049 set :processUnit.2:state 2
  1050 jump *label286 always
  1051 label *label285
 
  1062 jump *label280 always
  1063 label *label279
  1064 label *label280
-    * op equal *tmp359 :processUnit.2:state 2
-    * jump *label289 equal *tmp359 false
+ 1065 jump *label289 notEqual :processUnit.2:state 2
  1066 ucontrol within .CORE_X .CORE_Y 8 *tmp361
  1067 jump *label291 equal *tmp361 false
  1068 ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
  1069 sensor *tmp363 @unit @totalItems
-    * op greaterThanEq *tmp364 *tmp363 .UNIT_CAPACITY
-    * jump *label293 equal *tmp364 false
+ 1070 jump *label293 lessThan *tmp363 .UNIT_CAPACITY
  1071 ucontrol approach .DOME_X .DOME_Y 6
  1072 set :processUnit.2:state 3
  1073 jump *label294 always
 
  1089 jump *label290 always
  1090 label *label289
  1091 label *label290
-    * op equal *tmp373 :processUnit.2:state 3
-    * jump *label295 equal *tmp373 false
+ 1092 jump *label295 notEqual :processUnit.2:state 3
  1093 ucontrol within .DOME_X .DOME_Y 8 *tmp375
  1094 jump *label297 equal *tmp375 false
  1095 jump *label299 equal :processUnit.2:supply false
 
  1101 set .MSG ", waiting\n"
  1102 label *label300
  1103 sensor *tmp378 @unit @totalItems
-    * op lessThanEq *tmp379 *tmp378 0
-    * jump *label301 equal *tmp379 false
+ 1104 jump *label301 greaterThan *tmp378 0
  1105 ucontrol approach .CORE_X .CORE_Y 6
  1106 set :processUnit.2:state 2
  1107 jump *label302 always
 
  1133 print *tmp388
  1134 print "["
  1135 print "]"
-    * op greaterThanEq *tmp389 :processUnit.2:distance 0
-    * jump *label303 equal *tmp389 false
+ 1136 jump *label303 lessThan :processUnit.2:distance 0
  1137 print .MSG
  1138 print :processUnit.2:distance
  1139 print "["
 
  1155 set :processUnit.3:supply *tmp393
  1156 # "Function: inline def rebindUnit(in currentUnit)"
  1157 set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * op notEqual *tmp395 :rebindUnit.7:currentUnit null
-    * jump *label309 equal *tmp395 false
+ 1158 jump *label309 equal :rebindUnit.7:currentUnit null
  1159 ubind :rebindUnit.7:currentUnit
  1160 sensor *tmp397 @unit @dead
  1161 op equal *tmp398 *tmp397 0
 
  1172 label *label310
  1173 ubind .TYPE
  1174 set :rebindUnit.7:firstUnit @unit
-    * op notEqual *tmp403 :rebindUnit.7:firstUnit null
-    * jump *label313 equal *tmp403 false
+ 1175 jump *label313 equal :rebindUnit.7:firstUnit null
  1176 label *label315
  1177 sensor *tmp405 @unit @controlled
-    * op equal *tmp406 *tmp405 0
-    * jump *label318 equal *tmp406 false
+ 1178 jump *label318 notEqual *tmp405 0
  1179 jump *label308 always
  1180 jump *label319 always
  1181 label *label318
  1182 label *label319
  1183 ubind .TYPE
  1184 label *label316
-    * op notEqual *tmp408 @unit :rebindUnit.7:firstUnit
-    * jump *label317 equal *tmp408 false
+ 1185 jump *label317 equal @unit :rebindUnit.7:firstUnit
  1186 label *label320
  1187 sensor *tmp409 :rebindUnit.7:firstUnit @dead
-    * op equal *tmp410 *tmp409 0
-    * jump *label315 notEqual *tmp410 false
+ 1188 jump *label315 equal *tmp409 0
  1189 label *label317
  1190 jump *label314 always
  1191 label *label313
 
  1195 sensor :processUnit.3:state @unit @flag
  1196 set :processUnit.3:distance -1
  1197 set :processUnit.3:color "gold"
-    * op lessThan *tmp412 :processUnit.3:state 2
-    * jump *label323 notEqual *tmp412 false
+ 1198 jump *label323 lessThan :processUnit.3:state 2
  1199 label *label324
-    * op greaterThan *tmp413 :processUnit.3:state 3
-    * jump *label321 equal *tmp413 false
+ 1200 jump *label321 lessThanEq :processUnit.3:state 3
  1201 label *label323
  1202 sensor *tmp415 @unit @firstItem
-    * op equal *tmp416 *tmp415 :processUnit.3:item
-    * jump *label325 equal *tmp416 false
+ 1203 jump *label325 notEqual *tmp415 :processUnit.3:item
  1204 set :processUnit.3:state 3
  1205 jump *label326 always
  1206 label *label325
  1207 sensor *tmp418 @unit @totalItems
-    * op equal *tmp419 *tmp418 0
-    * jump *label327 equal *tmp419 false
+ 1208 jump *label327 notEqual *tmp418 0
  1209 set :processUnit.3:state 2
  1210 jump *label328 always
  1211 label *label327
 
  1222 jump *label322 always
  1223 label *label321
  1224 label *label322
-    * op equal *tmp423 :processUnit.3:state 2
-    * jump *label331 equal *tmp423 false
+ 1225 jump *label331 notEqual :processUnit.3:state 2
  1226 ucontrol within .CORE_X .CORE_Y 8 *tmp425
  1227 jump *label333 equal *tmp425 false
  1228 ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
  1229 sensor *tmp427 @unit @totalItems
-    * op greaterThanEq *tmp428 *tmp427 .UNIT_CAPACITY
-    * jump *label335 equal *tmp428 false
+ 1230 jump *label335 lessThan *tmp427 .UNIT_CAPACITY
  1231 ucontrol approach .DOME_X .DOME_Y 6
  1232 set :processUnit.3:state 3
  1233 jump *label336 always
 
  1249 jump *label332 always
  1250 label *label331
  1251 label *label332
-    * op equal *tmp437 :processUnit.3:state 3
-    * jump *label337 equal *tmp437 false
+ 1252 jump *label337 notEqual :processUnit.3:state 3
  1253 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1254 jump *label339 equal *tmp439 false
  1255 jump *label341 equal :processUnit.3:supply false
 
  1261 set .MSG ", waiting\n"
  1262 label *label342
  1263 sensor *tmp442 @unit @totalItems
-    * op lessThanEq *tmp443 *tmp442 0
-    * jump *label343 equal *tmp443 false
+ 1264 jump *label343 greaterThan *tmp442 0
  1265 ucontrol approach .CORE_X .CORE_Y 6
  1266 set :processUnit.3:state 2
  1267 jump *label344 always
 
  1293 print *tmp452
  1294 print "["
  1295 print "]"
-    * op greaterThanEq *tmp453 :processUnit.3:distance 0
-    * jump *label345 equal *tmp453 false
+ 1296 jump *label345 lessThan :processUnit.3:distance 0
  1297 print .MSG
  1298 print :processUnit.3:distance
  1299 print "["
 
  1326 print " "
  1327 print "ms"
  1328 printflush message1
-    * op notEqual *tmp463 .TYPE UNIT_TYPE
-    * jump *label349 equal *tmp463 false
+ 1329 jump *label349 equal .TYPE UNIT_TYPE
  1330 label *label352
-    * op greaterThan *tmp464 :unitCheck @time
-    * jump *label349 equal *tmp464 false
+ 1331 jump *label349 lessThanEq :unitCheck @time
  1332 jump *label351 always
  1333 label *label351
  1334 # "Function: inline def areUnitsAvailable(in type, in output)"
 
  1339 set :areUnitsAvailable.2:needed 0
  1340 ubind :areUnitsAvailable.2:type
  1341 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp467 :areUnitsAvailable.2:firstUnit null
-    * jump *label356 equal *tmp467 false
+ 1342 jump *label356 equal :areUnitsAvailable.2:firstUnit null
  1343 # "Function: inline def needsFourUnits(in unit)"
  1344 set :needsFourUnits.3:unit @unit
  1345 op sub *tmp470 .DOME_X .CORE_X
 
  1361 set :areUnitsAvailable.2:needed *tmp477
  1362 label *label361
  1363 sensor *tmp478 @unit @controlled
-    * op equal *tmp479 *tmp478 0
-    * jump *label366 notEqual *tmp479 false
+ 1364 jump *label366 equal *tmp478 0
  1365 label *label367
  1366 sensor *tmp480 @unit @controller
-    * op equal *tmp481 *tmp480 @this
-    * jump *label364 equal *tmp481 false
+ 1367 jump *label364 notEqual *tmp480 @this
  1368 label *label366
  1369 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * op greaterThanEq *tmp483 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
-    * jump *label368 equal *tmp483 false
+ 1370 jump *label368 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1371 set *tmp466 true
  1372 jump *label355 always
  1373 jump *label369 always
 
  1379 label *label365
  1380 ubind :areUnitsAvailable.2:type
  1381 label *label362
-    * op notEqual *tmp486 @unit :areUnitsAvailable.2:firstUnit
-    * jump *label363 equal *tmp486 false
+ 1382 jump *label363 equal @unit :areUnitsAvailable.2:firstUnit
  1383 label *label370
  1384 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
-    * op equal *tmp488 *tmp487 0
-    * jump *label361 notEqual *tmp488 false
+ 1385 jump *label361 equal *tmp487 0
  1386 label *label363
  1387 jump *label357 always
  1388 label *label356
 
  1395 print ","
  1396 print " free: "
  1397 print :areUnitsAvailable.2:free
-    * op greaterThan *tmp490 :areUnitsAvailable.2:needed 0
-    * jump *label373 equal *tmp490 false
+ 1398 jump *label373 lessThanEq :areUnitsAvailable.2:needed 0
  1399 print ", needed: "
  1400 print :areUnitsAvailable.2:needed
  1401 jump *label374 always
 
  1426 # "Function: noinline def locateCore(in type)"
  1427 ubind :locateCore:type
  1428 sensor *tmp494 @unit @controlled
-    * op equal *tmp495 *tmp494 0
-    * jump *label378 notEqual *tmp495 false
+ 1429 jump *label378 equal *tmp494 0
  1430 label *label379
  1431 sensor *tmp496 @unit @controller
-    * op equal *tmp497 *tmp496 @this
-    * jump *label376 equal *tmp497 false
+ 1432 jump *label376 notEqual *tmp496 @this
  1433 label *label378
  1434 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1435 jump *label377 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-83 instructions):
 
    34 call *label0 :locateCore*retaddr :locateCore*retval
    35 jump *label15 equal :locateCore*retval false
    36 jump *label1 always
-    * jump *label16 always
    37 label *label15
    38 label *label16
    39 label *label9
 
   101 jump *label39 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   102 set *tmp10 true
   103 jump *label26 always
-    * jump *label40 always
   104 label *label39
   105 label *label40
   106 jump *label36 always
 
   114 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
   115 jump *label32 equal *tmp31 0
   116 label *label34
-    * jump *label28 always
   117 label *label27
   118 label *label28
   119 jump *label42 equal :areUnitsAvailable:output false
 
   127 jump *label44 lessThanEq :areUnitsAvailable:needed 0
   128 print ", needed: "
   129 print :areUnitsAvailable:needed
-    * jump *label45 always
   130 label *label44
   131 label *label45
   132 print "\n"
-    * jump *label43 always
   133 label *label42
   134 label *label43
   135 set *tmp10 false
 
   139 jump *label24 equal *tmp10 false
   140 set *tmp9 UNIT_TYPE
   141 jump *label20 always
-    * jump *label25 always
   142 label *label24
   143 label *label25
   144 set :chooseUnitType:type @flare
 
   196 jump *label70 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   197 set *tmp40 true
   198 jump *label57 always
-    * jump *label71 always
   199 label *label70
   200 label *label71
   201 jump *label67 always
 
   209 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   210 jump *label63 equal *tmp61 0
   211 label *label65
-    * jump *label59 always
   212 label *label58
   213 label *label59
   214 jump *label73 equal :areUnitsAvailable.1:output false
 
   222 jump *label75 lessThanEq :areUnitsAvailable.1:needed 0
   223 print ", needed: "
   224 print :areUnitsAvailable.1:needed
-    * jump *label76 always
   225 label *label75
   226 label *label76
   227 print "\n"
-    * jump *label74 always
   228 label *label73
   229 label *label74
   230 set *tmp40 false
 
   235 printflush null
   236 set *tmp9 :chooseUnitType:type
   237 jump *label20 always
-    * jump *label56 always
   238 label *label55
   239 label *label56
-    * jump *label54 always
   240 label *label53
   241 label *label54
   242 label *label47
 
   262 set :rebindUnits:firstUnit @unit
   263 jump *label78 notEqual :rebindUnits:firstUnit null
   264 end
-    * jump *label79 always
   265 label *label78
   266 label *label79
   267 label *label80
 
   275 set .UNIT_P1 @unit
   276 jump *label85 equal .UNIT_S2 null
   277 jump *label82 always
-    * jump *label86 always
   278 label *label85
   279 label *label86
-    * jump *label84 always
   280 label *label83
   281 label *label84
   282 ubind .TYPE
 
   286 sensor *tmp78 :rebindUnits:firstUnit @dead
   287 jump *label80 equal *tmp78 0
   288 label *label82
-    * jump *label77 always
   289 label *label77
   290 # "Function: inline def acquireUnit(in currentUnit)"
   291 set :acquireUnit:currentUnit .UNIT_S1
 
   300 op land *tmp88 *tmp85 *tmp87
   301 jump *label92 equal *tmp88 false
   302 jump *label89 always
-    * jump *label93 always
   303 label *label92
   304 label *label93
-    * jump *label91 always
   305 label *label90
   306 label *label91
   307 ubind .TYPE
 
   311 sensor *tmp92 @unit @controlled
   312 jump *label99 notEqual *tmp92 0
   313 jump *label89 always
-    * jump *label100 always
   314 label *label99
   315 label *label100
   316 ubind .TYPE
 
   320 sensor *tmp96 :rebindUnit:firstUnit @dead
   321 jump *label96 equal *tmp96 0
   322 label *label98
-    * jump *label95 always
   323 label *label94
   324 label *label95
   325 end
 
   343 op land *tmp106 *tmp103 *tmp105
   344 jump *label106 equal *tmp106 false
   345 jump *label103 always
-    * jump *label107 always
   346 label *label106
   347 label *label107
-    * jump *label105 always
   348 label *label104
   349 label *label105
   350 ubind .TYPE
 
   354 sensor *tmp110 @unit @controlled
   355 jump *label113 notEqual *tmp110 0
   356 jump *label103 always
-    * jump *label114 always
   357 label *label113
   358 label *label114
   359 ubind .TYPE
 
   363 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   364 jump *label110 equal *tmp114 0
   365 label *label112
-    * jump *label109 always
   366 label *label108
   367 label *label109
   368 end
 
   388 label *label120
   389 set .UNIT_S1 :swap:a
   390 set .UNIT_P1 :swap:b
-    * jump *label117 always
   391 label *label116
   392 label *label117
   393 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   396 op strictEqual *tmp124 .SPEED null
   397 jump *label121 equal *tmp124 false
   398 stop
-    * jump *label122 always
   399 label *label121
   400 label *label122
   401 # "Function: inline def needsFourUnits(in unit)"
 
   425 op land *tmp143 *tmp140 *tmp142
   426 jump *label130 equal *tmp143 false
   427 jump *label127 always
-    * jump *label131 always
   428 label *label130
   429 label *label131
-    * jump *label129 always
   430 label *label128
   431 label *label129
   432 ubind .TYPE
 
   436 sensor *tmp147 @unit @controlled
   437 jump *label137 notEqual *tmp147 0
   438 jump *label127 always
-    * jump *label138 always
   439 label *label137
   440 label *label138
   441 ubind .TYPE
 
   445 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   446 jump *label134 equal *tmp151 0
   447 label *label136
-    * jump *label133 always
   448 label *label132
   449 label *label133
   450 end
 
   468 op land *tmp161 *tmp158 *tmp160
   469 jump *label144 equal *tmp161 false
   470 jump *label141 always
-    * jump *label145 always
   471 label *label144
   472 label *label145
-    * jump *label143 always
   473 label *label142
   474 label *label143
   475 ubind .TYPE
 
   479 sensor *tmp165 @unit @controlled
   480 jump *label151 notEqual *tmp165 0
   481 jump *label141 always
-    * jump *label152 always
   482 label *label151
   483 label *label152
   484 ubind .TYPE
 
   488 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   489 jump *label148 equal *tmp169 0
   490 label *label150
-    * jump *label147 always
   491 label *label146
   492 label *label147
   493 end
 
   503 label *label157
   504 sensor *tmp173 .UNIT_P2 @firstItem
   505 jump *label154 equal *tmp173 @phase-fabric
-    * jump *label156 always
   506 label *label156
   507 # "Function: inline void swap(in out a, in out b)"
   508 set :swap.1:a .UNIT_S1
 
   513 label *label158
   514 set .UNIT_S1 :swap.1:a
   515 set .UNIT_P2 :swap.1:b
-    * jump *label155 always
   516 label *label154
   517 label *label155
   518 sensor *tmp176 .UNIT_S2 @firstItem
 
   530 label *label163
   531 set .UNIT_S2 :swap.2:a
   532 set .UNIT_P2 :swap.2:b
-    * jump *label160 always
   533 label *label159
   534 label *label160
   535 set .GROUP1 "unit  1"
 
   617 op land *tmp203 *tmp200 *tmp202
   618 jump *label182 equal *tmp203 false
   619 jump *label179 always
-    * jump *label183 always
   620 label *label182
   621 label *label183
-    * jump *label181 always
   622 label *label180
   623 label *label181
   624 ubind .TYPE
 
   628 sensor *tmp207 @unit @controlled
   629 jump *label189 notEqual *tmp207 0
   630 jump *label179 always
-    * jump *label190 always
   631 label *label189
   632 label *label190
   633 ubind .TYPE
 
   637 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   638 jump *label186 equal *tmp211 0
   639 label *label188
-    * jump *label185 always
   640 label *label184
   641 label *label185
   642 end
 
   663 ucontrol within .CORE_X .CORE_Y 8 *tmp223
   664 jump *label200 equal *tmp223 false
   665 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label201 always
   666 label *label200
   667 label *label201
   668 label *label199
   669 label *label197
-    * jump *label193 always
   670 label *label192
   671 label *label193
   672 jump *label202 notEqual :processUnit:state 2
 
   693 op idiv *tmp237 *tmp236 .SPEED_TENTHS
   694 op div :processUnit:distance *tmp237 10
   695 label *label205
-    * jump *label203 always
   696 label *label202
   697 label *label203
   698 jump *label208 notEqual :processUnit:state 3
 
   710 jump *label214 greaterThan *tmp244 0
   711 ucontrol approach .CORE_X .CORE_Y 6
   712 set :processUnit:state 2
-    * jump *label215 always
   713 label *label214
   714 label *label215
   715 jump *label211 always
 
   724 op idiv *tmp252 *tmp251 .SPEED_TENTHS
   725 op div :processUnit:distance *tmp252 10
   726 label *label211
-    * jump *label209 always
   727 label *label208
   728 label *label209
   729 ucontrol flag :processUnit:state
 
   768 op land *tmp267 *tmp264 *tmp266
   769 jump *label224 equal *tmp267 false
   770 jump *label221 always
-    * jump *label225 always
   771 label *label224
   772 label *label225
-    * jump *label223 always
   773 label *label222
   774 label *label223
   775 ubind .TYPE
 
   779 sensor *tmp271 @unit @controlled
   780 jump *label231 notEqual *tmp271 0
   781 jump *label221 always
-    * jump *label232 always
   782 label *label231
   783 label *label232
   784 ubind .TYPE
 
   788 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   789 jump *label228 equal *tmp275 0
   790 label *label230
-    * jump *label227 always
   791 label *label226
   792 label *label227
   793 end
 
   814 ucontrol within .CORE_X .CORE_Y 8 *tmp287
   815 jump *label242 equal *tmp287 false
   816 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label243 always
   817 label *label242
   818 label *label243
   819 label *label241
   820 label *label239
-    * jump *label235 always
   821 label *label234
   822 label *label235
   823 jump *label244 notEqual :processUnit.1:state 2
 
   844 op idiv *tmp301 *tmp300 .SPEED_TENTHS
   845 op div :processUnit.1:distance *tmp301 10
   846 label *label247
-    * jump *label245 always
   847 label *label244
   848 label *label245
   849 jump *label250 notEqual :processUnit.1:state 3
 
   861 jump *label256 greaterThan *tmp308 0
   862 ucontrol approach .CORE_X .CORE_Y 6
   863 set :processUnit.1:state 2
-    * jump *label257 always
   864 label *label256
   865 label *label257
   866 jump *label253 always
 
   875 op idiv *tmp316 *tmp315 .SPEED_TENTHS
   876 op div :processUnit.1:distance *tmp316 10
   877 label *label253
-    * jump *label251 always
   878 label *label250
   879 label *label251
   880 ucontrol flag :processUnit.1:state
 
   910 op equal *tmp322 *tmp325 0
   911 label *label261
   912 set .SUPPLY_S_FIRST *tmp322
-    * jump *label219 always
   913 label *label218
   914 label *label219
   915 # "Function: inline void printDomeStatus(in item, in text)"
 
   948 op land *tmp337 *tmp334 *tmp336
   949 jump *label269 equal *tmp337 false
   950 jump *label266 always
-    * jump *label270 always
   951 label *label269
   952 label *label270
-    * jump *label268 always
   953 label *label267
   954 label *label268
   955 ubind .TYPE
 
   959 sensor *tmp341 @unit @controlled
   960 jump *label276 notEqual *tmp341 0
   961 jump *label266 always
-    * jump *label277 always
   962 label *label276
   963 label *label277
   964 ubind .TYPE
 
   968 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   969 jump *label273 equal *tmp345 0
   970 label *label275
-    * jump *label272 always
   971 label *label271
   972 label *label272
   973 end
 
   994 ucontrol within .CORE_X .CORE_Y 8 *tmp357
   995 jump *label287 equal *tmp357 false
   996 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label288 always
   997 label *label287
   998 label *label288
   999 label *label286
  1000 label *label284
-    * jump *label280 always
  1001 label *label279
  1002 label *label280
  1003 jump *label289 notEqual :processUnit.2:state 2
 
  1024 op idiv *tmp371 *tmp370 .SPEED_TENTHS
  1025 op div :processUnit.2:distance *tmp371 10
  1026 label *label292
-    * jump *label290 always
  1027 label *label289
  1028 label *label290
  1029 jump *label295 notEqual :processUnit.2:state 3
 
  1041 jump *label301 greaterThan *tmp378 0
  1042 ucontrol approach .CORE_X .CORE_Y 6
  1043 set :processUnit.2:state 2
-    * jump *label302 always
  1044 label *label301
  1045 label *label302
  1046 jump *label298 always
 
  1055 op idiv *tmp386 *tmp385 .SPEED_TENTHS
  1056 op div :processUnit.2:distance *tmp386 10
  1057 label *label298
-    * jump *label296 always
  1058 label *label295
  1059 label *label296
  1060 ucontrol flag :processUnit.2:state
 
  1099 op land *tmp401 *tmp398 *tmp400
  1100 jump *label311 equal *tmp401 false
  1101 jump *label308 always
-    * jump *label312 always
  1102 label *label311
  1103 label *label312
-    * jump *label310 always
  1104 label *label309
  1105 label *label310
  1106 ubind .TYPE
 
  1110 sensor *tmp405 @unit @controlled
  1111 jump *label318 notEqual *tmp405 0
  1112 jump *label308 always
-    * jump *label319 always
  1113 label *label318
  1114 label *label319
  1115 ubind .TYPE
 
  1119 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1120 jump *label315 equal *tmp409 0
  1121 label *label317
-    * jump *label314 always
  1122 label *label313
  1123 label *label314
  1124 end
 
  1145 ucontrol within .CORE_X .CORE_Y 8 *tmp421
  1146 jump *label329 equal *tmp421 false
  1147 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label330 always
  1148 label *label329
  1149 label *label330
  1150 label *label328
  1151 label *label326
-    * jump *label322 always
  1152 label *label321
  1153 label *label322
  1154 jump *label331 notEqual :processUnit.3:state 2
 
  1175 op idiv *tmp435 *tmp434 .SPEED_TENTHS
  1176 op div :processUnit.3:distance *tmp435 10
  1177 label *label334
-    * jump *label332 always
  1178 label *label331
  1179 label *label332
  1180 jump *label337 notEqual :processUnit.3:state 3
 
  1192 jump *label343 greaterThan *tmp442 0
  1193 ucontrol approach .CORE_X .CORE_Y 6
  1194 set :processUnit.3:state 2
-    * jump *label344 always
  1195 label *label343
  1196 label *label344
  1197 jump *label340 always
 
  1206 op idiv *tmp450 *tmp449 .SPEED_TENTHS
  1207 op div :processUnit.3:distance *tmp450 10
  1208 label *label340
-    * jump *label338 always
  1209 label *label337
  1210 label *label338
  1211 ucontrol flag :processUnit.3:state
 
  1241 op equal *tmp456 *tmp459 0
  1242 label *label348
  1243 set .SUPPLY_P_FIRST *tmp456
-    * jump *label306 always
  1244 label *label305
  1245 label *label306
  1246 op sub *tmp461 @time :start
 
  1254 jump *label349 equal .TYPE UNIT_TYPE
  1255 label *label352
  1256 jump *label349 lessThanEq :unitCheck @time
-    * jump *label351 always
  1257 label *label351
  1258 # "Function: inline def areUnitsAvailable(in type, in output)"
  1259 set :areUnitsAvailable.2:type UNIT_TYPE
 
  1294 jump *label368 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1295 set *tmp466 true
  1296 jump *label355 always
-    * jump *label369 always
  1297 label *label368
  1298 label *label369
  1299 jump *label365 always
 
  1307 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1308 jump *label361 equal *tmp487 0
  1309 label *label363
-    * jump *label357 always
  1310 label *label356
  1311 label *label357
  1312 jump *label371 equal :areUnitsAvailable.2:output false
 
  1320 jump *label373 lessThanEq :areUnitsAvailable.2:needed 0
  1321 print ", needed: "
  1322 print :areUnitsAvailable.2:needed
-    * jump *label374 always
  1323 label *label373
  1324 label *label374
  1325 print "\n"
-    * jump *label372 always
  1326 label *label371
  1327 label *label372
  1328 set *tmp466 false
 
  1331 label *label355
  1332 jump *label353 equal *tmp466 false
  1333 end
-    * jump *label354 always
  1334 label *label353
  1335 label *label354
  1336 op add :unitCheck @time 5000
-    * jump *label350 always
  1337 label *label349
  1338 label *label350
  1339 label *label173
 
  1350 jump *label376 notEqual *tmp496 @this
  1351 label *label378
  1352 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
-    * jump *label377 always
  1353 label *label376
  1354 label *label377
  1355 set :locateCore*retval .CORE

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-11 instructions):
 
    68 set :areUnitsAvailable:free 0
    69 set :areUnitsAvailable:occupied 0
    70 set :areUnitsAvailable:needed 0
-    * ubind :areUnitsAvailable:type
+   71 ubind UNIT_TYPE
    72 set :areUnitsAvailable:firstUnit @unit
    73 jump *label27 equal :areUnitsAvailable:firstUnit null
    74 # "Function: inline def needsFourUnits(in unit)"
 
    81 op div :needsFourUnits:travel_time *tmp17 *tmp18
    82 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    83 jump *label31 always
-    * set *tmp13 null
    84 label *label31
    85 jump *label29 equal *tmp13 false
    86 set *tmp21 4
 
    97 jump *label35 notEqual *tmp24 @this
    98 label *label37
    99 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label39 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
+  100 jump *label39 lessThan :areUnitsAvailable:free *tmp21
   101 set *tmp10 true
   102 jump *label26 always
   103 label *label39
 
   106 label *label35
   107 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   108 label *label36
-    * ubind :areUnitsAvailable:type
+  109 ubind UNIT_TYPE
   110 label *label33
   111 jump *label34 equal @unit :areUnitsAvailable:firstUnit
   112 label *label41
 
   115 label *label34
   116 label *label27
   117 label *label28
-    * jump *label42 equal :areUnitsAvailable:output false
-    * print :areUnitsAvailable:type
+  118 jump *label42 equal true false
+  119 print UNIT_TYPE
   120 print ":"
   121 print " occupied: "
   122 print :areUnitsAvailable:occupied
 
   133 label *label43
   134 set *tmp10 false
   135 jump *label26 always
-    * set *tmp10 null
   136 label *label26
   137 jump *label24 equal *tmp10 false
   138 set *tmp9 UNIT_TYPE
 
   161 set :areUnitsAvailable.1:free 0
   162 set :areUnitsAvailable.1:occupied 0
   163 set :areUnitsAvailable.1:needed 0
-    * ubind :areUnitsAvailable.1:type
+  164 ubind :chooseUnitType:type
   165 set :areUnitsAvailable.1:firstUnit @unit
   166 jump *label58 equal :areUnitsAvailable.1:firstUnit null
   167 # "Function: inline def needsFourUnits(in unit)"
 
   174 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   175 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   176 jump *label62 always
-    * set *tmp43 null
   177 label *label62
   178 jump *label60 equal *tmp43 false
   179 set *tmp51 4
 
   190 jump *label66 notEqual *tmp54 @this
   191 label *label68
   192 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label70 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  193 jump *label70 lessThan :areUnitsAvailable.1:free *tmp51
   194 set *tmp40 true
   195 jump *label57 always
   196 label *label70
 
   199 label *label66
   200 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   201 label *label67
-    * ubind :areUnitsAvailable.1:type
+  202 ubind :chooseUnitType:type
   203 label *label64
   204 jump *label65 equal @unit :areUnitsAvailable.1:firstUnit
   205 label *label72
 
   208 label *label65
   209 label *label58
   210 label *label59
-    * jump *label73 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  211 jump *label73 equal true false
+  212 print :chooseUnitType:type
   213 print ":"
   214 print " occupied: "
   215 print :areUnitsAvailable.1:occupied
 
   226 label *label74
   227 set *tmp40 false
   228 jump *label57 always
-    * set *tmp40 null
   229 label *label57
   230 jump *label55 equal *tmp40 false
   231 printflush null
 
   250 printflush message1
   251 # "Function: inline def rebindUnits()"
   252 set .UNIT_P2 null
-    * set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P1 .UNIT_S2
-    * set .UNIT_S1 .UNIT_P1
+  253 set .UNIT_S2 null
+  254 set .UNIT_P1 .UNIT_P2
+  255 set .UNIT_S1 .UNIT_S2
   256 set :rebindUnits:count 0
-    * ubind .TYPE
+  257 ubind *tmp9
   258 set :rebindUnits:firstUnit @unit
   259 jump *label78 notEqual :rebindUnits:firstUnit null
   260 end
 
   275 label *label86
   276 label *label83
   277 label *label84
-    * ubind .TYPE
+  278 ubind *tmp9
   279 label *label81
   280 jump *label82 equal @unit :rebindUnits:firstUnit
   281 label *label87
 
   286 # "Function: inline def acquireUnit(in currentUnit)"
   287 set :acquireUnit:currentUnit .UNIT_S1
   288 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * jump *label90 equal :rebindUnit:currentUnit null
-    * ubind :rebindUnit:currentUnit
+  289 set :rebindUnit:currentUnit .UNIT_S1
+  290 jump *label90 equal :acquireUnit:currentUnit null
+  291 ubind :acquireUnit:currentUnit
   292 sensor *tmp84 @unit @dead
   293 op equal *tmp85 *tmp84 0
   294 sensor *tmp86 @unit @controller
 
   300 label *label93
   301 label *label90
   302 label *label91
-    * ubind .TYPE
+  303 ubind *tmp9
   304 set :rebindUnit:firstUnit @unit
   305 jump *label94 equal :rebindUnit:firstUnit null
   306 label *label96
 
   309 jump *label89 always
   310 label *label99
   311 label *label100
-    * ubind .TYPE
+  312 ubind *tmp9
   313 label *label97
   314 jump *label98 equal @unit :rebindUnit:firstUnit
   315 label *label101
 
   323 ucontrol flag 1
   324 set *tmp80 @unit
   325 jump *label88 always
-    * set *tmp80 null
   326 label *label88
   327 set .UNIT_S1 *tmp80
   328 # "Function: inline def acquireUnit(in currentUnit)"
   329 set :acquireUnit.1:currentUnit .UNIT_P1
   330 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * jump *label104 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  331 set :rebindUnit.1:currentUnit .UNIT_P1
+  332 jump *label104 equal :acquireUnit.1:currentUnit null
+  333 ubind :acquireUnit.1:currentUnit
   334 sensor *tmp102 @unit @dead
   335 op equal *tmp103 *tmp102 0
   336 sensor *tmp104 @unit @controller
 
   342 label *label107
   343 label *label104
   344 label *label105
-    * ubind .TYPE
+  345 ubind *tmp9
   346 set :rebindUnit.1:firstUnit @unit
   347 jump *label108 equal :rebindUnit.1:firstUnit null
   348 label *label110
 
   351 jump *label103 always
   352 label *label113
   353 label *label114
-    * ubind .TYPE
+  354 ubind *tmp9
   355 label *label111
   356 jump *label112 equal @unit :rebindUnit.1:firstUnit
   357 label *label115
 
   365 ucontrol flag 1
   366 set *tmp98 @unit
   367 jump *label102 always
-    * set *tmp98 null
   368 label *label102
   369 set .UNIT_P1 *tmp98
-    * sensor *tmp116 .UNIT_S1 @firstItem
+  370 sensor *tmp116 *tmp80 @firstItem
   371 jump *label118 equal *tmp116 @phase-fabric
   372 label *label119
-    * sensor *tmp118 .UNIT_P1 @firstItem
+  373 sensor *tmp118 *tmp98 @firstItem
   374 jump *label116 notEqual *tmp118 @silicon
   375 label *label118
   376 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:a .UNIT_S1
-    * set :swap:b .UNIT_P1
-    * set :swap:t :swap:a
-    * set :swap:a :swap:b
+  377 set :swap:a *tmp80
+  378 set :swap:b *tmp98
+  379 set :swap:t .UNIT_S1
+  380 set :swap:a .UNIT_P1
   381 set :swap:b :swap:t
   382 label *label120
   383 set .UNIT_S1 :swap:a
-    * set .UNIT_P1 :swap:b
+  384 set .UNIT_P1 :swap:t
   385 label *label116
   386 label *label117
   387 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   398 op sub *tmp128 .DOME_Y .CORE_Y
   399 op len *tmp129 *tmp127 *tmp128
   400 op mul *tmp130 2 *tmp129
-    * sensor *tmp131 :needsFourUnits.2:unit @speed
-    * op div :needsFourUnits.2:travel_time *tmp130 *tmp131
+  401 sensor *tmp131 .UNIT_S1 @speed
+  402 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   403 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   404 jump *label123 always
-    * set *tmp126 null
   405 label *label123
   406 set .FOUR_UNITS *tmp126
-    * jump *label124 equal .FOUR_UNITS false
+  407 jump *label124 equal *tmp126 false
   408 # "Function: inline def acquireUnit(in currentUnit)"
   409 set :acquireUnit.2:currentUnit .UNIT_S2
   410 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * jump *label128 equal :rebindUnit.2:currentUnit null
-    * ubind :rebindUnit.2:currentUnit
+  411 set :rebindUnit.2:currentUnit .UNIT_S2
+  412 jump *label128 equal :acquireUnit.2:currentUnit null
+  413 ubind :acquireUnit.2:currentUnit
   414 sensor *tmp139 @unit @dead
   415 op equal *tmp140 *tmp139 0
   416 sensor *tmp141 @unit @controller
 
   422 label *label131
   423 label *label128
   424 label *label129
-    * ubind .TYPE
+  425 ubind *tmp9
   426 set :rebindUnit.2:firstUnit @unit
   427 jump *label132 equal :rebindUnit.2:firstUnit null
   428 label *label134
 
   431 jump *label127 always
   432 label *label137
   433 label *label138
-    * ubind .TYPE
+  434 ubind *tmp9
   435 label *label135
   436 jump *label136 equal @unit :rebindUnit.2:firstUnit
   437 label *label139
 
   445 ucontrol flag 1
   446 set *tmp135 @unit
   447 jump *label126 always
-    * set *tmp135 null
   448 label *label126
   449 set .UNIT_S2 *tmp135
   450 # "Function: inline def acquireUnit(in currentUnit)"
   451 set :acquireUnit.3:currentUnit .UNIT_P2
   452 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * jump *label142 equal :rebindUnit.3:currentUnit null
-    * ubind :rebindUnit.3:currentUnit
+  453 set :rebindUnit.3:currentUnit .UNIT_P2
+  454 jump *label142 equal :acquireUnit.3:currentUnit null
+  455 ubind :acquireUnit.3:currentUnit
   456 sensor *tmp157 @unit @dead
   457 op equal *tmp158 *tmp157 0
   458 sensor *tmp159 @unit @controller
 
   464 label *label145
   465 label *label142
   466 label *label143
-    * ubind .TYPE
+  467 ubind *tmp9
   468 set :rebindUnit.3:firstUnit @unit
   469 jump *label146 equal :rebindUnit.3:firstUnit null
   470 label *label148
 
   473 jump *label141 always
   474 label *label151
   475 label *label152
-    * ubind .TYPE
+  476 ubind *tmp9
   477 label *label149
   478 jump *label150 equal @unit :rebindUnit.3:firstUnit
   479 label *label153
 
   487 ucontrol flag 1
   488 set *tmp153 @unit
   489 jump *label140 always
-    * set *tmp153 null
   490 label *label140
   491 set .UNIT_P2 *tmp153
   492 sensor *tmp171 .UNIT_S1 @firstItem
   493 jump *label154 notEqual *tmp171 @phase-fabric
   494 label *label157
-    * sensor *tmp173 .UNIT_P2 @firstItem
+  495 sensor *tmp173 *tmp153 @firstItem
   496 jump *label154 equal *tmp173 @phase-fabric
   497 label *label156
   498 # "Function: inline void swap(in out a, in out b)"
   499 set :swap.1:a .UNIT_S1
-    * set :swap.1:b .UNIT_P2
-    * set :swap.1:t :swap.1:a
-    * set :swap.1:a :swap.1:b
+  500 set :swap.1:b *tmp153
+  501 set :swap.1:t .UNIT_S1
+  502 set :swap.1:a .UNIT_P2
   503 set :swap.1:b :swap.1:t
   504 label *label158
   505 set .UNIT_S1 :swap.1:a
-    * set .UNIT_P2 :swap.1:b
+  506 set .UNIT_P2 :swap.1:t
   507 label *label154
   508 label *label155
-    * sensor *tmp176 .UNIT_S2 @firstItem
+  509 sensor *tmp176 *tmp135 @firstItem
   510 jump *label161 equal *tmp176 @phase-fabric
   511 label *label162
   512 sensor *tmp178 .UNIT_P2 @firstItem
   513 jump *label159 notEqual *tmp178 @silicon
   514 label *label161
   515 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:a .UNIT_S2
+  516 set :swap.2:a *tmp135
   517 set :swap.2:b .UNIT_P2
-    * set :swap.2:t :swap.2:a
-    * set :swap.2:a :swap.2:b
+  518 set :swap.2:t .UNIT_S2
+  519 set :swap.2:a .UNIT_P2
   520 set :swap.2:b :swap.2:t
   521 label *label163
   522 set .UNIT_S2 :swap.2:a
-    * set .UNIT_P2 :swap.2:b
+  523 set .UNIT_P2 :swap.2:t
   524 label *label159
   525 label *label160
   526 set .GROUP1 "unit  1"
 
   535 set .UNIT_P2 null
   536 set .GROUP1 "unit"
   537 label *label125
-    * jump *label166 equal .FOUR_UNITS false
+  538 jump *label166 equal *tmp126 false
   539 label *label167
   540 sensor *tmp182 .UNIT_S1 @totalItems
   541 sensor *tmp183 .UNIT_S2 @totalItems
 
   547 set *tmp185 false
   548 label *label165
   549 set .SUPPLY_S_FIRST *tmp185
-    * jump *label170 equal .FOUR_UNITS false
+  550 jump *label170 equal *tmp126 false
   551 label *label171
   552 sensor *tmp187 .UNIT_P1 @totalItems
   553 sensor *tmp188 .UNIT_P2 @totalItems
 
   568 print "\n"
   569 print "\n"
   570 print "Unit type: [green]"
-    * print .TYPE
+  571 print *tmp9
   572 print "["
   573 print "]"
   574 print "\n"
   575 # "Function: inline void printDomeStatus(in item, in text)"
   576 set :printDomeStatus:item @silicon
   577 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
-    * print :printDomeStatus:text
-    * sensor :printDomeStatus:level .DOME :printDomeStatus:item
+  578 print "\n[green]Silicon[] status:\n"
+  579 sensor :printDomeStatus:level .DOME @silicon
   580 jump *label176 lessThanEq :printDomeStatus:level 3
   581 print "  dome:  [green]"
   582 print :printDomeStatus:level
 
   598 set :processUnit:group .GROUP1
   599 set :processUnit:supply .SUPPLY_S_FIRST
   600 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit :processUnit:unit
-    * jump *label180 equal :rebindUnit.4:currentUnit null
-    * ubind :rebindUnit.4:currentUnit
+  601 set :rebindUnit.4:currentUnit .UNIT_S1
+  602 jump *label180 equal :processUnit:unit null
+  603 ubind :processUnit:unit
   604 sensor *tmp199 @unit @dead
   605 op equal *tmp200 *tmp199 0
   606 sensor *tmp201 @unit @controller
 
   612 label *label183
   613 label *label180
   614 label *label181
-    * ubind .TYPE
+  615 ubind *tmp9
   616 set :rebindUnit.4:firstUnit @unit
   617 jump *label184 equal :rebindUnit.4:firstUnit null
   618 label *label186
 
   621 jump *label179 always
   622 label *label189
   623 label *label190
-    * ubind .TYPE
+  624 ubind *tmp9
   625 label *label187
   626 jump *label188 equal @unit :rebindUnit.4:firstUnit
   627 label *label191
 
   640 jump *label192 lessThanEq :processUnit:state 3
   641 label *label194
   642 sensor *tmp217 @unit @firstItem
-    * jump *label196 notEqual *tmp217 :processUnit:item
+  643 jump *label196 notEqual *tmp217 @silicon
   644 set :processUnit:state 3
   645 jump *label197 always
   646 label *label196
 
   663 jump *label202 notEqual :processUnit:state 2
   664 ucontrol within .CORE_X .CORE_Y 8 *tmp227
   665 jump *label204 equal *tmp227 false
-    * ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
+  666 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   667 sensor *tmp229 @unit @totalItems
   668 jump *label206 lessThan *tmp229 .UNIT_CAPACITY
   669 ucontrol approach .DOME_X .DOME_Y 6
 
   689 jump *label208 notEqual :processUnit:state 3
   690 ucontrol within .DOME_X .DOME_Y 8 *tmp241
   691 jump *label210 equal *tmp241 false
-    * jump *label212 equal :processUnit:supply false
+  692 jump *label212 equal .SUPPLY_S_FIRST false
   693 ucontrol itemDrop .DOME .UNIT_CAPACITY
   694 set .MSG ", supplying\n"
   695 jump *label213 always
 
   720 ucontrol flag :processUnit:state
   721 sensor *tmp254 @unit @totalItems
   722 print "  "
-    * print :processUnit:group
+  723 print .GROUP1
   724 print ":"
   725 print " ["
-    * print :processUnit:color
+  726 print "gold"
   727 print "]"
   728 print *tmp254
   729 print "["
 
   741 set :processUnit:unit @unit
   742 label *label178
   743 set .UNIT_S1 :processUnit:unit
-    * jump *label218 equal .FOUR_UNITS false
+  744 jump *label218 equal *tmp126 false
   745 op equal *tmp259 .SUPPLY_S_FIRST false
   746 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   747 set :processUnit.1:unit .UNIT_S2
 
   749 set :processUnit.1:group .GROUP2
   750 set :processUnit.1:supply *tmp259
   751 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * jump *label222 equal :rebindUnit.5:currentUnit null
-    * ubind :rebindUnit.5:currentUnit
+  752 set :rebindUnit.5:currentUnit .UNIT_S2
+  753 jump *label222 equal :processUnit.1:unit null
+  754 ubind :processUnit.1:unit
   755 sensor *tmp263 @unit @dead
   756 op equal *tmp264 *tmp263 0
   757 sensor *tmp265 @unit @controller
 
   763 label *label225
   764 label *label222
   765 label *label223
-    * ubind .TYPE
+  766 ubind *tmp9
   767 set :rebindUnit.5:firstUnit @unit
   768 jump *label226 equal :rebindUnit.5:firstUnit null
   769 label *label228
 
   772 jump *label221 always
   773 label *label231
   774 label *label232
-    * ubind .TYPE
+  775 ubind *tmp9
   776 label *label229
   777 jump *label230 equal @unit :rebindUnit.5:firstUnit
   778 label *label233
 
   791 jump *label234 lessThanEq :processUnit.1:state 3
   792 label *label236
   793 sensor *tmp281 @unit @firstItem
-    * jump *label238 notEqual *tmp281 :processUnit.1:item
+  794 jump *label238 notEqual *tmp281 @silicon
   795 set :processUnit.1:state 3
   796 jump *label239 always
   797 label *label238
 
   814 jump *label244 notEqual :processUnit.1:state 2
   815 ucontrol within .CORE_X .CORE_Y 8 *tmp291
   816 jump *label246 equal *tmp291 false
-    * ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
+  817 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   818 sensor *tmp293 @unit @totalItems
   819 jump *label248 lessThan *tmp293 .UNIT_CAPACITY
   820 ucontrol approach .DOME_X .DOME_Y 6
 
   840 jump *label250 notEqual :processUnit.1:state 3
   841 ucontrol within .DOME_X .DOME_Y 8 *tmp305
   842 jump *label252 equal *tmp305 false
-    * jump *label254 equal :processUnit.1:supply false
+  843 jump *label254 equal *tmp259 false
   844 ucontrol itemDrop .DOME .UNIT_CAPACITY
   845 set .MSG ", supplying\n"
   846 jump *label255 always
 
   871 ucontrol flag :processUnit.1:state
   872 sensor *tmp318 @unit @totalItems
   873 print "  "
-    * print :processUnit.1:group
+  874 print .GROUP2
   875 print ":"
   876 print " ["
-    * print :processUnit.1:color
+  877 print "gold"
   878 print "]"
   879 print *tmp318
   880 print "["
 
   893 label *label220
   894 set .UNIT_S2 :processUnit.1:unit
   895 jump *label260 equal .SUPPLY_S_FIRST false
-    * sensor *tmp323 .UNIT_S1 @totalItems
+  896 sensor *tmp323 :processUnit:unit @totalItems
   897 op greaterThan *tmp322 *tmp323 0
   898 jump *label261 always
   899 label *label260
-    * sensor *tmp325 .UNIT_S2 @totalItems
+  900 sensor *tmp325 :processUnit.1:unit @totalItems
   901 op equal *tmp322 *tmp325 0
   902 label *label261
   903 set .SUPPLY_S_FIRST *tmp322
 
   906 # "Function: inline void printDomeStatus(in item, in text)"
   907 set :printDomeStatus.1:item @phase-fabric
   908 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
-    * print :printDomeStatus.1:text
-    * sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
+  909 print "\n[green]Phase fabric[] status:\n"
+  910 sensor :printDomeStatus.1:level .DOME @phase-fabric
   911 jump *label263 lessThanEq :printDomeStatus.1:level 3
   912 print "  dome:  [green]"
   913 print :printDomeStatus.1:level
 
   929 set :processUnit.2:group .GROUP1
   930 set :processUnit.2:supply .SUPPLY_P_FIRST
   931 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * jump *label267 equal :rebindUnit.6:currentUnit null
-    * ubind :rebindUnit.6:currentUnit
+  932 set :rebindUnit.6:currentUnit .UNIT_P1
+  933 jump *label267 equal :processUnit.2:unit null
+  934 ubind :processUnit.2:unit
   935 sensor *tmp333 @unit @dead
   936 op equal *tmp334 *tmp333 0
   937 sensor *tmp335 @unit @controller
 
   943 label *label270
   944 label *label267
   945 label *label268
-    * ubind .TYPE
+  946 ubind *tmp9
   947 set :rebindUnit.6:firstUnit @unit
   948 jump *label271 equal :rebindUnit.6:firstUnit null
   949 label *label273
 
   952 jump *label266 always
   953 label *label276
   954 label *label277
-    * ubind .TYPE
+  955 ubind *tmp9
   956 label *label274
   957 jump *label275 equal @unit :rebindUnit.6:firstUnit
   958 label *label278
 
   971 jump *label279 lessThanEq :processUnit.2:state 3
   972 label *label281
   973 sensor *tmp351 @unit @firstItem
-    * jump *label283 notEqual *tmp351 :processUnit.2:item
+  974 jump *label283 notEqual *tmp351 @phase-fabric
   975 set :processUnit.2:state 3
   976 jump *label284 always
   977 label *label283
 
   994 jump *label289 notEqual :processUnit.2:state 2
   995 ucontrol within .CORE_X .CORE_Y 8 *tmp361
   996 jump *label291 equal *tmp361 false
-    * ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
+  997 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
   998 sensor *tmp363 @unit @totalItems
   999 jump *label293 lessThan *tmp363 .UNIT_CAPACITY
  1000 ucontrol approach .DOME_X .DOME_Y 6
 
  1020 jump *label295 notEqual :processUnit.2:state 3
  1021 ucontrol within .DOME_X .DOME_Y 8 *tmp375
  1022 jump *label297 equal *tmp375 false
-    * jump *label299 equal :processUnit.2:supply false
+ 1023 jump *label299 equal .SUPPLY_P_FIRST false
  1024 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1025 set .MSG ", supplying\n"
  1026 jump *label300 always
 
  1051 ucontrol flag :processUnit.2:state
  1052 sensor *tmp388 @unit @totalItems
  1053 print "  "
-    * print :processUnit.2:group
+ 1054 print .GROUP1
  1055 print ":"
  1056 print " ["
-    * print :processUnit.2:color
+ 1057 print "gold"
  1058 print "]"
  1059 print *tmp388
  1060 print "["
 
  1072 set :processUnit.2:unit @unit
  1073 label *label265
  1074 set .UNIT_P1 :processUnit.2:unit
-    * jump *label305 equal .FOUR_UNITS false
+ 1075 jump *label305 equal *tmp126 false
  1076 op equal *tmp393 .SUPPLY_P_FIRST false
  1077 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
  1078 set :processUnit.3:unit .UNIT_P2
 
  1080 set :processUnit.3:group .GROUP2
  1081 set :processUnit.3:supply *tmp393
  1082 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * jump *label309 equal :rebindUnit.7:currentUnit null
-    * ubind :rebindUnit.7:currentUnit
+ 1083 set :rebindUnit.7:currentUnit .UNIT_P2
+ 1084 jump *label309 equal :processUnit.3:unit null
+ 1085 ubind :processUnit.3:unit
  1086 sensor *tmp397 @unit @dead
  1087 op equal *tmp398 *tmp397 0
  1088 sensor *tmp399 @unit @controller
 
  1094 label *label312
  1095 label *label309
  1096 label *label310
-    * ubind .TYPE
+ 1097 ubind *tmp9
  1098 set :rebindUnit.7:firstUnit @unit
  1099 jump *label313 equal :rebindUnit.7:firstUnit null
  1100 label *label315
 
  1103 jump *label308 always
  1104 label *label318
  1105 label *label319
-    * ubind .TYPE
+ 1106 ubind *tmp9
  1107 label *label316
  1108 jump *label317 equal @unit :rebindUnit.7:firstUnit
  1109 label *label320
 
  1122 jump *label321 lessThanEq :processUnit.3:state 3
  1123 label *label323
  1124 sensor *tmp415 @unit @firstItem
-    * jump *label325 notEqual *tmp415 :processUnit.3:item
+ 1125 jump *label325 notEqual *tmp415 @phase-fabric
  1126 set :processUnit.3:state 3
  1127 jump *label326 always
  1128 label *label325
 
  1145 jump *label331 notEqual :processUnit.3:state 2
  1146 ucontrol within .CORE_X .CORE_Y 8 *tmp425
  1147 jump *label333 equal *tmp425 false
-    * ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
+ 1148 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1149 sensor *tmp427 @unit @totalItems
  1150 jump *label335 lessThan *tmp427 .UNIT_CAPACITY
  1151 ucontrol approach .DOME_X .DOME_Y 6
 
  1171 jump *label337 notEqual :processUnit.3:state 3
  1172 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1173 jump *label339 equal *tmp439 false
-    * jump *label341 equal :processUnit.3:supply false
+ 1174 jump *label341 equal *tmp393 false
  1175 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1176 set .MSG ", supplying\n"
  1177 jump *label342 always
 
  1202 ucontrol flag :processUnit.3:state
  1203 sensor *tmp452 @unit @totalItems
  1204 print "  "
-    * print :processUnit.3:group
+ 1205 print .GROUP2
  1206 print ":"
  1207 print " ["
-    * print :processUnit.3:color
+ 1208 print "gold"
  1209 print "]"
  1210 print *tmp452
  1211 print "["
 
  1224 label *label307
  1225 set .UNIT_P2 :processUnit.3:unit
  1226 jump *label347 equal .SUPPLY_P_FIRST false
-    * sensor *tmp457 .UNIT_P1 @totalItems
+ 1227 sensor *tmp457 :processUnit.2:unit @totalItems
  1228 op greaterThan *tmp456 *tmp457 0
  1229 jump *label348 always
  1230 label *label347
-    * sensor *tmp459 .UNIT_P2 @totalItems
+ 1231 sensor *tmp459 :processUnit.3:unit @totalItems
  1232 op equal *tmp456 *tmp459 0
  1233 label *label348
  1234 set .SUPPLY_P_FIRST *tmp456
 
  1242 print " "
  1243 print "ms"
  1244 printflush message1
-    * jump *label349 equal .TYPE UNIT_TYPE
+ 1245 jump *label349 equal *tmp9 UNIT_TYPE
  1246 label *label352
  1247 jump *label349 lessThanEq :unitCheck @time
  1248 label *label351
 
  1252 set :areUnitsAvailable.2:free 0
  1253 set :areUnitsAvailable.2:occupied 0
  1254 set :areUnitsAvailable.2:needed 0
-    * ubind :areUnitsAvailable.2:type
+ 1255 ubind UNIT_TYPE
  1256 set :areUnitsAvailable.2:firstUnit @unit
  1257 jump *label356 equal :areUnitsAvailable.2:firstUnit null
  1258 # "Function: inline def needsFourUnits(in unit)"
  1259 set :needsFourUnits.3:unit @unit
  1260 op sub *tmp470 .DOME_X .CORE_X
  1261 op sub *tmp471 .DOME_Y .CORE_Y
-    * op len *tmp472 *tmp470 *tmp471
-    * op mul *tmp473 2 *tmp472
+ 1262 op len *tmp472 *tmp127 *tmp128
+ 1263 op mul *tmp473 2 *tmp129
  1264 sensor *tmp474 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp473 *tmp474
+ 1265 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
  1266 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
  1267 jump *label360 always
-    * set *tmp469 null
  1268 label *label360
  1269 jump *label358 equal *tmp469 false
  1270 set *tmp477 4
 
  1281 jump *label364 notEqual *tmp480 @this
  1282 label *label366
  1283 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label368 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1284 jump *label368 lessThan :areUnitsAvailable.2:free *tmp477
  1285 set *tmp466 true
  1286 jump *label355 always
  1287 label *label368
 
  1290 label *label364
  1291 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1292 label *label365
-    * ubind :areUnitsAvailable.2:type
+ 1293 ubind UNIT_TYPE
  1294 label *label362
  1295 jump *label363 equal @unit :areUnitsAvailable.2:firstUnit
  1296 label *label370
 
  1299 label *label363
  1300 label *label356
  1301 label *label357
-    * jump *label371 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+ 1302 jump *label371 equal false false
+ 1303 print UNIT_TYPE
  1304 print ":"
  1305 print " occupied: "
  1306 print :areUnitsAvailable.2:occupied
 
  1317 label *label372
  1318 set *tmp466 false
  1319 jump *label355 always
-    * set *tmp466 null
  1320 label *label355
  1321 jump *label353 equal *tmp466 false
  1322 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-47 instructions):
 
    63 print "[gold]Looking for suitable unit type:[]"
    64 print "\n"
    65 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable:type UNIT_TYPE
-    * set :areUnitsAvailable:output true
    66 set :areUnitsAvailable:free 0
    67 set :areUnitsAvailable:occupied 0
    68 set :areUnitsAvailable:needed 0
 
   154 label *label46
   155 jump *label53 equal :chooseUnitType:type UNIT_TYPE
   156 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:type :chooseUnitType:type
-    * set :areUnitsAvailable.1:output true
   157 set :areUnitsAvailable.1:free 0
   158 set :areUnitsAvailable.1:occupied 0
   159 set :areUnitsAvailable.1:needed 0
 
   241 label *label23
   242 set *tmp9 null
   243 label *label20
-    * set .TYPE *tmp9
   244 print "[gold]Binding units..."
   245 printflush message1
   246 # "Function: inline def rebindUnits()"
   247 set .UNIT_P2 null
   248 set .UNIT_S2 null
-    * set .UNIT_P1 .UNIT_P2
-    * set .UNIT_S1 .UNIT_S2
+  249 set .UNIT_P1 null
+  250 set .UNIT_S1 null
   251 set :rebindUnits:count 0
   252 ubind *tmp9
   253 set :rebindUnits:firstUnit @unit
 
   281 # "Function: inline def acquireUnit(in currentUnit)"
   282 set :acquireUnit:currentUnit .UNIT_S1
   283 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit:currentUnit .UNIT_S1
-    * jump *label90 equal :acquireUnit:currentUnit null
-    * ubind :acquireUnit:currentUnit
+  284 jump *label90 equal .UNIT_S1 null
+  285 ubind .UNIT_S1
   286 sensor *tmp84 @unit @dead
   287 op equal *tmp85 *tmp84 0
   288 sensor *tmp86 @unit @controller
 
   322 # "Function: inline def acquireUnit(in currentUnit)"
   323 set :acquireUnit.1:currentUnit .UNIT_P1
   324 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit .UNIT_P1
-    * jump *label104 equal :acquireUnit.1:currentUnit null
-    * ubind :acquireUnit.1:currentUnit
+  325 jump *label104 equal .UNIT_P1 null
+  326 ubind .UNIT_P1
   327 sensor *tmp102 @unit @dead
   328 op equal *tmp103 *tmp102 0
   329 sensor *tmp104 @unit @controller
 
   367 jump *label116 notEqual *tmp118 @silicon
   368 label *label118
   369 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:a *tmp80
-    * set :swap:b *tmp98
-    * set :swap:t .UNIT_S1
-    * set :swap:a .UNIT_P1
-    * set :swap:b :swap:t
+  370 set :swap:t *tmp80
+  371 set :swap:a *tmp98
+  372 set :swap:b .UNIT_S1
   373 label *label120
-    * set .UNIT_S1 :swap:a
+  374 set .UNIT_S1 .UNIT_P1
   375 set .UNIT_P1 :swap:t
   376 label *label116
   377 label *label117
 
   384 label *label121
   385 label *label122
   386 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.2:unit .UNIT_S1
   387 op sub *tmp127 .DOME_X .CORE_X
   388 op sub *tmp128 .DOME_Y .CORE_Y
   389 op len *tmp129 *tmp127 *tmp128
 
   393 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   394 jump *label123 always
   395 label *label123
-    * set .FOUR_UNITS *tmp126
   396 jump *label124 equal *tmp126 false
   397 # "Function: inline def acquireUnit(in currentUnit)"
   398 set :acquireUnit.2:currentUnit .UNIT_S2
   399 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit .UNIT_S2
-    * jump *label128 equal :acquireUnit.2:currentUnit null
-    * ubind :acquireUnit.2:currentUnit
+  400 jump *label128 equal .UNIT_S2 null
+  401 ubind .UNIT_S2
   402 sensor *tmp139 @unit @dead
   403 op equal *tmp140 *tmp139 0
   404 sensor *tmp141 @unit @controller
 
   438 # "Function: inline def acquireUnit(in currentUnit)"
   439 set :acquireUnit.3:currentUnit .UNIT_P2
   440 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit .UNIT_P2
-    * jump *label142 equal :acquireUnit.3:currentUnit null
-    * ubind :acquireUnit.3:currentUnit
+  441 jump *label142 equal .UNIT_P2 null
+  442 ubind .UNIT_P2
   443 sensor *tmp157 @unit @dead
   444 op equal *tmp158 *tmp157 0
   445 sensor *tmp159 @unit @controller
 
   483 jump *label154 equal *tmp173 @phase-fabric
   484 label *label156
   485 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.1:a .UNIT_S1
-    * set :swap.1:b *tmp153
   486 set :swap.1:t .UNIT_S1
-    * set :swap.1:a .UNIT_P2
-    * set :swap.1:b :swap.1:t
+  487 set :swap.1:a *tmp153
+  488 set :swap.1:b .UNIT_S1
   489 label *label158
-    * set .UNIT_S1 :swap.1:a
+  490 set .UNIT_S1 .UNIT_P2
   491 set .UNIT_P2 :swap.1:t
   492 label *label154
   493 label *label155
 
   498 jump *label159 notEqual *tmp178 @silicon
   499 label *label161
   500 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:a *tmp135
-    * set :swap.2:b .UNIT_P2
-    * set :swap.2:t .UNIT_S2
+  501 set :swap.2:t *tmp135
   502 set :swap.2:a .UNIT_P2
-    * set :swap.2:b :swap.2:t
+  503 set :swap.2:b .UNIT_S2
   504 label *label163
-    * set .UNIT_S2 :swap.2:a
+  505 set .UNIT_S2 .UNIT_P2
   506 set .UNIT_P2 :swap.2:t
   507 label *label159
   508 label *label160
 
   556 print "]"
   557 print "\n"
   558 # "Function: inline void printDomeStatus(in item, in text)"
-    * set :printDomeStatus:item @silicon
-    * set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   559 print "\n[green]Silicon[] status:\n"
   560 sensor :printDomeStatus:level .DOME @silicon
   561 jump *label176 lessThanEq :printDomeStatus:level 3
 
   575 label *label175
   576 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   577 set :processUnit:unit .UNIT_S1
-    * set :processUnit:item @silicon
-    * set :processUnit:group .GROUP1
-    * set :processUnit:supply .SUPPLY_S_FIRST
   578 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit .UNIT_S1
-    * jump *label180 equal :processUnit:unit null
-    * ubind :processUnit:unit
+  579 jump *label180 equal .UNIT_S1 null
+  580 ubind .UNIT_S1
   581 sensor *tmp199 @unit @dead
   582 op equal *tmp200 *tmp199 0
   583 sensor *tmp201 @unit @controller
 
   611 label *label179
   612 sensor :processUnit:state @unit @flag
   613 set :processUnit:distance -1
-    * set :processUnit:color "gold"
   614 jump *label194 lessThan :processUnit:state 2
   615 label *label195
   616 jump *label192 lessThanEq :processUnit:state 3
 
   721 op equal *tmp259 .SUPPLY_S_FIRST false
   722 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   723 set :processUnit.1:unit .UNIT_S2
-    * set :processUnit.1:item @silicon
-    * set :processUnit.1:group .GROUP2
-    * set :processUnit.1:supply *tmp259
   724 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit .UNIT_S2
-    * jump *label222 equal :processUnit.1:unit null
-    * ubind :processUnit.1:unit
+  725 jump *label222 equal .UNIT_S2 null
+  726 ubind .UNIT_S2
   727 sensor *tmp263 @unit @dead
   728 op equal *tmp264 *tmp263 0
   729 sensor *tmp265 @unit @controller
 
   757 label *label221
   758 sensor :processUnit.1:state @unit @flag
   759 set :processUnit.1:distance -1
-    * set :processUnit.1:color "gold"
   760 jump *label236 lessThan :processUnit.1:state 2
   761 label *label237
   762 jump *label234 lessThanEq :processUnit.1:state 3
 
   875 label *label218
   876 label *label219
   877 # "Function: inline void printDomeStatus(in item, in text)"
-    * set :printDomeStatus.1:item @phase-fabric
-    * set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   878 print "\n[green]Phase fabric[] status:\n"
   879 sensor :printDomeStatus.1:level .DOME @phase-fabric
   880 jump *label263 lessThanEq :printDomeStatus.1:level 3
 
   894 label *label262
   895 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   896 set :processUnit.2:unit .UNIT_P1
-    * set :processUnit.2:item @phase-fabric
-    * set :processUnit.2:group .GROUP1
-    * set :processUnit.2:supply .SUPPLY_P_FIRST
   897 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit .UNIT_P1
-    * jump *label267 equal :processUnit.2:unit null
-    * ubind :processUnit.2:unit
+  898 jump *label267 equal .UNIT_P1 null
+  899 ubind .UNIT_P1
   900 sensor *tmp333 @unit @dead
   901 op equal *tmp334 *tmp333 0
   902 sensor *tmp335 @unit @controller
 
   930 label *label266
   931 sensor :processUnit.2:state @unit @flag
   932 set :processUnit.2:distance -1
-    * set :processUnit.2:color "gold"
   933 jump *label281 lessThan :processUnit.2:state 2
   934 label *label282
   935 jump *label279 lessThanEq :processUnit.2:state 3
 
  1040 op equal *tmp393 .SUPPLY_P_FIRST false
  1041 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
  1042 set :processUnit.3:unit .UNIT_P2
-    * set :processUnit.3:item @phase-fabric
-    * set :processUnit.3:group .GROUP2
-    * set :processUnit.3:supply *tmp393
  1043 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit .UNIT_P2
-    * jump *label309 equal :processUnit.3:unit null
-    * ubind :processUnit.3:unit
+ 1044 jump *label309 equal .UNIT_P2 null
+ 1045 ubind .UNIT_P2
  1046 sensor *tmp397 @unit @dead
  1047 op equal *tmp398 *tmp397 0
  1048 sensor *tmp399 @unit @controller
 
  1076 label *label308
  1077 sensor :processUnit.3:state @unit @flag
  1078 set :processUnit.3:distance -1
-    * set :processUnit.3:color "gold"
  1079 jump *label323 lessThan :processUnit.3:state 2
  1080 label *label324
  1081 jump *label321 lessThanEq :processUnit.3:state 3
 
  1206 jump *label349 lessThanEq :unitCheck @time
  1207 label *label351
  1208 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
  1209 set :areUnitsAvailable.2:free 0
  1210 set :areUnitsAvailable.2:occupied 0
  1211 set :areUnitsAvailable.2:needed 0
 
  1214 jump *label356 equal :areUnitsAvailable.2:firstUnit null
  1215 # "Function: inline def needsFourUnits(in unit)"
  1216 set :needsFourUnits.3:unit @unit
-    * op sub *tmp470 .DOME_X .CORE_X
-    * op sub *tmp471 .DOME_Y .CORE_Y
-    * op len *tmp472 *tmp127 *tmp128
-    * op mul *tmp473 2 *tmp129
  1217 sensor *tmp474 :needsFourUnits.3:unit @speed
  1218 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
  1219 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   279 label *label82
   280 label *label77
   281 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit:currentUnit .UNIT_S1
   282 # "Function: inline def rebindUnit(in currentUnit)"
   283 jump *label90 equal .UNIT_S1 null
   284 ubind .UNIT_S1
 
   319 label *label88
   320 set .UNIT_S1 *tmp80
   321 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.1:currentUnit .UNIT_P1
   322 # "Function: inline def rebindUnit(in currentUnit)"
   323 jump *label104 equal .UNIT_P1 null
   324 ubind .UNIT_P1
 
   366 label *label118
   367 # "Function: inline void swap(in out a, in out b)"
   368 set :swap:t *tmp80
-    * set :swap:a *tmp98
-    * set :swap:b .UNIT_S1
+  369 set :swap:b *tmp80
   370 label *label120
-    * set .UNIT_S1 .UNIT_P1
-    * set .UNIT_P1 :swap:t
+  371 set .UNIT_S1 *tmp98
+  372 set .UNIT_P1 *tmp80
   373 label *label116
   374 label *label117
   375 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   392 label *label123
   393 jump *label124 equal *tmp126 false
   394 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.2:currentUnit .UNIT_S2
   395 # "Function: inline def rebindUnit(in currentUnit)"
   396 jump *label128 equal .UNIT_S2 null
   397 ubind .UNIT_S2
 
   432 label *label126
   433 set .UNIT_S2 *tmp135
   434 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.3:currentUnit .UNIT_P2
   435 # "Function: inline def rebindUnit(in currentUnit)"
   436 jump *label142 equal .UNIT_P2 null
   437 ubind .UNIT_P2
 
   479 label *label156
   480 # "Function: inline void swap(in out a, in out b)"
   481 set :swap.1:t .UNIT_S1
-    * set :swap.1:a *tmp153
-    * set :swap.1:b .UNIT_S1
   482 label *label158
-    * set .UNIT_S1 .UNIT_P2
+  483 set .UNIT_S1 *tmp153
   484 set .UNIT_P2 :swap.1:t
   485 label *label154
   486 label *label155
 
   492 label *label161
   493 # "Function: inline void swap(in out a, in out b)"
   494 set :swap.2:t *tmp135
-    * set :swap.2:a .UNIT_P2
-    * set :swap.2:b .UNIT_S2
+  495 set :swap.2:b *tmp135
   496 label *label163
   497 set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P2 :swap.2:t
+  498 set .UNIT_P2 *tmp135
   499 label *label159
   500 label *label160
   501 set .GROUP1 "unit  1"
 
   566 label *label177
   567 label *label175
   568 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit:unit .UNIT_S1
   569 # "Function: inline def rebindUnit(in currentUnit)"
   570 jump *label180 equal .UNIT_S1 null
   571 ubind .UNIT_S1
 
   711 jump *label218 equal *tmp126 false
   712 op equal *tmp259 .SUPPLY_S_FIRST false
   713 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.1:unit .UNIT_S2
   714 # "Function: inline def rebindUnit(in currentUnit)"
   715 jump *label222 equal .UNIT_S2 null
   716 ubind .UNIT_S2
 
   883 label *label264
   884 label *label262
   885 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.2:unit .UNIT_P1
   886 # "Function: inline def rebindUnit(in currentUnit)"
   887 jump *label267 equal .UNIT_P1 null
   888 ubind .UNIT_P1
 
  1028 jump *label305 equal *tmp126 false
  1029 op equal *tmp393 .SUPPLY_P_FIRST false
  1030 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.3:unit .UNIT_P2
  1031 # "Function: inline def rebindUnit(in currentUnit)"
  1032 jump *label309 equal .UNIT_P2 null
  1033 ubind .UNIT_P2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-4 instructions):
 
   365 jump *label116 notEqual *tmp118 @silicon
   366 label *label118
   367 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:t *tmp80
-    * set :swap:b *tmp80
   368 label *label120
   369 set .UNIT_S1 *tmp98
   370 set .UNIT_P1 *tmp80
 
   489 jump *label159 notEqual *tmp178 @silicon
   490 label *label161
   491 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:t *tmp135
-    * set :swap.2:b *tmp135
   492 label *label163
   493 set .UNIT_S2 .UNIT_P2
   494 set .UNIT_P2 *tmp135

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     5 set .DOME dome1
     6 label *label2
     7 jump *label4 notEqual .DOME null
+    8 label *label380
     9 print "[gold]Waiting for an overdrive dome to be connected..."
    10 printflush message1
    11 set .DOME dome1
    12 label *label3
-    * jump *label2 always
+   13 jump *label380 equal .DOME null
    14 label *label4
    15 print "[gold]Locating core..."
    16 printflush message1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-9 instructions):
 
    70 ubind UNIT_TYPE
    71 set :areUnitsAvailable:firstUnit @unit
    72 jump *label27 equal :areUnitsAvailable:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits:unit @unit
-    * op sub *tmp14 .DOME_X .CORE_X
-    * op sub *tmp15 .DOME_Y .CORE_Y
-    * op len *tmp16 *tmp14 *tmp15
-    * op mul *tmp17 2 *tmp16
-    * sensor *tmp18 :needsFourUnits:unit @speed
-    * op div :needsFourUnits:travel_time *tmp17 *tmp18
-    * op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
-    * jump *label31 always
-    * label *label31
-    * jump *label29 equal *tmp13 false
-    * set *tmp21 4
-    * jump *label30 always
-    * label *label29
-    * set *tmp21 2
-    * label *label30
+   73 # "Function: inline def needsFourUnits(in unit)"
+   74 set :needsFourUnits:unit @unit
+   75 op sub *tmp14 .DOME_X .CORE_X
+   76 op sub *tmp15 .DOME_Y .CORE_Y
+   77 op len *tmp16 *tmp14 *tmp15
+   78 op mul *tmp17 2 *tmp16
+   79 sensor *tmp18 :needsFourUnits:unit @speed
+   80 op div :needsFourUnits:travel_time *tmp17 *tmp18
+   81 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
+   82 jump *label381 always
+   83 label *label381
+   84 select *tmp21 notEqual *tmp13 false 4 2
    85 set :areUnitsAvailable:needed *tmp21
    86 label *label32
    87 sensor *tmp22 @unit @controlled
 
   156 ubind :chooseUnitType:type
   157 set :areUnitsAvailable.1:firstUnit @unit
   158 jump *label58 equal :areUnitsAvailable.1:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp44 .DOME_X .CORE_X
-    * op sub *tmp45 .DOME_Y .CORE_Y
-    * op len *tmp46 *tmp44 *tmp45
-    * op mul *tmp47 2 *tmp46
-    * sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label62 always
-    * label *label62
-    * jump *label60 equal *tmp43 false
-    * set *tmp51 4
-    * jump *label61 always
-    * label *label60
-    * set *tmp51 2
-    * label *label61
+  159 # "Function: inline def needsFourUnits(in unit)"
+  160 set :needsFourUnits.1:unit @unit
+  161 op sub *tmp44 .DOME_X .CORE_X
+  162 op sub *tmp45 .DOME_Y .CORE_Y
+  163 op len *tmp46 *tmp44 *tmp45
+  164 op mul *tmp47 2 *tmp46
+  165 sensor *tmp48 :needsFourUnits.1:unit @speed
+  166 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  167 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  168 jump *label382 always
+  169 label *label382
+  170 select *tmp51 notEqual *tmp43 false 4 2
   171 set :areUnitsAvailable.1:needed *tmp51
   172 label *label63
   173 sensor *tmp52 @unit @controlled
 
  1187 ubind UNIT_TYPE
  1188 set :areUnitsAvailable.2:firstUnit @unit
  1189 jump *label356 equal :areUnitsAvailable.2:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.3:unit @unit
-    * sensor *tmp474 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp130 *tmp474
-    * op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
-    * jump *label360 always
-    * label *label360
-    * jump *label358 equal *tmp469 false
-    * set *tmp477 4
-    * jump *label359 always
-    * label *label358
-    * set *tmp477 2
-    * label *label359
+ 1190 # "Function: inline def needsFourUnits(in unit)"
+ 1191 set :needsFourUnits.3:unit @unit
+ 1192 sensor *tmp474 :needsFourUnits.3:unit @speed
+ 1193 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
+ 1194 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
+ 1195 jump *label383 always
+ 1196 label *label383
+ 1197 select *tmp477 notEqual *tmp469 false 4 2
  1198 set :areUnitsAvailable.2:needed *tmp477
  1199 label *label361
  1200 sensor *tmp478 @unit @controlled

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 2 (-4 instructions):
 
   497 set .UNIT_P2 null
   498 set .GROUP1 "unit"
   499 label *label125
+  500 set .SUPPLY_S_FIRST false
   501 jump *label166 equal *tmp126 false
   502 label *label167
   503 sensor *tmp182 .UNIT_S1 @totalItems
   504 sensor *tmp183 .UNIT_S2 @totalItems
-    * jump *label164 greaterThanEq *tmp182 *tmp183
+  505 jump *label165 greaterThanEq *tmp182 *tmp183
   506 label *label166
-    * set *tmp185 true
+  507 set .SUPPLY_S_FIRST true
   508 jump *label165 always
-    * label *label164
-    * set *tmp185 false
   509 label *label165
-    * set .SUPPLY_S_FIRST *tmp185
+  510 set .SUPPLY_P_FIRST false
   511 jump *label170 equal *tmp126 false
   512 label *label171
   513 sensor *tmp187 .UNIT_P1 @totalItems
   514 sensor *tmp188 .UNIT_P2 @totalItems
-    * jump *label168 greaterThanEq *tmp187 *tmp188
+  515 jump *label169 greaterThanEq *tmp187 *tmp188
   516 label *label170
-    * set *tmp190 true
+  517 set .SUPPLY_P_FIRST true
   518 jump *label169 always
-    * label *label168
-    * set *tmp190 false
   519 label *label169
-    * set .SUPPLY_P_FIRST *tmp190
   520 op add :unitCheck @time 5000
   521 label *label172
   522 sensor *tmp192 switch1 @enabled
 
   838 set .UNIT_S2 :processUnit.1:unit
   839 jump *label260 equal .SUPPLY_S_FIRST false
   840 sensor *tmp323 :processUnit:unit @totalItems
-    * op greaterThan *tmp322 *tmp323 0
+  841 op greaterThan .SUPPLY_S_FIRST *tmp323 0
   842 jump *label261 always
   843 label *label260
   844 sensor *tmp325 :processUnit.1:unit @totalItems
-    * op equal *tmp322 *tmp325 0
+  845 op equal .SUPPLY_S_FIRST *tmp325 0
   846 label *label261
-    * set .SUPPLY_S_FIRST *tmp322
   847 label *label218
   848 label *label219
   849 # "Function: inline void printDomeStatus(in item, in text)"
 
  1154 set .UNIT_P2 :processUnit.3:unit
  1155 jump *label347 equal .SUPPLY_P_FIRST false
  1156 sensor *tmp457 :processUnit.2:unit @totalItems
-    * op greaterThan *tmp456 *tmp457 0
+ 1157 op greaterThan .SUPPLY_P_FIRST *tmp457 0
  1158 jump *label348 always
  1159 label *label347
  1160 sensor *tmp459 :processUnit.3:unit @totalItems
-    * op equal *tmp456 *tmp459 0
+ 1161 op equal .SUPPLY_P_FIRST *tmp459 0
  1162 label *label348
-    * set .SUPPLY_P_FIRST *tmp456
  1163 label *label305
  1164 label *label306
  1165 op sub *tmp461 @time :start

Modifications by Unroll iteration loop at line 169:9 (+7 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * set :locateDomeAndCore:type @flare
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label11 (m:marker0)
-    * set :locateDomeAndCore:type @poly
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label12 (m:marker0)
-    * set :locateDomeAndCore:type @mega
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label13 (m:marker0)
-    * set :locateDomeAndCore:type @mono
-    * set *tmp1 null
-    * label *label8
-    * set :locateCore:type :locateDomeAndCore:type
-    * call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label15 equal :locateCore*retval false
-    * jump *label1 always
-    * label *label15
-    * label *label16
-    * label *label9
-    * multijump *tmp1 0 0 (m:marker0)
-    * multilabel *label14 (m:marker0)
-    * label *label10
+   19 set :locateDomeAndCore:type @flare
+   20 label *label384
+   21 set :locateCore:type :locateDomeAndCore:type
+   22 call *label0 :locateCore*retaddr :locateCore*retval
+   23 jump *label385 equal :locateCore*retval false
+   24 jump *label1 always
+   25 label *label385
+   26 label *label386
+   27 label *label387
+   28 set :locateDomeAndCore:type @poly
+   29 label *label390
+   30 set :locateCore:type :locateDomeAndCore:type
+   31 call *label0 :locateCore*retaddr :locateCore*retval
+   32 jump *label391 equal :locateCore*retval false
+   33 jump *label1 always
+   34 label *label391
+   35 label *label392
+   36 label *label393
+   37 set :locateDomeAndCore:type @mega
+   38 label *label396
+   39 set :locateCore:type :locateDomeAndCore:type
+   40 call *label0 :locateCore*retaddr :locateCore*retval
+   41 jump *label397 equal :locateCore*retval false
+   42 jump *label1 always
+   43 label *label397
+   44 label *label398
+   45 label *label399
+   46 set :locateDomeAndCore:type @mono
+   47 label *label402
+   48 set :locateCore:type :locateDomeAndCore:type
+   49 call *label0 :locateCore*retaddr :locateCore*retval
+   50 jump *label403 equal :locateCore*retval false
+   51 jump *label1 always
+   52 label *label403
+   53 label *label404
+   54 label *label405
+   55 label *label10
    56 label *label6
    57 jump *label5 always
    58 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
     6 label *label2
-    * jump *label4 notEqual .DOME null
+    7 jump *label4 notEqual dome1 null
     8 label *label380
     9 print "[gold]Waiting for an overdrive dome to be connected..."
    10 printflush message1
    11 set .DOME dome1
    12 label *label3
-    * jump *label380 equal .DOME null
+   13 jump *label380 equal dome1 null
    14 label *label4
    15 print "[gold]Locating core..."
    16 printflush message1
 
    18 label *label5
    19 set :locateDomeAndCore:type @flare
    20 label *label384
-    * set :locateCore:type :locateDomeAndCore:type
+   21 set :locateCore:type @flare
    22 call *label0 :locateCore*retaddr :locateCore*retval
    23 jump *label385 equal :locateCore*retval false
    24 jump *label1 always
 
    27 label *label387
    28 set :locateDomeAndCore:type @poly
    29 label *label390
-    * set :locateCore:type :locateDomeAndCore:type
+   30 set :locateCore:type @poly
    31 call *label0 :locateCore*retaddr :locateCore*retval
    32 jump *label391 equal :locateCore*retval false
    33 jump *label1 always
 
    36 label *label393
    37 set :locateDomeAndCore:type @mega
    38 label *label396
-    * set :locateCore:type :locateDomeAndCore:type
+   39 set :locateCore:type @mega
    40 call *label0 :locateCore*retaddr :locateCore*retval
    41 jump *label397 equal :locateCore*retval false
    42 jump *label1 always
 
    45 label *label399
    46 set :locateDomeAndCore:type @mono
    47 label *label402
-    * set :locateCore:type :locateDomeAndCore:type
+   48 set :locateCore:type @mono
    49 call *label0 :locateCore*retaddr :locateCore*retval
    50 jump *label403 equal :locateCore*retval false
    51 jump *label1 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * set :locateDomeAndCore:type @flare
    19 label *label384
    20 set :locateCore:type @flare
    21 call *label0 :locateCore*retaddr :locateCore*retval
 
    24 label *label385
    25 label *label386
    26 label *label387
-    * set :locateDomeAndCore:type @poly
    27 label *label390
    28 set :locateCore:type @poly
    29 call *label0 :locateCore*retaddr :locateCore*retval
 
    32 label *label391
    33 label *label392
    34 label *label393
-    * set :locateDomeAndCore:type @mega
    35 label *label396
    36 set :locateCore:type @mega
    37 call *label0 :locateCore*retaddr :locateCore*retval
 
    40 label *label397
    41 label *label398
    42 label *label399
-    * set :locateDomeAndCore:type @mono
    43 label *label402
    44 set :locateCore:type @mono
    45 call *label0 :locateCore*retaddr :locateCore*retval

Modifications by Replicate loop condition at line 54:5 (+1 instructions):
 
    60 label *label17
    61 sensor *tmp7 switch1 @enabled
    62 jump *label19 notEqual *tmp7 false
+   63 label *label409
    64 print "[coral]Activate switch to begin supplying overdrive dome..."
    65 print "\n"
    66 printflush message1
    67 label *label18
-    * jump *label17 always
+   68 sensor *tmp7 switch1 @enabled
+   69 jump *label409 equal *tmp7 false
    70 label *label19
    71 # "Function: inline def chooseUnitType()"
    72 label *label21

Modifications by Replicate loop condition at line 119:5 (+1 instructions):
 
   531 label *label172
   532 sensor *tmp192 switch1 @enabled
   533 jump *label174 equal *tmp192 false
+  534 label *label410
   535 set :start @time
   536 print " === [gold]Supplying Overdrive Dome[] === "
   537 print "\n"
 
  1254 label *label349
  1255 label *label350
  1256 label *label173
-    * jump *label172 always
+ 1257 sensor *tmp192 switch1 @enabled
+ 1258 jump *label410 notEqual *tmp192 false
  1259 label *label174
  1260 end
  1261 label *label0

Modifications by Unroll iteration loop at line 201:9 (+142 instructions):
 
   143 jump *label20 always
   144 label *label24
   145 label *label25
-    * set :chooseUnitType:type @flare
-    * op add *tmp37 @counter 1
-    * jump *label46 always
-    * multilabel *label49 (m:marker1)
-    * set :chooseUnitType:type @poly
-    * op add *tmp37 @counter 1
-    * jump *label46 always
-    * multilabel *label50 (m:marker1)
-    * set :chooseUnitType:type @mega
-    * op add *tmp37 @counter 1
-    * jump *label46 always
-    * multilabel *label51 (m:marker1)
-    * set :chooseUnitType:type @mono
-    * set *tmp37 null
-    * label *label46
-    * jump *label53 equal :chooseUnitType:type UNIT_TYPE
-    * # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:free 0
-    * set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label58 equal :areUnitsAvailable.1:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp44 .DOME_X .CORE_X
-    * op sub *tmp45 .DOME_Y .CORE_Y
-    * op len *tmp46 *tmp44 *tmp45
-    * op mul *tmp47 2 *tmp46
-    * sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label382 always
-    * label *label382
-    * select *tmp51 notEqual *tmp43 false 4 2
-    * set :areUnitsAvailable.1:needed *tmp51
-    * label *label63
-    * sensor *tmp52 @unit @controlled
-    * jump *label68 equal *tmp52 0
-    * label *label69
-    * sensor *tmp54 @unit @controller
-    * jump *label66 notEqual *tmp54 @this
-    * label *label68
-    * op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label70 lessThan :areUnitsAvailable.1:free *tmp51
-    * set *tmp40 true
-    * jump *label57 always
-    * label *label70
-    * label *label71
-    * jump *label67 always
-    * label *label66
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label67
-    * ubind :chooseUnitType:type
-    * label *label64
-    * jump *label65 equal @unit :areUnitsAvailable.1:firstUnit
-    * label *label72
-    * sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
-    * jump *label63 equal *tmp61 0
-    * label *label65
-    * label *label58
-    * label *label59
-    * jump *label73 equal true false
-    * print :chooseUnitType:type
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.1:free
-    * jump *label75 lessThanEq :areUnitsAvailable.1:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.1:needed
-    * label *label75
-    * label *label76
-    * print "\n"
-    * label *label73
-    * label *label74
-    * set *tmp40 false
-    * jump *label57 always
-    * label *label57
-    * jump *label55 equal *tmp40 false
-    * printflush null
-    * set *tmp9 :chooseUnitType:type
-    * jump *label20 always
-    * label *label55
-    * label *label56
-    * label *label53
-    * label *label54
-    * label *label47
-    * multijump *tmp37 0 0 (m:marker1)
-    * multilabel *label52 (m:marker1)
-    * label *label48
+  146 set :chooseUnitType:type @flare
+  147 label *label411
+  148 jump *label432 equal :chooseUnitType:type UNIT_TYPE
+  149 # "Function: inline def areUnitsAvailable(in type, in output)"
+  150 set :areUnitsAvailable.1:free 0
+  151 set :areUnitsAvailable.1:occupied 0
+  152 set :areUnitsAvailable.1:needed 0
+  153 ubind :chooseUnitType:type
+  154 set :areUnitsAvailable.1:firstUnit @unit
+  155 jump *label423 equal :areUnitsAvailable.1:firstUnit null
+  156 # "Function: inline def needsFourUnits(in unit)"
+  157 set :needsFourUnits.1:unit @unit
+  158 op sub *tmp44 .DOME_X .CORE_X
+  159 op sub *tmp45 .DOME_Y .CORE_Y
+  160 op len *tmp46 *tmp44 *tmp45
+  161 op mul *tmp47 2 *tmp46
+  162 sensor *tmp48 :needsFourUnits.1:unit @speed
+  163 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  164 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  165 jump *label412 always
+  166 label *label412
+  167 select *tmp51 notEqual *tmp43 false 4 2
+  168 set :areUnitsAvailable.1:needed *tmp51
+  169 label *label413
+  170 sensor *tmp52 @unit @controlled
+  171 jump *label415 equal *tmp52 0
+  172 label *label414
+  173 sensor *tmp54 @unit @controller
+  174 jump *label418 notEqual *tmp54 @this
+  175 label *label415
+  176 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  177 jump *label416 lessThan :areUnitsAvailable.1:free *tmp51
+  178 set *tmp40 true
+  179 jump *label429 always
+  180 label *label416
+  181 label *label417
+  182 jump *label419 always
+  183 label *label418
+  184 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  185 label *label419
+  186 ubind :chooseUnitType:type
+  187 label *label420
+  188 jump *label422 equal @unit :areUnitsAvailable.1:firstUnit
+  189 label *label421
+  190 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  191 jump *label413 equal *tmp61 0
+  192 label *label422
+  193 label *label423
+  194 label *label424
+  195 jump *label427 equal true false
+  196 print :chooseUnitType:type
+  197 print ":"
+  198 print " occupied: "
+  199 print :areUnitsAvailable.1:occupied
+  200 print ","
+  201 print " free: "
+  202 print :areUnitsAvailable.1:free
+  203 jump *label425 lessThanEq :areUnitsAvailable.1:needed 0
+  204 print ", needed: "
+  205 print :areUnitsAvailable.1:needed
+  206 label *label425
+  207 label *label426
+  208 print "\n"
+  209 label *label427
+  210 label *label428
+  211 set *tmp40 false
+  212 jump *label429 always
+  213 label *label429
+  214 jump *label430 equal *tmp40 false
+  215 printflush null
+  216 set *tmp9 :chooseUnitType:type
+  217 jump *label20 always
+  218 label *label430
+  219 label *label431
+  220 label *label432
+  221 label *label433
+  222 label *label434
+  223 set :chooseUnitType:type @poly
+  224 label *label437
+  225 jump *label458 equal :chooseUnitType:type UNIT_TYPE
+  226 # "Function: inline def areUnitsAvailable(in type, in output)"
+  227 set :areUnitsAvailable.1:free 0
+  228 set :areUnitsAvailable.1:occupied 0
+  229 set :areUnitsAvailable.1:needed 0
+  230 ubind :chooseUnitType:type
+  231 set :areUnitsAvailable.1:firstUnit @unit
+  232 jump *label449 equal :areUnitsAvailable.1:firstUnit null
+  233 # "Function: inline def needsFourUnits(in unit)"
+  234 set :needsFourUnits.1:unit @unit
+  235 op sub *tmp44 .DOME_X .CORE_X
+  236 op sub *tmp45 .DOME_Y .CORE_Y
+  237 op len *tmp46 *tmp44 *tmp45
+  238 op mul *tmp47 2 *tmp46
+  239 sensor *tmp48 :needsFourUnits.1:unit @speed
+  240 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  241 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  242 jump *label438 always
+  243 label *label438
+  244 select *tmp51 notEqual *tmp43 false 4 2
+  245 set :areUnitsAvailable.1:needed *tmp51
+  246 label *label439
+  247 sensor *tmp52 @unit @controlled
+  248 jump *label441 equal *tmp52 0
+  249 label *label440
+  250 sensor *tmp54 @unit @controller
+  251 jump *label444 notEqual *tmp54 @this
+  252 label *label441
+  253 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  254 jump *label442 lessThan :areUnitsAvailable.1:free *tmp51
+  255 set *tmp40 true
+  256 jump *label455 always
+  257 label *label442
+  258 label *label443
+  259 jump *label445 always
+  260 label *label444
+  261 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  262 label *label445
+  263 ubind :chooseUnitType:type
+  264 label *label446
+  265 jump *label448 equal @unit :areUnitsAvailable.1:firstUnit
+  266 label *label447
+  267 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  268 jump *label439 equal *tmp61 0
+  269 label *label448
+  270 label *label449
+  271 label *label450
+  272 jump *label453 equal true false
+  273 print :chooseUnitType:type
+  274 print ":"
+  275 print " occupied: "
+  276 print :areUnitsAvailable.1:occupied
+  277 print ","
+  278 print " free: "
+  279 print :areUnitsAvailable.1:free
+  280 jump *label451 lessThanEq :areUnitsAvailable.1:needed 0
+  281 print ", needed: "
+  282 print :areUnitsAvailable.1:needed
+  283 label *label451
+  284 label *label452
+  285 print "\n"
+  286 label *label453
+  287 label *label454
+  288 set *tmp40 false
+  289 jump *label455 always
+  290 label *label455
+  291 jump *label456 equal *tmp40 false
+  292 printflush null
+  293 set *tmp9 :chooseUnitType:type
+  294 jump *label20 always
+  295 label *label456
+  296 label *label457
+  297 label *label458
+  298 label *label459
+  299 label *label460
+  300 set :chooseUnitType:type @mega
+  301 label *label463
+  302 jump *label484 equal :chooseUnitType:type UNIT_TYPE
+  303 # "Function: inline def areUnitsAvailable(in type, in output)"
+  304 set :areUnitsAvailable.1:free 0
+  305 set :areUnitsAvailable.1:occupied 0
+  306 set :areUnitsAvailable.1:needed 0
+  307 ubind :chooseUnitType:type
+  308 set :areUnitsAvailable.1:firstUnit @unit
+  309 jump *label475 equal :areUnitsAvailable.1:firstUnit null
+  310 # "Function: inline def needsFourUnits(in unit)"
+  311 set :needsFourUnits.1:unit @unit
+  312 op sub *tmp44 .DOME_X .CORE_X
+  313 op sub *tmp45 .DOME_Y .CORE_Y
+  314 op len *tmp46 *tmp44 *tmp45
+  315 op mul *tmp47 2 *tmp46
+  316 sensor *tmp48 :needsFourUnits.1:unit @speed
+  317 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  318 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  319 jump *label464 always
+  320 label *label464
+  321 select *tmp51 notEqual *tmp43 false 4 2
+  322 set :areUnitsAvailable.1:needed *tmp51
+  323 label *label465
+  324 sensor *tmp52 @unit @controlled
+  325 jump *label467 equal *tmp52 0
+  326 label *label466
+  327 sensor *tmp54 @unit @controller
+  328 jump *label470 notEqual *tmp54 @this
+  329 label *label467
+  330 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  331 jump *label468 lessThan :areUnitsAvailable.1:free *tmp51
+  332 set *tmp40 true
+  333 jump *label481 always
+  334 label *label468
+  335 label *label469
+  336 jump *label471 always
+  337 label *label470
+  338 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  339 label *label471
+  340 ubind :chooseUnitType:type
+  341 label *label472
+  342 jump *label474 equal @unit :areUnitsAvailable.1:firstUnit
+  343 label *label473
+  344 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  345 jump *label465 equal *tmp61 0
+  346 label *label474
+  347 label *label475
+  348 label *label476
+  349 jump *label479 equal true false
+  350 print :chooseUnitType:type
+  351 print ":"
+  352 print " occupied: "
+  353 print :areUnitsAvailable.1:occupied
+  354 print ","
+  355 print " free: "
+  356 print :areUnitsAvailable.1:free
+  357 jump *label477 lessThanEq :areUnitsAvailable.1:needed 0
+  358 print ", needed: "
+  359 print :areUnitsAvailable.1:needed
+  360 label *label477
+  361 label *label478
+  362 print "\n"
+  363 label *label479
+  364 label *label480
+  365 set *tmp40 false
+  366 jump *label481 always
+  367 label *label481
+  368 jump *label482 equal *tmp40 false
+  369 printflush null
+  370 set *tmp9 :chooseUnitType:type
+  371 jump *label20 always
+  372 label *label482
+  373 label *label483
+  374 label *label484
+  375 label *label485
+  376 label *label486
+  377 set :chooseUnitType:type @mono
+  378 label *label489
+  379 jump *label510 equal :chooseUnitType:type UNIT_TYPE
+  380 # "Function: inline def areUnitsAvailable(in type, in output)"
+  381 set :areUnitsAvailable.1:free 0
+  382 set :areUnitsAvailable.1:occupied 0
+  383 set :areUnitsAvailable.1:needed 0
+  384 ubind :chooseUnitType:type
+  385 set :areUnitsAvailable.1:firstUnit @unit
+  386 jump *label501 equal :areUnitsAvailable.1:firstUnit null
+  387 # "Function: inline def needsFourUnits(in unit)"
+  388 set :needsFourUnits.1:unit @unit
+  389 op sub *tmp44 .DOME_X .CORE_X
+  390 op sub *tmp45 .DOME_Y .CORE_Y
+  391 op len *tmp46 *tmp44 *tmp45
+  392 op mul *tmp47 2 *tmp46
+  393 sensor *tmp48 :needsFourUnits.1:unit @speed
+  394 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  395 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  396 jump *label490 always
+  397 label *label490
+  398 select *tmp51 notEqual *tmp43 false 4 2
+  399 set :areUnitsAvailable.1:needed *tmp51
+  400 label *label491
+  401 sensor *tmp52 @unit @controlled
+  402 jump *label493 equal *tmp52 0
+  403 label *label492
+  404 sensor *tmp54 @unit @controller
+  405 jump *label496 notEqual *tmp54 @this
+  406 label *label493
+  407 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  408 jump *label494 lessThan :areUnitsAvailable.1:free *tmp51
+  409 set *tmp40 true
+  410 jump *label507 always
+  411 label *label494
+  412 label *label495
+  413 jump *label497 always
+  414 label *label496
+  415 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  416 label *label497
+  417 ubind :chooseUnitType:type
+  418 label *label498
+  419 jump *label500 equal @unit :areUnitsAvailable.1:firstUnit
+  420 label *label499
+  421 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  422 jump *label491 equal *tmp61 0
+  423 label *label500
+  424 label *label501
+  425 label *label502
+  426 jump *label505 equal true false
+  427 print :chooseUnitType:type
+  428 print ":"
+  429 print " occupied: "
+  430 print :areUnitsAvailable.1:occupied
+  431 print ","
+  432 print " free: "
+  433 print :areUnitsAvailable.1:free
+  434 jump *label503 lessThanEq :areUnitsAvailable.1:needed 0
+  435 print ", needed: "
+  436 print :areUnitsAvailable.1:needed
+  437 label *label503
+  438 label *label504
+  439 print "\n"
+  440 label *label505
+  441 label *label506
+  442 set *tmp40 false
+  443 jump *label507 always
+  444 label *label507
+  445 jump *label508 equal *tmp40 false
+  446 printflush null
+  447 set *tmp9 :chooseUnitType:type
+  448 jump *label20 always
+  449 label *label508
+  450 label *label509
+  451 label *label510
+  452 label *label511
+  453 label *label512
+  454 label *label48
   455 printflush message1
   456 label *label22
   457 jump *label21 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   145 label *label25
   146 set :chooseUnitType:type @flare
   147 label *label411
-    * jump *label432 equal :chooseUnitType:type UNIT_TYPE
+  148 jump *label432 equal @flare UNIT_TYPE
   149 # "Function: inline def areUnitsAvailable(in type, in output)"
   150 set :areUnitsAvailable.1:free 0
   151 set :areUnitsAvailable.1:occupied 0
   152 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  153 ubind @flare
   154 set :areUnitsAvailable.1:firstUnit @unit
   155 jump *label423 equal :areUnitsAvailable.1:firstUnit null
   156 # "Function: inline def needsFourUnits(in unit)"
 
   183 label *label418
   184 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   185 label *label419
-    * ubind :chooseUnitType:type
+  186 ubind @flare
   187 label *label420
   188 jump *label422 equal @unit :areUnitsAvailable.1:firstUnit
   189 label *label421
 
   193 label *label423
   194 label *label424
   195 jump *label427 equal true false
-    * print :chooseUnitType:type
+  196 print @flare
   197 print ":"
   198 print " occupied: "
   199 print :areUnitsAvailable.1:occupied
 
   213 label *label429
   214 jump *label430 equal *tmp40 false
   215 printflush null
-    * set *tmp9 :chooseUnitType:type
+  216 set *tmp9 @flare
   217 jump *label20 always
   218 label *label430
   219 label *label431
 
   222 label *label434
   223 set :chooseUnitType:type @poly
   224 label *label437
-    * jump *label458 equal :chooseUnitType:type UNIT_TYPE
+  225 jump *label458 equal @poly UNIT_TYPE
   226 # "Function: inline def areUnitsAvailable(in type, in output)"
   227 set :areUnitsAvailable.1:free 0
   228 set :areUnitsAvailable.1:occupied 0
   229 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  230 ubind @poly
   231 set :areUnitsAvailable.1:firstUnit @unit
   232 jump *label449 equal :areUnitsAvailable.1:firstUnit null
   233 # "Function: inline def needsFourUnits(in unit)"
 
   260 label *label444
   261 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   262 label *label445
-    * ubind :chooseUnitType:type
+  263 ubind @poly
   264 label *label446
   265 jump *label448 equal @unit :areUnitsAvailable.1:firstUnit
   266 label *label447
 
   270 label *label449
   271 label *label450
   272 jump *label453 equal true false
-    * print :chooseUnitType:type
+  273 print @poly
   274 print ":"
   275 print " occupied: "
   276 print :areUnitsAvailable.1:occupied
 
   290 label *label455
   291 jump *label456 equal *tmp40 false
   292 printflush null
-    * set *tmp9 :chooseUnitType:type
+  293 set *tmp9 @poly
   294 jump *label20 always
   295 label *label456
   296 label *label457
 
   299 label *label460
   300 set :chooseUnitType:type @mega
   301 label *label463
-    * jump *label484 equal :chooseUnitType:type UNIT_TYPE
+  302 jump *label484 equal @mega UNIT_TYPE
   303 # "Function: inline def areUnitsAvailable(in type, in output)"
   304 set :areUnitsAvailable.1:free 0
   305 set :areUnitsAvailable.1:occupied 0
   306 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  307 ubind @mega
   308 set :areUnitsAvailable.1:firstUnit @unit
   309 jump *label475 equal :areUnitsAvailable.1:firstUnit null
   310 # "Function: inline def needsFourUnits(in unit)"
 
   337 label *label470
   338 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   339 label *label471
-    * ubind :chooseUnitType:type
+  340 ubind @mega
   341 label *label472
   342 jump *label474 equal @unit :areUnitsAvailable.1:firstUnit
   343 label *label473
 
   347 label *label475
   348 label *label476
   349 jump *label479 equal true false
-    * print :chooseUnitType:type
+  350 print @mega
   351 print ":"
   352 print " occupied: "
   353 print :areUnitsAvailable.1:occupied
 
   367 label *label481
   368 jump *label482 equal *tmp40 false
   369 printflush null
-    * set *tmp9 :chooseUnitType:type
+  370 set *tmp9 @mega
   371 jump *label20 always
   372 label *label482
   373 label *label483
 
   376 label *label486
   377 set :chooseUnitType:type @mono
   378 label *label489
-    * jump *label510 equal :chooseUnitType:type UNIT_TYPE
+  379 jump *label510 equal @mono UNIT_TYPE
   380 # "Function: inline def areUnitsAvailable(in type, in output)"
   381 set :areUnitsAvailable.1:free 0
   382 set :areUnitsAvailable.1:occupied 0
   383 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  384 ubind @mono
   385 set :areUnitsAvailable.1:firstUnit @unit
   386 jump *label501 equal :areUnitsAvailable.1:firstUnit null
   387 # "Function: inline def needsFourUnits(in unit)"
 
   414 label *label496
   415 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   416 label *label497
-    * ubind :chooseUnitType:type
+  417 ubind @mono
   418 label *label498
   419 jump *label500 equal @unit :areUnitsAvailable.1:firstUnit
   420 label *label499
 
   424 label *label501
   425 label *label502
   426 jump *label505 equal true false
-    * print :chooseUnitType:type
+  427 print @mono
   428 print ":"
   429 print " occupied: "
   430 print :areUnitsAvailable.1:occupied
 
   444 label *label507
   445 jump *label508 equal *tmp40 false
   446 printflush null
-    * set *tmp9 :chooseUnitType:type
+  447 set *tmp9 @mono
   448 jump *label20 always
   449 label *label508
   450 label *label509

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
   143 jump *label20 always
   144 label *label24
   145 label *label25
-    * set :chooseUnitType:type @flare
   146 label *label411
   147 jump *label432 equal @flare UNIT_TYPE
   148 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   219 label *label432
   220 label *label433
   221 label *label434
-    * set :chooseUnitType:type @poly
   222 label *label437
   223 jump *label458 equal @poly UNIT_TYPE
   224 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   295 label *label458
   296 label *label459
   297 label *label460
-    * set :chooseUnitType:type @mega
   298 label *label463
   299 jump *label484 equal @mega UNIT_TYPE
   300 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   371 label *label484
   372 label *label485
   373 label *label486
-    * set :chooseUnitType:type @mono
   374 label *label489
   375 jump *label510 equal @mono UNIT_TYPE
   376 # "Function: inline def areUnitsAvailable(in type, in output)"

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-5 instructions):
 
   119 label *label34
   120 label *label27
   121 label *label28
-    * jump *label42 equal true false
   122 print UNIT_TYPE
   123 print ":"
   124 print " occupied: "
 
   190 label *label422
   191 label *label423
   192 label *label424
-    * jump *label427 equal true false
   193 print @flare
   194 print ":"
   195 print " occupied: "
 
   265 label *label448
   266 label *label449
   267 label *label450
-    * jump *label453 equal true false
   268 print @poly
   269 print ":"
   270 print " occupied: "
 
   340 label *label474
   341 label *label475
   342 label *label476
-    * jump *label479 equal true false
   343 print @mega
   344 print ":"
   345 print " occupied: "
 
   415 label *label500
   416 label *label501
   417 label *label502
-    * jump *label505 equal true false
   418 print @mono
   419 print ":"
   420 print " occupied: "
 
  1434 label *label363
  1435 label *label356
  1436 label *label357
-    * jump *label371 equal false false
+ 1437 jump *label371 always
  1438 print UNIT_TYPE
  1439 print ":"
  1440 print " occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-19 instructions):
 
    89 sensor *tmp18 :needsFourUnits:unit @speed
    90 op div :needsFourUnits:travel_time *tmp17 *tmp18
    91 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
-    * jump *label381 always
    92 label *label381
    93 select *tmp21 notEqual *tmp13 false 4 2
    94 set :areUnitsAvailable:needed *tmp21
 
   134 label *label42
   135 label *label43
   136 set *tmp10 false
-    * jump *label26 always
   137 label *label26
   138 jump *label24 equal *tmp10 false
   139 set *tmp9 UNIT_TYPE
 
   158 sensor *tmp48 :needsFourUnits.1:unit @speed
   159 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   160 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label412 always
   161 label *label412
   162 select *tmp51 notEqual *tmp43 false 4 2
   163 set :areUnitsAvailable.1:needed *tmp51
 
   203 label *label427
   204 label *label428
   205 set *tmp40 false
-    * jump *label429 always
   206 label *label429
   207 jump *label430 equal *tmp40 false
   208 printflush null
 
   231 sensor *tmp48 :needsFourUnits.1:unit @speed
   232 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   233 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label438 always
   234 label *label438
   235 select *tmp51 notEqual *tmp43 false 4 2
   236 set :areUnitsAvailable.1:needed *tmp51
 
   276 label *label453
   277 label *label454
   278 set *tmp40 false
-    * jump *label455 always
   279 label *label455
   280 jump *label456 equal *tmp40 false
   281 printflush null
 
   304 sensor *tmp48 :needsFourUnits.1:unit @speed
   305 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   306 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label464 always
   307 label *label464
   308 select *tmp51 notEqual *tmp43 false 4 2
   309 set :areUnitsAvailable.1:needed *tmp51
 
   349 label *label479
   350 label *label480
   351 set *tmp40 false
-    * jump *label481 always
   352 label *label481
   353 jump *label482 equal *tmp40 false
   354 printflush null
 
   377 sensor *tmp48 :needsFourUnits.1:unit @speed
   378 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   379 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label490 always
   380 label *label490
   381 select *tmp51 notEqual *tmp43 false 4 2
   382 set :areUnitsAvailable.1:needed *tmp51
 
   422 label *label505
   423 label *label506
   424 set *tmp40 false
-    * jump *label507 always
   425 label *label507
   426 jump *label508 equal *tmp40 false
   427 printflush null
 
   513 label *label89
   514 ucontrol flag 1
   515 set *tmp80 @unit
-    * jump *label88 always
   516 label *label88
   517 set .UNIT_S1 *tmp80
   518 # "Function: inline def acquireUnit(in currentUnit)"
 
   552 label *label103
   553 ucontrol flag 1
   554 set *tmp98 @unit
-    * jump *label102 always
   555 label *label102
   556 set .UNIT_P1 *tmp98
   557 sensor *tmp116 *tmp80 @firstItem
 
   582 sensor *tmp131 .UNIT_S1 @speed
   583 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   584 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
-    * jump *label123 always
   585 label *label123
   586 jump *label124 equal *tmp126 false
   587 # "Function: inline def acquireUnit(in currentUnit)"
 
   621 label *label127
   622 ucontrol flag 1
   623 set *tmp135 @unit
-    * jump *label126 always
   624 label *label126
   625 set .UNIT_S2 *tmp135
   626 # "Function: inline def acquireUnit(in currentUnit)"
 
   660 label *label141
   661 ucontrol flag 1
   662 set *tmp153 @unit
-    * jump *label140 always
   663 label *label140
   664 set .UNIT_P2 *tmp153
   665 sensor *tmp171 .UNIT_S1 @firstItem
 
   707 jump *label165 greaterThanEq *tmp182 *tmp183
   708 label *label166
   709 set .SUPPLY_S_FIRST true
-    * jump *label165 always
   710 label *label165
   711 set .SUPPLY_P_FIRST false
   712 jump *label170 equal *tmp126 false
 
   716 jump *label169 greaterThanEq *tmp187 *tmp188
   717 label *label170
   718 set .SUPPLY_P_FIRST true
-    * jump *label169 always
   719 label *label169
   720 op add :unitCheck @time 5000
   721 label *label172
 
  1387 sensor *tmp474 :needsFourUnits.3:unit @speed
  1388 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
  1389 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
-    * jump *label383 always
  1390 label *label383
  1391 select *tmp477 notEqual *tmp469 false 4 2
  1392 set :areUnitsAvailable.2:needed *tmp477
 
  1433 label *label371
  1434 label *label372
  1435 set *tmp466 false
-    * jump *label355 always
  1436 label *label355
  1437 jump *label353 equal *tmp466 false
  1438 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-2 instructions):
 
  1378 # "Function: inline def areUnitsAvailable(in type, in output)"
  1379 set :areUnitsAvailable.2:free 0
  1380 set :areUnitsAvailable.2:occupied 0
-    * set :areUnitsAvailable.2:needed 0
  1381 ubind UNIT_TYPE
  1382 set :areUnitsAvailable.2:firstUnit @unit
  1383 jump *label356 equal :areUnitsAvailable.2:firstUnit null
 
  1388 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
  1389 label *label383
  1390 select *tmp477 notEqual *tmp469 false 4 2
-    * set :areUnitsAvailable.2:needed *tmp477
  1391 label *label361
  1392 sensor *tmp478 @unit @controlled
  1393 jump *label366 equal *tmp478 0

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     3 remark "Do not modify anything below this line."
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
-    * label *label2
     6 jump *label4 notEqual dome1 null
     7 label *label380
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
-    * label *label3
    11 jump *label380 equal dome1 null
    12 label *label4
    13 print "[gold]Locating core..."
    14 printflush message1
    15 set .CORE null
    16 label *label5
-    * label *label384
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
    19 jump *label385 equal :locateCore*retval false
    20 jump *label1 always
    21 label *label385
-    * label *label386
-    * label *label387
-    * label *label390
    22 set :locateCore:type @poly
    23 call *label0 :locateCore*retaddr :locateCore*retval
    24 jump *label391 equal :locateCore*retval false
    25 jump *label1 always
    26 label *label391
-    * label *label392
-    * label *label393
-    * label *label396
    27 set :locateCore:type @mega
    28 call *label0 :locateCore*retaddr :locateCore*retval
    29 jump *label397 equal :locateCore*retval false
    30 jump *label1 always
    31 label *label397
-    * label *label398
-    * label *label399
-    * label *label402
    32 set :locateCore:type @mono
    33 call *label0 :locateCore*retaddr :locateCore*retval
    34 jump *label403 equal :locateCore*retval false
    35 jump *label1 always
    36 label *label403
-    * label *label404
-    * label *label405
-    * label *label10
-    * label *label6
    37 jump *label5 always
-    * label *label7
    38 label *label1
    39 sensor .CORE_X .CORE @x
    40 sensor .CORE_Y .CORE @y
    41 sensor .DOME_X .DOME @x
    42 sensor .DOME_Y .DOME @y
-    * label *label17
    43 sensor *tmp7 switch1 @enabled
    44 jump *label19 notEqual *tmp7 false
    45 label *label409
    46 print "[coral]Activate switch to begin supplying overdrive dome..."
    47 print "\n"
    48 printflush message1
-    * label *label18
    49 sensor *tmp7 switch1 @enabled
    50 jump *label409 equal *tmp7 false
    51 label *label19
 
    70 sensor *tmp18 :needsFourUnits:unit @speed
    71 op div :needsFourUnits:travel_time *tmp17 *tmp18
    72 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
-    * label *label381
    73 select *tmp21 notEqual *tmp13 false 4 2
    74 set :areUnitsAvailable:needed *tmp21
    75 label *label32
    76 sensor *tmp22 @unit @controlled
    77 jump *label37 equal *tmp22 0
-    * label *label38
    78 sensor *tmp24 @unit @controller
    79 jump *label35 notEqual *tmp24 @this
    80 label *label37
 
    83 set *tmp10 true
    84 jump *label26 always
    85 label *label39
-    * label *label40
    86 jump *label36 always
    87 label *label35
    88 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    89 label *label36
    90 ubind UNIT_TYPE
-    * label *label33
    91 jump *label34 equal @unit :areUnitsAvailable:firstUnit
-    * label *label41
    92 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
    93 jump *label32 equal *tmp31 0
    94 label *label34
    95 label *label27
-    * label *label28
    96 print UNIT_TYPE
    97 print ":"
    98 print " occupied: "
 
   104 print ", needed: "
   105 print :areUnitsAvailable:needed
   106 label *label44
-    * label *label45
   107 print "\n"
-    * label *label42
-    * label *label43
   108 set *tmp10 false
   109 label *label26
   110 jump *label24 equal *tmp10 false
   111 set *tmp9 UNIT_TYPE
   112 jump *label20 always
   113 label *label24
-    * label *label25
-    * label *label411
   114 jump *label432 equal @flare UNIT_TYPE
   115 # "Function: inline def areUnitsAvailable(in type, in output)"
   116 set :areUnitsAvailable.1:free 0
 
   128 sensor *tmp48 :needsFourUnits.1:unit @speed
   129 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   130 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * label *label412
   131 select *tmp51 notEqual *tmp43 false 4 2
   132 set :areUnitsAvailable.1:needed *tmp51
   133 label *label413
   134 sensor *tmp52 @unit @controlled
   135 jump *label415 equal *tmp52 0
-    * label *label414
   136 sensor *tmp54 @unit @controller
   137 jump *label418 notEqual *tmp54 @this
   138 label *label415
 
   141 set *tmp40 true
   142 jump *label429 always
   143 label *label416
-    * label *label417
   144 jump *label419 always
   145 label *label418
   146 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   147 label *label419
   148 ubind @flare
-    * label *label420
   149 jump *label422 equal @unit :areUnitsAvailable.1:firstUnit
-    * label *label421
   150 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   151 jump *label413 equal *tmp61 0
   152 label *label422
   153 label *label423
-    * label *label424
   154 print @flare
   155 print ":"
   156 print " occupied: "
 
   162 print ", needed: "
   163 print :areUnitsAvailable.1:needed
   164 label *label425
-    * label *label426
   165 print "\n"
-    * label *label427
-    * label *label428
   166 set *tmp40 false
   167 label *label429
   168 jump *label430 equal *tmp40 false
 
   170 set *tmp9 @flare
   171 jump *label20 always
   172 label *label430
-    * label *label431
   173 label *label432
-    * label *label433
-    * label *label434
-    * label *label437
   174 jump *label458 equal @poly UNIT_TYPE
   175 # "Function: inline def areUnitsAvailable(in type, in output)"
   176 set :areUnitsAvailable.1:free 0
 
   188 sensor *tmp48 :needsFourUnits.1:unit @speed
   189 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   190 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * label *label438
   191 select *tmp51 notEqual *tmp43 false 4 2
   192 set :areUnitsAvailable.1:needed *tmp51
   193 label *label439
   194 sensor *tmp52 @unit @controlled
   195 jump *label441 equal *tmp52 0
-    * label *label440
   196 sensor *tmp54 @unit @controller
   197 jump *label444 notEqual *tmp54 @this
   198 label *label441
 
   201 set *tmp40 true
   202 jump *label455 always
   203 label *label442
-    * label *label443
   204 jump *label445 always
   205 label *label444
   206 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   207 label *label445
   208 ubind @poly
-    * label *label446
   209 jump *label448 equal @unit :areUnitsAvailable.1:firstUnit
-    * label *label447
   210 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   211 jump *label439 equal *tmp61 0
   212 label *label448
   213 label *label449
-    * label *label450
   214 print @poly
   215 print ":"
   216 print " occupied: "
 
   222 print ", needed: "
   223 print :areUnitsAvailable.1:needed
   224 label *label451
-    * label *label452
   225 print "\n"
-    * label *label453
-    * label *label454
   226 set *tmp40 false
   227 label *label455
   228 jump *label456 equal *tmp40 false
 
   230 set *tmp9 @poly
   231 jump *label20 always
   232 label *label456
-    * label *label457
   233 label *label458
-    * label *label459
-    * label *label460
-    * label *label463
   234 jump *label484 equal @mega UNIT_TYPE
   235 # "Function: inline def areUnitsAvailable(in type, in output)"
   236 set :areUnitsAvailable.1:free 0
 
   248 sensor *tmp48 :needsFourUnits.1:unit @speed
   249 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   250 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * label *label464
   251 select *tmp51 notEqual *tmp43 false 4 2
   252 set :areUnitsAvailable.1:needed *tmp51
   253 label *label465
   254 sensor *tmp52 @unit @controlled
   255 jump *label467 equal *tmp52 0
-    * label *label466
   256 sensor *tmp54 @unit @controller
   257 jump *label470 notEqual *tmp54 @this
   258 label *label467
 
   261 set *tmp40 true
   262 jump *label481 always
   263 label *label468
-    * label *label469
   264 jump *label471 always
   265 label *label470
   266 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   267 label *label471
   268 ubind @mega
-    * label *label472
   269 jump *label474 equal @unit :areUnitsAvailable.1:firstUnit
-    * label *label473
   270 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   271 jump *label465 equal *tmp61 0
   272 label *label474
   273 label *label475
-    * label *label476
   274 print @mega
   275 print ":"
   276 print " occupied: "
 
   282 print ", needed: "
   283 print :areUnitsAvailable.1:needed
   284 label *label477
-    * label *label478
   285 print "\n"
-    * label *label479
-    * label *label480
   286 set *tmp40 false
   287 label *label481
   288 jump *label482 equal *tmp40 false
 
   290 set *tmp9 @mega
   291 jump *label20 always
   292 label *label482
-    * label *label483
   293 label *label484
-    * label *label485
-    * label *label486
-    * label *label489
   294 jump *label510 equal @mono UNIT_TYPE
   295 # "Function: inline def areUnitsAvailable(in type, in output)"
   296 set :areUnitsAvailable.1:free 0
 
   308 sensor *tmp48 :needsFourUnits.1:unit @speed
   309 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   310 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * label *label490
   311 select *tmp51 notEqual *tmp43 false 4 2
   312 set :areUnitsAvailable.1:needed *tmp51
   313 label *label491
   314 sensor *tmp52 @unit @controlled
   315 jump *label493 equal *tmp52 0
-    * label *label492
   316 sensor *tmp54 @unit @controller
   317 jump *label496 notEqual *tmp54 @this
   318 label *label493
 
   321 set *tmp40 true
   322 jump *label507 always
   323 label *label494
-    * label *label495
   324 jump *label497 always
   325 label *label496
   326 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   327 label *label497
   328 ubind @mono
-    * label *label498
   329 jump *label500 equal @unit :areUnitsAvailable.1:firstUnit
-    * label *label499
   330 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   331 jump *label491 equal *tmp61 0
   332 label *label500
   333 label *label501
-    * label *label502
   334 print @mono
   335 print ":"
   336 print " occupied: "
 
   342 print ", needed: "
   343 print :areUnitsAvailable.1:needed
   344 label *label503
-    * label *label504
   345 print "\n"
-    * label *label505
-    * label *label506
   346 set *tmp40 false
   347 label *label507
   348 jump *label508 equal *tmp40 false
 
   350 set *tmp9 @mono
   351 jump *label20 always
   352 label *label508
-    * label *label509
   353 label *label510
-    * label *label511
-    * label *label512
-    * label *label48
   354 printflush message1
-    * label *label22
   355 jump *label21 always
-    * label *label23
   356 set *tmp9 null
   357 label *label20
   358 print "[gold]Binding units..."
 
   368 jump *label78 notEqual :rebindUnits:firstUnit null
   369 end
   370 label *label78
-    * label *label79
   371 label *label80
   372 sensor *tmp70 @unit @controller
   373 jump *label83 notEqual *tmp70 @this
 
   380 jump *label85 equal .UNIT_S2 null
   381 jump *label82 always
   382 label *label85
-    * label *label86
   383 label *label83
-    * label *label84
   384 ubind *tmp9
-    * label *label81
   385 jump *label82 equal @unit :rebindUnits:firstUnit
-    * label *label87
   386 sensor *tmp78 :rebindUnits:firstUnit @dead
   387 jump *label80 equal *tmp78 0
   388 label *label82
-    * label *label77
   389 # "Function: inline def acquireUnit(in currentUnit)"
   390 # "Function: inline def rebindUnit(in currentUnit)"
   391 jump *label90 equal .UNIT_S1 null
 
   398 jump *label92 equal *tmp88 false
   399 jump *label89 always
   400 label *label92
-    * label *label93
   401 label *label90
-    * label *label91
   402 ubind *tmp9
   403 set :rebindUnit:firstUnit @unit
   404 jump *label94 equal :rebindUnit:firstUnit null
 
   407 jump *label99 notEqual *tmp92 0
   408 jump *label89 always
   409 label *label99
-    * label *label100
   410 ubind *tmp9
-    * label *label97
   411 jump *label98 equal @unit :rebindUnit:firstUnit
-    * label *label101
   412 sensor *tmp96 :rebindUnit:firstUnit @dead
   413 jump *label96 equal *tmp96 0
   414 label *label98
   415 label *label94
-    * label *label95
   416 end
   417 label *label89
   418 ucontrol flag 1
   419 set *tmp80 @unit
-    * label *label88
   420 set .UNIT_S1 *tmp80
   421 # "Function: inline def acquireUnit(in currentUnit)"
   422 # "Function: inline def rebindUnit(in currentUnit)"
 
   430 jump *label106 equal *tmp106 false
   431 jump *label103 always
   432 label *label106
-    * label *label107
   433 label *label104
-    * label *label105
   434 ubind *tmp9
   435 set :rebindUnit.1:firstUnit @unit
   436 jump *label108 equal :rebindUnit.1:firstUnit null
 
   439 jump *label113 notEqual *tmp110 0
   440 jump *label103 always
   441 label *label113
-    * label *label114
   442 ubind *tmp9
-    * label *label111
   443 jump *label112 equal @unit :rebindUnit.1:firstUnit
-    * label *label115
   444 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   445 jump *label110 equal *tmp114 0
   446 label *label112
   447 label *label108
-    * label *label109
   448 end
   449 label *label103
   450 ucontrol flag 1
   451 set *tmp98 @unit
-    * label *label102
   452 set .UNIT_P1 *tmp98
   453 sensor *tmp116 *tmp80 @firstItem
   454 jump *label118 equal *tmp116 @phase-fabric
-    * label *label119
   455 sensor *tmp118 *tmp98 @firstItem
   456 jump *label116 notEqual *tmp118 @silicon
   457 label *label118
   458 # "Function: inline void swap(in out a, in out b)"
-    * label *label120
   459 set .UNIT_S1 *tmp98
   460 set .UNIT_P1 *tmp80
   461 label *label116
-    * label *label117
   462 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
   463 sensor .SPEED .UNIT_S1 @speed
   464 op div .SPEED_TENTHS .SPEED 10
 
   466 jump *label121 equal *tmp124 false
   467 stop
   468 label *label121
-    * label *label122
   469 # "Function: inline def needsFourUnits(in unit)"
   470 op sub *tmp127 .DOME_X .CORE_X
   471 op sub *tmp128 .DOME_Y .CORE_Y
 
   474 sensor *tmp131 .UNIT_S1 @speed
   475 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   476 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
-    * label *label123
   477 jump *label124 equal *tmp126 false
   478 # "Function: inline def acquireUnit(in currentUnit)"
   479 # "Function: inline def rebindUnit(in currentUnit)"
 
   487 jump *label130 equal *tmp143 false
   488 jump *label127 always
   489 label *label130
-    * label *label131
   490 label *label128
-    * label *label129
   491 ubind *tmp9
   492 set :rebindUnit.2:firstUnit @unit
   493 jump *label132 equal :rebindUnit.2:firstUnit null
 
   496 jump *label137 notEqual *tmp147 0
   497 jump *label127 always
   498 label *label137
-    * label *label138
   499 ubind *tmp9
-    * label *label135
   500 jump *label136 equal @unit :rebindUnit.2:firstUnit
-    * label *label139
   501 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   502 jump *label134 equal *tmp151 0
   503 label *label136
   504 label *label132
-    * label *label133
   505 end
   506 label *label127
   507 ucontrol flag 1
   508 set *tmp135 @unit
-    * label *label126
   509 set .UNIT_S2 *tmp135
   510 # "Function: inline def acquireUnit(in currentUnit)"
   511 # "Function: inline def rebindUnit(in currentUnit)"
 
   519 jump *label144 equal *tmp161 false
   520 jump *label141 always
   521 label *label144
-    * label *label145
   522 label *label142
-    * label *label143
   523 ubind *tmp9
   524 set :rebindUnit.3:firstUnit @unit
   525 jump *label146 equal :rebindUnit.3:firstUnit null
 
   528 jump *label151 notEqual *tmp165 0
   529 jump *label141 always
   530 label *label151
-    * label *label152
   531 ubind *tmp9
-    * label *label149
   532 jump *label150 equal @unit :rebindUnit.3:firstUnit
-    * label *label153
   533 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   534 jump *label148 equal *tmp169 0
   535 label *label150
   536 label *label146
-    * label *label147
   537 end
   538 label *label141
   539 ucontrol flag 1
   540 set *tmp153 @unit
-    * label *label140
   541 set .UNIT_P2 *tmp153
   542 sensor *tmp171 .UNIT_S1 @firstItem
   543 jump *label154 notEqual *tmp171 @phase-fabric
-    * label *label157
   544 sensor *tmp173 *tmp153 @firstItem
   545 jump *label154 equal *tmp173 @phase-fabric
-    * label *label156
   546 # "Function: inline void swap(in out a, in out b)"
   547 set :swap.1:t .UNIT_S1
-    * label *label158
   548 set .UNIT_S1 *tmp153
   549 set .UNIT_P2 :swap.1:t
   550 label *label154
-    * label *label155
   551 sensor *tmp176 *tmp135 @firstItem
   552 jump *label161 equal *tmp176 @phase-fabric
-    * label *label162
   553 sensor *tmp178 .UNIT_P2 @firstItem
   554 jump *label159 notEqual *tmp178 @silicon
   555 label *label161
   556 # "Function: inline void swap(in out a, in out b)"
-    * label *label163
   557 set .UNIT_S2 .UNIT_P2
   558 set .UNIT_P2 *tmp135
   559 label *label159
-    * label *label160
   560 set .GROUP1 "unit  1"
   561 set .GROUP2 "unit 2"
   562 jump *label125 always
 
   571 label *label125
   572 set .SUPPLY_S_FIRST false
   573 jump *label166 equal *tmp126 false
-    * label *label167
   574 sensor *tmp182 .UNIT_S1 @totalItems
   575 sensor *tmp183 .UNIT_S2 @totalItems
   576 jump *label165 greaterThanEq *tmp182 *tmp183
 
   579 label *label165
   580 set .SUPPLY_P_FIRST false
   581 jump *label170 equal *tmp126 false
-    * label *label171
   582 sensor *tmp187 .UNIT_P1 @totalItems
   583 sensor *tmp188 .UNIT_P2 @totalItems
   584 jump *label169 greaterThanEq *tmp187 *tmp188
 
   586 set .SUPPLY_P_FIRST true
   587 label *label169
   588 op add :unitCheck @time 5000
-    * label *label172
   589 sensor *tmp192 switch1 @enabled
   590 jump *label174 equal *tmp192 false
   591 label *label410
 
   615 print "]"
   616 print "\n"
   617 label *label177
-    * label *label175
   618 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   619 # "Function: inline def rebindUnit(in currentUnit)"
   620 jump *label180 equal .UNIT_S1 null
 
   627 jump *label182 equal *tmp203 false
   628 jump *label179 always
   629 label *label182
-    * label *label183
   630 label *label180
-    * label *label181
   631 ubind *tmp9
   632 set :rebindUnit.4:firstUnit @unit
   633 jump *label184 equal :rebindUnit.4:firstUnit null
 
   636 jump *label189 notEqual *tmp207 0
   637 jump *label179 always
   638 label *label189
-    * label *label190
   639 ubind *tmp9
-    * label *label187
   640 jump *label188 equal @unit :rebindUnit.4:firstUnit
-    * label *label191
   641 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   642 jump *label186 equal *tmp211 0
   643 label *label188
   644 label *label184
-    * label *label185
   645 end
   646 label *label179
   647 sensor :processUnit:state @unit @flag
   648 set :processUnit:distance -1
   649 jump *label194 lessThan :processUnit:state 2
-    * label *label195
   650 jump *label192 lessThanEq :processUnit:state 3
   651 label *label194
   652 sensor *tmp217 @unit @firstItem
 
   665 jump *label200 equal *tmp223 false
   666 ucontrol itemDrop .CORE .UNIT_CAPACITY
   667 label *label200
-    * label *label201
   668 label *label199
   669 label *label197
   670 label *label192
-    * label *label193
   671 jump *label202 notEqual :processUnit:state 2
   672 ucontrol within .CORE_X .CORE_Y 8 *tmp227
   673 jump *label204 equal *tmp227 false
 
   693 op div :processUnit:distance *tmp237 10
   694 label *label205
   695 label *label202
-    * label *label203
   696 jump *label208 notEqual :processUnit:state 3
   697 ucontrol within .DOME_X .DOME_Y 8 *tmp241
   698 jump *label210 equal *tmp241 false
 
   709 ucontrol approach .CORE_X .CORE_Y 6
   710 set :processUnit:state 2
   711 label *label214
-    * label *label215
   712 jump *label211 always
   713 label *label210
   714 ucontrol approach .DOME_X .DOME_Y 6
 
   722 op div :processUnit:distance *tmp252 10
   723 label *label211
   724 label *label208
-    * label *label209
   725 ucontrol flag :processUnit:state
   726 sensor *tmp254 @unit @totalItems
   727 print "  "
 
   744 print .MSG
   745 label *label217
   746 set :processUnit:unit @unit
-    * label *label178
   747 set .UNIT_S1 :processUnit:unit
   748 jump *label218 equal *tmp126 false
   749 op equal *tmp259 .SUPPLY_S_FIRST false
 
   759 jump *label224 equal *tmp267 false
   760 jump *label221 always
   761 label *label224
-    * label *label225
   762 label *label222
-    * label *label223
   763 ubind *tmp9
   764 set :rebindUnit.5:firstUnit @unit
   765 jump *label226 equal :rebindUnit.5:firstUnit null
 
   768 jump *label231 notEqual *tmp271 0
   769 jump *label221 always
   770 label *label231
-    * label *label232
   771 ubind *tmp9
-    * label *label229
   772 jump *label230 equal @unit :rebindUnit.5:firstUnit
-    * label *label233
   773 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   774 jump *label228 equal *tmp275 0
   775 label *label230
   776 label *label226
-    * label *label227
   777 end
   778 label *label221
   779 sensor :processUnit.1:state @unit @flag
   780 set :processUnit.1:distance -1
   781 jump *label236 lessThan :processUnit.1:state 2
-    * label *label237
   782 jump *label234 lessThanEq :processUnit.1:state 3
   783 label *label236
   784 sensor *tmp281 @unit @firstItem
 
   797 jump *label242 equal *tmp287 false
   798 ucontrol itemDrop .CORE .UNIT_CAPACITY
   799 label *label242
-    * label *label243
   800 label *label241
   801 label *label239
   802 label *label234
-    * label *label235
   803 jump *label244 notEqual :processUnit.1:state 2
   804 ucontrol within .CORE_X .CORE_Y 8 *tmp291
   805 jump *label246 equal *tmp291 false
 
   825 op div :processUnit.1:distance *tmp301 10
   826 label *label247
   827 label *label244
-    * label *label245
   828 jump *label250 notEqual :processUnit.1:state 3
   829 ucontrol within .DOME_X .DOME_Y 8 *tmp305
   830 jump *label252 equal *tmp305 false
 
   841 ucontrol approach .CORE_X .CORE_Y 6
   842 set :processUnit.1:state 2
   843 label *label256
-    * label *label257
   844 jump *label253 always
   845 label *label252
   846 ucontrol approach .DOME_X .DOME_Y 6
 
   854 op div :processUnit.1:distance *tmp316 10
   855 label *label253
   856 label *label250
-    * label *label251
   857 ucontrol flag :processUnit.1:state
   858 sensor *tmp318 @unit @totalItems
   859 print "  "
 
   876 print .MSG
   877 label *label259
   878 set :processUnit.1:unit @unit
-    * label *label220
   879 set .UNIT_S2 :processUnit.1:unit
   880 jump *label260 equal .SUPPLY_S_FIRST false
   881 sensor *tmp323 :processUnit:unit @totalItems
 
   886 op equal .SUPPLY_S_FIRST *tmp325 0
   887 label *label261
   888 label *label218
-    * label *label219
   889 # "Function: inline void printDomeStatus(in item, in text)"
   890 print "\n[green]Phase fabric[] status:\n"
   891 sensor :printDomeStatus.1:level .DOME @phase-fabric
 
   903 print "]"
   904 print "\n"
   905 label *label264
-    * label *label262
   906 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   907 # "Function: inline def rebindUnit(in currentUnit)"
   908 jump *label267 equal .UNIT_P1 null
 
   915 jump *label269 equal *tmp337 false
   916 jump *label266 always
   917 label *label269
-    * label *label270
   918 label *label267
-    * label *label268
   919 ubind *tmp9
   920 set :rebindUnit.6:firstUnit @unit
   921 jump *label271 equal :rebindUnit.6:firstUnit null
 
   924 jump *label276 notEqual *tmp341 0
   925 jump *label266 always
   926 label *label276
-    * label *label277
   927 ubind *tmp9
-    * label *label274
   928 jump *label275 equal @unit :rebindUnit.6:firstUnit
-    * label *label278
   929 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   930 jump *label273 equal *tmp345 0
   931 label *label275
   932 label *label271
-    * label *label272
   933 end
   934 label *label266
   935 sensor :processUnit.2:state @unit @flag
   936 set :processUnit.2:distance -1
   937 jump *label281 lessThan :processUnit.2:state 2
-    * label *label282
   938 jump *label279 lessThanEq :processUnit.2:state 3
   939 label *label281
   940 sensor *tmp351 @unit @firstItem
 
   953 jump *label287 equal *tmp357 false
   954 ucontrol itemDrop .CORE .UNIT_CAPACITY
   955 label *label287
-    * label *label288
   956 label *label286
   957 label *label284
   958 label *label279
-    * label *label280
   959 jump *label289 notEqual :processUnit.2:state 2
   960 ucontrol within .CORE_X .CORE_Y 8 *tmp361
   961 jump *label291 equal *tmp361 false
 
   981 op div :processUnit.2:distance *tmp371 10
   982 label *label292
   983 label *label289
-    * label *label290
   984 jump *label295 notEqual :processUnit.2:state 3
   985 ucontrol within .DOME_X .DOME_Y 8 *tmp375
   986 jump *label297 equal *tmp375 false
 
   997 ucontrol approach .CORE_X .CORE_Y 6
   998 set :processUnit.2:state 2
   999 label *label301
-    * label *label302
  1000 jump *label298 always
  1001 label *label297
  1002 ucontrol approach .DOME_X .DOME_Y 6
 
  1010 op div :processUnit.2:distance *tmp386 10
  1011 label *label298
  1012 label *label295
-    * label *label296
  1013 ucontrol flag :processUnit.2:state
  1014 sensor *tmp388 @unit @totalItems
  1015 print "  "
 
  1032 print .MSG
  1033 label *label304
  1034 set :processUnit.2:unit @unit
-    * label *label265
  1035 set .UNIT_P1 :processUnit.2:unit
  1036 jump *label305 equal *tmp126 false
  1037 op equal *tmp393 .SUPPLY_P_FIRST false
 
  1047 jump *label311 equal *tmp401 false
  1048 jump *label308 always
  1049 label *label311
-    * label *label312
  1050 label *label309
-    * label *label310
  1051 ubind *tmp9
  1052 set :rebindUnit.7:firstUnit @unit
  1053 jump *label313 equal :rebindUnit.7:firstUnit null
 
  1056 jump *label318 notEqual *tmp405 0
  1057 jump *label308 always
  1058 label *label318
-    * label *label319
  1059 ubind *tmp9
-    * label *label316
  1060 jump *label317 equal @unit :rebindUnit.7:firstUnit
-    * label *label320
  1061 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1062 jump *label315 equal *tmp409 0
  1063 label *label317
  1064 label *label313
-    * label *label314
  1065 end
  1066 label *label308
  1067 sensor :processUnit.3:state @unit @flag
  1068 set :processUnit.3:distance -1
  1069 jump *label323 lessThan :processUnit.3:state 2
-    * label *label324
  1070 jump *label321 lessThanEq :processUnit.3:state 3
  1071 label *label323
  1072 sensor *tmp415 @unit @firstItem
 
  1085 jump *label329 equal *tmp421 false
  1086 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1087 label *label329
-    * label *label330
  1088 label *label328
  1089 label *label326
  1090 label *label321
-    * label *label322
  1091 jump *label331 notEqual :processUnit.3:state 2
  1092 ucontrol within .CORE_X .CORE_Y 8 *tmp425
  1093 jump *label333 equal *tmp425 false
 
  1113 op div :processUnit.3:distance *tmp435 10
  1114 label *label334
  1115 label *label331
-    * label *label332
  1116 jump *label337 notEqual :processUnit.3:state 3
  1117 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1118 jump *label339 equal *tmp439 false
 
  1129 ucontrol approach .CORE_X .CORE_Y 6
  1130 set :processUnit.3:state 2
  1131 label *label343
-    * label *label344
  1132 jump *label340 always
  1133 label *label339
  1134 ucontrol approach .DOME_X .DOME_Y 6
 
  1142 op div :processUnit.3:distance *tmp450 10
  1143 label *label340
  1144 label *label337
-    * label *label338
  1145 ucontrol flag :processUnit.3:state
  1146 sensor *tmp452 @unit @totalItems
  1147 print "  "
 
  1164 print .MSG
  1165 label *label346
  1166 set :processUnit.3:unit @unit
-    * label *label307
  1167 set .UNIT_P2 :processUnit.3:unit
  1168 jump *label347 equal .SUPPLY_P_FIRST false
  1169 sensor *tmp457 :processUnit.2:unit @totalItems
 
  1174 op equal .SUPPLY_P_FIRST *tmp459 0
  1175 label *label348
  1176 label *label305
-    * label *label306
  1177 op sub *tmp461 @time :start
  1178 op floor *tmp462 *tmp461
  1179 print "\n"
 
  1183 print "ms"
  1184 printflush message1
  1185 jump *label349 equal *tmp9 UNIT_TYPE
-    * label *label352
  1186 jump *label349 lessThanEq :unitCheck @time
-    * label *label351
  1187 # "Function: inline def areUnitsAvailable(in type, in output)"
  1188 set :areUnitsAvailable.2:free 0
  1189 set :areUnitsAvailable.2:occupied 0
 
  1195 sensor *tmp474 :needsFourUnits.3:unit @speed
  1196 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
  1197 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
-    * label *label383
  1198 select *tmp477 notEqual *tmp469 false 4 2
  1199 label *label361
  1200 sensor *tmp478 @unit @controlled
  1201 jump *label366 equal *tmp478 0
-    * label *label367
  1202 sensor *tmp480 @unit @controller
  1203 jump *label364 notEqual *tmp480 @this
  1204 label *label366
 
  1207 set *tmp466 true
  1208 jump *label355 always
  1209 label *label368
-    * label *label369
  1210 jump *label365 always
  1211 label *label364
  1212 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1213 label *label365
  1214 ubind UNIT_TYPE
-    * label *label362
  1215 jump *label363 equal @unit :areUnitsAvailable.2:firstUnit
-    * label *label370
  1216 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1217 jump *label361 equal *tmp487 0
  1218 label *label363
  1219 label *label356
-    * label *label357
  1220 jump *label371 always
  1221 print UNIT_TYPE
  1222 print ":"
 
  1229 print ", needed: "
  1230 print :areUnitsAvailable.2:needed
  1231 label *label373
-    * label *label374
  1232 print "\n"
  1233 label *label371
-    * label *label372
  1234 set *tmp466 false
  1235 label *label355
  1236 jump *label353 equal *tmp466 false
  1237 end
  1238 label *label353
-    * label *label354
  1239 op add :unitCheck @time 5000
  1240 label *label349
-    * label *label350
-    * label *label173
  1241 sensor *tmp192 switch1 @enabled
  1242 jump *label410 notEqual *tmp192 false
  1243 label *label174
 
  1247 ubind :locateCore:type
  1248 sensor *tmp494 @unit @controlled
  1249 jump *label378 equal *tmp494 0
-    * label *label379
  1250 sensor *tmp496 @unit @controller
  1251 jump *label376 notEqual *tmp496 @this
  1252 label *label378
  1253 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1254 label *label376
-    * label *label377
  1255 set :locateCore*retval .CORE
-    * label *label375
  1256 return :locateCore*retaddr
  1257 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-21 instructions):
 
    16 label *label5
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label385 equal :locateCore*retval false
-    * jump *label1 always
+   19 jump *label1 notEqual :locateCore*retval false
    20 label *label385
    21 set :locateCore:type @poly
    22 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label391 equal :locateCore*retval false
-    * jump *label1 always
+   23 jump *label1 notEqual :locateCore*retval false
    24 label *label391
    25 set :locateCore:type @mega
    26 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label397 equal :locateCore*retval false
-    * jump *label1 always
+   27 jump *label1 notEqual :locateCore*retval false
    28 label *label397
    29 set :locateCore:type @mono
    30 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label403 equal :locateCore*retval false
-    * jump *label1 always
+   31 jump *label1 notEqual :locateCore*retval false
    32 label *label403
    33 jump *label5 always
    34 label *label1
 
   373 set .UNIT_P2 .UNIT_S1
   374 set .UNIT_S1 .UNIT_P1
   375 set .UNIT_P1 @unit
-    * jump *label85 equal .UNIT_S2 null
-    * jump *label82 always
+  376 jump *label82 notEqual .UNIT_S2 null
   377 label *label85
   378 label *label83
   379 ubind *tmp9
 
   390 sensor *tmp86 @unit @controller
   391 op equal *tmp87 *tmp86 @this
   392 op land *tmp88 *tmp85 *tmp87
-    * jump *label92 equal *tmp88 false
-    * jump *label89 always
+  393 jump *label89 notEqual *tmp88 false
   394 label *label92
   395 label *label90
   396 ubind *tmp9
 
   398 jump *label94 equal :rebindUnit:firstUnit null
   399 label *label96
   400 sensor *tmp92 @unit @controlled
-    * jump *label99 notEqual *tmp92 0
-    * jump *label89 always
+  401 jump *label89 equal *tmp92 0
   402 label *label99
   403 ubind *tmp9
   404 jump *label98 equal @unit :rebindUnit:firstUnit
 
   420 sensor *tmp104 @unit @controller
   421 op equal *tmp105 *tmp104 @this
   422 op land *tmp106 *tmp103 *tmp105
-    * jump *label106 equal *tmp106 false
-    * jump *label103 always
+  423 jump *label103 notEqual *tmp106 false
   424 label *label106
   425 label *label104
   426 ubind *tmp9
 
   428 jump *label108 equal :rebindUnit.1:firstUnit null
   429 label *label110
   430 sensor *tmp110 @unit @controlled
-    * jump *label113 notEqual *tmp110 0
-    * jump *label103 always
+  431 jump *label103 equal *tmp110 0
   432 label *label113
   433 ubind *tmp9
   434 jump *label112 equal @unit :rebindUnit.1:firstUnit
 
   475 sensor *tmp141 @unit @controller
   476 op equal *tmp142 *tmp141 @this
   477 op land *tmp143 *tmp140 *tmp142
-    * jump *label130 equal *tmp143 false
-    * jump *label127 always
+  478 jump *label127 notEqual *tmp143 false
   479 label *label130
   480 label *label128
   481 ubind *tmp9
 
   483 jump *label132 equal :rebindUnit.2:firstUnit null
   484 label *label134
   485 sensor *tmp147 @unit @controlled
-    * jump *label137 notEqual *tmp147 0
-    * jump *label127 always
+  486 jump *label127 equal *tmp147 0
   487 label *label137
   488 ubind *tmp9
   489 jump *label136 equal @unit :rebindUnit.2:firstUnit
 
   505 sensor *tmp159 @unit @controller
   506 op equal *tmp160 *tmp159 @this
   507 op land *tmp161 *tmp158 *tmp160
-    * jump *label144 equal *tmp161 false
-    * jump *label141 always
+  508 jump *label141 notEqual *tmp161 false
   509 label *label144
   510 label *label142
   511 ubind *tmp9
 
   513 jump *label146 equal :rebindUnit.3:firstUnit null
   514 label *label148
   515 sensor *tmp165 @unit @controlled
-    * jump *label151 notEqual *tmp165 0
-    * jump *label141 always
+  516 jump *label141 equal *tmp165 0
   517 label *label151
   518 ubind *tmp9
   519 jump *label150 equal @unit :rebindUnit.3:firstUnit
 
   611 sensor *tmp201 @unit @controller
   612 op equal *tmp202 *tmp201 @this
   613 op land *tmp203 *tmp200 *tmp202
-    * jump *label182 equal *tmp203 false
-    * jump *label179 always
+  614 jump *label179 notEqual *tmp203 false
   615 label *label182
   616 label *label180
   617 ubind *tmp9
 
   619 jump *label184 equal :rebindUnit.4:firstUnit null
   620 label *label186
   621 sensor *tmp207 @unit @controlled
-    * jump *label189 notEqual *tmp207 0
-    * jump *label179 always
+  622 jump *label179 equal *tmp207 0
   623 label *label189
   624 ubind *tmp9
   625 jump *label188 equal @unit :rebindUnit.4:firstUnit
 
   741 sensor *tmp265 @unit @controller
   742 op equal *tmp266 *tmp265 @this
   743 op land *tmp267 *tmp264 *tmp266
-    * jump *label224 equal *tmp267 false
-    * jump *label221 always
+  744 jump *label221 notEqual *tmp267 false
   745 label *label224
   746 label *label222
   747 ubind *tmp9
 
   749 jump *label226 equal :rebindUnit.5:firstUnit null
   750 label *label228
   751 sensor *tmp271 @unit @controlled
-    * jump *label231 notEqual *tmp271 0
-    * jump *label221 always
+  752 jump *label221 equal *tmp271 0
   753 label *label231
   754 ubind *tmp9
   755 jump *label230 equal @unit :rebindUnit.5:firstUnit
 
   895 sensor *tmp335 @unit @controller
   896 op equal *tmp336 *tmp335 @this
   897 op land *tmp337 *tmp334 *tmp336
-    * jump *label269 equal *tmp337 false
-    * jump *label266 always
+  898 jump *label266 notEqual *tmp337 false
   899 label *label269
   900 label *label267
   901 ubind *tmp9
 
   903 jump *label271 equal :rebindUnit.6:firstUnit null
   904 label *label273
   905 sensor *tmp341 @unit @controlled
-    * jump *label276 notEqual *tmp341 0
-    * jump *label266 always
+  906 jump *label266 equal *tmp341 0
   907 label *label276
   908 ubind *tmp9
   909 jump *label275 equal @unit :rebindUnit.6:firstUnit
 
  1025 sensor *tmp399 @unit @controller
  1026 op equal *tmp400 *tmp399 @this
  1027 op land *tmp401 *tmp398 *tmp400
-    * jump *label311 equal *tmp401 false
-    * jump *label308 always
+ 1028 jump *label308 notEqual *tmp401 false
  1029 label *label311
  1030 label *label309
  1031 ubind *tmp9
 
  1033 jump *label313 equal :rebindUnit.7:firstUnit null
  1034 label *label315
  1035 sensor *tmp405 @unit @controlled
-    * jump *label318 notEqual *tmp405 0
-    * jump *label308 always
+ 1036 jump *label308 equal *tmp405 0
  1037 label *label318
  1038 ubind *tmp9
  1039 jump *label317 equal @unit :rebindUnit.7:firstUnit

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
    19 jump *label1 notEqual :locateCore*retval false
-    * label *label385
    20 set :locateCore:type @poly
    21 call *label0 :locateCore*retaddr :locateCore*retval
    22 jump *label1 notEqual :locateCore*retval false
-    * label *label391
    23 set :locateCore:type @mega
    24 call *label0 :locateCore*retaddr :locateCore*retval
    25 jump *label1 notEqual :locateCore*retval false
-    * label *label397
    26 set :locateCore:type @mono
    27 call *label0 :locateCore*retaddr :locateCore*retval
    28 jump *label1 notEqual :locateCore*retval false
-    * label *label403
    29 jump *label5 always
    30 label *label1
    31 sensor .CORE_X .CORE @x
 
   370 set .UNIT_S1 .UNIT_P1
   371 set .UNIT_P1 @unit
   372 jump *label82 notEqual .UNIT_S2 null
-    * label *label85
   373 label *label83
   374 ubind *tmp9
   375 jump *label82 equal @unit :rebindUnits:firstUnit
 
   386 op equal *tmp87 *tmp86 @this
   387 op land *tmp88 *tmp85 *tmp87
   388 jump *label89 notEqual *tmp88 false
-    * label *label92
   389 label *label90
   390 ubind *tmp9
   391 set :rebindUnit:firstUnit @unit
 
   393 label *label96
   394 sensor *tmp92 @unit @controlled
   395 jump *label89 equal *tmp92 0
-    * label *label99
   396 ubind *tmp9
   397 jump *label98 equal @unit :rebindUnit:firstUnit
   398 sensor *tmp96 :rebindUnit:firstUnit @dead
 
   414 op equal *tmp105 *tmp104 @this
   415 op land *tmp106 *tmp103 *tmp105
   416 jump *label103 notEqual *tmp106 false
-    * label *label106
   417 label *label104
   418 ubind *tmp9
   419 set :rebindUnit.1:firstUnit @unit
 
   421 label *label110
   422 sensor *tmp110 @unit @controlled
   423 jump *label103 equal *tmp110 0
-    * label *label113
   424 ubind *tmp9
   425 jump *label112 equal @unit :rebindUnit.1:firstUnit
   426 sensor *tmp114 :rebindUnit.1:firstUnit @dead
 
   467 op equal *tmp142 *tmp141 @this
   468 op land *tmp143 *tmp140 *tmp142
   469 jump *label127 notEqual *tmp143 false
-    * label *label130
   470 label *label128
   471 ubind *tmp9
   472 set :rebindUnit.2:firstUnit @unit
 
   474 label *label134
   475 sensor *tmp147 @unit @controlled
   476 jump *label127 equal *tmp147 0
-    * label *label137
   477 ubind *tmp9
   478 jump *label136 equal @unit :rebindUnit.2:firstUnit
   479 sensor *tmp151 :rebindUnit.2:firstUnit @dead
 
   495 op equal *tmp160 *tmp159 @this
   496 op land *tmp161 *tmp158 *tmp160
   497 jump *label141 notEqual *tmp161 false
-    * label *label144
   498 label *label142
   499 ubind *tmp9
   500 set :rebindUnit.3:firstUnit @unit
 
   502 label *label148
   503 sensor *tmp165 @unit @controlled
   504 jump *label141 equal *tmp165 0
-    * label *label151
   505 ubind *tmp9
   506 jump *label150 equal @unit :rebindUnit.3:firstUnit
   507 sensor *tmp169 :rebindUnit.3:firstUnit @dead
 
   599 op equal *tmp202 *tmp201 @this
   600 op land *tmp203 *tmp200 *tmp202
   601 jump *label179 notEqual *tmp203 false
-    * label *label182
   602 label *label180
   603 ubind *tmp9
   604 set :rebindUnit.4:firstUnit @unit
 
   606 label *label186
   607 sensor *tmp207 @unit @controlled
   608 jump *label179 equal *tmp207 0
-    * label *label189
   609 ubind *tmp9
   610 jump *label188 equal @unit :rebindUnit.4:firstUnit
   611 sensor *tmp211 :rebindUnit.4:firstUnit @dead
 
   727 op equal *tmp266 *tmp265 @this
   728 op land *tmp267 *tmp264 *tmp266
   729 jump *label221 notEqual *tmp267 false
-    * label *label224
   730 label *label222
   731 ubind *tmp9
   732 set :rebindUnit.5:firstUnit @unit
 
   734 label *label228
   735 sensor *tmp271 @unit @controlled
   736 jump *label221 equal *tmp271 0
-    * label *label231
   737 ubind *tmp9
   738 jump *label230 equal @unit :rebindUnit.5:firstUnit
   739 sensor *tmp275 :rebindUnit.5:firstUnit @dead
 
   879 op equal *tmp336 *tmp335 @this
   880 op land *tmp337 *tmp334 *tmp336
   881 jump *label266 notEqual *tmp337 false
-    * label *label269
   882 label *label267
   883 ubind *tmp9
   884 set :rebindUnit.6:firstUnit @unit
 
   886 label *label273
   887 sensor *tmp341 @unit @controlled
   888 jump *label266 equal *tmp341 0
-    * label *label276
   889 ubind *tmp9
   890 jump *label275 equal @unit :rebindUnit.6:firstUnit
   891 sensor *tmp345 :rebindUnit.6:firstUnit @dead
 
  1007 op equal *tmp400 *tmp399 @this
  1008 op land *tmp401 *tmp398 *tmp400
  1009 jump *label308 notEqual *tmp401 false
-    * label *label311
  1010 label *label309
  1011 ubind *tmp9
  1012 set :rebindUnit.7:firstUnit @unit
 
  1014 label *label315
  1015 sensor *tmp405 @unit @controlled
  1016 jump *label308 equal *tmp405 0
-    * label *label318
  1017 ubind *tmp9
  1018 jump *label317 equal @unit :rebindUnit.7:firstUnit
  1019 sensor *tmp409 :rebindUnit.7:firstUnit @dead

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @flare
 
    72 jump *label35 notEqual *tmp24 @this
    73 label *label37
    74 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label39 lessThan :areUnitsAvailable:free *tmp21
+   75 jump *label36 lessThan :areUnitsAvailable:free *tmp21
    76 set *tmp10 true
    77 jump *label26 always
    78 label *label39
 
   130 jump *label418 notEqual *tmp54 @this
   131 label *label415
   132 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label416 lessThan :areUnitsAvailable.1:free *tmp51
+  133 jump *label419 lessThan :areUnitsAvailable.1:free *tmp51
   134 set *tmp40 true
   135 jump *label429 always
   136 label *label416
 
   190 jump *label444 notEqual *tmp54 @this
   191 label *label441
   192 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label442 lessThan :areUnitsAvailable.1:free *tmp51
+  193 jump *label445 lessThan :areUnitsAvailable.1:free *tmp51
   194 set *tmp40 true
   195 jump *label455 always
   196 label *label442
 
   250 jump *label470 notEqual *tmp54 @this
   251 label *label467
   252 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label468 lessThan :areUnitsAvailable.1:free *tmp51
+  253 jump *label471 lessThan :areUnitsAvailable.1:free *tmp51
   254 set *tmp40 true
   255 jump *label481 always
   256 label *label468
 
   310 jump *label496 notEqual *tmp54 @this
   311 label *label493
   312 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label494 lessThan :areUnitsAvailable.1:free *tmp51
+  313 jump *label497 lessThan :areUnitsAvailable.1:free *tmp51
   314 set *tmp40 true
   315 jump *label507 always
   316 label *label494
 
   390 label *label90
   391 ubind *tmp9
   392 set :rebindUnit:firstUnit @unit
-    * jump *label94 equal :rebindUnit:firstUnit null
+  393 jump __start__ equal :rebindUnit:firstUnit null
   394 label *label96
   395 sensor *tmp92 @unit @controlled
   396 jump *label89 equal *tmp92 0
   397 ubind *tmp9
-    * jump *label98 equal @unit :rebindUnit:firstUnit
+  398 jump __start__ equal @unit :rebindUnit:firstUnit
   399 sensor *tmp96 :rebindUnit:firstUnit @dead
   400 jump *label96 equal *tmp96 0
   401 label *label98
 
   418 label *label104
   419 ubind *tmp9
   420 set :rebindUnit.1:firstUnit @unit
-    * jump *label108 equal :rebindUnit.1:firstUnit null
+  421 jump __start__ equal :rebindUnit.1:firstUnit null
   422 label *label110
   423 sensor *tmp110 @unit @controlled
   424 jump *label103 equal *tmp110 0
   425 ubind *tmp9
-    * jump *label112 equal @unit :rebindUnit.1:firstUnit
+  426 jump __start__ equal @unit :rebindUnit.1:firstUnit
   427 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   428 jump *label110 equal *tmp114 0
   429 label *label112
 
   471 label *label128
   472 ubind *tmp9
   473 set :rebindUnit.2:firstUnit @unit
-    * jump *label132 equal :rebindUnit.2:firstUnit null
+  474 jump __start__ equal :rebindUnit.2:firstUnit null
   475 label *label134
   476 sensor *tmp147 @unit @controlled
   477 jump *label127 equal *tmp147 0
   478 ubind *tmp9
-    * jump *label136 equal @unit :rebindUnit.2:firstUnit
+  479 jump __start__ equal @unit :rebindUnit.2:firstUnit
   480 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   481 jump *label134 equal *tmp151 0
   482 label *label136
 
   499 label *label142
   500 ubind *tmp9
   501 set :rebindUnit.3:firstUnit @unit
-    * jump *label146 equal :rebindUnit.3:firstUnit null
+  502 jump __start__ equal :rebindUnit.3:firstUnit null
   503 label *label148
   504 sensor *tmp165 @unit @controlled
   505 jump *label141 equal *tmp165 0
   506 ubind *tmp9
-    * jump *label150 equal @unit :rebindUnit.3:firstUnit
+  507 jump __start__ equal @unit :rebindUnit.3:firstUnit
   508 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   509 jump *label148 equal *tmp169 0
   510 label *label150
 
   562 label *label169
   563 op add :unitCheck @time 5000
   564 sensor *tmp192 switch1 @enabled
-    * jump *label174 equal *tmp192 false
+  565 jump __start__ equal *tmp192 false
   566 label *label410
   567 set :start @time
   568 print " === [gold]Supplying Overdrive Dome[] === "
 
   603 label *label180
   604 ubind *tmp9
   605 set :rebindUnit.4:firstUnit @unit
-    * jump *label184 equal :rebindUnit.4:firstUnit null
+  606 jump __start__ equal :rebindUnit.4:firstUnit null
   607 label *label186
   608 sensor *tmp207 @unit @controlled
   609 jump *label179 equal *tmp207 0
   610 ubind *tmp9
-    * jump *label188 equal @unit :rebindUnit.4:firstUnit
+  611 jump __start__ equal @unit :rebindUnit.4:firstUnit
   612 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   613 jump *label186 equal *tmp211 0
   614 label *label188
 
   647 jump *label206 lessThan *tmp229 .UNIT_CAPACITY
   648 ucontrol approach .DOME_X .DOME_Y 6
   649 set :processUnit:state 3
-    * jump *label207 always
+  650 jump *label205 always
   651 label *label206
   652 set .MSG ", loading\n"
   653 label *label207
 
   676 set .MSG ", waiting\n"
   677 label *label213
   678 sensor *tmp244 @unit @totalItems
-    * jump *label214 greaterThan *tmp244 0
+  679 jump *label211 greaterThan *tmp244 0
   680 ucontrol approach .CORE_X .CORE_Y 6
   681 set :processUnit:state 2
   682 label *label214
 
   731 label *label222
   732 ubind *tmp9
   733 set :rebindUnit.5:firstUnit @unit
-    * jump *label226 equal :rebindUnit.5:firstUnit null
+  734 jump __start__ equal :rebindUnit.5:firstUnit null
   735 label *label228
   736 sensor *tmp271 @unit @controlled
   737 jump *label221 equal *tmp271 0
   738 ubind *tmp9
-    * jump *label230 equal @unit :rebindUnit.5:firstUnit
+  739 jump __start__ equal @unit :rebindUnit.5:firstUnit
   740 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   741 jump *label228 equal *tmp275 0
   742 label *label230
 
   775 jump *label248 lessThan *tmp293 .UNIT_CAPACITY
   776 ucontrol approach .DOME_X .DOME_Y 6
   777 set :processUnit.1:state 3
-    * jump *label249 always
+  778 jump *label247 always
   779 label *label248
   780 set .MSG ", loading\n"
   781 label *label249
 
   804 set .MSG ", waiting\n"
   805 label *label255
   806 sensor *tmp308 @unit @totalItems
-    * jump *label256 greaterThan *tmp308 0
+  807 jump *label253 greaterThan *tmp308 0
   808 ucontrol approach .CORE_X .CORE_Y 6
   809 set :processUnit.1:state 2
   810 label *label256
 
   883 label *label267
   884 ubind *tmp9
   885 set :rebindUnit.6:firstUnit @unit
-    * jump *label271 equal :rebindUnit.6:firstUnit null
+  886 jump __start__ equal :rebindUnit.6:firstUnit null
   887 label *label273
   888 sensor *tmp341 @unit @controlled
   889 jump *label266 equal *tmp341 0
   890 ubind *tmp9
-    * jump *label275 equal @unit :rebindUnit.6:firstUnit
+  891 jump __start__ equal @unit :rebindUnit.6:firstUnit
   892 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   893 jump *label273 equal *tmp345 0
   894 label *label275
 
   927 jump *label293 lessThan *tmp363 .UNIT_CAPACITY
   928 ucontrol approach .DOME_X .DOME_Y 6
   929 set :processUnit.2:state 3
-    * jump *label294 always
+  930 jump *label292 always
   931 label *label293
   932 set .MSG ", loading\n"
   933 label *label294
 
   956 set .MSG ", waiting\n"
   957 label *label300
   958 sensor *tmp378 @unit @totalItems
-    * jump *label301 greaterThan *tmp378 0
+  959 jump *label298 greaterThan *tmp378 0
   960 ucontrol approach .CORE_X .CORE_Y 6
   961 set :processUnit.2:state 2
   962 label *label301
 
  1011 label *label309
  1012 ubind *tmp9
  1013 set :rebindUnit.7:firstUnit @unit
-    * jump *label313 equal :rebindUnit.7:firstUnit null
+ 1014 jump __start__ equal :rebindUnit.7:firstUnit null
  1015 label *label315
  1016 sensor *tmp405 @unit @controlled
  1017 jump *label308 equal *tmp405 0
  1018 ubind *tmp9
-    * jump *label317 equal @unit :rebindUnit.7:firstUnit
+ 1019 jump __start__ equal @unit :rebindUnit.7:firstUnit
  1020 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1021 jump *label315 equal *tmp409 0
  1022 label *label317
 
  1055 jump *label335 lessThan *tmp427 .UNIT_CAPACITY
  1056 ucontrol approach .DOME_X .DOME_Y 6
  1057 set :processUnit.3:state 3
-    * jump *label336 always
+ 1058 jump *label334 always
  1059 label *label335
  1060 set .MSG ", loading\n"
  1061 label *label336
 
  1084 set .MSG ", waiting\n"
  1085 label *label342
  1086 sensor *tmp442 @unit @totalItems
-    * jump *label343 greaterThan *tmp442 0
+ 1087 jump *label340 greaterThan *tmp442 0
  1088 ucontrol approach .CORE_X .CORE_Y 6
  1089 set :processUnit.3:state 2
  1090 label *label343
 
  1148 set :areUnitsAvailable.2:occupied 0
  1149 ubind UNIT_TYPE
  1150 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label356 equal :areUnitsAvailable.2:firstUnit null
+ 1151 jump *label371 equal :areUnitsAvailable.2:firstUnit null
  1152 # "Function: inline def needsFourUnits(in unit)"
  1153 set :needsFourUnits.3:unit @unit
  1154 sensor *tmp474 :needsFourUnits.3:unit @speed
 
  1162 jump *label364 notEqual *tmp480 @this
  1163 label *label366
  1164 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label368 lessThan :areUnitsAvailable.2:free *tmp477
+ 1165 jump *label365 lessThan :areUnitsAvailable.2:free *tmp477
  1166 set *tmp466 true
  1167 jump *label355 always
  1168 label *label368
 
  1171 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1172 label *label365
  1173 ubind UNIT_TYPE
-    * jump *label363 equal @unit :areUnitsAvailable.2:firstUnit
+ 1174 jump *label371 equal @unit :areUnitsAvailable.2:firstUnit
  1175 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1176 jump *label361 equal *tmp487 0
  1177 label *label363

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-19 instructions):
 
    75 jump *label36 lessThan :areUnitsAvailable:free *tmp21
    76 set *tmp10 true
    77 jump *label26 always
-    * label *label39
-    * jump *label36 always
    78 label *label35
    79 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    80 label *label36
 
   131 jump *label419 lessThan :areUnitsAvailable.1:free *tmp51
   132 set *tmp40 true
   133 jump *label429 always
-    * label *label416
-    * jump *label419 always
   134 label *label418
   135 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   136 label *label419
 
   189 jump *label445 lessThan :areUnitsAvailable.1:free *tmp51
   190 set *tmp40 true
   191 jump *label455 always
-    * label *label442
-    * jump *label445 always
   192 label *label444
   193 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   194 label *label445
 
   247 jump *label471 lessThan :areUnitsAvailable.1:free *tmp51
   248 set *tmp40 true
   249 jump *label481 always
-    * label *label468
-    * jump *label471 always
   250 label *label470
   251 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   252 label *label471
 
   305 jump *label497 lessThan :areUnitsAvailable.1:free *tmp51
   306 set *tmp40 true
   307 jump *label507 always
-    * label *label494
-    * jump *label497 always
   308 label *label496
   309 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   310 label *label497
 
   336 label *label510
   337 printflush message1
   338 jump *label21 always
-    * set *tmp9 null
   339 label *label20
   340 print "[gold]Binding units..."
   341 printflush message1
 
   387 jump __start__ equal @unit :rebindUnit:firstUnit
   388 sensor *tmp96 :rebindUnit:firstUnit @dead
   389 jump *label96 equal *tmp96 0
-    * label *label98
-    * label *label94
   390 end
   391 label *label89
   392 ucontrol flag 1
 
   413 jump __start__ equal @unit :rebindUnit.1:firstUnit
   414 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   415 jump *label110 equal *tmp114 0
-    * label *label112
-    * label *label108
   416 end
   417 label *label103
   418 ucontrol flag 1
 
   464 jump __start__ equal @unit :rebindUnit.2:firstUnit
   465 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   466 jump *label134 equal *tmp151 0
-    * label *label136
-    * label *label132
   467 end
   468 label *label127
   469 ucontrol flag 1
 
   490 jump __start__ equal @unit :rebindUnit.3:firstUnit
   491 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   492 jump *label148 equal *tmp169 0
-    * label *label150
-    * label *label146
   493 end
   494 label *label141
   495 ucontrol flag 1
 
   592 jump __start__ equal @unit :rebindUnit.4:firstUnit
   593 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   594 jump *label186 equal *tmp211 0
-    * label *label188
-    * label *label184
   595 end
   596 label *label179
   597 sensor :processUnit:state @unit @flag
 
   629 jump *label205 always
   630 label *label206
   631 set .MSG ", loading\n"
-    * label *label207
   632 jump *label205 always
   633 label *label204
   634 ucontrol approach .CORE_X .CORE_Y 6
 
   657 jump *label211 greaterThan *tmp244 0
   658 ucontrol approach .CORE_X .CORE_Y 6
   659 set :processUnit:state 2
-    * label *label214
   660 jump *label211 always
   661 label *label210
   662 ucontrol approach .DOME_X .DOME_Y 6
 
   716 jump __start__ equal @unit :rebindUnit.5:firstUnit
   717 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   718 jump *label228 equal *tmp275 0
-    * label *label230
-    * label *label226
   719 end
   720 label *label221
   721 sensor :processUnit.1:state @unit @flag
 
   753 jump *label247 always
   754 label *label248
   755 set .MSG ", loading\n"
-    * label *label249
   756 jump *label247 always
   757 label *label246
   758 ucontrol approach .CORE_X .CORE_Y 6
 
   781 jump *label253 greaterThan *tmp308 0
   782 ucontrol approach .CORE_X .CORE_Y 6
   783 set :processUnit.1:state 2
-    * label *label256
   784 jump *label253 always
   785 label *label252
   786 ucontrol approach .DOME_X .DOME_Y 6
 
   864 jump __start__ equal @unit :rebindUnit.6:firstUnit
   865 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   866 jump *label273 equal *tmp345 0
-    * label *label275
-    * label *label271
   867 end
   868 label *label266
   869 sensor :processUnit.2:state @unit @flag
 
   901 jump *label292 always
   902 label *label293
   903 set .MSG ", loading\n"
-    * label *label294
   904 jump *label292 always
   905 label *label291
   906 ucontrol approach .CORE_X .CORE_Y 6
 
   929 jump *label298 greaterThan *tmp378 0
   930 ucontrol approach .CORE_X .CORE_Y 6
   931 set :processUnit.2:state 2
-    * label *label301
   932 jump *label298 always
   933 label *label297
   934 ucontrol approach .DOME_X .DOME_Y 6
 
   988 jump __start__ equal @unit :rebindUnit.7:firstUnit
   989 sensor *tmp409 :rebindUnit.7:firstUnit @dead
   990 jump *label315 equal *tmp409 0
-    * label *label317
-    * label *label313
   991 end
   992 label *label308
   993 sensor :processUnit.3:state @unit @flag
 
  1025 jump *label334 always
  1026 label *label335
  1027 set .MSG ", loading\n"
-    * label *label336
  1028 jump *label334 always
  1029 label *label333
  1030 ucontrol approach .CORE_X .CORE_Y 6
 
  1053 jump *label340 greaterThan *tmp442 0
  1054 ucontrol approach .CORE_X .CORE_Y 6
  1055 set :processUnit.3:state 2
-    * label *label343
  1056 jump *label340 always
  1057 label *label339
  1058 ucontrol approach .DOME_X .DOME_Y 6
 
  1130 jump *label365 lessThan :areUnitsAvailable.2:free *tmp477
  1131 set *tmp466 true
  1132 jump *label355 always
-    * label *label368
-    * jump *label365 always
  1133 label *label364
  1134 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1135 label *label365
 
  1137 jump *label371 equal @unit :areUnitsAvailable.2:firstUnit
  1138 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1139 jump *label361 equal *tmp487 0
-    * label *label363
-    * label *label356
  1140 jump *label371 always
-    * print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.2:free
-    * jump *label373 lessThanEq :areUnitsAvailable.2:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.2:needed
-    * label *label373
-    * print "\n"
  1141 label *label371
  1142 set *tmp466 false
  1143 label *label355
 
  1148 label *label349
  1149 sensor *tmp192 switch1 @enabled
  1150 jump *label410 notEqual *tmp192 false
-    * label *label174
  1151 end
  1152 label *label0
  1153 # "Function: noinline def locateCore(in type)"
 
  1161 label *label376
  1162 set :locateCore*retval .CORE
  1163 return :locateCore*retaddr
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1 (-1 instructions):
 
   439 op sub *tmp128 .DOME_Y .CORE_Y
   440 op len *tmp129 *tmp127 *tmp128
   441 op mul *tmp130 2 *tmp129
-    * sensor *tmp131 .UNIT_S1 @speed
   442 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   443 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   444 jump *label124 equal *tmp126 false

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
  1136 jump *label371 equal @unit :areUnitsAvailable.2:firstUnit
  1137 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1138 jump *label361 equal *tmp487 0
-    * jump *label371 always
  1139 label *label371
  1140 set *tmp466 false
  1141 label *label355

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-1 instructions):
 
    26 jump *label1 notEqual :locateCore*retval false
    27 set :locateCore:type @mono
    28 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label1 notEqual :locateCore*retval false
-    * jump *label5 always
+   29 jump *label5 equal :locateCore*retval false
    30 label *label1
    31 sensor .CORE_X .CORE @x
    32 sensor .CORE_Y .CORE @y

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
  1154 sensor *tmp496 @unit @controller
  1155 jump *label376 notEqual *tmp496 @this
  1156 label *label378
-    * ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
+ 1157 ulocate building core false @copper 0 0 0 .CORE
  1158 label *label376
  1159 set :locateCore*retval .CORE
  1160 return :locateCore*retaddr

Modifications by Final phase, Print Merging, iteration 1 (-75 instructions):
 
    35 sensor *tmp7 switch1 @enabled
    36 jump *label19 notEqual *tmp7 false
    37 label *label409
-    * print "[coral]Activate switch to begin supplying overdrive dome..."
-    * print "\n"
+   38 print "[coral]Activate switch to begin supplying overdrive dome...\n"
    39 printflush message1
    40 sensor *tmp7 switch1 @enabled
    41 jump *label409 equal *tmp7 false
 
    43 # "Function: inline def chooseUnitType()"
    44 label *label21
    45 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   46 print "[gold]Looking for suitable unit type:[]\n"
    47 # "Function: inline def areUnitsAvailable(in type, in output)"
    48 set :areUnitsAvailable:free 0
    49 set :areUnitsAvailable:occupied 0
 
    82 label *label34
    83 label *label27
    84 print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable:occupied
-    * print ","
-    * print " free: "
+   85 print ": occupied: {0}, free: "
+   86 format :areUnitsAvailable:occupied
    87 print :areUnitsAvailable:free
    88 jump *label44 lessThanEq :areUnitsAvailable:needed 0
    89 print ", needed: "
 
   134 jump *label413 equal *tmp61 0
   135 label *label422
   136 label *label423
-    * print @flare
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  137 print "flare: occupied: {0}, free: "
+  138 format :areUnitsAvailable.1:occupied
   139 print :areUnitsAvailable.1:free
   140 jump *label425 lessThanEq :areUnitsAvailable.1:needed 0
   141 print ", needed: "
 
   188 jump *label439 equal *tmp61 0
   189 label *label448
   190 label *label449
-    * print @poly
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  191 print "poly: occupied: {0}, free: "
+  192 format :areUnitsAvailable.1:occupied
   193 print :areUnitsAvailable.1:free
   194 jump *label451 lessThanEq :areUnitsAvailable.1:needed 0
   195 print ", needed: "
 
   242 jump *label465 equal *tmp61 0
   243 label *label474
   244 label *label475
-    * print @mega
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  245 print "mega: occupied: {0}, free: "
+  246 format :areUnitsAvailable.1:occupied
   247 print :areUnitsAvailable.1:free
   248 jump *label477 lessThanEq :areUnitsAvailable.1:needed 0
   249 print ", needed: "
 
   296 jump *label491 equal *tmp61 0
   297 label *label500
   298 label *label501
-    * print @mono
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  299 print "mono: occupied: {0}, free: "
+  300 format :areUnitsAvailable.1:occupied
   301 print :areUnitsAvailable.1:free
   302 jump *label503 lessThanEq :areUnitsAvailable.1:needed 0
   303 print ", needed: "
 
   523 jump __start__ equal *tmp192 false
   524 label *label410
   525 set :start @time
-    * print " === [gold]Supplying Overdrive Dome[] === "
-    * print "\n"
-    * print "\n"
-    * print "Unit type: [green]"
-    * print *tmp9
-    * print "["
-    * print "]"
-    * print "\n"
+  526 print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
+  527 format *tmp9
   528 # "Function: inline void printDomeStatus(in item, in text)"
-    * print "\n[green]Silicon[] status:\n"
   529 sensor :printDomeStatus:level .DOME @silicon
   530 jump *label176 lessThanEq :printDomeStatus:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  531 print "  dome:  [green]{0}[]\n"
+  532 format :printDomeStatus:level
   533 jump *label177 always
   534 label *label176
-    * print "  dome:  [coral]"
-    * print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  535 print "  dome:  [coral]{0}[]\n"
+  536 format :printDomeStatus:level
   537 label *label177
   538 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   539 # "Function: inline def rebindUnit(in currentUnit)"
 
   636 label *label208
   637 ucontrol flag :processUnit:state
   638 sensor *tmp254 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp254
-    * print "["
-    * print "]"
+  639 print "  {0}: [gold]{0}[]"
+  640 format .GROUP1
+  641 format *tmp254
   642 jump *label216 lessThan :processUnit:distance 0
   643 print .MSG
   644 print :processUnit:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  645 print "[] sec\n"
   646 jump *label217 always
   647 label *label216
   648 print .MSG
 
   752 label *label250
   753 ucontrol flag :processUnit.1:state
   754 sensor *tmp318 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp318
-    * print "["
-    * print "]"
+  755 print "  {0}: [gold]{0}[]"
+  756 format .GROUP2
+  757 format *tmp318
   758 jump *label258 lessThan :processUnit.1:distance 0
   759 print .MSG
   760 print :processUnit.1:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  761 print "[] sec\n"
   762 jump *label259 always
   763 label *label258
   764 print .MSG
 
   778 print "\n[green]Phase fabric[] status:\n"
   779 sensor :printDomeStatus.1:level .DOME @phase-fabric
   780 jump *label263 lessThanEq :printDomeStatus.1:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  781 print "  dome:  [green]{0}[]\n"
+  782 format :printDomeStatus.1:level
   783 jump *label264 always
   784 label *label263
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  785 print "  dome:  [coral]{0}[]\n"
+  786 format :printDomeStatus.1:level
   787 label *label264
   788 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   789 # "Function: inline def rebindUnit(in currentUnit)"
 
   886 label *label295
   887 ucontrol flag :processUnit.2:state
   888 sensor *tmp388 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp388
-    * print "["
-    * print "]"
+  889 print "  {0}: [gold]{0}[]"
+  890 format .GROUP1
+  891 format *tmp388
   892 jump *label303 lessThan :processUnit.2:distance 0
   893 print .MSG
   894 print :processUnit.2:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  895 print "[] sec\n"
   896 jump *label304 always
   897 label *label303
   898 print .MSG
 
  1002 label *label337
  1003 ucontrol flag :processUnit.3:state
  1004 sensor *tmp452 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp452
-    * print "["
-    * print "]"
+ 1005 print "  {0}: [gold]{0}[]"
+ 1006 format .GROUP2
+ 1007 format *tmp452
  1008 jump *label345 lessThan :processUnit.3:distance 0
  1009 print .MSG
  1010 print :processUnit.3:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1011 print "[] sec\n"
  1012 jump *label346 always
  1013 label *label345
  1014 print .MSG
 
  1026 label *label305
  1027 op sub *tmp461 @time :start
  1028 op floor *tmp462 *tmp461
-    * print "\n"
-    * print "[lightgray]Loop time: "
-    * print *tmp462
-    * print " "
-    * print "ms"
+ 1029 print "\n[lightgray]Loop time: {0} ms"
+ 1030 format *tmp462
  1031 printflush message1
  1032 jump *label349 equal *tmp9 UNIT_TYPE
  1033 jump *label349 lessThanEq :unitCheck @time

Final code before resolving virtual instructions:

label __start__
remark "This is the preferred unit type to use for bringing in supplies."
remark "If no units of this type exist, we'll try using other types."
set UNIT_TYPE @flare
remark "Do not modify anything below this line."
# "Function: inline void locateDomeAndCore()"
set .DOME dome1
jump *label4 notEqual dome1 null
label *label380
print "[gold]Waiting for an overdrive dome to be connected..."
printflush message1
set .DOME dome1
jump *label380 equal dome1 null
label *label4
print "[gold]Locating core..."
printflush message1
set .CORE null
label *label5
set :locateCore:type @flare
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @poly
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @mega
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @mono
call *label0 :locateCore*retaddr :locateCore*retval
jump *label5 equal :locateCore*retval false
label *label1
sensor .CORE_X .CORE @x
sensor .CORE_Y .CORE @y
sensor .DOME_X .DOME @x
sensor .DOME_Y .DOME @y
sensor *tmp7 switch1 @enabled
jump *label19 notEqual *tmp7 false
label *label409
print "[coral]Activate switch to begin supplying overdrive dome...\n"
printflush message1
sensor *tmp7 switch1 @enabled
jump *label409 equal *tmp7 false
label *label19
# "Function: inline def chooseUnitType()"
label *label21
printflush null
print "[gold]Looking for suitable unit type:[]\n"
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable:free 0
set :areUnitsAvailable:occupied 0
set :areUnitsAvailable:needed 0
ubind UNIT_TYPE
set :areUnitsAvailable:firstUnit @unit
jump *label27 equal :areUnitsAvailable:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits:unit @unit
op sub *tmp14 .DOME_X .CORE_X
op sub *tmp15 .DOME_Y .CORE_Y
op len *tmp16 *tmp14 *tmp15
op mul *tmp17 2 *tmp16
sensor *tmp18 :needsFourUnits:unit @speed
op div :needsFourUnits:travel_time *tmp17 *tmp18
op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
select *tmp21 notEqual *tmp13 false 4 2
set :areUnitsAvailable:needed *tmp21
label *label32
sensor *tmp22 @unit @controlled
jump *label37 equal *tmp22 0
sensor *tmp24 @unit @controller
jump *label35 notEqual *tmp24 @this
label *label37
op add :areUnitsAvailable:free :areUnitsAvailable:free 1
jump *label36 lessThan :areUnitsAvailable:free *tmp21
set *tmp10 true
jump *label26 always
label *label35
op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
label *label36
ubind UNIT_TYPE
jump *label34 equal @unit :areUnitsAvailable:firstUnit
sensor *tmp31 :areUnitsAvailable:firstUnit @dead
jump *label32 equal *tmp31 0
label *label34
label *label27
print UNIT_TYPE
print ": occupied: {0}, free: "
format :areUnitsAvailable:occupied
print :areUnitsAvailable:free
jump *label44 lessThanEq :areUnitsAvailable:needed 0
print ", needed: "
print :areUnitsAvailable:needed
label *label44
print "\n"
set *tmp10 false
label *label26
jump *label24 equal *tmp10 false
set *tmp9 UNIT_TYPE
jump *label20 always
label *label24
jump *label432 equal @flare UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @flare
set :areUnitsAvailable.1:firstUnit @unit
jump *label423 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
select *tmp51 notEqual *tmp43 false 4 2
set :areUnitsAvailable.1:needed *tmp51
label *label413
sensor *tmp52 @unit @controlled
jump *label415 equal *tmp52 0
sensor *tmp54 @unit @controller
jump *label418 notEqual *tmp54 @this
label *label415
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label419 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump *label429 always
label *label418
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label419
ubind @flare
jump *label422 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump *label413 equal *tmp61 0
label *label422
label *label423
print "flare: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label425 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label425
print "\n"
set *tmp40 false
label *label429
jump *label430 equal *tmp40 false
printflush null
set *tmp9 @flare
jump *label20 always
label *label430
label *label432
jump *label458 equal @poly UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @poly
set :areUnitsAvailable.1:firstUnit @unit
jump *label449 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
select *tmp51 notEqual *tmp43 false 4 2
set :areUnitsAvailable.1:needed *tmp51
label *label439
sensor *tmp52 @unit @controlled
jump *label441 equal *tmp52 0
sensor *tmp54 @unit @controller
jump *label444 notEqual *tmp54 @this
label *label441
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label445 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump *label455 always
label *label444
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label445
ubind @poly
jump *label448 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump *label439 equal *tmp61 0
label *label448
label *label449
print "poly: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label451 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label451
print "\n"
set *tmp40 false
label *label455
jump *label456 equal *tmp40 false
printflush null
set *tmp9 @poly
jump *label20 always
label *label456
label *label458
jump *label484 equal @mega UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mega
set :areUnitsAvailable.1:firstUnit @unit
jump *label475 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
select *tmp51 notEqual *tmp43 false 4 2
set :areUnitsAvailable.1:needed *tmp51
label *label465
sensor *tmp52 @unit @controlled
jump *label467 equal *tmp52 0
sensor *tmp54 @unit @controller
jump *label470 notEqual *tmp54 @this
label *label467
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label471 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump *label481 always
label *label470
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label471
ubind @mega
jump *label474 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump *label465 equal *tmp61 0
label *label474
label *label475
print "mega: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label477 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label477
print "\n"
set *tmp40 false
label *label481
jump *label482 equal *tmp40 false
printflush null
set *tmp9 @mega
jump *label20 always
label *label482
label *label484
jump *label510 equal @mono UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mono
set :areUnitsAvailable.1:firstUnit @unit
jump *label501 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
select *tmp51 notEqual *tmp43 false 4 2
set :areUnitsAvailable.1:needed *tmp51
label *label491
sensor *tmp52 @unit @controlled
jump *label493 equal *tmp52 0
sensor *tmp54 @unit @controller
jump *label496 notEqual *tmp54 @this
label *label493
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label497 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump *label507 always
label *label496
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label497
ubind @mono
jump *label500 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump *label491 equal *tmp61 0
label *label500
label *label501
print "mono: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label503 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label503
print "\n"
set *tmp40 false
label *label507
jump *label508 equal *tmp40 false
printflush null
set *tmp9 @mono
jump *label20 always
label *label508
label *label510
printflush message1
jump *label21 always
label *label20
print "[gold]Binding units..."
printflush message1
# "Function: inline def rebindUnits()"
set .UNIT_P2 null
set .UNIT_S2 null
set .UNIT_P1 null
set .UNIT_S1 null
set :rebindUnits:count 0
ubind *tmp9
set :rebindUnits:firstUnit @unit
jump *label78 notEqual :rebindUnits:firstUnit null
end
label *label78
label *label80
sensor *tmp70 @unit @controller
jump *label83 notEqual *tmp70 @this
op add :rebindUnits:count :rebindUnits:count 1
ucontrol flag 1
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 .UNIT_P1
set .UNIT_P1 @unit
jump *label82 notEqual .UNIT_S2 null
label *label83
ubind *tmp9
jump *label82 equal @unit :rebindUnits:firstUnit
sensor *tmp78 :rebindUnits:firstUnit @dead
jump *label80 equal *tmp78 0
label *label82
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label90 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp84 @unit @dead
op equal *tmp85 *tmp84 0
sensor *tmp86 @unit @controller
op equal *tmp87 *tmp86 @this
op land *tmp88 *tmp85 *tmp87
jump *label89 notEqual *tmp88 false
label *label90
ubind *tmp9
set :rebindUnit:firstUnit @unit
jump __start__ equal :rebindUnit:firstUnit null
label *label96
sensor *tmp92 @unit @controlled
jump *label89 equal *tmp92 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit:firstUnit
sensor *tmp96 :rebindUnit:firstUnit @dead
jump *label96 equal *tmp96 0
end
label *label89
ucontrol flag 1
set *tmp80 @unit
set .UNIT_S1 *tmp80
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label104 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp102 @unit @dead
op equal *tmp103 *tmp102 0
sensor *tmp104 @unit @controller
op equal *tmp105 *tmp104 @this
op land *tmp106 *tmp103 *tmp105
jump *label103 notEqual *tmp106 false
label *label104
ubind *tmp9
set :rebindUnit.1:firstUnit @unit
jump __start__ equal :rebindUnit.1:firstUnit null
label *label110
sensor *tmp110 @unit @controlled
jump *label103 equal *tmp110 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.1:firstUnit
sensor *tmp114 :rebindUnit.1:firstUnit @dead
jump *label110 equal *tmp114 0
end
label *label103
ucontrol flag 1
set *tmp98 @unit
set .UNIT_P1 *tmp98
sensor *tmp116 *tmp80 @firstItem
jump *label118 equal *tmp116 @phase-fabric
sensor *tmp118 *tmp98 @firstItem
jump *label116 notEqual *tmp118 @silicon
label *label118
# "Function: inline void swap(in out a, in out b)"
set .UNIT_S1 *tmp98
set .UNIT_P1 *tmp80
label *label116
sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
sensor .SPEED .UNIT_S1 @speed
op div .SPEED_TENTHS .SPEED 10
op strictEqual *tmp124 .SPEED null
jump *label121 equal *tmp124 false
stop
label *label121
# "Function: inline def needsFourUnits(in unit)"
op sub *tmp127 .DOME_X .CORE_X
op sub *tmp128 .DOME_Y .CORE_Y
op len *tmp129 *tmp127 *tmp128
op mul *tmp130 2 *tmp129
op div :needsFourUnits.2:travel_time *tmp130 .SPEED
op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
jump *label124 equal *tmp126 false
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label128 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp139 @unit @dead
op equal *tmp140 *tmp139 0
sensor *tmp141 @unit @controller
op equal *tmp142 *tmp141 @this
op land *tmp143 *tmp140 *tmp142
jump *label127 notEqual *tmp143 false
label *label128
ubind *tmp9
set :rebindUnit.2:firstUnit @unit
jump __start__ equal :rebindUnit.2:firstUnit null
label *label134
sensor *tmp147 @unit @controlled
jump *label127 equal *tmp147 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.2:firstUnit
sensor *tmp151 :rebindUnit.2:firstUnit @dead
jump *label134 equal *tmp151 0
end
label *label127
ucontrol flag 1
set *tmp135 @unit
set .UNIT_S2 *tmp135
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label142 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp157 @unit @dead
op equal *tmp158 *tmp157 0
sensor *tmp159 @unit @controller
op equal *tmp160 *tmp159 @this
op land *tmp161 *tmp158 *tmp160
jump *label141 notEqual *tmp161 false
label *label142
ubind *tmp9
set :rebindUnit.3:firstUnit @unit
jump __start__ equal :rebindUnit.3:firstUnit null
label *label148
sensor *tmp165 @unit @controlled
jump *label141 equal *tmp165 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.3:firstUnit
sensor *tmp169 :rebindUnit.3:firstUnit @dead
jump *label148 equal *tmp169 0
end
label *label141
ucontrol flag 1
set *tmp153 @unit
set .UNIT_P2 *tmp153
sensor *tmp171 .UNIT_S1 @firstItem
jump *label154 notEqual *tmp171 @phase-fabric
sensor *tmp173 *tmp153 @firstItem
jump *label154 equal *tmp173 @phase-fabric
# "Function: inline void swap(in out a, in out b)"
set :swap.1:t .UNIT_S1
set .UNIT_S1 *tmp153
set .UNIT_P2 :swap.1:t
label *label154
sensor *tmp176 *tmp135 @firstItem
jump *label161 equal *tmp176 @phase-fabric
sensor *tmp178 .UNIT_P2 @firstItem
jump *label159 notEqual *tmp178 @silicon
label *label161
# "Function: inline void swap(in out a, in out b)"
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 *tmp135
label *label159
set .GROUP1 "unit  1"
set .GROUP2 "unit 2"
jump *label125 always
label *label124
ubind .UNIT_S2
ucontrol unbind
set .UNIT_S2 null
ubind .UNIT_P2
ucontrol unbind
set .UNIT_P2 null
set .GROUP1 "unit"
label *label125
set .SUPPLY_S_FIRST false
jump *label166 equal *tmp126 false
sensor *tmp182 .UNIT_S1 @totalItems
sensor *tmp183 .UNIT_S2 @totalItems
jump *label165 greaterThanEq *tmp182 *tmp183
label *label166
set .SUPPLY_S_FIRST true
label *label165
set .SUPPLY_P_FIRST false
jump *label170 equal *tmp126 false
sensor *tmp187 .UNIT_P1 @totalItems
sensor *tmp188 .UNIT_P2 @totalItems
jump *label169 greaterThanEq *tmp187 *tmp188
label *label170
set .SUPPLY_P_FIRST true
label *label169
op add :unitCheck @time 5000
sensor *tmp192 switch1 @enabled
jump __start__ equal *tmp192 false
label *label410
set :start @time
print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
format *tmp9
# "Function: inline void printDomeStatus(in item, in text)"
sensor :printDomeStatus:level .DOME @silicon
jump *label176 lessThanEq :printDomeStatus:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus:level
jump *label177 always
label *label176
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus:level
label *label177
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label180 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp199 @unit @dead
op equal *tmp200 *tmp199 0
sensor *tmp201 @unit @controller
op equal *tmp202 *tmp201 @this
op land *tmp203 *tmp200 *tmp202
jump *label179 notEqual *tmp203 false
label *label180
ubind *tmp9
set :rebindUnit.4:firstUnit @unit
jump __start__ equal :rebindUnit.4:firstUnit null
label *label186
sensor *tmp207 @unit @controlled
jump *label179 equal *tmp207 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.4:firstUnit
sensor *tmp211 :rebindUnit.4:firstUnit @dead
jump *label186 equal *tmp211 0
end
label *label179
sensor :processUnit:state @unit @flag
set :processUnit:distance -1
jump *label194 lessThan :processUnit:state 2
jump *label192 lessThanEq :processUnit:state 3
label *label194
sensor *tmp217 @unit @firstItem
jump *label196 notEqual *tmp217 @silicon
set :processUnit:state 3
jump *label197 always
label *label196
sensor *tmp220 @unit @totalItems
jump *label198 notEqual *tmp220 0
set :processUnit:state 2
jump *label199 always
label *label198
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp223
jump *label200 equal *tmp223 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label200
label *label199
label *label197
label *label192
jump *label202 notEqual :processUnit:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp227
jump *label204 equal *tmp227 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp229 @unit @totalItems
jump *label206 lessThan *tmp229 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit:state 3
jump *label205 always
label *label206
set .MSG ", loading\n"
jump *label205 always
label *label204
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp232 @unit @x
op sub *tmp233 .CORE_X *tmp232
sensor *tmp234 @unit @y
op sub *tmp235 .CORE_Y *tmp234
op len *tmp236 *tmp233 *tmp235
op idiv *tmp237 *tmp236 .SPEED_TENTHS
op div :processUnit:distance *tmp237 10
label *label205
label *label202
jump *label208 notEqual :processUnit:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp241
jump *label210 equal *tmp241 false
jump *label212 equal .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label213 always
label *label212
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label213
sensor *tmp244 @unit @totalItems
jump *label211 greaterThan *tmp244 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit:state 2
jump *label211 always
label *label210
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp247 @unit @x
op sub *tmp248 .DOME_X *tmp247
sensor *tmp249 @unit @y
op sub *tmp250 .DOME_Y *tmp249
op len *tmp251 *tmp248 *tmp250
op idiv *tmp252 *tmp251 .SPEED_TENTHS
op div :processUnit:distance *tmp252 10
label *label211
label *label208
ucontrol flag :processUnit:state
sensor *tmp254 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp254
jump *label216 lessThan :processUnit:distance 0
print .MSG
print :processUnit:distance
print "[] sec\n"
jump *label217 always
label *label216
print .MSG
label *label217
set :processUnit:unit @unit
set .UNIT_S1 :processUnit:unit
jump *label218 equal *tmp126 false
op equal *tmp259 .SUPPLY_S_FIRST false
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label222 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp263 @unit @dead
op equal *tmp264 *tmp263 0
sensor *tmp265 @unit @controller
op equal *tmp266 *tmp265 @this
op land *tmp267 *tmp264 *tmp266
jump *label221 notEqual *tmp267 false
label *label222
ubind *tmp9
set :rebindUnit.5:firstUnit @unit
jump __start__ equal :rebindUnit.5:firstUnit null
label *label228
sensor *tmp271 @unit @controlled
jump *label221 equal *tmp271 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.5:firstUnit
sensor *tmp275 :rebindUnit.5:firstUnit @dead
jump *label228 equal *tmp275 0
end
label *label221
sensor :processUnit.1:state @unit @flag
set :processUnit.1:distance -1
jump *label236 lessThan :processUnit.1:state 2
jump *label234 lessThanEq :processUnit.1:state 3
label *label236
sensor *tmp281 @unit @firstItem
jump *label238 notEqual *tmp281 @silicon
set :processUnit.1:state 3
jump *label239 always
label *label238
sensor *tmp284 @unit @totalItems
jump *label240 notEqual *tmp284 0
set :processUnit.1:state 2
jump *label241 always
label *label240
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp287
jump *label242 equal *tmp287 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label242
label *label241
label *label239
label *label234
jump *label244 notEqual :processUnit.1:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp291
jump *label246 equal *tmp291 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp293 @unit @totalItems
jump *label248 lessThan *tmp293 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:state 3
jump *label247 always
label *label248
set .MSG ", loading\n"
jump *label247 always
label *label246
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp296 @unit @x
op sub *tmp297 .CORE_X *tmp296
sensor *tmp298 @unit @y
op sub *tmp299 .CORE_Y *tmp298
op len *tmp300 *tmp297 *tmp299
op idiv *tmp301 *tmp300 .SPEED_TENTHS
op div :processUnit.1:distance *tmp301 10
label *label247
label *label244
jump *label250 notEqual :processUnit.1:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp305
jump *label252 equal *tmp305 false
jump *label254 equal *tmp259 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label255 always
label *label254
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label255
sensor *tmp308 @unit @totalItems
jump *label253 greaterThan *tmp308 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:state 2
jump *label253 always
label *label252
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp311 @unit @x
op sub *tmp312 .DOME_X *tmp311
sensor *tmp313 @unit @y
op sub *tmp314 .DOME_Y *tmp313
op len *tmp315 *tmp312 *tmp314
op idiv *tmp316 *tmp315 .SPEED_TENTHS
op div :processUnit.1:distance *tmp316 10
label *label253
label *label250
ucontrol flag :processUnit.1:state
sensor *tmp318 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp318
jump *label258 lessThan :processUnit.1:distance 0
print .MSG
print :processUnit.1:distance
print "[] sec\n"
jump *label259 always
label *label258
print .MSG
label *label259
set :processUnit.1:unit @unit
set .UNIT_S2 :processUnit.1:unit
jump *label260 equal .SUPPLY_S_FIRST false
sensor *tmp323 :processUnit:unit @totalItems
op greaterThan .SUPPLY_S_FIRST *tmp323 0
jump *label261 always
label *label260
sensor *tmp325 :processUnit.1:unit @totalItems
op equal .SUPPLY_S_FIRST *tmp325 0
label *label261
label *label218
# "Function: inline void printDomeStatus(in item, in text)"
print "\n[green]Phase fabric[] status:\n"
sensor :printDomeStatus.1:level .DOME @phase-fabric
jump *label263 lessThanEq :printDomeStatus.1:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.1:level
jump *label264 always
label *label263
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.1:level
label *label264
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label267 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp333 @unit @dead
op equal *tmp334 *tmp333 0
sensor *tmp335 @unit @controller
op equal *tmp336 *tmp335 @this
op land *tmp337 *tmp334 *tmp336
jump *label266 notEqual *tmp337 false
label *label267
ubind *tmp9
set :rebindUnit.6:firstUnit @unit
jump __start__ equal :rebindUnit.6:firstUnit null
label *label273
sensor *tmp341 @unit @controlled
jump *label266 equal *tmp341 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.6:firstUnit
sensor *tmp345 :rebindUnit.6:firstUnit @dead
jump *label273 equal *tmp345 0
end
label *label266
sensor :processUnit.2:state @unit @flag
set :processUnit.2:distance -1
jump *label281 lessThan :processUnit.2:state 2
jump *label279 lessThanEq :processUnit.2:state 3
label *label281
sensor *tmp351 @unit @firstItem
jump *label283 notEqual *tmp351 @phase-fabric
set :processUnit.2:state 3
jump *label284 always
label *label283
sensor *tmp354 @unit @totalItems
jump *label285 notEqual *tmp354 0
set :processUnit.2:state 2
jump *label286 always
label *label285
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp357
jump *label287 equal *tmp357 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label287
label *label286
label *label284
label *label279
jump *label289 notEqual :processUnit.2:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp361
jump *label291 equal *tmp361 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp363 @unit @totalItems
jump *label293 lessThan *tmp363 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:state 3
jump *label292 always
label *label293
set .MSG ", loading\n"
jump *label292 always
label *label291
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp366 @unit @x
op sub *tmp367 .CORE_X *tmp366
sensor *tmp368 @unit @y
op sub *tmp369 .CORE_Y *tmp368
op len *tmp370 *tmp367 *tmp369
op idiv *tmp371 *tmp370 .SPEED_TENTHS
op div :processUnit.2:distance *tmp371 10
label *label292
label *label289
jump *label295 notEqual :processUnit.2:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp375
jump *label297 equal *tmp375 false
jump *label299 equal .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label300 always
label *label299
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label300
sensor *tmp378 @unit @totalItems
jump *label298 greaterThan *tmp378 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:state 2
jump *label298 always
label *label297
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp381 @unit @x
op sub *tmp382 .DOME_X *tmp381
sensor *tmp383 @unit @y
op sub *tmp384 .DOME_Y *tmp383
op len *tmp385 *tmp382 *tmp384
op idiv *tmp386 *tmp385 .SPEED_TENTHS
op div :processUnit.2:distance *tmp386 10
label *label298
label *label295
ucontrol flag :processUnit.2:state
sensor *tmp388 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp388
jump *label303 lessThan :processUnit.2:distance 0
print .MSG
print :processUnit.2:distance
print "[] sec\n"
jump *label304 always
label *label303
print .MSG
label *label304
set :processUnit.2:unit @unit
set .UNIT_P1 :processUnit.2:unit
jump *label305 equal *tmp126 false
op equal *tmp393 .SUPPLY_P_FIRST false
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label309 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp397 @unit @dead
op equal *tmp398 *tmp397 0
sensor *tmp399 @unit @controller
op equal *tmp400 *tmp399 @this
op land *tmp401 *tmp398 *tmp400
jump *label308 notEqual *tmp401 false
label *label309
ubind *tmp9
set :rebindUnit.7:firstUnit @unit
jump __start__ equal :rebindUnit.7:firstUnit null
label *label315
sensor *tmp405 @unit @controlled
jump *label308 equal *tmp405 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.7:firstUnit
sensor *tmp409 :rebindUnit.7:firstUnit @dead
jump *label315 equal *tmp409 0
end
label *label308
sensor :processUnit.3:state @unit @flag
set :processUnit.3:distance -1
jump *label323 lessThan :processUnit.3:state 2
jump *label321 lessThanEq :processUnit.3:state 3
label *label323
sensor *tmp415 @unit @firstItem
jump *label325 notEqual *tmp415 @phase-fabric
set :processUnit.3:state 3
jump *label326 always
label *label325
sensor *tmp418 @unit @totalItems
jump *label327 notEqual *tmp418 0
set :processUnit.3:state 2
jump *label328 always
label *label327
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp421
jump *label329 equal *tmp421 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label329
label *label328
label *label326
label *label321
jump *label331 notEqual :processUnit.3:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp425
jump *label333 equal *tmp425 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp427 @unit @totalItems
jump *label335 lessThan *tmp427 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:state 3
jump *label334 always
label *label335
set .MSG ", loading\n"
jump *label334 always
label *label333
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp430 @unit @x
op sub *tmp431 .CORE_X *tmp430
sensor *tmp432 @unit @y
op sub *tmp433 .CORE_Y *tmp432
op len *tmp434 *tmp431 *tmp433
op idiv *tmp435 *tmp434 .SPEED_TENTHS
op div :processUnit.3:distance *tmp435 10
label *label334
label *label331
jump *label337 notEqual :processUnit.3:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp439
jump *label339 equal *tmp439 false
jump *label341 equal *tmp393 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label342 always
label *label341
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label342
sensor *tmp442 @unit @totalItems
jump *label340 greaterThan *tmp442 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:state 2
jump *label340 always
label *label339
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp445 @unit @x
op sub *tmp446 .DOME_X *tmp445
sensor *tmp447 @unit @y
op sub *tmp448 .DOME_Y *tmp447
op len *tmp449 *tmp446 *tmp448
op idiv *tmp450 *tmp449 .SPEED_TENTHS
op div :processUnit.3:distance *tmp450 10
label *label340
label *label337
ucontrol flag :processUnit.3:state
sensor *tmp452 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp452
jump *label345 lessThan :processUnit.3:distance 0
print .MSG
print :processUnit.3:distance
print "[] sec\n"
jump *label346 always
label *label345
print .MSG
label *label346
set :processUnit.3:unit @unit
set .UNIT_P2 :processUnit.3:unit
jump *label347 equal .SUPPLY_P_FIRST false
sensor *tmp457 :processUnit.2:unit @totalItems
op greaterThan .SUPPLY_P_FIRST *tmp457 0
jump *label348 always
label *label347
sensor *tmp459 :processUnit.3:unit @totalItems
op equal .SUPPLY_P_FIRST *tmp459 0
label *label348
label *label305
op sub *tmp461 @time :start
op floor *tmp462 *tmp461
print "\n[lightgray]Loop time: {0} ms"
format *tmp462
printflush message1
jump *label349 equal *tmp9 UNIT_TYPE
jump *label349 lessThanEq :unitCheck @time
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.2:free 0
set :areUnitsAvailable.2:occupied 0
ubind UNIT_TYPE
set :areUnitsAvailable.2:firstUnit @unit
jump *label371 equal :areUnitsAvailable.2:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.3:unit @unit
sensor *tmp474 :needsFourUnits.3:unit @speed
op div :needsFourUnits.3:travel_time *tmp130 *tmp474
op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
select *tmp477 notEqual *tmp469 false 4 2
label *label361
sensor *tmp478 @unit @controlled
jump *label366 equal *tmp478 0
sensor *tmp480 @unit @controller
jump *label364 notEqual *tmp480 @this
label *label366
op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
jump *label365 lessThan :areUnitsAvailable.2:free *tmp477
set *tmp466 true
jump *label355 always
label *label364
op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
label *label365
ubind UNIT_TYPE
jump *label371 equal @unit :areUnitsAvailable.2:firstUnit
sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
jump *label361 equal *tmp487 0
label *label371
set *tmp466 false
label *label355
jump *label353 equal *tmp466 false
end
label *label353
op add :unitCheck @time 5000
label *label349
sensor *tmp192 switch1 @enabled
jump *label410 notEqual *tmp192 false
end
label *label0
# "Function: noinline def locateCore(in type)"
ubind :locateCore:type
sensor *tmp494 @unit @controlled
jump *label378 equal *tmp494 0
sensor *tmp496 @unit @controller
jump *label376 notEqual *tmp496 @this
label *label378
ulocate building core false @copper 0 0 0 .CORE
label *label376
set :locateCore*retval .CORE
return :locateCore*retaddr
