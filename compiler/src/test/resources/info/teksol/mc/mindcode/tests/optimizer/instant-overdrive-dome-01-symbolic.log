  1480 instructions before optimizations.
    41 instructions eliminated by Temp Variables Elimination (2 passes, 6 iterations).
   259 instructions eliminated by Dead Code Elimination (2 passes, 9 iterations).
     7 instructions eliminated by Jump Normalization (2 passes, 6 iterations).
   125 instructions eliminated by Condition Optimization (2 passes, 6 iterations).
   101 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
    20 instructions eliminated by Boolean Optimization (2 passes, 8 iterations).
       2 final jumps of a short-circuited expression optimized.
       6 fully-evaluated expressions optimized using selects.
     4 instructions eliminated by If Expression Optimization (3 iterations).
    88 instructions eliminated by Data Flow Optimization (4 passes, 16 iterations).
     2 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
   158 instructions added by Loop Unrolling (7 iterations).
     2 loops unrolled by Loop Unrolling.
    46 instructions eliminated by Jump Straightening (3 passes, 9 iterations).
    33 instructions updated by Jump Threading.
    19 instructions eliminated by Unreachable Code Elimination (3 iterations).
    75 instructions eliminated by Print Merging.
   855 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 229):
    Replicate loop condition at line 54:5                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000
  * Unroll iteration loop at line 169:9                          size    +5, benefit      375.0, efficiency     75.000 (+3 instructions)
    Unroll iteration loop at line 201:9                          size  +197, benefit      375.0, efficiency      1.904

Pass 1: speed optimization selection (cost limit 226):
  * Replicate loop condition at line 54:5                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000
    Unroll iteration loop at line 201:9                          size  +197, benefit      375.0, efficiency      1.904

Pass 1: speed optimization selection (cost limit 225):
  * Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Unroll iteration loop at line 201:9                          size  +197, benefit      375.0, efficiency      1.904

Pass 1: speed optimization selection (cost limit 224):
  * Unroll iteration loop at line 201:9                          size  +197, benefit      375.0, efficiency      1.904 (+147 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-173 instructions):
 
    36 call *label0 :locateCore*retaddr :locateCore*retval
    37 jump *label15 equal :locateCore*retval false
    38 jump *label1 always
-    * set *tmp2 null
    39 jump *label16 always
    40 label *label15
-    * set *tmp2 null
    41 label *label16
    42 label *label9
    43 multijump *tmp1 0 0 (m:marker0)
 
   122 label *label39
   123 set *tmp28 null
   124 label *label40
-    * set *tmp26 *tmp28
   125 jump *label36 always
   126 label *label35
   127 set *tmp29 :areUnitsAvailable:occupied
   128 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
-    * set *tmp26 *tmp29
   129 label *label36
   130 ubind :areUnitsAvailable:type
   131 label *label33
 
   137 jump *label34 equal *tmp32 false
   138 jump *label32 always
   139 label *label34
-    * set *tmp12 null
   140 jump *label28 always
   141 label *label27
-    * set *tmp12 null
   142 label *label28
   143 jump *label42 equal :areUnitsAvailable:output false
   144 print :areUnitsAvailable:type
 
   152 jump *label44 equal *tmp34 false
   153 print ", needed: "
   154 print :areUnitsAvailable:needed
-    * set *tmp35 null
   155 jump *label45 always
   156 label *label44
-    * set *tmp35 null
   157 label *label45
   158 print "\n"
-    * set *tmp33 null
   159 jump *label43 always
   160 label *label42
-    * set *tmp33 null
   161 label *label43
   162 set *tmp10 false
   163 jump *label26 always
 
   166 jump *label24 equal *tmp10 false
   167 set *tmp9 UNIT_TYPE
   168 jump *label20 always
-    * set *tmp36 null
   169 jump *label25 always
   170 label *label24
-    * set *tmp36 null
   171 label *label25
   172 set :chooseUnitType:type @flare
   173 op add *tmp37 @counter 1
 
   237 label *label70
   238 set *tmp58 null
   239 label *label71
-    * set *tmp56 *tmp58
   240 jump *label67 always
   241 label *label66
   242 set *tmp59 :areUnitsAvailable.1:occupied
   243 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp56 *tmp59
   244 label *label67
   245 ubind :areUnitsAvailable.1:type
   246 label *label64
 
   252 jump *label65 equal *tmp62 false
   253 jump *label63 always
   254 label *label65
-    * set *tmp42 null
   255 jump *label59 always
   256 label *label58
-    * set *tmp42 null
   257 label *label59
   258 jump *label73 equal :areUnitsAvailable.1:output false
   259 print :areUnitsAvailable.1:type
 
   267 jump *label75 equal *tmp64 false
   268 print ", needed: "
   269 print :areUnitsAvailable.1:needed
-    * set *tmp65 null
   270 jump *label76 always
   271 label *label75
-    * set *tmp65 null
   272 label *label76
   273 print "\n"
-    * set *tmp63 null
   274 jump *label74 always
   275 label *label73
-    * set *tmp63 null
   276 label *label74
   277 set *tmp40 false
   278 jump *label57 always
 
   287 label *label55
   288 set *tmp66 null
   289 label *label56
-    * set *tmp39 *tmp66
   290 jump *label54 always
   291 label *label53
-    * set *tmp39 null
   292 label *label54
   293 label *label47
   294 multijump *tmp37 0 0 (m:marker1)
 
   314 op equal *tmp68 :rebindUnits:firstUnit null
   315 jump *label78 equal *tmp68 false
   316 end
-    * set *tmp69 null
   317 jump *label79 always
   318 label *label78
-    * set *tmp69 null
   319 label *label79
   320 label *label80
   321 sensor *tmp70 @unit @controller
   322 op equal *tmp71 *tmp70 @this
   323 jump *label83 equal *tmp71 false
-    * set *tmp73 :rebindUnits:count
   324 op add :rebindUnits:count :rebindUnits:count 1
   325 ucontrol flag 1
   326 set .UNIT_S2 .UNIT_P2
 
   336 label *label85
   337 set *tmp76 null
   338 label *label86
-    * set *tmp72 *tmp76
   339 jump *label84 always
   340 label *label83
-    * set *tmp72 null
   341 label *label84
   342 ubind .TYPE
   343 label *label81
 
   349 jump *label82 equal *tmp79 false
   350 jump *label80 always
   351 label *label82
-    * set *tmp67 :rebindUnits:count
   352 jump *label77 always
-    * set *tmp67 null
   353 label *label77
   354 # "Function: inline def acquireUnit(in currentUnit)"
   355 set :acquireUnit:currentUnit .UNIT_S1
 
   364 op equal *tmp87 *tmp86 @this
   365 op land *tmp88 *tmp85 *tmp87
   366 jump *label92 equal *tmp88 false
-    * set *tmp81 :rebindUnit:currentUnit
   367 jump *label89 always
   368 set *tmp89 null
   369 jump *label93 always
   370 label *label92
   371 set *tmp89 null
   372 label *label93
-    * set *tmp83 *tmp89
   373 jump *label91 always
   374 label *label90
-    * set *tmp83 null
   375 label *label91
   376 ubind .TYPE
   377 set :rebindUnit:firstUnit @unit
 
   381 sensor *tmp92 @unit @controlled
   382 op equal *tmp93 *tmp92 0
   383 jump *label99 equal *tmp93 false
-    * set *tmp81 @unit
   384 jump *label89 always
-    * set *tmp94 null
   385 jump *label100 always
   386 label *label99
-    * set *tmp94 null
   387 label *label100
   388 ubind .TYPE
   389 label *label97
 
   395 jump *label98 equal *tmp97 false
   396 jump *label96 always
   397 label *label98
-    * set *tmp91 null
   398 jump *label95 always
   399 label *label94
-    * set *tmp91 null
   400 label *label95
   401 end
-    * set *tmp81 null
   402 label *label89
   403 ucontrol flag 1
   404 set *tmp80 @unit
 
   419 op equal *tmp105 *tmp104 @this
   420 op land *tmp106 *tmp103 *tmp105
   421 jump *label106 equal *tmp106 false
-    * set *tmp99 :rebindUnit.1:currentUnit
   422 jump *label103 always
   423 set *tmp107 null
   424 jump *label107 always
   425 label *label106
   426 set *tmp107 null
   427 label *label107
-    * set *tmp101 *tmp107
   428 jump *label105 always
   429 label *label104
-    * set *tmp101 null
   430 label *label105
   431 ubind .TYPE
   432 set :rebindUnit.1:firstUnit @unit
 
   436 sensor *tmp110 @unit @controlled
   437 op equal *tmp111 *tmp110 0
   438 jump *label113 equal *tmp111 false
-    * set *tmp99 @unit
   439 jump *label103 always
-    * set *tmp112 null
   440 jump *label114 always
   441 label *label113
-    * set *tmp112 null
   442 label *label114
   443 ubind .TYPE
   444 label *label111
 
   450 jump *label112 equal *tmp115 false
   451 jump *label110 always
   452 label *label112
-    * set *tmp109 null
   453 jump *label109 always
   454 label *label108
-    * set *tmp109 null
   455 label *label109
   456 end
-    * set *tmp99 null
   457 label *label103
   458 ucontrol flag 1
   459 set *tmp98 @unit
 
   479 label *label120
   480 set .UNIT_S1 :swap:a
   481 set .UNIT_P1 :swap:b
-    * set *tmp120 null
   482 jump *label117 always
   483 label *label116
-    * set *tmp120 null
   484 label *label117
   485 sensor *tmp121 .UNIT_S1 @itemCapacity
   486 set .UNIT_CAPACITY *tmp121
 
   491 op strictEqual *tmp124 .SPEED null
   492 jump *label121 equal *tmp124 false
   493 stop
-    * set *tmp125 null
   494 jump *label122 always
   495 label *label121
-    * set *tmp125 null
   496 label *label122
   497 # "Function: inline def needsFourUnits(in unit)"
   498 set :needsFourUnits.2:unit .UNIT_S1
 
   523 op equal *tmp142 *tmp141 @this
   524 op land *tmp143 *tmp140 *tmp142
   525 jump *label130 equal *tmp143 false
-    * set *tmp136 :rebindUnit.2:currentUnit
   526 jump *label127 always
   527 set *tmp144 null
   528 jump *label131 always
   529 label *label130
   530 set *tmp144 null
   531 label *label131
-    * set *tmp138 *tmp144
   532 jump *label129 always
   533 label *label128
-    * set *tmp138 null
   534 label *label129
   535 ubind .TYPE
   536 set :rebindUnit.2:firstUnit @unit
 
   540 sensor *tmp147 @unit @controlled
   541 op equal *tmp148 *tmp147 0
   542 jump *label137 equal *tmp148 false
-    * set *tmp136 @unit
   543 jump *label127 always
-    * set *tmp149 null
   544 jump *label138 always
   545 label *label137
-    * set *tmp149 null
   546 label *label138
   547 ubind .TYPE
   548 label *label135
 
   554 jump *label136 equal *tmp152 false
   555 jump *label134 always
   556 label *label136
-    * set *tmp146 null
   557 jump *label133 always
   558 label *label132
-    * set *tmp146 null
   559 label *label133
   560 end
-    * set *tmp136 null
   561 label *label127
   562 ucontrol flag 1
   563 set *tmp135 @unit
 
   578 op equal *tmp160 *tmp159 @this
   579 op land *tmp161 *tmp158 *tmp160
   580 jump *label144 equal *tmp161 false
-    * set *tmp154 :rebindUnit.3:currentUnit
   581 jump *label141 always
   582 set *tmp162 null
   583 jump *label145 always
   584 label *label144
   585 set *tmp162 null
   586 label *label145
-    * set *tmp156 *tmp162
   587 jump *label143 always
   588 label *label142
-    * set *tmp156 null
   589 label *label143
   590 ubind .TYPE
   591 set :rebindUnit.3:firstUnit @unit
 
   595 sensor *tmp165 @unit @controlled
   596 op equal *tmp166 *tmp165 0
   597 jump *label151 equal *tmp166 false
-    * set *tmp154 @unit
   598 jump *label141 always
-    * set *tmp167 null
   599 jump *label152 always
   600 label *label151
-    * set *tmp167 null
   601 label *label152
   602 ubind .TYPE
   603 label *label149
 
   609 jump *label150 equal *tmp170 false
   610 jump *label148 always
   611 label *label150
-    * set *tmp164 null
   612 jump *label147 always
   613 label *label146
-    * set *tmp164 null
   614 label *label147
   615 end
-    * set *tmp154 null
   616 label *label141
   617 ucontrol flag 1
   618 set *tmp153 @unit
 
   638 label *label158
   639 set .UNIT_S1 :swap.1:a
   640 set .UNIT_P2 :swap.1:b
-    * set *tmp175 null
   641 jump *label155 always
   642 label *label154
-    * set *tmp175 null
   643 label *label155
   644 sensor *tmp176 .UNIT_S2 @firstItem
   645 op equal *tmp177 *tmp176 @phase-fabric
 
   659 label *label163
   660 set .UNIT_S2 :swap.2:a
   661 set .UNIT_P2 :swap.2:b
-    * set *tmp180 null
   662 jump *label160 always
   663 label *label159
-    * set *tmp180 null
   664 label *label160
   665 set .GROUP1 "unit  1"
   666 set .GROUP2 "unit 2"
-    * set *tmp134 .GROUP2
   667 jump *label125 always
   668 label *label124
   669 ubind .UNIT_S2
 
   673 ucontrol unbind
   674 set .UNIT_P2 null
   675 set .GROUP1 "unit"
-    * set *tmp134 .GROUP1
   676 label *label125
   677 op equal *tmp181 .FOUR_UNITS false
   678 jump *label166 notEqual *tmp181 false
 
   731 print "["
   732 print "]"
   733 print "\n"
-    * set *tmp195 null
   734 jump *label177 always
   735 label *label176
   736 print "  dome:  [coral]"
 
   738 print "["
   739 print "]"
   740 print "\n"
-    * set *tmp195 null
   741 label *label177
   742 label *label175
   743 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
 
   756 op equal *tmp202 *tmp201 @this
   757 op land *tmp203 *tmp200 *tmp202
   758 jump *label182 equal *tmp203 false
-    * set *tmp196 :rebindUnit.4:currentUnit
   759 jump *label179 always
   760 set *tmp204 null
   761 jump *label183 always
   762 label *label182
   763 set *tmp204 null
   764 label *label183
-    * set *tmp198 *tmp204
   765 jump *label181 always
   766 label *label180
-    * set *tmp198 null
   767 label *label181
   768 ubind .TYPE
   769 set :rebindUnit.4:firstUnit @unit
 
   773 sensor *tmp207 @unit @controlled
   774 op equal *tmp208 *tmp207 0
   775 jump *label189 equal *tmp208 false
-    * set *tmp196 @unit
   776 jump *label179 always
-    * set *tmp209 null
   777 jump *label190 always
   778 label *label189
-    * set *tmp209 null
   779 label *label190
   780 ubind .TYPE
   781 label *label187
 
   787 jump *label188 equal *tmp212 false
   788 jump *label186 always
   789 label *label188
-    * set *tmp206 null
   790 jump *label185 always
   791 label *label184
-    * set *tmp206 null
   792 label *label185
   793 end
-    * set *tmp196 null
   794 label *label179
   795 sensor *tmp213 @unit @flag
   796 set :processUnit:state *tmp213
 
   831 label *label199
   832 set *tmp219 *tmp222
   833 label *label197
-    * set *tmp216 *tmp219
   834 jump *label193 always
   835 label *label192
-    * set *tmp216 null
   836 label *label193
   837 op equal *tmp225 :processUnit:state 2
   838 jump *label202 equal *tmp225 false
 
   865 set :processUnit:distance *tmp238
   866 set *tmp228 :processUnit:distance
   867 label *label205
-    * set *tmp226 *tmp228
   868 jump *label203 always
   869 label *label202
-    * set *tmp226 null
   870 label *label203
   871 op equal *tmp239 :processUnit:state 3
   872 jump *label208 equal *tmp239 false
 
   875 jump *label212 equal :processUnit:supply false
   876 ucontrol itemDrop .DOME .UNIT_CAPACITY
   877 set .MSG ", supplying\n"
-    * set *tmp243 .MSG
   878 jump *label213 always
   879 label *label212
   880 ucontrol approach .DOME_X .DOME_Y 6
   881 set .MSG ", waiting\n"
-    * set *tmp243 .MSG
   882 label *label213
   883 sensor *tmp244 @unit @totalItems
   884 op lessThanEq *tmp245 *tmp244 0
 
   905 set :processUnit:distance *tmp253
   906 set *tmp242 :processUnit:distance
   907 label *label211
-    * set *tmp240 *tmp242
   908 jump *label209 always
   909 label *label208
-    * set *tmp240 null
   910 label *label209
   911 ucontrol flag :processUnit:state
   912 sensor *tmp254 @unit @totalItems
 
   926 print "["
   927 print "] sec"
   928 print "\n"
-    * set *tmp256 null
   929 jump *label217 always
   930 label *label216
   931 print .MSG
-    * set *tmp256 .MSG
   932 label *label217
   933 set *tmp257 @unit
   934 set :processUnit:unit *tmp257
 
   952 op equal *tmp266 *tmp265 @this
   953 op land *tmp267 *tmp264 *tmp266
   954 jump *label224 equal *tmp267 false
-    * set *tmp260 :rebindUnit.5:currentUnit
   955 jump *label221 always
   956 set *tmp268 null
   957 jump *label225 always
   958 label *label224
   959 set *tmp268 null
   960 label *label225
-    * set *tmp262 *tmp268
   961 jump *label223 always
   962 label *label222
-    * set *tmp262 null
   963 label *label223
   964 ubind .TYPE
   965 set :rebindUnit.5:firstUnit @unit
 
   969 sensor *tmp271 @unit @controlled
   970 op equal *tmp272 *tmp271 0
   971 jump *label231 equal *tmp272 false
-    * set *tmp260 @unit
   972 jump *label221 always
-    * set *tmp273 null
   973 jump *label232 always
   974 label *label231
-    * set *tmp273 null
   975 label *label232
   976 ubind .TYPE
   977 label *label229
 
   983 jump *label230 equal *tmp276 false
   984 jump *label228 always
   985 label *label230
-    * set *tmp270 null
   986 jump *label227 always
   987 label *label226
-    * set *tmp270 null
   988 label *label227
   989 end
-    * set *tmp260 null
   990 label *label221
   991 sensor *tmp277 @unit @flag
   992 set :processUnit.1:state *tmp277
 
  1027 label *label241
  1028 set *tmp283 *tmp286
  1029 label *label239
-    * set *tmp280 *tmp283
  1030 jump *label235 always
  1031 label *label234
-    * set *tmp280 null
  1032 label *label235
  1033 op equal *tmp289 :processUnit.1:state 2
  1034 jump *label244 equal *tmp289 false
 
  1061 set :processUnit.1:distance *tmp302
  1062 set *tmp292 :processUnit.1:distance
  1063 label *label247
-    * set *tmp290 *tmp292
  1064 jump *label245 always
  1065 label *label244
-    * set *tmp290 null
  1066 label *label245
  1067 op equal *tmp303 :processUnit.1:state 3
  1068 jump *label250 equal *tmp303 false
 
  1071 jump *label254 equal :processUnit.1:supply false
  1072 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1073 set .MSG ", supplying\n"
-    * set *tmp307 .MSG
  1074 jump *label255 always
  1075 label *label254
  1076 ucontrol approach .DOME_X .DOME_Y 6
  1077 set .MSG ", waiting\n"
-    * set *tmp307 .MSG
  1078 label *label255
  1079 sensor *tmp308 @unit @totalItems
  1080 op lessThanEq *tmp309 *tmp308 0
 
  1101 set :processUnit.1:distance *tmp317
  1102 set *tmp306 :processUnit.1:distance
  1103 label *label253
-    * set *tmp304 *tmp306
  1104 jump *label251 always
  1105 label *label250
-    * set *tmp304 null
  1106 label *label251
  1107 ucontrol flag :processUnit.1:state
  1108 sensor *tmp318 @unit @totalItems
 
  1122 print "["
  1123 print "] sec"
  1124 print "\n"
-    * set *tmp320 null
  1125 jump *label259 always
  1126 label *label258
  1127 print .MSG
-    * set *tmp320 .MSG
  1128 label *label259
  1129 set *tmp321 @unit
  1130 set :processUnit.1:unit *tmp321
 
  1141 set *tmp322 *tmp326
  1142 label *label261
  1143 set .SUPPLY_S_FIRST *tmp322
-    * set *tmp258 .SUPPLY_S_FIRST
  1144 jump *label219 always
  1145 label *label218
-    * set *tmp258 null
  1146 label *label219
  1147 # "Function: inline void printDomeStatus(in item, in text)"
  1148 set :printDomeStatus.1:item @phase-fabric
 
  1157 print "["
  1158 print "]"
  1159 print "\n"
-    * set *tmp329 null
  1160 jump *label264 always
  1161 label *label263
  1162 print "  dome:  [coral]"
 
  1164 print "["
  1165 print "]"
  1166 print "\n"
-    * set *tmp329 null
  1167 label *label264
  1168 label *label262
  1169 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
 
  1182 op equal *tmp336 *tmp335 @this
  1183 op land *tmp337 *tmp334 *tmp336
  1184 jump *label269 equal *tmp337 false
-    * set *tmp330 :rebindUnit.6:currentUnit
  1185 jump *label266 always
  1186 set *tmp338 null
  1187 jump *label270 always
  1188 label *label269
  1189 set *tmp338 null
  1190 label *label270
-    * set *tmp332 *tmp338
  1191 jump *label268 always
  1192 label *label267
-    * set *tmp332 null
  1193 label *label268
  1194 ubind .TYPE
  1195 set :rebindUnit.6:firstUnit @unit
 
  1199 sensor *tmp341 @unit @controlled
  1200 op equal *tmp342 *tmp341 0
  1201 jump *label276 equal *tmp342 false
-    * set *tmp330 @unit
  1202 jump *label266 always
-    * set *tmp343 null
  1203 jump *label277 always
  1204 label *label276
-    * set *tmp343 null
  1205 label *label277
  1206 ubind .TYPE
  1207 label *label274
 
  1213 jump *label275 equal *tmp346 false
  1214 jump *label273 always
  1215 label *label275
-    * set *tmp340 null
  1216 jump *label272 always
  1217 label *label271
-    * set *tmp340 null
  1218 label *label272
  1219 end
-    * set *tmp330 null
  1220 label *label266
  1221 sensor *tmp347 @unit @flag
  1222 set :processUnit.2:state *tmp347
 
  1257 label *label286
  1258 set *tmp353 *tmp356
  1259 label *label284
-    * set *tmp350 *tmp353
  1260 jump *label280 always
  1261 label *label279
-    * set *tmp350 null
  1262 label *label280
  1263 op equal *tmp359 :processUnit.2:state 2
  1264 jump *label289 equal *tmp359 false
 
  1291 set :processUnit.2:distance *tmp372
  1292 set *tmp362 :processUnit.2:distance
  1293 label *label292
-    * set *tmp360 *tmp362
  1294 jump *label290 always
  1295 label *label289
-    * set *tmp360 null
  1296 label *label290
  1297 op equal *tmp373 :processUnit.2:state 3
  1298 jump *label295 equal *tmp373 false
 
  1301 jump *label299 equal :processUnit.2:supply false
  1302 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1303 set .MSG ", supplying\n"
-    * set *tmp377 .MSG
  1304 jump *label300 always
  1305 label *label299
  1306 ucontrol approach .DOME_X .DOME_Y 6
  1307 set .MSG ", waiting\n"
-    * set *tmp377 .MSG
  1308 label *label300
  1309 sensor *tmp378 @unit @totalItems
  1310 op lessThanEq *tmp379 *tmp378 0
 
  1331 set :processUnit.2:distance *tmp387
  1332 set *tmp376 :processUnit.2:distance
  1333 label *label298
-    * set *tmp374 *tmp376
  1334 jump *label296 always
  1335 label *label295
-    * set *tmp374 null
  1336 label *label296
  1337 ucontrol flag :processUnit.2:state
  1338 sensor *tmp388 @unit @totalItems
 
  1352 print "["
  1353 print "] sec"
  1354 print "\n"
-    * set *tmp390 null
  1355 jump *label304 always
  1356 label *label303
  1357 print .MSG
-    * set *tmp390 .MSG
  1358 label *label304
  1359 set *tmp391 @unit
  1360 set :processUnit.2:unit *tmp391
 
  1378 op equal *tmp400 *tmp399 @this
  1379 op land *tmp401 *tmp398 *tmp400
  1380 jump *label311 equal *tmp401 false
-    * set *tmp394 :rebindUnit.7:currentUnit
  1381 jump *label308 always
  1382 set *tmp402 null
  1383 jump *label312 always
  1384 label *label311
  1385 set *tmp402 null
  1386 label *label312
-    * set *tmp396 *tmp402
  1387 jump *label310 always
  1388 label *label309
-    * set *tmp396 null
  1389 label *label310
  1390 ubind .TYPE
  1391 set :rebindUnit.7:firstUnit @unit
 
  1395 sensor *tmp405 @unit @controlled
  1396 op equal *tmp406 *tmp405 0
  1397 jump *label318 equal *tmp406 false
-    * set *tmp394 @unit
  1398 jump *label308 always
-    * set *tmp407 null
  1399 jump *label319 always
  1400 label *label318
-    * set *tmp407 null
  1401 label *label319
  1402 ubind .TYPE
  1403 label *label316
 
  1409 jump *label317 equal *tmp410 false
  1410 jump *label315 always
  1411 label *label317
-    * set *tmp404 null
  1412 jump *label314 always
  1413 label *label313
-    * set *tmp404 null
  1414 label *label314
  1415 end
-    * set *tmp394 null
  1416 label *label308
  1417 sensor *tmp411 @unit @flag
  1418 set :processUnit.3:state *tmp411
 
  1453 label *label328
  1454 set *tmp417 *tmp420
  1455 label *label326
-    * set *tmp414 *tmp417
  1456 jump *label322 always
  1457 label *label321
-    * set *tmp414 null
  1458 label *label322
  1459 op equal *tmp423 :processUnit.3:state 2
  1460 jump *label331 equal *tmp423 false
 
  1487 set :processUnit.3:distance *tmp436
  1488 set *tmp426 :processUnit.3:distance
  1489 label *label334
-    * set *tmp424 *tmp426
  1490 jump *label332 always
  1491 label *label331
-    * set *tmp424 null
  1492 label *label332
  1493 op equal *tmp437 :processUnit.3:state 3
  1494 jump *label337 equal *tmp437 false
 
  1497 jump *label341 equal :processUnit.3:supply false
  1498 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1499 set .MSG ", supplying\n"
-    * set *tmp441 .MSG
  1500 jump *label342 always
  1501 label *label341
  1502 ucontrol approach .DOME_X .DOME_Y 6
  1503 set .MSG ", waiting\n"
-    * set *tmp441 .MSG
  1504 label *label342
  1505 sensor *tmp442 @unit @totalItems
  1506 op lessThanEq *tmp443 *tmp442 0
 
  1527 set :processUnit.3:distance *tmp451
  1528 set *tmp440 :processUnit.3:distance
  1529 label *label340
-    * set *tmp438 *tmp440
  1530 jump *label338 always
  1531 label *label337
-    * set *tmp438 null
  1532 label *label338
  1533 ucontrol flag :processUnit.3:state
  1534 sensor *tmp452 @unit @totalItems
 
  1548 print "["
  1549 print "] sec"
  1550 print "\n"
-    * set *tmp454 null
  1551 jump *label346 always
  1552 label *label345
  1553 print .MSG
-    * set *tmp454 .MSG
  1554 label *label346
  1555 set *tmp455 @unit
  1556 set :processUnit.3:unit *tmp455
 
  1567 set *tmp456 *tmp460
  1568 label *label348
  1569 set .SUPPLY_P_FIRST *tmp456
-    * set *tmp392 .SUPPLY_P_FIRST
  1570 jump *label306 always
  1571 label *label305
-    * set *tmp392 null
  1572 label *label306
  1573 op sub *tmp461 @time :start
  1574 op floor *tmp462 *tmp461
 
  1636 label *label368
  1637 set *tmp484 null
  1638 label *label369
-    * set *tmp482 *tmp484
  1639 jump *label365 always
  1640 label *label364
  1641 set *tmp485 :areUnitsAvailable.2:occupied
  1642 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp482 *tmp485
  1643 label *label365
  1644 ubind :areUnitsAvailable.2:type
  1645 label *label362
 
  1651 jump *label363 equal *tmp488 false
  1652 jump *label361 always
  1653 label *label363
-    * set *tmp468 null
  1654 jump *label357 always
  1655 label *label356
-    * set *tmp468 null
  1656 label *label357
  1657 jump *label371 equal :areUnitsAvailable.2:output false
  1658 print :areUnitsAvailable.2:type
 
  1666 jump *label373 equal *tmp490 false
  1667 print ", needed: "
  1668 print :areUnitsAvailable.2:needed
-    * set *tmp491 null
  1669 jump *label374 always
  1670 label *label373
-    * set *tmp491 null
  1671 label *label374
  1672 print "\n"
-    * set *tmp489 null
  1673 jump *label372 always
  1674 label *label371
-    * set *tmp489 null
  1675 label *label372
  1676 set *tmp466 false
  1677 jump *label355 always
 
  1679 label *label355
  1680 jump *label353 equal *tmp466 false
  1681 end
-    * set *tmp492 null
  1682 jump *label354 always
  1683 label *label353
-    * set *tmp492 null
  1684 label *label354
  1685 op add *tmp493 @time 5000
  1686 set :unitCheck *tmp493
-    * set *tmp465 :unitCheck
  1687 jump *label350 always
  1688 label *label349
-    * set *tmp465 null
  1689 label *label350
  1690 label *label173
  1691 jump *label172 always
 
  1705 label *label378
  1706 ulocate building core false @copper *tmp500 *tmp501 *tmp502 *tmp499
  1707 set .CORE *tmp499
-    * set *tmp498 .CORE
  1708 jump *label377 always
  1709 label *label376
-    * set *tmp498 null
  1710 label *label377
  1711 set :locateCore*retval .CORE
  1712 label *label375

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-53 instructions):
 
   117 jump *label39 equal *tmp27 false
   118 set *tmp10 true
   119 jump *label26 always
-    * set *tmp28 null
   120 jump *label40 always
   121 label *label39
-    * set *tmp28 null
   122 label *label40
   123 jump *label36 always
   124 label *label35
-    * set *tmp29 :areUnitsAvailable:occupied
   125 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   126 label *label36
   127 ubind :areUnitsAvailable:type
 
   229 jump *label70 equal *tmp57 false
   230 set *tmp40 true
   231 jump *label57 always
-    * set *tmp58 null
   232 jump *label71 always
   233 label *label70
-    * set *tmp58 null
   234 label *label71
   235 jump *label67 always
   236 label *label66
-    * set *tmp59 :areUnitsAvailable.1:occupied
   237 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   238 label *label67
   239 ubind :areUnitsAvailable.1:type
 
   276 printflush null
   277 set *tmp9 :chooseUnitType:type
   278 jump *label20 always
-    * set *tmp66 null
   279 jump *label56 always
   280 label *label55
-    * set *tmp66 null
   281 label *label56
   282 jump *label54 always
   283 label *label53
 
   323 op notEqual *tmp75 .UNIT_S2 null
   324 jump *label85 equal *tmp75 false
   325 jump *label82 always
-    * set *tmp76 null
   326 jump *label86 always
   327 label *label85
-    * set *tmp76 null
   328 label *label86
   329 jump *label84 always
   330 label *label83
 
   355 op land *tmp88 *tmp85 *tmp87
   356 jump *label92 equal *tmp88 false
   357 jump *label89 always
-    * set *tmp89 null
   358 jump *label93 always
   359 label *label92
-    * set *tmp89 null
   360 label *label93
   361 jump *label91 always
   362 label *label90
 
   408 op land *tmp106 *tmp103 *tmp105
   409 jump *label106 equal *tmp106 false
   410 jump *label103 always
-    * set *tmp107 null
   411 jump *label107 always
   412 label *label106
-    * set *tmp107 null
   413 label *label107
   414 jump *label105 always
   415 label *label104
 
   510 op land *tmp143 *tmp140 *tmp142
   511 jump *label130 equal *tmp143 false
   512 jump *label127 always
-    * set *tmp144 null
   513 jump *label131 always
   514 label *label130
-    * set *tmp144 null
   515 label *label131
   516 jump *label129 always
   517 label *label128
 
   563 op land *tmp161 *tmp158 *tmp160
   564 jump *label144 equal *tmp161 false
   565 jump *label141 always
-    * set *tmp162 null
   566 jump *label145 always
   567 label *label144
-    * set *tmp162 null
   568 label *label145
   569 jump *label143 always
   570 label *label142
 
   739 op land *tmp203 *tmp200 *tmp202
   740 jump *label182 equal *tmp203 false
   741 jump *label179 always
-    * set *tmp204 null
   742 jump *label183 always
   743 label *label182
-    * set *tmp204 null
   744 label *label183
   745 jump *label181 always
   746 label *label180
 
   787 op equal *tmp218 *tmp217 :processUnit:item
   788 jump *label196 equal *tmp218 false
   789 set :processUnit:state 3
-    * set *tmp219 :processUnit:state
   790 jump *label197 always
   791 label *label196
   792 sensor *tmp220 @unit @totalItems
 
   808 label *label201
   809 set *tmp222 *tmp224
   810 label *label199
-    * set *tmp219 *tmp222
   811 label *label197
   812 jump *label193 always
   813 label *label192
 
   828 set .MSG ", loading\n"
   829 set *tmp231 .MSG
   830 label *label207
-    * set *tmp228 *tmp231
   831 jump *label205 always
   832 label *label204
   833 ucontrol approach .CORE_X .CORE_Y 6
 
   840 op idiv *tmp237 *tmp236 .SPEED_TENTHS
   841 op div *tmp238 *tmp237 10
   842 set :processUnit:distance *tmp238
-    * set *tmp228 :processUnit:distance
   843 label *label205
   844 jump *label203 always
   845 label *label202
 
   866 label *label214
   867 set *tmp246 null
   868 label *label215
-    * set *tmp242 *tmp246
   869 jump *label211 always
   870 label *label210
   871 ucontrol approach .DOME_X .DOME_Y 6
 
   878 op idiv *tmp252 *tmp251 .SPEED_TENTHS
   879 op div *tmp253 *tmp252 10
   880 set :processUnit:distance *tmp253
-    * set *tmp242 :processUnit:distance
   881 label *label211
   882 jump *label209 always
   883 label *label208
 
   927 op land *tmp267 *tmp264 *tmp266
   928 jump *label224 equal *tmp267 false
   929 jump *label221 always
-    * set *tmp268 null
   930 jump *label225 always
   931 label *label224
-    * set *tmp268 null
   932 label *label225
   933 jump *label223 always
   934 label *label222
 
   975 op equal *tmp282 *tmp281 :processUnit.1:item
   976 jump *label238 equal *tmp282 false
   977 set :processUnit.1:state 3
-    * set *tmp283 :processUnit.1:state
   978 jump *label239 always
   979 label *label238
   980 sensor *tmp284 @unit @totalItems
 
   996 label *label243
   997 set *tmp286 *tmp288
   998 label *label241
-    * set *tmp283 *tmp286
   999 label *label239
  1000 jump *label235 always
  1001 label *label234
 
  1016 set .MSG ", loading\n"
  1017 set *tmp295 .MSG
  1018 label *label249
-    * set *tmp292 *tmp295
  1019 jump *label247 always
  1020 label *label246
  1021 ucontrol approach .CORE_X .CORE_Y 6
 
  1028 op idiv *tmp301 *tmp300 .SPEED_TENTHS
  1029 op div *tmp302 *tmp301 10
  1030 set :processUnit.1:distance *tmp302
-    * set *tmp292 :processUnit.1:distance
  1031 label *label247
  1032 jump *label245 always
  1033 label *label244
 
  1054 label *label256
  1055 set *tmp310 null
  1056 label *label257
-    * set *tmp306 *tmp310
  1057 jump *label253 always
  1058 label *label252
  1059 ucontrol approach .DOME_X .DOME_Y 6
 
  1066 op idiv *tmp316 *tmp315 .SPEED_TENTHS
  1067 op div *tmp317 *tmp316 10
  1068 set :processUnit.1:distance *tmp317
-    * set *tmp306 :processUnit.1:distance
  1069 label *label253
  1070 jump *label251 always
  1071 label *label250
 
  1149 op land *tmp337 *tmp334 *tmp336
  1150 jump *label269 equal *tmp337 false
  1151 jump *label266 always
-    * set *tmp338 null
  1152 jump *label270 always
  1153 label *label269
-    * set *tmp338 null
  1154 label *label270
  1155 jump *label268 always
  1156 label *label267
 
  1197 op equal *tmp352 *tmp351 :processUnit.2:item
  1198 jump *label283 equal *tmp352 false
  1199 set :processUnit.2:state 3
-    * set *tmp353 :processUnit.2:state
  1200 jump *label284 always
  1201 label *label283
  1202 sensor *tmp354 @unit @totalItems
 
  1218 label *label288
  1219 set *tmp356 *tmp358
  1220 label *label286
-    * set *tmp353 *tmp356
  1221 label *label284
  1222 jump *label280 always
  1223 label *label279
 
  1238 set .MSG ", loading\n"
  1239 set *tmp365 .MSG
  1240 label *label294
-    * set *tmp362 *tmp365
  1241 jump *label292 always
  1242 label *label291
  1243 ucontrol approach .CORE_X .CORE_Y 6
 
  1250 op idiv *tmp371 *tmp370 .SPEED_TENTHS
  1251 op div *tmp372 *tmp371 10
  1252 set :processUnit.2:distance *tmp372
-    * set *tmp362 :processUnit.2:distance
  1253 label *label292
  1254 jump *label290 always
  1255 label *label289
 
  1276 label *label301
  1277 set *tmp380 null
  1278 label *label302
-    * set *tmp376 *tmp380
  1279 jump *label298 always
  1280 label *label297
  1281 ucontrol approach .DOME_X .DOME_Y 6
 
  1288 op idiv *tmp386 *tmp385 .SPEED_TENTHS
  1289 op div *tmp387 *tmp386 10
  1290 set :processUnit.2:distance *tmp387
-    * set *tmp376 :processUnit.2:distance
  1291 label *label298
  1292 jump *label296 always
  1293 label *label295
 
  1337 op land *tmp401 *tmp398 *tmp400
  1338 jump *label311 equal *tmp401 false
  1339 jump *label308 always
-    * set *tmp402 null
  1340 jump *label312 always
  1341 label *label311
-    * set *tmp402 null
  1342 label *label312
  1343 jump *label310 always
  1344 label *label309
 
  1385 op equal *tmp416 *tmp415 :processUnit.3:item
  1386 jump *label325 equal *tmp416 false
  1387 set :processUnit.3:state 3
-    * set *tmp417 :processUnit.3:state
  1388 jump *label326 always
  1389 label *label325
  1390 sensor *tmp418 @unit @totalItems
 
  1406 label *label330
  1407 set *tmp420 *tmp422
  1408 label *label328
-    * set *tmp417 *tmp420
  1409 label *label326
  1410 jump *label322 always
  1411 label *label321
 
  1426 set .MSG ", loading\n"
  1427 set *tmp429 .MSG
  1428 label *label336
-    * set *tmp426 *tmp429
  1429 jump *label334 always
  1430 label *label333
  1431 ucontrol approach .CORE_X .CORE_Y 6
 
  1438 op idiv *tmp435 *tmp434 .SPEED_TENTHS
  1439 op div *tmp436 *tmp435 10
  1440 set :processUnit.3:distance *tmp436
-    * set *tmp426 :processUnit.3:distance
  1441 label *label334
  1442 jump *label332 always
  1443 label *label331
 
  1464 label *label343
  1465 set *tmp444 null
  1466 label *label344
-    * set *tmp440 *tmp444
  1467 jump *label340 always
  1468 label *label339
  1469 ucontrol approach .DOME_X .DOME_Y 6
 
  1476 op idiv *tmp450 *tmp449 .SPEED_TENTHS
  1477 op div *tmp451 *tmp450 10
  1478 set :processUnit.3:distance *tmp451
-    * set *tmp440 :processUnit.3:distance
  1479 label *label340
  1480 jump *label338 always
  1481 label *label337
 
  1581 jump *label368 equal *tmp483 false
  1582 set *tmp466 true
  1583 jump *label355 always
-    * set *tmp484 null
  1584 jump *label369 always
  1585 label *label368
-    * set *tmp484 null
  1586 label *label369
  1587 jump *label365 always
  1588 label *label364
-    * set *tmp485 :areUnitsAvailable.2:occupied
  1589 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1590 label *label365
  1591 ubind :areUnitsAvailable.2:type

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-24 instructions):
 
   793 op equal *tmp221 *tmp220 0
   794 jump *label198 equal *tmp221 false
   795 set :processUnit:state 2
-    * set *tmp222 :processUnit:state
   796 jump *label199 always
   797 label *label198
   798 set .MSG ", initializing\n"
 
   805 label *label200
   806 set *tmp224 null
   807 label *label201
-    * set *tmp222 *tmp224
   808 label *label199
   809 label *label197
   810 jump *label193 always
 
   820 jump *label206 equal *tmp230 false
   821 ucontrol approach .DOME_X .DOME_Y 6
   822 set :processUnit:state 3
-    * set *tmp231 :processUnit:state
   823 jump *label207 always
   824 label *label206
   825 set .MSG ", loading\n"
-    * set *tmp231 .MSG
   826 label *label207
   827 jump *label205 always
   828 label *label204
 
   857 jump *label214 equal *tmp245 false
   858 ucontrol approach .CORE_X .CORE_Y 6
   859 set :processUnit:state 2
-    * set *tmp246 :processUnit:state
   860 jump *label215 always
   861 label *label214
-    * set *tmp246 null
   862 label *label215
   863 jump *label211 always
   864 label *label210
 
   975 op equal *tmp285 *tmp284 0
   976 jump *label240 equal *tmp285 false
   977 set :processUnit.1:state 2
-    * set *tmp286 :processUnit.1:state
   978 jump *label241 always
   979 label *label240
   980 set .MSG ", initializing\n"
 
   987 label *label242
   988 set *tmp288 null
   989 label *label243
-    * set *tmp286 *tmp288
   990 label *label241
   991 label *label239
   992 jump *label235 always
 
  1002 jump *label248 equal *tmp294 false
  1003 ucontrol approach .DOME_X .DOME_Y 6
  1004 set :processUnit.1:state 3
-    * set *tmp295 :processUnit.1:state
  1005 jump *label249 always
  1006 label *label248
  1007 set .MSG ", loading\n"
-    * set *tmp295 .MSG
  1008 label *label249
  1009 jump *label247 always
  1010 label *label246
 
  1039 jump *label256 equal *tmp309 false
  1040 ucontrol approach .CORE_X .CORE_Y 6
  1041 set :processUnit.1:state 2
-    * set *tmp310 :processUnit.1:state
  1042 jump *label257 always
  1043 label *label256
-    * set *tmp310 null
  1044 label *label257
  1045 jump *label253 always
  1046 label *label252
 
  1191 op equal *tmp355 *tmp354 0
  1192 jump *label285 equal *tmp355 false
  1193 set :processUnit.2:state 2
-    * set *tmp356 :processUnit.2:state
  1194 jump *label286 always
  1195 label *label285
  1196 set .MSG ", initializing\n"
 
  1203 label *label287
  1204 set *tmp358 null
  1205 label *label288
-    * set *tmp356 *tmp358
  1206 label *label286
  1207 label *label284
  1208 jump *label280 always
 
  1218 jump *label293 equal *tmp364 false
  1219 ucontrol approach .DOME_X .DOME_Y 6
  1220 set :processUnit.2:state 3
-    * set *tmp365 :processUnit.2:state
  1221 jump *label294 always
  1222 label *label293
  1223 set .MSG ", loading\n"
-    * set *tmp365 .MSG
  1224 label *label294
  1225 jump *label292 always
  1226 label *label291
 
  1255 jump *label301 equal *tmp379 false
  1256 ucontrol approach .CORE_X .CORE_Y 6
  1257 set :processUnit.2:state 2
-    * set *tmp380 :processUnit.2:state
  1258 jump *label302 always
  1259 label *label301
-    * set *tmp380 null
  1260 label *label302
  1261 jump *label298 always
  1262 label *label297
 
  1373 op equal *tmp419 *tmp418 0
  1374 jump *label327 equal *tmp419 false
  1375 set :processUnit.3:state 2
-    * set *tmp420 :processUnit.3:state
  1376 jump *label328 always
  1377 label *label327
  1378 set .MSG ", initializing\n"
 
  1385 label *label329
  1386 set *tmp422 null
  1387 label *label330
-    * set *tmp420 *tmp422
  1388 label *label328
  1389 label *label326
  1390 jump *label322 always
 
  1400 jump *label335 equal *tmp428 false
  1401 ucontrol approach .DOME_X .DOME_Y 6
  1402 set :processUnit.3:state 3
-    * set *tmp429 :processUnit.3:state
  1403 jump *label336 always
  1404 label *label335
  1405 set .MSG ", loading\n"
-    * set *tmp429 .MSG
  1406 label *label336
  1407 jump *label334 always
  1408 label *label333
 
  1437 jump *label343 equal *tmp443 false
  1438 ucontrol approach .CORE_X .CORE_Y 6
  1439 set :processUnit.3:state 2
-    * set *tmp444 :processUnit.3:state
  1440 jump *label344 always
  1441 label *label343
-    * set *tmp444 null
  1442 label *label344
  1443 jump *label340 always
  1444 label *label339

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
   800 ucontrol within .CORE_X .CORE_Y 8 *tmp223
   801 jump *label200 equal *tmp223 false
   802 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp224 null
   803 jump *label201 always
   804 label *label200
-    * set *tmp224 null
   805 label *label201
   806 label *label199
   807 label *label197
 
   980 ucontrol within .CORE_X .CORE_Y 8 *tmp287
   981 jump *label242 equal *tmp287 false
   982 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp288 null
   983 jump *label243 always
   984 label *label242
-    * set *tmp288 null
   985 label *label243
   986 label *label241
   987 label *label239
 
  1194 ucontrol within .CORE_X .CORE_Y 8 *tmp357
  1195 jump *label287 equal *tmp357 false
  1196 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp358 null
  1197 jump *label288 always
  1198 label *label287
-    * set *tmp358 null
  1199 label *label288
  1200 label *label286
  1201 label *label284
 
  1374 ucontrol within .CORE_X .CORE_Y 8 *tmp421
  1375 jump *label329 equal *tmp421 false
  1376 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp422 null
  1377 jump *label330 always
  1378 label *label329
-    * set *tmp422 null
  1379 label *label330
  1380 label *label328
  1381 label *label326

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-41 instructions):
 
    47 jump *label5 always
    48 label *label7
    49 label *label1
-    * sensor *tmp3 .CORE @x
-    * set .CORE_X *tmp3
-    * sensor *tmp4 .CORE @y
-    * set .CORE_Y *tmp4
-    * sensor *tmp5 .DOME @x
-    * set .DOME_X *tmp5
-    * sensor *tmp6 .DOME @y
-    * set .DOME_Y *tmp6
+   50 sensor .CORE_X .CORE @x
+   51 sensor .CORE_Y .CORE @y
+   52 sensor .DOME_X .DOME @x
+   53 sensor .DOME_Y .DOME @y
    54 label *label17
    55 sensor *tmp7 switch1 @enabled
    56 op equal *tmp8 *tmp7 false
 
    84 op len *tmp16 *tmp14 *tmp15
    85 op mul *tmp17 2 *tmp16
    86 sensor *tmp18 :needsFourUnits:unit @speed
-    * op div *tmp19 *tmp17 *tmp18
-    * set :needsFourUnits:travel_time *tmp19
-    * op greaterThanEq *tmp20 :needsFourUnits:travel_time 47
-    * set *tmp13 *tmp20
+   87 op div :needsFourUnits:travel_time *tmp17 *tmp18
+   88 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    89 jump *label31 always
    90 set *tmp13 null
    91 label *label31
 
   194 op len *tmp46 *tmp44 *tmp45
   195 op mul *tmp47 2 *tmp46
   196 sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div *tmp49 *tmp47 *tmp48
-    * set :needsFourUnits.1:travel_time *tmp49
-    * op greaterThanEq *tmp50 :needsFourUnits.1:travel_time 47
-    * set *tmp43 *tmp50
+  197 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  198 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   199 jump *label62 always
   200 set *tmp43 null
   201 label *label62
 
   310 set .UNIT_S2 .UNIT_P2
   311 set .UNIT_P2 .UNIT_S1
   312 set .UNIT_S1 .UNIT_P1
-    * set *tmp74 @unit
-    * set .UNIT_P1 *tmp74
+  313 set .UNIT_P1 @unit
   314 op notEqual *tmp75 .UNIT_S2 null
   315 jump *label85 equal *tmp75 false
   316 jump *label82 always
 
   459 jump *label117 always
   460 label *label116
   461 label *label117
-    * sensor *tmp121 .UNIT_S1 @itemCapacity
-    * set .UNIT_CAPACITY *tmp121
-    * sensor *tmp122 .UNIT_S1 @speed
-    * set .SPEED *tmp122
-    * op div *tmp123 .SPEED 10
-    * set .SPEED_TENTHS *tmp123
+  462 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
+  463 sensor .SPEED .UNIT_S1 @speed
+  464 op div .SPEED_TENTHS .SPEED 10
   465 op strictEqual *tmp124 .SPEED null
   466 jump *label121 equal *tmp124 false
   467 stop
 
   475 op len *tmp129 *tmp127 *tmp128
   476 op mul *tmp130 2 *tmp129
   477 sensor *tmp131 :needsFourUnits.2:unit @speed
-    * op div *tmp132 *tmp130 *tmp131
-    * set :needsFourUnits.2:travel_time *tmp132
-    * op greaterThanEq *tmp133 :needsFourUnits.2:travel_time 47
-    * set *tmp126 *tmp133
+  478 op div :needsFourUnits.2:travel_time *tmp130 *tmp131
+  479 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   480 jump *label123 always
   481 set *tmp126 null
   482 label *label123
 
   672 set *tmp190 false
   673 label *label169
   674 set .SUPPLY_P_FIRST *tmp190
-    * op add *tmp191 @time 5000
-    * set :unitCheck *tmp191
+  675 op add :unitCheck @time 5000
   676 label *label172
   677 sensor *tmp192 switch1 @enabled
   678 jump *label174 equal *tmp192 false
 
   689 set :printDomeStatus:item @silicon
   690 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   691 print :printDomeStatus:text
-    * sensor *tmp193 .DOME :printDomeStatus:item
-    * set :printDomeStatus:level *tmp193
+  692 sensor :printDomeStatus:level .DOME :printDomeStatus:item
   693 op greaterThan *tmp194 :printDomeStatus:level 3
   694 jump *label176 equal *tmp194 false
   695 print "  dome:  [green]"
 
   756 label *label185
   757 end
   758 label *label179
-    * sensor *tmp213 @unit @flag
-    * set :processUnit:state *tmp213
+  759 sensor :processUnit:state @unit @flag
   760 set :processUnit:distance -1
   761 set :processUnit:color "gold"
   762 op lessThan *tmp214 :processUnit:state 2
 
   815 op sub *tmp235 .CORE_Y *tmp234
   816 op len *tmp236 *tmp233 *tmp235
   817 op idiv *tmp237 *tmp236 .SPEED_TENTHS
-    * op div *tmp238 *tmp237 10
-    * set :processUnit:distance *tmp238
+  818 op div :processUnit:distance *tmp237 10
   819 label *label205
   820 jump *label203 always
   821 label *label202
 
   850 op sub *tmp250 .DOME_Y *tmp249
   851 op len *tmp251 *tmp248 *tmp250
   852 op idiv *tmp252 *tmp251 .SPEED_TENTHS
-    * op div *tmp253 *tmp252 10
-    * set :processUnit:distance *tmp253
+  853 op div :processUnit:distance *tmp252 10
   854 label *label211
   855 jump *label209 always
   856 label *label208
 
   877 label *label216
   878 print .MSG
   879 label *label217
-    * set *tmp257 @unit
-    * set :processUnit:unit *tmp257
+  880 set :processUnit:unit @unit
   881 label *label178
   882 set .UNIT_S1 :processUnit:unit
   883 jump *label218 equal .FOUR_UNITS false
 
   932 label *label227
   933 end
   934 label *label221
-    * sensor *tmp277 @unit @flag
-    * set :processUnit.1:state *tmp277
+  935 sensor :processUnit.1:state @unit @flag
   936 set :processUnit.1:distance -1
   937 set :processUnit.1:color "gold"
   938 op lessThan *tmp278 :processUnit.1:state 2
 
   991 op sub *tmp299 .CORE_Y *tmp298
   992 op len *tmp300 *tmp297 *tmp299
   993 op idiv *tmp301 *tmp300 .SPEED_TENTHS
-    * op div *tmp302 *tmp301 10
-    * set :processUnit.1:distance *tmp302
+  994 op div :processUnit.1:distance *tmp301 10
   995 label *label247
   996 jump *label245 always
   997 label *label244
 
  1026 op sub *tmp314 .DOME_Y *tmp313
  1027 op len *tmp315 *tmp312 *tmp314
  1028 op idiv *tmp316 *tmp315 .SPEED_TENTHS
-    * op div *tmp317 *tmp316 10
-    * set :processUnit.1:distance *tmp317
+ 1029 op div :processUnit.1:distance *tmp316 10
  1030 label *label253
  1031 jump *label251 always
  1032 label *label250
 
  1053 label *label258
  1054 print .MSG
  1055 label *label259
-    * set *tmp321 @unit
-    * set :processUnit.1:unit *tmp321
+ 1056 set :processUnit.1:unit @unit
  1057 label *label220
  1058 set .UNIT_S2 :processUnit.1:unit
  1059 jump *label260 equal .SUPPLY_S_FIRST false
  1060 sensor *tmp323 .UNIT_S1 @totalItems
-    * op greaterThan *tmp324 *tmp323 0
-    * set *tmp322 *tmp324
+ 1061 op greaterThan *tmp322 *tmp323 0
  1062 jump *label261 always
  1063 label *label260
  1064 sensor *tmp325 .UNIT_S2 @totalItems
-    * op equal *tmp326 *tmp325 0
-    * set *tmp322 *tmp326
+ 1065 op equal *tmp322 *tmp325 0
  1066 label *label261
  1067 set .SUPPLY_S_FIRST *tmp322
  1068 jump *label219 always
 
  1072 set :printDomeStatus.1:item @phase-fabric
  1073 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
  1074 print :printDomeStatus.1:text
-    * sensor *tmp327 .DOME :printDomeStatus.1:item
-    * set :printDomeStatus.1:level *tmp327
+ 1075 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
  1076 op greaterThan *tmp328 :printDomeStatus.1:level 3
  1077 jump *label263 equal *tmp328 false
  1078 print "  dome:  [green]"
 
  1139 label *label272
  1140 end
  1141 label *label266
-    * sensor *tmp347 @unit @flag
-    * set :processUnit.2:state *tmp347
+ 1142 sensor :processUnit.2:state @unit @flag
  1143 set :processUnit.2:distance -1
  1144 set :processUnit.2:color "gold"
  1145 op lessThan *tmp348 :processUnit.2:state 2
 
  1198 op sub *tmp369 .CORE_Y *tmp368
  1199 op len *tmp370 *tmp367 *tmp369
  1200 op idiv *tmp371 *tmp370 .SPEED_TENTHS
-    * op div *tmp372 *tmp371 10
-    * set :processUnit.2:distance *tmp372
+ 1201 op div :processUnit.2:distance *tmp371 10
  1202 label *label292
  1203 jump *label290 always
  1204 label *label289
 
  1233 op sub *tmp384 .DOME_Y *tmp383
  1234 op len *tmp385 *tmp382 *tmp384
  1235 op idiv *tmp386 *tmp385 .SPEED_TENTHS
-    * op div *tmp387 *tmp386 10
-    * set :processUnit.2:distance *tmp387
+ 1236 op div :processUnit.2:distance *tmp386 10
  1237 label *label298
  1238 jump *label296 always
  1239 label *label295
 
  1260 label *label303
  1261 print .MSG
  1262 label *label304
-    * set *tmp391 @unit
-    * set :processUnit.2:unit *tmp391
+ 1263 set :processUnit.2:unit @unit
  1264 label *label265
  1265 set .UNIT_P1 :processUnit.2:unit
  1266 jump *label305 equal .FOUR_UNITS false
 
  1315 label *label314
  1316 end
  1317 label *label308
-    * sensor *tmp411 @unit @flag
-    * set :processUnit.3:state *tmp411
+ 1318 sensor :processUnit.3:state @unit @flag
  1319 set :processUnit.3:distance -1
  1320 set :processUnit.3:color "gold"
  1321 op lessThan *tmp412 :processUnit.3:state 2
 
  1374 op sub *tmp433 .CORE_Y *tmp432
  1375 op len *tmp434 *tmp431 *tmp433
  1376 op idiv *tmp435 *tmp434 .SPEED_TENTHS
-    * op div *tmp436 *tmp435 10
-    * set :processUnit.3:distance *tmp436
+ 1377 op div :processUnit.3:distance *tmp435 10
  1378 label *label334
  1379 jump *label332 always
  1380 label *label331
 
  1409 op sub *tmp448 .DOME_Y *tmp447
  1410 op len *tmp449 *tmp446 *tmp448
  1411 op idiv *tmp450 *tmp449 .SPEED_TENTHS
-    * op div *tmp451 *tmp450 10
-    * set :processUnit.3:distance *tmp451
+ 1412 op div :processUnit.3:distance *tmp450 10
  1413 label *label340
  1414 jump *label338 always
  1415 label *label337
 
  1436 label *label345
  1437 print .MSG
  1438 label *label346
-    * set *tmp455 @unit
-    * set :processUnit.3:unit *tmp455
+ 1439 set :processUnit.3:unit @unit
  1440 label *label307
  1441 set .UNIT_P2 :processUnit.3:unit
  1442 jump *label347 equal .SUPPLY_P_FIRST false
  1443 sensor *tmp457 .UNIT_P1 @totalItems
-    * op greaterThan *tmp458 *tmp457 0
-    * set *tmp456 *tmp458
+ 1444 op greaterThan *tmp456 *tmp457 0
  1445 jump *label348 always
  1446 label *label347
  1447 sensor *tmp459 .UNIT_P2 @totalItems
-    * op equal *tmp460 *tmp459 0
-    * set *tmp456 *tmp460
+ 1448 op equal *tmp456 *tmp459 0
  1449 label *label348
  1450 set .SUPPLY_P_FIRST *tmp456
  1451 jump *label306 always
 
  1483 op len *tmp472 *tmp470 *tmp471
  1484 op mul *tmp473 2 *tmp472
  1485 sensor *tmp474 :needsFourUnits.3:unit @speed
-    * op div *tmp475 *tmp473 *tmp474
-    * set :needsFourUnits.3:travel_time *tmp475
-    * op greaterThanEq *tmp476 :needsFourUnits.3:travel_time 47
-    * set *tmp469 *tmp476
+ 1486 op div :needsFourUnits.3:travel_time *tmp473 *tmp474
+ 1487 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
  1488 jump *label360 always
  1489 set *tmp469 null
  1490 label *label360
 
  1558 jump *label354 always
  1559 label *label353
  1560 label *label354
-    * op add *tmp493 @time 5000
-    * set :unitCheck *tmp493
+ 1561 op add :unitCheck @time 5000
  1562 jump *label350 always
  1563 label *label349
  1564 label *label350
 
  1578 jump *label378 notEqual *tmp497 false
  1579 jump *label376 always
  1580 label *label378
-    * ulocate building core false @copper *tmp500 *tmp501 *tmp502 *tmp499
-    * set .CORE *tmp499
+ 1581 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1582 jump *label377 always
  1583 label *label376
  1584 label *label377

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * jump *label7 equal true false
    19 set :locateDomeAndCore:type @flare
    20 op add *tmp1 @counter 1
    21 jump *label8 always
 
    62 label *label19
    63 # "Function: inline def chooseUnitType()"
    64 label *label21
-    * jump *label23 equal true false
    65 printflush null
    66 print "[gold]Looking for suitable unit type:[]"
    67 print "\n"

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-24 instructions):
 
   101 label *label38
   102 sensor *tmp24 @unit @controller
   103 op equal *tmp25 *tmp24 @this
-    * jump *label37 notEqual *tmp25 false
-    * jump *label35 always
+  104 jump *label35 equal *tmp25 false
   105 label *label37
   106 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
   107 op greaterThanEq *tmp27 :areUnitsAvailable:free :areUnitsAvailable:needed
 
   122 label *label41
   123 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
   124 op equal *tmp32 *tmp31 0
-    * jump *label34 equal *tmp32 false
-    * jump *label32 always
+  125 jump *label32 notEqual *tmp32 false
   126 label *label34
   127 jump *label28 always
   128 label *label27
 
   209 label *label69
   210 sensor *tmp54 @unit @controller
   211 op equal *tmp55 *tmp54 @this
-    * jump *label68 notEqual *tmp55 false
-    * jump *label66 always
+  212 jump *label66 equal *tmp55 false
   213 label *label68
   214 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
   215 op greaterThanEq *tmp57 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
 
   230 label *label72
   231 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   232 op equal *tmp62 *tmp61 0
-    * jump *label65 equal *tmp62 false
-    * jump *label63 always
+  233 jump *label63 notEqual *tmp62 false
   234 label *label65
   235 jump *label59 always
   236 label *label58
 
   321 label *label87
   322 sensor *tmp78 :rebindUnits:firstUnit @dead
   323 op equal *tmp79 *tmp78 0
-    * jump *label82 equal *tmp79 false
-    * jump *label80 always
+  324 jump *label80 notEqual *tmp79 false
   325 label *label82
   326 jump *label77 always
   327 label *label77
 
   364 label *label101
   365 sensor *tmp96 :rebindUnit:firstUnit @dead
   366 op equal *tmp97 *tmp96 0
-    * jump *label98 equal *tmp97 false
-    * jump *label96 always
+  367 jump *label96 notEqual *tmp97 false
   368 label *label98
   369 jump *label95 always
   370 label *label94
 
   416 label *label115
   417 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   418 op equal *tmp115 *tmp114 0
-    * jump *label112 equal *tmp115 false
-    * jump *label110 always
+  419 jump *label110 notEqual *tmp115 false
   420 label *label112
   421 jump *label109 always
   422 label *label108
 
   435 label *label119
   436 sensor *tmp118 .UNIT_P1 @firstItem
   437 op equal *tmp119 *tmp118 @silicon
-    * jump *label118 notEqual *tmp119 false
-    * jump *label116 always
+  438 jump *label116 equal *tmp119 false
   439 label *label118
   440 # "Function: inline void swap(in out a, in out b)"
   441 set :swap:a .UNIT_S1
 
   511 label *label139
   512 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   513 op equal *tmp152 *tmp151 0
-    * jump *label136 equal *tmp152 false
-    * jump *label134 always
+  514 jump *label134 notEqual *tmp152 false
   515 label *label136
   516 jump *label133 always
   517 label *label132
 
   563 label *label153
   564 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   565 op equal *tmp170 *tmp169 0
-    * jump *label150 equal *tmp170 false
-    * jump *label148 always
+  566 jump *label148 notEqual *tmp170 false
   567 label *label150
   568 jump *label147 always
   569 label *label146
 
   603 label *label162
   604 sensor *tmp178 .UNIT_P2 @firstItem
   605 op equal *tmp179 *tmp178 @silicon
-    * jump *label161 notEqual *tmp179 false
-    * jump *label159 always
+  606 jump *label159 equal *tmp179 false
   607 label *label161
   608 # "Function: inline void swap(in out a, in out b)"
   609 set :swap.2:a .UNIT_S2
 
   635 sensor *tmp182 .UNIT_S1 @totalItems
   636 sensor *tmp183 .UNIT_S2 @totalItems
   637 op lessThan *tmp184 *tmp182 *tmp183
-    * jump *label166 notEqual *tmp184 false
-    * jump *label164 always
+  638 jump *label164 equal *tmp184 false
   639 label *label166
   640 set *tmp185 true
   641 jump *label165 always
 
   649 sensor *tmp187 .UNIT_P1 @totalItems
   650 sensor *tmp188 .UNIT_P2 @totalItems
   651 op lessThan *tmp189 *tmp187 *tmp188
-    * jump *label170 notEqual *tmp189 false
-    * jump *label168 always
+  652 jump *label168 equal *tmp189 false
   653 label *label170
   654 set *tmp190 true
   655 jump *label169 always
 
   733 label *label191
   734 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   735 op equal *tmp212 *tmp211 0
-    * jump *label188 equal *tmp212 false
-    * jump *label186 always
+  736 jump *label186 notEqual *tmp212 false
   737 label *label188
   738 jump *label185 always
   739 label *label184
 
   747 jump *label194 notEqual *tmp214 false
   748 label *label195
   749 op greaterThan *tmp215 :processUnit:state 3
-    * jump *label194 notEqual *tmp215 false
-    * jump *label192 always
+  750 jump *label192 equal *tmp215 false
   751 label *label194
   752 sensor *tmp217 @unit @firstItem
   753 op equal *tmp218 *tmp217 :processUnit:item
 
   907 label *label233
   908 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   909 op equal *tmp276 *tmp275 0
-    * jump *label230 equal *tmp276 false
-    * jump *label228 always
+  910 jump *label228 notEqual *tmp276 false
   911 label *label230
   912 jump *label227 always
   913 label *label226
 
   921 jump *label236 notEqual *tmp278 false
   922 label *label237
   923 op greaterThan *tmp279 :processUnit.1:state 3
-    * jump *label236 notEqual *tmp279 false
-    * jump *label234 always
+  924 jump *label234 equal *tmp279 false
   925 label *label236
   926 sensor *tmp281 @unit @firstItem
   927 op equal *tmp282 *tmp281 :processUnit.1:item
 
  1112 label *label278
  1113 sensor *tmp345 :rebindUnit.6:firstUnit @dead
  1114 op equal *tmp346 *tmp345 0
-    * jump *label275 equal *tmp346 false
-    * jump *label273 always
+ 1115 jump *label273 notEqual *tmp346 false
  1116 label *label275
  1117 jump *label272 always
  1118 label *label271
 
  1126 jump *label281 notEqual *tmp348 false
  1127 label *label282
  1128 op greaterThan *tmp349 :processUnit.2:state 3
-    * jump *label281 notEqual *tmp349 false
-    * jump *label279 always
+ 1129 jump *label279 equal *tmp349 false
  1130 label *label281
  1131 sensor *tmp351 @unit @firstItem
  1132 op equal *tmp352 *tmp351 :processUnit.2:item
 
  1286 label *label320
  1287 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1288 op equal *tmp410 *tmp409 0
-    * jump *label317 equal *tmp410 false
-    * jump *label315 always
+ 1289 jump *label315 notEqual *tmp410 false
  1290 label *label317
  1291 jump *label314 always
  1292 label *label313
 
  1300 jump *label323 notEqual *tmp412 false
  1301 label *label324
  1302 op greaterThan *tmp413 :processUnit.3:state 3
-    * jump *label323 notEqual *tmp413 false
-    * jump *label321 always
+ 1303 jump *label321 equal *tmp413 false
  1304 label *label323
  1305 sensor *tmp415 @unit @firstItem
  1306 op equal *tmp416 *tmp415 :processUnit.3:item
 
  1479 label *label367
  1480 sensor *tmp480 @unit @controller
  1481 op equal *tmp481 *tmp480 @this
-    * jump *label366 notEqual *tmp481 false
-    * jump *label364 always
+ 1482 jump *label364 equal *tmp481 false
  1483 label *label366
  1484 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
  1485 op greaterThanEq *tmp483 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
 
  1500 label *label370
  1501 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1502 op equal *tmp488 *tmp487 0
-    * jump *label363 equal *tmp488 false
-    * jump *label361 always
+ 1503 jump *label361 notEqual *tmp488 false
  1504 label *label363
  1505 jump *label357 always
  1506 label *label356
 
  1550 label *label379
  1551 sensor *tmp496 @unit @controller
  1552 op equal *tmp497 *tmp496 @this
-    * jump *label378 notEqual *tmp497 false
-    * jump *label376 always
+ 1553 jump *label376 equal *tmp497 false
  1554 label *label378
  1555 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1556 jump *label377 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-121 instructions):
 
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
     6 label *label2
-    * op equal *tmp0 .DOME null
-    * jump *label4 equal *tmp0 false
+    7 jump *label4 notEqual .DOME null
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
 
    51 sensor .DOME_Y .DOME @y
    52 label *label17
    53 sensor *tmp7 switch1 @enabled
-    * op equal *tmp8 *tmp7 false
-    * jump *label19 equal *tmp8 false
+   54 jump *label19 notEqual *tmp7 false
    55 print "[coral]Activate switch to begin supplying overdrive dome..."
    56 print "\n"
    57 printflush message1
 
    71 set :areUnitsAvailable:needed 0
    72 ubind :areUnitsAvailable:type
    73 set :areUnitsAvailable:firstUnit @unit
-    * op notEqual *tmp11 :areUnitsAvailable:firstUnit null
-    * jump *label27 equal *tmp11 false
+   74 jump *label27 equal :areUnitsAvailable:firstUnit null
    75 # "Function: inline def needsFourUnits(in unit)"
    76 set :needsFourUnits:unit @unit
    77 op sub *tmp14 .DOME_X .CORE_X
 
    93 set :areUnitsAvailable:needed *tmp21
    94 label *label32
    95 sensor *tmp22 @unit @controlled
-    * op equal *tmp23 *tmp22 0
-    * jump *label37 notEqual *tmp23 false
+   96 jump *label37 equal *tmp22 0
    97 label *label38
    98 sensor *tmp24 @unit @controller
-    * op equal *tmp25 *tmp24 @this
-    * jump *label35 equal *tmp25 false
+   99 jump *label35 notEqual *tmp24 @this
   100 label *label37
   101 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * op greaterThanEq *tmp27 :areUnitsAvailable:free :areUnitsAvailable:needed
-    * jump *label39 equal *tmp27 false
+  102 jump *label39 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   103 set *tmp10 true
   104 jump *label26 always
   105 jump *label40 always
 
   111 label *label36
   112 ubind :areUnitsAvailable:type
   113 label *label33
-    * op notEqual *tmp30 @unit :areUnitsAvailable:firstUnit
-    * jump *label34 equal *tmp30 false
+  114 jump *label34 equal @unit :areUnitsAvailable:firstUnit
   115 label *label41
   116 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
-    * op equal *tmp32 *tmp31 0
-    * jump *label32 notEqual *tmp32 false
+  117 jump *label32 equal *tmp31 0
   118 label *label34
   119 jump *label28 always
   120 label *label27
 
   127 print ","
   128 print " free: "
   129 print :areUnitsAvailable:free
-    * op greaterThan *tmp34 :areUnitsAvailable:needed 0
-    * jump *label44 equal *tmp34 false
+  130 jump *label44 lessThanEq :areUnitsAvailable:needed 0
   131 print ", needed: "
   132 print :areUnitsAvailable:needed
   133 jump *label45 always
 
   162 set :chooseUnitType:type @mono
   163 set *tmp37 null
   164 label *label46
-    * op notEqual *tmp38 :chooseUnitType:type UNIT_TYPE
-    * jump *label53 equal *tmp38 false
+  165 jump *label53 equal :chooseUnitType:type UNIT_TYPE
   166 # "Function: inline def areUnitsAvailable(in type, in output)"
   167 set :areUnitsAvailable.1:type :chooseUnitType:type
   168 set :areUnitsAvailable.1:output true
 
   171 set :areUnitsAvailable.1:needed 0
   172 ubind :areUnitsAvailable.1:type
   173 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp41 :areUnitsAvailable.1:firstUnit null
-    * jump *label58 equal *tmp41 false
+  174 jump *label58 equal :areUnitsAvailable.1:firstUnit null
   175 # "Function: inline def needsFourUnits(in unit)"
   176 set :needsFourUnits.1:unit @unit
   177 op sub *tmp44 .DOME_X .CORE_X
 
   193 set :areUnitsAvailable.1:needed *tmp51
   194 label *label63
   195 sensor *tmp52 @unit @controlled
-    * op equal *tmp53 *tmp52 0
-    * jump *label68 notEqual *tmp53 false
+  196 jump *label68 equal *tmp52 0
   197 label *label69
   198 sensor *tmp54 @unit @controller
-    * op equal *tmp55 *tmp54 @this
-    * jump *label66 equal *tmp55 false
+  199 jump *label66 notEqual *tmp54 @this
   200 label *label68
   201 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * op greaterThanEq *tmp57 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
-    * jump *label70 equal *tmp57 false
+  202 jump *label70 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   203 set *tmp40 true
   204 jump *label57 always
   205 jump *label71 always
 
   211 label *label67
   212 ubind :areUnitsAvailable.1:type
   213 label *label64
-    * op notEqual *tmp60 @unit :areUnitsAvailable.1:firstUnit
-    * jump *label65 equal *tmp60 false
+  214 jump *label65 equal @unit :areUnitsAvailable.1:firstUnit
   215 label *label72
   216 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp62 *tmp61 0
-    * jump *label63 notEqual *tmp62 false
+  217 jump *label63 equal *tmp61 0
   218 label *label65
   219 jump *label59 always
   220 label *label58
 
   227 print ","
   228 print " free: "
   229 print :areUnitsAvailable.1:free
-    * op greaterThan *tmp64 :areUnitsAvailable.1:needed 0
-    * jump *label75 equal *tmp64 false
+  230 jump *label75 lessThanEq :areUnitsAvailable.1:needed 0
   231 print ", needed: "
   232 print :areUnitsAvailable.1:needed
   233 jump *label76 always
 
   272 set :rebindUnits:count 0
   273 ubind .TYPE
   274 set :rebindUnits:firstUnit @unit
-    * op equal *tmp68 :rebindUnits:firstUnit null
-    * jump *label78 equal *tmp68 false
+  275 jump *label78 notEqual :rebindUnits:firstUnit null
   276 end
   277 jump *label79 always
   278 label *label78
   279 label *label79
   280 label *label80
   281 sensor *tmp70 @unit @controller
-    * op equal *tmp71 *tmp70 @this
-    * jump *label83 equal *tmp71 false
+  282 jump *label83 notEqual *tmp70 @this
   283 op add :rebindUnits:count :rebindUnits:count 1
   284 ucontrol flag 1
   285 set .UNIT_S2 .UNIT_P2
   286 set .UNIT_P2 .UNIT_S1
   287 set .UNIT_S1 .UNIT_P1
   288 set .UNIT_P1 @unit
-    * op notEqual *tmp75 .UNIT_S2 null
-    * jump *label85 equal *tmp75 false
+  289 jump *label85 equal .UNIT_S2 null
   290 jump *label82 always
   291 jump *label86 always
   292 label *label85
 
   296 label *label84
   297 ubind .TYPE
   298 label *label81
-    * op notEqual *tmp77 @unit :rebindUnits:firstUnit
-    * jump *label82 equal *tmp77 false
+  299 jump *label82 equal @unit :rebindUnits:firstUnit
   300 label *label87
   301 sensor *tmp78 :rebindUnits:firstUnit @dead
-    * op equal *tmp79 *tmp78 0
-    * jump *label80 notEqual *tmp79 false
+  302 jump *label80 equal *tmp78 0
   303 label *label82
   304 jump *label77 always
   305 label *label77
 
   307 set :acquireUnit:currentUnit .UNIT_S1
   308 # "Function: inline def rebindUnit(in currentUnit)"
   309 set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * op notEqual *tmp82 :rebindUnit:currentUnit null
-    * jump *label90 equal *tmp82 false
+  310 jump *label90 equal :rebindUnit:currentUnit null
   311 ubind :rebindUnit:currentUnit
   312 sensor *tmp84 @unit @dead
   313 op equal *tmp85 *tmp84 0
 
   324 label *label91
   325 ubind .TYPE
   326 set :rebindUnit:firstUnit @unit
-    * op notEqual *tmp90 :rebindUnit:firstUnit null
-    * jump *label94 equal *tmp90 false
+  327 jump *label94 equal :rebindUnit:firstUnit null
   328 label *label96
   329 sensor *tmp92 @unit @controlled
-    * op equal *tmp93 *tmp92 0
-    * jump *label99 equal *tmp93 false
+  330 jump *label99 notEqual *tmp92 0
   331 jump *label89 always
   332 jump *label100 always
   333 label *label99
   334 label *label100
   335 ubind .TYPE
   336 label *label97
-    * op notEqual *tmp95 @unit :rebindUnit:firstUnit
-    * jump *label98 equal *tmp95 false
+  337 jump *label98 equal @unit :rebindUnit:firstUnit
   338 label *label101
   339 sensor *tmp96 :rebindUnit:firstUnit @dead
-    * op equal *tmp97 *tmp96 0
-    * jump *label96 notEqual *tmp97 false
+  340 jump *label96 equal *tmp96 0
   341 label *label98
   342 jump *label95 always
   343 label *label94
 
   354 set :acquireUnit.1:currentUnit .UNIT_P1
   355 # "Function: inline def rebindUnit(in currentUnit)"
   356 set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * op notEqual *tmp100 :rebindUnit.1:currentUnit null
-    * jump *label104 equal *tmp100 false
+  357 jump *label104 equal :rebindUnit.1:currentUnit null
   358 ubind :rebindUnit.1:currentUnit
   359 sensor *tmp102 @unit @dead
   360 op equal *tmp103 *tmp102 0
 
   371 label *label105
   372 ubind .TYPE
   373 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp108 :rebindUnit.1:firstUnit null
-    * jump *label108 equal *tmp108 false
+  374 jump *label108 equal :rebindUnit.1:firstUnit null
   375 label *label110
   376 sensor *tmp110 @unit @controlled
-    * op equal *tmp111 *tmp110 0
-    * jump *label113 equal *tmp111 false
+  377 jump *label113 notEqual *tmp110 0
   378 jump *label103 always
   379 jump *label114 always
   380 label *label113
   381 label *label114
   382 ubind .TYPE
   383 label *label111
-    * op notEqual *tmp113 @unit :rebindUnit.1:firstUnit
-    * jump *label112 equal *tmp113 false
+  384 jump *label112 equal @unit :rebindUnit.1:firstUnit
   385 label *label115
   386 sensor *tmp114 :rebindUnit.1:firstUnit @dead
-    * op equal *tmp115 *tmp114 0
-    * jump *label110 notEqual *tmp115 false
+  387 jump *label110 equal *tmp114 0
   388 label *label112
   389 jump *label109 always
   390 label *label108
 
   398 label *label102
   399 set .UNIT_P1 *tmp98
   400 sensor *tmp116 .UNIT_S1 @firstItem
-    * op equal *tmp117 *tmp116 @phase-fabric
-    * jump *label118 notEqual *tmp117 false
+  401 jump *label118 equal *tmp116 @phase-fabric
   402 label *label119
   403 sensor *tmp118 .UNIT_P1 @firstItem
-    * op equal *tmp119 *tmp118 @silicon
-    * jump *label116 equal *tmp119 false
+  404 jump *label116 notEqual *tmp118 @silicon
   405 label *label118
   406 # "Function: inline void swap(in out a, in out b)"
   407 set :swap:a .UNIT_S1
 
   442 set :acquireUnit.2:currentUnit .UNIT_S2
   443 # "Function: inline def rebindUnit(in currentUnit)"
   444 set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * op notEqual *tmp137 :rebindUnit.2:currentUnit null
-    * jump *label128 equal *tmp137 false
+  445 jump *label128 equal :rebindUnit.2:currentUnit null
   446 ubind :rebindUnit.2:currentUnit
   447 sensor *tmp139 @unit @dead
   448 op equal *tmp140 *tmp139 0
 
   459 label *label129
   460 ubind .TYPE
   461 set :rebindUnit.2:firstUnit @unit
-    * op notEqual *tmp145 :rebindUnit.2:firstUnit null
-    * jump *label132 equal *tmp145 false
+  462 jump *label132 equal :rebindUnit.2:firstUnit null
   463 label *label134
   464 sensor *tmp147 @unit @controlled
-    * op equal *tmp148 *tmp147 0
-    * jump *label137 equal *tmp148 false
+  465 jump *label137 notEqual *tmp147 0
   466 jump *label127 always
   467 jump *label138 always
   468 label *label137
   469 label *label138
   470 ubind .TYPE
   471 label *label135
-    * op notEqual *tmp150 @unit :rebindUnit.2:firstUnit
-    * jump *label136 equal *tmp150 false
+  472 jump *label136 equal @unit :rebindUnit.2:firstUnit
   473 label *label139
   474 sensor *tmp151 :rebindUnit.2:firstUnit @dead
-    * op equal *tmp152 *tmp151 0
-    * jump *label134 notEqual *tmp152 false
+  475 jump *label134 equal *tmp151 0
   476 label *label136
   477 jump *label133 always
   478 label *label132
 
   489 set :acquireUnit.3:currentUnit .UNIT_P2
   490 # "Function: inline def rebindUnit(in currentUnit)"
   491 set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * op notEqual *tmp155 :rebindUnit.3:currentUnit null
-    * jump *label142 equal *tmp155 false
+  492 jump *label142 equal :rebindUnit.3:currentUnit null
   493 ubind :rebindUnit.3:currentUnit
   494 sensor *tmp157 @unit @dead
   495 op equal *tmp158 *tmp157 0
 
   506 label *label143
   507 ubind .TYPE
   508 set :rebindUnit.3:firstUnit @unit
-    * op notEqual *tmp163 :rebindUnit.3:firstUnit null
-    * jump *label146 equal *tmp163 false
+  509 jump *label146 equal :rebindUnit.3:firstUnit null
   510 label *label148
   511 sensor *tmp165 @unit @controlled
-    * op equal *tmp166 *tmp165 0
-    * jump *label151 equal *tmp166 false
+  512 jump *label151 notEqual *tmp165 0
   513 jump *label141 always
   514 jump *label152 always
   515 label *label151
   516 label *label152
   517 ubind .TYPE
   518 label *label149
-    * op notEqual *tmp168 @unit :rebindUnit.3:firstUnit
-    * jump *label150 equal *tmp168 false
+  519 jump *label150 equal @unit :rebindUnit.3:firstUnit
   520 label *label153
   521 sensor *tmp169 :rebindUnit.3:firstUnit @dead
-    * op equal *tmp170 *tmp169 0
-    * jump *label148 notEqual *tmp170 false
+  522 jump *label148 equal *tmp169 0
   523 label *label150
   524 jump *label147 always
   525 label *label146
 
   533 label *label140
   534 set .UNIT_P2 *tmp153
   535 sensor *tmp171 .UNIT_S1 @firstItem
-    * op equal *tmp172 *tmp171 @phase-fabric
-    * jump *label154 equal *tmp172 false
+  536 jump *label154 notEqual *tmp171 @phase-fabric
   537 label *label157
   538 sensor *tmp173 .UNIT_P2 @firstItem
-    * op notEqual *tmp174 *tmp173 @phase-fabric
-    * jump *label154 equal *tmp174 false
+  539 jump *label154 equal *tmp173 @phase-fabric
   540 jump *label156 always
   541 label *label156
   542 # "Function: inline void swap(in out a, in out b)"
 
   552 label *label154
   553 label *label155
   554 sensor *tmp176 .UNIT_S2 @firstItem
-    * op equal *tmp177 *tmp176 @phase-fabric
-    * jump *label161 notEqual *tmp177 false
+  555 jump *label161 equal *tmp176 @phase-fabric
   556 label *label162
   557 sensor *tmp178 .UNIT_P2 @firstItem
-    * op equal *tmp179 *tmp178 @silicon
-    * jump *label159 equal *tmp179 false
+  558 jump *label159 notEqual *tmp178 @silicon
   559 label *label161
   560 # "Function: inline void swap(in out a, in out b)"
   561 set :swap.2:a .UNIT_S2
 
   581 set .UNIT_P2 null
   582 set .GROUP1 "unit"
   583 label *label125
-    * op equal *tmp181 .FOUR_UNITS false
-    * jump *label166 notEqual *tmp181 false
+  584 jump *label166 equal .FOUR_UNITS false
   585 label *label167
   586 sensor *tmp182 .UNIT_S1 @totalItems
   587 sensor *tmp183 .UNIT_S2 @totalItems
-    * op lessThan *tmp184 *tmp182 *tmp183
-    * jump *label164 equal *tmp184 false
+  588 jump *label164 greaterThanEq *tmp182 *tmp183
   589 label *label166
   590 set *tmp185 true
   591 jump *label165 always
 
   593 set *tmp185 false
   594 label *label165
   595 set .SUPPLY_S_FIRST *tmp185
-    * op equal *tmp186 .FOUR_UNITS false
-    * jump *label170 notEqual *tmp186 false
+  596 jump *label170 equal .FOUR_UNITS false
   597 label *label171
   598 sensor *tmp187 .UNIT_P1 @totalItems
   599 sensor *tmp188 .UNIT_P2 @totalItems
-    * op lessThan *tmp189 *tmp187 *tmp188
-    * jump *label168 equal *tmp189 false
+  600 jump *label168 greaterThanEq *tmp187 *tmp188
   601 label *label170
   602 set *tmp190 true
   603 jump *label169 always
 
   623 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   624 print :printDomeStatus:text
   625 sensor :printDomeStatus:level .DOME :printDomeStatus:item
-    * op greaterThan *tmp194 :printDomeStatus:level 3
-    * jump *label176 equal *tmp194 false
+  626 jump *label176 lessThanEq :printDomeStatus:level 3
   627 print "  dome:  [green]"
   628 print :printDomeStatus:level
   629 print "["
 
   645 set :processUnit:supply .SUPPLY_S_FIRST
   646 # "Function: inline def rebindUnit(in currentUnit)"
   647 set :rebindUnit.4:currentUnit :processUnit:unit
-    * op notEqual *tmp197 :rebindUnit.4:currentUnit null
-    * jump *label180 equal *tmp197 false
+  648 jump *label180 equal :rebindUnit.4:currentUnit null
   649 ubind :rebindUnit.4:currentUnit
   650 sensor *tmp199 @unit @dead
   651 op equal *tmp200 *tmp199 0
 
   662 label *label181
   663 ubind .TYPE
   664 set :rebindUnit.4:firstUnit @unit
-    * op notEqual *tmp205 :rebindUnit.4:firstUnit null
-    * jump *label184 equal *tmp205 false
+  665 jump *label184 equal :rebindUnit.4:firstUnit null
   666 label *label186
   667 sensor *tmp207 @unit @controlled
-    * op equal *tmp208 *tmp207 0
-    * jump *label189 equal *tmp208 false
+  668 jump *label189 notEqual *tmp207 0
   669 jump *label179 always
   670 jump *label190 always
   671 label *label189
   672 label *label190
   673 ubind .TYPE
   674 label *label187
-    * op notEqual *tmp210 @unit :rebindUnit.4:firstUnit
-    * jump *label188 equal *tmp210 false
+  675 jump *label188 equal @unit :rebindUnit.4:firstUnit
   676 label *label191
   677 sensor *tmp211 :rebindUnit.4:firstUnit @dead
-    * op equal *tmp212 *tmp211 0
-    * jump *label186 notEqual *tmp212 false
+  678 jump *label186 equal *tmp211 0
   679 label *label188
   680 jump *label185 always
   681 label *label184
 
   685 sensor :processUnit:state @unit @flag
   686 set :processUnit:distance -1
   687 set :processUnit:color "gold"
-    * op lessThan *tmp214 :processUnit:state 2
-    * jump *label194 notEqual *tmp214 false
+  688 jump *label194 lessThan :processUnit:state 2
   689 label *label195
-    * op greaterThan *tmp215 :processUnit:state 3
-    * jump *label192 equal *tmp215 false
+  690 jump *label192 lessThanEq :processUnit:state 3
   691 label *label194
   692 sensor *tmp217 @unit @firstItem
-    * op equal *tmp218 *tmp217 :processUnit:item
-    * jump *label196 equal *tmp218 false
+  693 jump *label196 notEqual *tmp217 :processUnit:item
   694 set :processUnit:state 3
   695 jump *label197 always
   696 label *label196
   697 sensor *tmp220 @unit @totalItems
-    * op equal *tmp221 *tmp220 0
-    * jump *label198 equal *tmp221 false
+  698 jump *label198 notEqual *tmp220 0
   699 set :processUnit:state 2
   700 jump *label199 always
   701 label *label198
 
   712 jump *label193 always
   713 label *label192
   714 label *label193
-    * op equal *tmp225 :processUnit:state 2
-    * jump *label202 equal *tmp225 false
+  715 jump *label202 notEqual :processUnit:state 2
   716 ucontrol within .CORE_X .CORE_Y 8 *tmp227
   717 jump *label204 equal *tmp227 false
   718 ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
   719 sensor *tmp229 @unit @totalItems
-    * op greaterThanEq *tmp230 *tmp229 .UNIT_CAPACITY
-    * jump *label206 equal *tmp230 false
+  720 jump *label206 lessThan *tmp229 .UNIT_CAPACITY
   721 ucontrol approach .DOME_X .DOME_Y 6
   722 set :processUnit:state 3
   723 jump *label207 always
 
   739 jump *label203 always
   740 label *label202
   741 label *label203
-    * op equal *tmp239 :processUnit:state 3
-    * jump *label208 equal *tmp239 false
+  742 jump *label208 notEqual :processUnit:state 3
   743 ucontrol within .DOME_X .DOME_Y 8 *tmp241
   744 jump *label210 equal *tmp241 false
   745 jump *label212 equal :processUnit:supply false
 
   751 set .MSG ", waiting\n"
   752 label *label213
   753 sensor *tmp244 @unit @totalItems
-    * op lessThanEq *tmp245 *tmp244 0
-    * jump *label214 equal *tmp245 false
+  754 jump *label214 greaterThan *tmp244 0
   755 ucontrol approach .CORE_X .CORE_Y 6
   756 set :processUnit:state 2
   757 jump *label215 always
 
   783 print *tmp254
   784 print "["
   785 print "]"
-    * op greaterThanEq *tmp255 :processUnit:distance 0
-    * jump *label216 equal *tmp255 false
+  786 jump *label216 lessThan :processUnit:distance 0
   787 print .MSG
   788 print :processUnit:distance
   789 print "["
 
   805 set :processUnit.1:supply *tmp259
   806 # "Function: inline def rebindUnit(in currentUnit)"
   807 set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * op notEqual *tmp261 :rebindUnit.5:currentUnit null
-    * jump *label222 equal *tmp261 false
+  808 jump *label222 equal :rebindUnit.5:currentUnit null
   809 ubind :rebindUnit.5:currentUnit
   810 sensor *tmp263 @unit @dead
   811 op equal *tmp264 *tmp263 0
 
   822 label *label223
   823 ubind .TYPE
   824 set :rebindUnit.5:firstUnit @unit
-    * op notEqual *tmp269 :rebindUnit.5:firstUnit null
-    * jump *label226 equal *tmp269 false
+  825 jump *label226 equal :rebindUnit.5:firstUnit null
   826 label *label228
   827 sensor *tmp271 @unit @controlled
-    * op equal *tmp272 *tmp271 0
-    * jump *label231 equal *tmp272 false
+  828 jump *label231 notEqual *tmp271 0
   829 jump *label221 always
   830 jump *label232 always
   831 label *label231
   832 label *label232
   833 ubind .TYPE
   834 label *label229
-    * op notEqual *tmp274 @unit :rebindUnit.5:firstUnit
-    * jump *label230 equal *tmp274 false
+  835 jump *label230 equal @unit :rebindUnit.5:firstUnit
   836 label *label233
   837 sensor *tmp275 :rebindUnit.5:firstUnit @dead
-    * op equal *tmp276 *tmp275 0
-    * jump *label228 notEqual *tmp276 false
+  838 jump *label228 equal *tmp275 0
   839 label *label230
   840 jump *label227 always
   841 label *label226
 
   845 sensor :processUnit.1:state @unit @flag
   846 set :processUnit.1:distance -1
   847 set :processUnit.1:color "gold"
-    * op lessThan *tmp278 :processUnit.1:state 2
-    * jump *label236 notEqual *tmp278 false
+  848 jump *label236 lessThan :processUnit.1:state 2
   849 label *label237
-    * op greaterThan *tmp279 :processUnit.1:state 3
-    * jump *label234 equal *tmp279 false
+  850 jump *label234 lessThanEq :processUnit.1:state 3
   851 label *label236
   852 sensor *tmp281 @unit @firstItem
-    * op equal *tmp282 *tmp281 :processUnit.1:item
-    * jump *label238 equal *tmp282 false
+  853 jump *label238 notEqual *tmp281 :processUnit.1:item
   854 set :processUnit.1:state 3
   855 jump *label239 always
   856 label *label238
   857 sensor *tmp284 @unit @totalItems
-    * op equal *tmp285 *tmp284 0
-    * jump *label240 equal *tmp285 false
+  858 jump *label240 notEqual *tmp284 0
   859 set :processUnit.1:state 2
   860 jump *label241 always
   861 label *label240
 
   872 jump *label235 always
   873 label *label234
   874 label *label235
-    * op equal *tmp289 :processUnit.1:state 2
-    * jump *label244 equal *tmp289 false
+  875 jump *label244 notEqual :processUnit.1:state 2
   876 ucontrol within .CORE_X .CORE_Y 8 *tmp291
   877 jump *label246 equal *tmp291 false
   878 ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
   879 sensor *tmp293 @unit @totalItems
-    * op greaterThanEq *tmp294 *tmp293 .UNIT_CAPACITY
-    * jump *label248 equal *tmp294 false
+  880 jump *label248 lessThan *tmp293 .UNIT_CAPACITY
   881 ucontrol approach .DOME_X .DOME_Y 6
   882 set :processUnit.1:state 3
   883 jump *label249 always
 
   899 jump *label245 always
   900 label *label244
   901 label *label245
-    * op equal *tmp303 :processUnit.1:state 3
-    * jump *label250 equal *tmp303 false
+  902 jump *label250 notEqual :processUnit.1:state 3
   903 ucontrol within .DOME_X .DOME_Y 8 *tmp305
   904 jump *label252 equal *tmp305 false
   905 jump *label254 equal :processUnit.1:supply false
 
   911 set .MSG ", waiting\n"
   912 label *label255
   913 sensor *tmp308 @unit @totalItems
-    * op lessThanEq *tmp309 *tmp308 0
-    * jump *label256 equal *tmp309 false
+  914 jump *label256 greaterThan *tmp308 0
   915 ucontrol approach .CORE_X .CORE_Y 6
   916 set :processUnit.1:state 2
   917 jump *label257 always
 
   943 print *tmp318
   944 print "["
   945 print "]"
-    * op greaterThanEq *tmp319 :processUnit.1:distance 0
-    * jump *label258 equal *tmp319 false
+  946 jump *label258 lessThan :processUnit.1:distance 0
   947 print .MSG
   948 print :processUnit.1:distance
   949 print "["
 
   973 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   974 print :printDomeStatus.1:text
   975 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
-    * op greaterThan *tmp328 :printDomeStatus.1:level 3
-    * jump *label263 equal *tmp328 false
+  976 jump *label263 lessThanEq :printDomeStatus.1:level 3
   977 print "  dome:  [green]"
   978 print :printDomeStatus.1:level
   979 print "["
 
   995 set :processUnit.2:supply .SUPPLY_P_FIRST
   996 # "Function: inline def rebindUnit(in currentUnit)"
   997 set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * op notEqual *tmp331 :rebindUnit.6:currentUnit null
-    * jump *label267 equal *tmp331 false
+  998 jump *label267 equal :rebindUnit.6:currentUnit null
   999 ubind :rebindUnit.6:currentUnit
  1000 sensor *tmp333 @unit @dead
  1001 op equal *tmp334 *tmp333 0
 
  1012 label *label268
  1013 ubind .TYPE
  1014 set :rebindUnit.6:firstUnit @unit
-    * op notEqual *tmp339 :rebindUnit.6:firstUnit null
-    * jump *label271 equal *tmp339 false
+ 1015 jump *label271 equal :rebindUnit.6:firstUnit null
  1016 label *label273
  1017 sensor *tmp341 @unit @controlled
-    * op equal *tmp342 *tmp341 0
-    * jump *label276 equal *tmp342 false
+ 1018 jump *label276 notEqual *tmp341 0
  1019 jump *label266 always
  1020 jump *label277 always
  1021 label *label276
  1022 label *label277
  1023 ubind .TYPE
  1024 label *label274
-    * op notEqual *tmp344 @unit :rebindUnit.6:firstUnit
-    * jump *label275 equal *tmp344 false
+ 1025 jump *label275 equal @unit :rebindUnit.6:firstUnit
  1026 label *label278
  1027 sensor *tmp345 :rebindUnit.6:firstUnit @dead
-    * op equal *tmp346 *tmp345 0
-    * jump *label273 notEqual *tmp346 false
+ 1028 jump *label273 equal *tmp345 0
  1029 label *label275
  1030 jump *label272 always
  1031 label *label271
 
  1035 sensor :processUnit.2:state @unit @flag
  1036 set :processUnit.2:distance -1
  1037 set :processUnit.2:color "gold"
-    * op lessThan *tmp348 :processUnit.2:state 2
-    * jump *label281 notEqual *tmp348 false
+ 1038 jump *label281 lessThan :processUnit.2:state 2
  1039 label *label282
-    * op greaterThan *tmp349 :processUnit.2:state 3
-    * jump *label279 equal *tmp349 false
+ 1040 jump *label279 lessThanEq :processUnit.2:state 3
  1041 label *label281
  1042 sensor *tmp351 @unit @firstItem
-    * op equal *tmp352 *tmp351 :processUnit.2:item
-    * jump *label283 equal *tmp352 false
+ 1043 jump *label283 notEqual *tmp351 :processUnit.2:item
  1044 set :processUnit.2:state 3
  1045 jump *label284 always
  1046 label *label283
  1047 sensor *tmp354 @unit @totalItems
-    * op equal *tmp355 *tmp354 0
-    * jump *label285 equal *tmp355 false
+ 1048 jump *label285 notEqual *tmp354 0
  1049 set :processUnit.2:state 2
  1050 jump *label286 always
  1051 label *label285
 
  1062 jump *label280 always
  1063 label *label279
  1064 label *label280
-    * op equal *tmp359 :processUnit.2:state 2
-    * jump *label289 equal *tmp359 false
+ 1065 jump *label289 notEqual :processUnit.2:state 2
  1066 ucontrol within .CORE_X .CORE_Y 8 *tmp361
  1067 jump *label291 equal *tmp361 false
  1068 ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
  1069 sensor *tmp363 @unit @totalItems
-    * op greaterThanEq *tmp364 *tmp363 .UNIT_CAPACITY
-    * jump *label293 equal *tmp364 false
+ 1070 jump *label293 lessThan *tmp363 .UNIT_CAPACITY
  1071 ucontrol approach .DOME_X .DOME_Y 6
  1072 set :processUnit.2:state 3
  1073 jump *label294 always
 
  1089 jump *label290 always
  1090 label *label289
  1091 label *label290
-    * op equal *tmp373 :processUnit.2:state 3
-    * jump *label295 equal *tmp373 false
+ 1092 jump *label295 notEqual :processUnit.2:state 3
  1093 ucontrol within .DOME_X .DOME_Y 8 *tmp375
  1094 jump *label297 equal *tmp375 false
  1095 jump *label299 equal :processUnit.2:supply false
 
  1101 set .MSG ", waiting\n"
  1102 label *label300
  1103 sensor *tmp378 @unit @totalItems
-    * op lessThanEq *tmp379 *tmp378 0
-    * jump *label301 equal *tmp379 false
+ 1104 jump *label301 greaterThan *tmp378 0
  1105 ucontrol approach .CORE_X .CORE_Y 6
  1106 set :processUnit.2:state 2
  1107 jump *label302 always
 
  1133 print *tmp388
  1134 print "["
  1135 print "]"
-    * op greaterThanEq *tmp389 :processUnit.2:distance 0
-    * jump *label303 equal *tmp389 false
+ 1136 jump *label303 lessThan :processUnit.2:distance 0
  1137 print .MSG
  1138 print :processUnit.2:distance
  1139 print "["
 
  1155 set :processUnit.3:supply *tmp393
  1156 # "Function: inline def rebindUnit(in currentUnit)"
  1157 set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * op notEqual *tmp395 :rebindUnit.7:currentUnit null
-    * jump *label309 equal *tmp395 false
+ 1158 jump *label309 equal :rebindUnit.7:currentUnit null
  1159 ubind :rebindUnit.7:currentUnit
  1160 sensor *tmp397 @unit @dead
  1161 op equal *tmp398 *tmp397 0
 
  1172 label *label310
  1173 ubind .TYPE
  1174 set :rebindUnit.7:firstUnit @unit
-    * op notEqual *tmp403 :rebindUnit.7:firstUnit null
-    * jump *label313 equal *tmp403 false
+ 1175 jump *label313 equal :rebindUnit.7:firstUnit null
  1176 label *label315
  1177 sensor *tmp405 @unit @controlled
-    * op equal *tmp406 *tmp405 0
-    * jump *label318 equal *tmp406 false
+ 1178 jump *label318 notEqual *tmp405 0
  1179 jump *label308 always
  1180 jump *label319 always
  1181 label *label318
  1182 label *label319
  1183 ubind .TYPE
  1184 label *label316
-    * op notEqual *tmp408 @unit :rebindUnit.7:firstUnit
-    * jump *label317 equal *tmp408 false
+ 1185 jump *label317 equal @unit :rebindUnit.7:firstUnit
  1186 label *label320
  1187 sensor *tmp409 :rebindUnit.7:firstUnit @dead
-    * op equal *tmp410 *tmp409 0
-    * jump *label315 notEqual *tmp410 false
+ 1188 jump *label315 equal *tmp409 0
  1189 label *label317
  1190 jump *label314 always
  1191 label *label313
 
  1195 sensor :processUnit.3:state @unit @flag
  1196 set :processUnit.3:distance -1
  1197 set :processUnit.3:color "gold"
-    * op lessThan *tmp412 :processUnit.3:state 2
-    * jump *label323 notEqual *tmp412 false
+ 1198 jump *label323 lessThan :processUnit.3:state 2
  1199 label *label324
-    * op greaterThan *tmp413 :processUnit.3:state 3
-    * jump *label321 equal *tmp413 false
+ 1200 jump *label321 lessThanEq :processUnit.3:state 3
  1201 label *label323
  1202 sensor *tmp415 @unit @firstItem
-    * op equal *tmp416 *tmp415 :processUnit.3:item
-    * jump *label325 equal *tmp416 false
+ 1203 jump *label325 notEqual *tmp415 :processUnit.3:item
  1204 set :processUnit.3:state 3
  1205 jump *label326 always
  1206 label *label325
  1207 sensor *tmp418 @unit @totalItems
-    * op equal *tmp419 *tmp418 0
-    * jump *label327 equal *tmp419 false
+ 1208 jump *label327 notEqual *tmp418 0
  1209 set :processUnit.3:state 2
  1210 jump *label328 always
  1211 label *label327
 
  1222 jump *label322 always
  1223 label *label321
  1224 label *label322
-    * op equal *tmp423 :processUnit.3:state 2
-    * jump *label331 equal *tmp423 false
+ 1225 jump *label331 notEqual :processUnit.3:state 2
  1226 ucontrol within .CORE_X .CORE_Y 8 *tmp425
  1227 jump *label333 equal *tmp425 false
  1228 ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
  1229 sensor *tmp427 @unit @totalItems
-    * op greaterThanEq *tmp428 *tmp427 .UNIT_CAPACITY
-    * jump *label335 equal *tmp428 false
+ 1230 jump *label335 lessThan *tmp427 .UNIT_CAPACITY
  1231 ucontrol approach .DOME_X .DOME_Y 6
  1232 set :processUnit.3:state 3
  1233 jump *label336 always
 
  1249 jump *label332 always
  1250 label *label331
  1251 label *label332
-    * op equal *tmp437 :processUnit.3:state 3
-    * jump *label337 equal *tmp437 false
+ 1252 jump *label337 notEqual :processUnit.3:state 3
  1253 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1254 jump *label339 equal *tmp439 false
  1255 jump *label341 equal :processUnit.3:supply false
 
  1261 set .MSG ", waiting\n"
  1262 label *label342
  1263 sensor *tmp442 @unit @totalItems
-    * op lessThanEq *tmp443 *tmp442 0
-    * jump *label343 equal *tmp443 false
+ 1264 jump *label343 greaterThan *tmp442 0
  1265 ucontrol approach .CORE_X .CORE_Y 6
  1266 set :processUnit.3:state 2
  1267 jump *label344 always
 
  1293 print *tmp452
  1294 print "["
  1295 print "]"
-    * op greaterThanEq *tmp453 :processUnit.3:distance 0
-    * jump *label345 equal *tmp453 false
+ 1296 jump *label345 lessThan :processUnit.3:distance 0
  1297 print .MSG
  1298 print :processUnit.3:distance
  1299 print "["
 
  1326 print " "
  1327 print "ms"
  1328 printflush message1
-    * op notEqual *tmp463 .TYPE UNIT_TYPE
-    * jump *label349 equal *tmp463 false
+ 1329 jump *label349 equal .TYPE UNIT_TYPE
  1330 label *label352
-    * op greaterThan *tmp464 :unitCheck @time
-    * jump *label349 equal *tmp464 false
+ 1331 jump *label349 lessThanEq :unitCheck @time
  1332 jump *label351 always
  1333 label *label351
  1334 # "Function: inline def areUnitsAvailable(in type, in output)"
 
  1339 set :areUnitsAvailable.2:needed 0
  1340 ubind :areUnitsAvailable.2:type
  1341 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp467 :areUnitsAvailable.2:firstUnit null
-    * jump *label356 equal *tmp467 false
+ 1342 jump *label356 equal :areUnitsAvailable.2:firstUnit null
  1343 # "Function: inline def needsFourUnits(in unit)"
  1344 set :needsFourUnits.3:unit @unit
  1345 op sub *tmp470 .DOME_X .CORE_X
 
  1361 set :areUnitsAvailable.2:needed *tmp477
  1362 label *label361
  1363 sensor *tmp478 @unit @controlled
-    * op equal *tmp479 *tmp478 0
-    * jump *label366 notEqual *tmp479 false
+ 1364 jump *label366 equal *tmp478 0
  1365 label *label367
  1366 sensor *tmp480 @unit @controller
-    * op equal *tmp481 *tmp480 @this
-    * jump *label364 equal *tmp481 false
+ 1367 jump *label364 notEqual *tmp480 @this
  1368 label *label366
  1369 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * op greaterThanEq *tmp483 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
-    * jump *label368 equal *tmp483 false
+ 1370 jump *label368 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1371 set *tmp466 true
  1372 jump *label355 always
  1373 jump *label369 always
 
  1379 label *label365
  1380 ubind :areUnitsAvailable.2:type
  1381 label *label362
-    * op notEqual *tmp486 @unit :areUnitsAvailable.2:firstUnit
-    * jump *label363 equal *tmp486 false
+ 1382 jump *label363 equal @unit :areUnitsAvailable.2:firstUnit
  1383 label *label370
  1384 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
-    * op equal *tmp488 *tmp487 0
-    * jump *label361 notEqual *tmp488 false
+ 1385 jump *label361 equal *tmp487 0
  1386 label *label363
  1387 jump *label357 always
  1388 label *label356
 
  1395 print ","
  1396 print " free: "
  1397 print :areUnitsAvailable.2:free
-    * op greaterThan *tmp490 :areUnitsAvailable.2:needed 0
-    * jump *label373 equal *tmp490 false
+ 1398 jump *label373 lessThanEq :areUnitsAvailable.2:needed 0
  1399 print ", needed: "
  1400 print :areUnitsAvailable.2:needed
  1401 jump *label374 always
 
  1426 # "Function: noinline def locateCore(in type)"
  1427 ubind :locateCore:type
  1428 sensor *tmp494 @unit @controlled
-    * op equal *tmp495 *tmp494 0
-    * jump *label378 notEqual *tmp495 false
+ 1429 jump *label378 equal *tmp494 0
  1430 label *label379
  1431 sensor *tmp496 @unit @controller
-    * op equal *tmp497 *tmp496 @this
-    * jump *label376 equal *tmp497 false
+ 1432 jump *label376 notEqual *tmp496 @this
  1433 label *label378
  1434 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
  1435 jump *label377 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-83 instructions):
 
    34 call *label0 :locateCore*retaddr :locateCore*retval
    35 jump *label15 equal :locateCore*retval false
    36 jump *label1 always
-    * jump *label16 always
    37 label *label15
    38 label *label16
    39 label *label9
 
   101 jump *label39 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   102 set *tmp10 true
   103 jump *label26 always
-    * jump *label40 always
   104 label *label39
   105 label *label40
   106 jump *label36 always
 
   114 sensor *tmp31 :areUnitsAvailable:firstUnit @dead
   115 jump *label32 equal *tmp31 0
   116 label *label34
-    * jump *label28 always
   117 label *label27
   118 label *label28
   119 jump *label42 equal :areUnitsAvailable:output false
 
   127 jump *label44 lessThanEq :areUnitsAvailable:needed 0
   128 print ", needed: "
   129 print :areUnitsAvailable:needed
-    * jump *label45 always
   130 label *label44
   131 label *label45
   132 print "\n"
-    * jump *label43 always
   133 label *label42
   134 label *label43
   135 set *tmp10 false
 
   139 jump *label24 equal *tmp10 false
   140 set *tmp9 UNIT_TYPE
   141 jump *label20 always
-    * jump *label25 always
   142 label *label24
   143 label *label25
   144 set :chooseUnitType:type @flare
 
   196 jump *label70 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   197 set *tmp40 true
   198 jump *label57 always
-    * jump *label71 always
   199 label *label70
   200 label *label71
   201 jump *label67 always
 
   209 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
   210 jump *label63 equal *tmp61 0
   211 label *label65
-    * jump *label59 always
   212 label *label58
   213 label *label59
   214 jump *label73 equal :areUnitsAvailable.1:output false
 
   222 jump *label75 lessThanEq :areUnitsAvailable.1:needed 0
   223 print ", needed: "
   224 print :areUnitsAvailable.1:needed
-    * jump *label76 always
   225 label *label75
   226 label *label76
   227 print "\n"
-    * jump *label74 always
   228 label *label73
   229 label *label74
   230 set *tmp40 false
 
   235 printflush null
   236 set *tmp9 :chooseUnitType:type
   237 jump *label20 always
-    * jump *label56 always
   238 label *label55
   239 label *label56
-    * jump *label54 always
   240 label *label53
   241 label *label54
   242 label *label47
 
   262 set :rebindUnits:firstUnit @unit
   263 jump *label78 notEqual :rebindUnits:firstUnit null
   264 end
-    * jump *label79 always
   265 label *label78
   266 label *label79
   267 label *label80
 
   275 set .UNIT_P1 @unit
   276 jump *label85 equal .UNIT_S2 null
   277 jump *label82 always
-    * jump *label86 always
   278 label *label85
   279 label *label86
-    * jump *label84 always
   280 label *label83
   281 label *label84
   282 ubind .TYPE
 
   286 sensor *tmp78 :rebindUnits:firstUnit @dead
   287 jump *label80 equal *tmp78 0
   288 label *label82
-    * jump *label77 always
   289 label *label77
   290 # "Function: inline def acquireUnit(in currentUnit)"
   291 set :acquireUnit:currentUnit .UNIT_S1
 
   300 op land *tmp88 *tmp85 *tmp87
   301 jump *label92 equal *tmp88 false
   302 jump *label89 always
-    * jump *label93 always
   303 label *label92
   304 label *label93
-    * jump *label91 always
   305 label *label90
   306 label *label91
   307 ubind .TYPE
 
   311 sensor *tmp92 @unit @controlled
   312 jump *label99 notEqual *tmp92 0
   313 jump *label89 always
-    * jump *label100 always
   314 label *label99
   315 label *label100
   316 ubind .TYPE
 
   320 sensor *tmp96 :rebindUnit:firstUnit @dead
   321 jump *label96 equal *tmp96 0
   322 label *label98
-    * jump *label95 always
   323 label *label94
   324 label *label95
   325 end
 
   343 op land *tmp106 *tmp103 *tmp105
   344 jump *label106 equal *tmp106 false
   345 jump *label103 always
-    * jump *label107 always
   346 label *label106
   347 label *label107
-    * jump *label105 always
   348 label *label104
   349 label *label105
   350 ubind .TYPE
 
   354 sensor *tmp110 @unit @controlled
   355 jump *label113 notEqual *tmp110 0
   356 jump *label103 always
-    * jump *label114 always
   357 label *label113
   358 label *label114
   359 ubind .TYPE
 
   363 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   364 jump *label110 equal *tmp114 0
   365 label *label112
-    * jump *label109 always
   366 label *label108
   367 label *label109
   368 end
 
   388 label *label120
   389 set .UNIT_S1 :swap:a
   390 set .UNIT_P1 :swap:b
-    * jump *label117 always
   391 label *label116
   392 label *label117
   393 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   396 op strictEqual *tmp124 .SPEED null
   397 jump *label121 equal *tmp124 false
   398 stop
-    * jump *label122 always
   399 label *label121
   400 label *label122
   401 # "Function: inline def needsFourUnits(in unit)"
 
   425 op land *tmp143 *tmp140 *tmp142
   426 jump *label130 equal *tmp143 false
   427 jump *label127 always
-    * jump *label131 always
   428 label *label130
   429 label *label131
-    * jump *label129 always
   430 label *label128
   431 label *label129
   432 ubind .TYPE
 
   436 sensor *tmp147 @unit @controlled
   437 jump *label137 notEqual *tmp147 0
   438 jump *label127 always
-    * jump *label138 always
   439 label *label137
   440 label *label138
   441 ubind .TYPE
 
   445 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   446 jump *label134 equal *tmp151 0
   447 label *label136
-    * jump *label133 always
   448 label *label132
   449 label *label133
   450 end
 
   468 op land *tmp161 *tmp158 *tmp160
   469 jump *label144 equal *tmp161 false
   470 jump *label141 always
-    * jump *label145 always
   471 label *label144
   472 label *label145
-    * jump *label143 always
   473 label *label142
   474 label *label143
   475 ubind .TYPE
 
   479 sensor *tmp165 @unit @controlled
   480 jump *label151 notEqual *tmp165 0
   481 jump *label141 always
-    * jump *label152 always
   482 label *label151
   483 label *label152
   484 ubind .TYPE
 
   488 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   489 jump *label148 equal *tmp169 0
   490 label *label150
-    * jump *label147 always
   491 label *label146
   492 label *label147
   493 end
 
   503 label *label157
   504 sensor *tmp173 .UNIT_P2 @firstItem
   505 jump *label154 equal *tmp173 @phase-fabric
-    * jump *label156 always
   506 label *label156
   507 # "Function: inline void swap(in out a, in out b)"
   508 set :swap.1:a .UNIT_S1
 
   513 label *label158
   514 set .UNIT_S1 :swap.1:a
   515 set .UNIT_P2 :swap.1:b
-    * jump *label155 always
   516 label *label154
   517 label *label155
   518 sensor *tmp176 .UNIT_S2 @firstItem
 
   530 label *label163
   531 set .UNIT_S2 :swap.2:a
   532 set .UNIT_P2 :swap.2:b
-    * jump *label160 always
   533 label *label159
   534 label *label160
   535 set .GROUP1 "unit  1"
 
   617 op land *tmp203 *tmp200 *tmp202
   618 jump *label182 equal *tmp203 false
   619 jump *label179 always
-    * jump *label183 always
   620 label *label182
   621 label *label183
-    * jump *label181 always
   622 label *label180
   623 label *label181
   624 ubind .TYPE
 
   628 sensor *tmp207 @unit @controlled
   629 jump *label189 notEqual *tmp207 0
   630 jump *label179 always
-    * jump *label190 always
   631 label *label189
   632 label *label190
   633 ubind .TYPE
 
   637 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   638 jump *label186 equal *tmp211 0
   639 label *label188
-    * jump *label185 always
   640 label *label184
   641 label *label185
   642 end
 
   663 ucontrol within .CORE_X .CORE_Y 8 *tmp223
   664 jump *label200 equal *tmp223 false
   665 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label201 always
   666 label *label200
   667 label *label201
   668 label *label199
   669 label *label197
-    * jump *label193 always
   670 label *label192
   671 label *label193
   672 jump *label202 notEqual :processUnit:state 2
 
   693 op idiv *tmp237 *tmp236 .SPEED_TENTHS
   694 op div :processUnit:distance *tmp237 10
   695 label *label205
-    * jump *label203 always
   696 label *label202
   697 label *label203
   698 jump *label208 notEqual :processUnit:state 3
 
   710 jump *label214 greaterThan *tmp244 0
   711 ucontrol approach .CORE_X .CORE_Y 6
   712 set :processUnit:state 2
-    * jump *label215 always
   713 label *label214
   714 label *label215
   715 jump *label211 always
 
   724 op idiv *tmp252 *tmp251 .SPEED_TENTHS
   725 op div :processUnit:distance *tmp252 10
   726 label *label211
-    * jump *label209 always
   727 label *label208
   728 label *label209
   729 ucontrol flag :processUnit:state
 
   768 op land *tmp267 *tmp264 *tmp266
   769 jump *label224 equal *tmp267 false
   770 jump *label221 always
-    * jump *label225 always
   771 label *label224
   772 label *label225
-    * jump *label223 always
   773 label *label222
   774 label *label223
   775 ubind .TYPE
 
   779 sensor *tmp271 @unit @controlled
   780 jump *label231 notEqual *tmp271 0
   781 jump *label221 always
-    * jump *label232 always
   782 label *label231
   783 label *label232
   784 ubind .TYPE
 
   788 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   789 jump *label228 equal *tmp275 0
   790 label *label230
-    * jump *label227 always
   791 label *label226
   792 label *label227
   793 end
 
   814 ucontrol within .CORE_X .CORE_Y 8 *tmp287
   815 jump *label242 equal *tmp287 false
   816 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label243 always
   817 label *label242
   818 label *label243
   819 label *label241
   820 label *label239
-    * jump *label235 always
   821 label *label234
   822 label *label235
   823 jump *label244 notEqual :processUnit.1:state 2
 
   844 op idiv *tmp301 *tmp300 .SPEED_TENTHS
   845 op div :processUnit.1:distance *tmp301 10
   846 label *label247
-    * jump *label245 always
   847 label *label244
   848 label *label245
   849 jump *label250 notEqual :processUnit.1:state 3
 
   861 jump *label256 greaterThan *tmp308 0
   862 ucontrol approach .CORE_X .CORE_Y 6
   863 set :processUnit.1:state 2
-    * jump *label257 always
   864 label *label256
   865 label *label257
   866 jump *label253 always
 
   875 op idiv *tmp316 *tmp315 .SPEED_TENTHS
   876 op div :processUnit.1:distance *tmp316 10
   877 label *label253
-    * jump *label251 always
   878 label *label250
   879 label *label251
   880 ucontrol flag :processUnit.1:state
 
   910 op equal *tmp322 *tmp325 0
   911 label *label261
   912 set .SUPPLY_S_FIRST *tmp322
-    * jump *label219 always
   913 label *label218
   914 label *label219
   915 # "Function: inline void printDomeStatus(in item, in text)"
 
   948 op land *tmp337 *tmp334 *tmp336
   949 jump *label269 equal *tmp337 false
   950 jump *label266 always
-    * jump *label270 always
   951 label *label269
   952 label *label270
-    * jump *label268 always
   953 label *label267
   954 label *label268
   955 ubind .TYPE
 
   959 sensor *tmp341 @unit @controlled
   960 jump *label276 notEqual *tmp341 0
   961 jump *label266 always
-    * jump *label277 always
   962 label *label276
   963 label *label277
   964 ubind .TYPE
 
   968 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   969 jump *label273 equal *tmp345 0
   970 label *label275
-    * jump *label272 always
   971 label *label271
   972 label *label272
   973 end
 
   994 ucontrol within .CORE_X .CORE_Y 8 *tmp357
   995 jump *label287 equal *tmp357 false
   996 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label288 always
   997 label *label287
   998 label *label288
   999 label *label286
  1000 label *label284
-    * jump *label280 always
  1001 label *label279
  1002 label *label280
  1003 jump *label289 notEqual :processUnit.2:state 2
 
  1024 op idiv *tmp371 *tmp370 .SPEED_TENTHS
  1025 op div :processUnit.2:distance *tmp371 10
  1026 label *label292
-    * jump *label290 always
  1027 label *label289
  1028 label *label290
  1029 jump *label295 notEqual :processUnit.2:state 3
 
  1041 jump *label301 greaterThan *tmp378 0
  1042 ucontrol approach .CORE_X .CORE_Y 6
  1043 set :processUnit.2:state 2
-    * jump *label302 always
  1044 label *label301
  1045 label *label302
  1046 jump *label298 always
 
  1055 op idiv *tmp386 *tmp385 .SPEED_TENTHS
  1056 op div :processUnit.2:distance *tmp386 10
  1057 label *label298
-    * jump *label296 always
  1058 label *label295
  1059 label *label296
  1060 ucontrol flag :processUnit.2:state
 
  1099 op land *tmp401 *tmp398 *tmp400
  1100 jump *label311 equal *tmp401 false
  1101 jump *label308 always
-    * jump *label312 always
  1102 label *label311
  1103 label *label312
-    * jump *label310 always
  1104 label *label309
  1105 label *label310
  1106 ubind .TYPE
 
  1110 sensor *tmp405 @unit @controlled
  1111 jump *label318 notEqual *tmp405 0
  1112 jump *label308 always
-    * jump *label319 always
  1113 label *label318
  1114 label *label319
  1115 ubind .TYPE
 
  1119 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1120 jump *label315 equal *tmp409 0
  1121 label *label317
-    * jump *label314 always
  1122 label *label313
  1123 label *label314
  1124 end
 
  1145 ucontrol within .CORE_X .CORE_Y 8 *tmp421
  1146 jump *label329 equal *tmp421 false
  1147 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label330 always
  1148 label *label329
  1149 label *label330
  1150 label *label328
  1151 label *label326
-    * jump *label322 always
  1152 label *label321
  1153 label *label322
  1154 jump *label331 notEqual :processUnit.3:state 2
 
  1175 op idiv *tmp435 *tmp434 .SPEED_TENTHS
  1176 op div :processUnit.3:distance *tmp435 10
  1177 label *label334
-    * jump *label332 always
  1178 label *label331
  1179 label *label332
  1180 jump *label337 notEqual :processUnit.3:state 3
 
  1192 jump *label343 greaterThan *tmp442 0
  1193 ucontrol approach .CORE_X .CORE_Y 6
  1194 set :processUnit.3:state 2
-    * jump *label344 always
  1195 label *label343
  1196 label *label344
  1197 jump *label340 always
 
  1206 op idiv *tmp450 *tmp449 .SPEED_TENTHS
  1207 op div :processUnit.3:distance *tmp450 10
  1208 label *label340
-    * jump *label338 always
  1209 label *label337
  1210 label *label338
  1211 ucontrol flag :processUnit.3:state
 
  1241 op equal *tmp456 *tmp459 0
  1242 label *label348
  1243 set .SUPPLY_P_FIRST *tmp456
-    * jump *label306 always
  1244 label *label305
  1245 label *label306
  1246 op sub *tmp461 @time :start
 
  1254 jump *label349 equal .TYPE UNIT_TYPE
  1255 label *label352
  1256 jump *label349 lessThanEq :unitCheck @time
-    * jump *label351 always
  1257 label *label351
  1258 # "Function: inline def areUnitsAvailable(in type, in output)"
  1259 set :areUnitsAvailable.2:type UNIT_TYPE
 
  1294 jump *label368 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1295 set *tmp466 true
  1296 jump *label355 always
-    * jump *label369 always
  1297 label *label368
  1298 label *label369
  1299 jump *label365 always
 
  1307 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1308 jump *label361 equal *tmp487 0
  1309 label *label363
-    * jump *label357 always
  1310 label *label356
  1311 label *label357
  1312 jump *label371 equal :areUnitsAvailable.2:output false
 
  1320 jump *label373 lessThanEq :areUnitsAvailable.2:needed 0
  1321 print ", needed: "
  1322 print :areUnitsAvailable.2:needed
-    * jump *label374 always
  1323 label *label373
  1324 label *label374
  1325 print "\n"
-    * jump *label372 always
  1326 label *label371
  1327 label *label372
  1328 set *tmp466 false
 
  1331 label *label355
  1332 jump *label353 equal *tmp466 false
  1333 end
-    * jump *label354 always
  1334 label *label353
  1335 label *label354
  1336 op add :unitCheck @time 5000
-    * jump *label350 always
  1337 label *label349
  1338 label *label350
  1339 label *label173
 
  1350 jump *label376 notEqual *tmp496 @this
  1351 label *label378
  1352 ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
-    * jump *label377 always
  1353 label *label376
  1354 label *label377
  1355 set :locateCore*retval .CORE

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-11 instructions):
 
    68 set :areUnitsAvailable:free 0
    69 set :areUnitsAvailable:occupied 0
    70 set :areUnitsAvailable:needed 0
-    * ubind :areUnitsAvailable:type
+   71 ubind UNIT_TYPE
    72 set :areUnitsAvailable:firstUnit @unit
    73 jump *label27 equal :areUnitsAvailable:firstUnit null
    74 # "Function: inline def needsFourUnits(in unit)"
 
    81 op div :needsFourUnits:travel_time *tmp17 *tmp18
    82 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    83 jump *label31 always
-    * set *tmp13 null
    84 label *label31
    85 jump *label29 equal *tmp13 false
    86 set *tmp21 4
 
    97 jump *label35 notEqual *tmp24 @this
    98 label *label37
    99 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label39 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
+  100 jump *label39 lessThan :areUnitsAvailable:free *tmp21
   101 set *tmp10 true
   102 jump *label26 always
   103 label *label39
 
   106 label *label35
   107 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   108 label *label36
-    * ubind :areUnitsAvailable:type
+  109 ubind UNIT_TYPE
   110 label *label33
   111 jump *label34 equal @unit :areUnitsAvailable:firstUnit
   112 label *label41
 
   115 label *label34
   116 label *label27
   117 label *label28
-    * jump *label42 equal :areUnitsAvailable:output false
-    * print :areUnitsAvailable:type
+  118 jump *label42 equal true false
+  119 print UNIT_TYPE
   120 print ":"
   121 print " occupied: "
   122 print :areUnitsAvailable:occupied
 
   133 label *label43
   134 set *tmp10 false
   135 jump *label26 always
-    * set *tmp10 null
   136 label *label26
   137 jump *label24 equal *tmp10 false
   138 set *tmp9 UNIT_TYPE
 
   161 set :areUnitsAvailable.1:free 0
   162 set :areUnitsAvailable.1:occupied 0
   163 set :areUnitsAvailable.1:needed 0
-    * ubind :areUnitsAvailable.1:type
+  164 ubind :chooseUnitType:type
   165 set :areUnitsAvailable.1:firstUnit @unit
   166 jump *label58 equal :areUnitsAvailable.1:firstUnit null
   167 # "Function: inline def needsFourUnits(in unit)"
 
   174 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   175 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   176 jump *label62 always
-    * set *tmp43 null
   177 label *label62
   178 jump *label60 equal *tmp43 false
   179 set *tmp51 4
 
   190 jump *label66 notEqual *tmp54 @this
   191 label *label68
   192 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label70 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  193 jump *label70 lessThan :areUnitsAvailable.1:free *tmp51
   194 set *tmp40 true
   195 jump *label57 always
   196 label *label70
 
   199 label *label66
   200 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   201 label *label67
-    * ubind :areUnitsAvailable.1:type
+  202 ubind :chooseUnitType:type
   203 label *label64
   204 jump *label65 equal @unit :areUnitsAvailable.1:firstUnit
   205 label *label72
 
   208 label *label65
   209 label *label58
   210 label *label59
-    * jump *label73 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  211 jump *label73 equal true false
+  212 print :chooseUnitType:type
   213 print ":"
   214 print " occupied: "
   215 print :areUnitsAvailable.1:occupied
 
   226 label *label74
   227 set *tmp40 false
   228 jump *label57 always
-    * set *tmp40 null
   229 label *label57
   230 jump *label55 equal *tmp40 false
   231 printflush null
 
   250 printflush message1
   251 # "Function: inline def rebindUnits()"
   252 set .UNIT_P2 null
-    * set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P1 .UNIT_S2
-    * set .UNIT_S1 .UNIT_P1
+  253 set .UNIT_S2 null
+  254 set .UNIT_P1 .UNIT_P2
+  255 set .UNIT_S1 .UNIT_S2
   256 set :rebindUnits:count 0
-    * ubind .TYPE
+  257 ubind *tmp9
   258 set :rebindUnits:firstUnit @unit
   259 jump *label78 notEqual :rebindUnits:firstUnit null
   260 end
 
   275 label *label86
   276 label *label83
   277 label *label84
-    * ubind .TYPE
+  278 ubind *tmp9
   279 label *label81
   280 jump *label82 equal @unit :rebindUnits:firstUnit
   281 label *label87
 
   286 # "Function: inline def acquireUnit(in currentUnit)"
   287 set :acquireUnit:currentUnit .UNIT_S1
   288 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * jump *label90 equal :rebindUnit:currentUnit null
-    * ubind :rebindUnit:currentUnit
+  289 set :rebindUnit:currentUnit .UNIT_S1
+  290 jump *label90 equal :acquireUnit:currentUnit null
+  291 ubind :acquireUnit:currentUnit
   292 sensor *tmp84 @unit @dead
   293 op equal *tmp85 *tmp84 0
   294 sensor *tmp86 @unit @controller
 
   300 label *label93
   301 label *label90
   302 label *label91
-    * ubind .TYPE
+  303 ubind *tmp9
   304 set :rebindUnit:firstUnit @unit
   305 jump *label94 equal :rebindUnit:firstUnit null
   306 label *label96
 
   309 jump *label89 always
   310 label *label99
   311 label *label100
-    * ubind .TYPE
+  312 ubind *tmp9
   313 label *label97
   314 jump *label98 equal @unit :rebindUnit:firstUnit
   315 label *label101
 
   323 ucontrol flag 1
   324 set *tmp80 @unit
   325 jump *label88 always
-    * set *tmp80 null
   326 label *label88
   327 set .UNIT_S1 *tmp80
   328 # "Function: inline def acquireUnit(in currentUnit)"
   329 set :acquireUnit.1:currentUnit .UNIT_P1
   330 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * jump *label104 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  331 set :rebindUnit.1:currentUnit .UNIT_P1
+  332 jump *label104 equal :acquireUnit.1:currentUnit null
+  333 ubind :acquireUnit.1:currentUnit
   334 sensor *tmp102 @unit @dead
   335 op equal *tmp103 *tmp102 0
   336 sensor *tmp104 @unit @controller
 
   342 label *label107
   343 label *label104
   344 label *label105
-    * ubind .TYPE
+  345 ubind *tmp9
   346 set :rebindUnit.1:firstUnit @unit
   347 jump *label108 equal :rebindUnit.1:firstUnit null
   348 label *label110
 
   351 jump *label103 always
   352 label *label113
   353 label *label114
-    * ubind .TYPE
+  354 ubind *tmp9
   355 label *label111
   356 jump *label112 equal @unit :rebindUnit.1:firstUnit
   357 label *label115
 
   365 ucontrol flag 1
   366 set *tmp98 @unit
   367 jump *label102 always
-    * set *tmp98 null
   368 label *label102
   369 set .UNIT_P1 *tmp98
-    * sensor *tmp116 .UNIT_S1 @firstItem
+  370 sensor *tmp116 *tmp80 @firstItem
   371 jump *label118 equal *tmp116 @phase-fabric
   372 label *label119
-    * sensor *tmp118 .UNIT_P1 @firstItem
+  373 sensor *tmp118 *tmp98 @firstItem
   374 jump *label116 notEqual *tmp118 @silicon
   375 label *label118
   376 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:a .UNIT_S1
-    * set :swap:b .UNIT_P1
-    * set :swap:t :swap:a
-    * set :swap:a :swap:b
+  377 set :swap:a *tmp80
+  378 set :swap:b *tmp98
+  379 set :swap:t .UNIT_S1
+  380 set :swap:a .UNIT_P1
   381 set :swap:b :swap:t
   382 label *label120
   383 set .UNIT_S1 :swap:a
-    * set .UNIT_P1 :swap:b
+  384 set .UNIT_P1 :swap:t
   385 label *label116
   386 label *label117
   387 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   398 op sub *tmp128 .DOME_Y .CORE_Y
   399 op len *tmp129 *tmp127 *tmp128
   400 op mul *tmp130 2 *tmp129
-    * sensor *tmp131 :needsFourUnits.2:unit @speed
-    * op div :needsFourUnits.2:travel_time *tmp130 *tmp131
+  401 sensor *tmp131 .UNIT_S1 @speed
+  402 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   403 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   404 jump *label123 always
-    * set *tmp126 null
   405 label *label123
   406 set .FOUR_UNITS *tmp126
-    * jump *label124 equal .FOUR_UNITS false
+  407 jump *label124 equal *tmp126 false
   408 # "Function: inline def acquireUnit(in currentUnit)"
   409 set :acquireUnit.2:currentUnit .UNIT_S2
   410 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * jump *label128 equal :rebindUnit.2:currentUnit null
-    * ubind :rebindUnit.2:currentUnit
+  411 set :rebindUnit.2:currentUnit .UNIT_S2
+  412 jump *label128 equal :acquireUnit.2:currentUnit null
+  413 ubind :acquireUnit.2:currentUnit
   414 sensor *tmp139 @unit @dead
   415 op equal *tmp140 *tmp139 0
   416 sensor *tmp141 @unit @controller
 
   422 label *label131
   423 label *label128
   424 label *label129
-    * ubind .TYPE
+  425 ubind *tmp9
   426 set :rebindUnit.2:firstUnit @unit
   427 jump *label132 equal :rebindUnit.2:firstUnit null
   428 label *label134
 
   431 jump *label127 always
   432 label *label137
   433 label *label138
-    * ubind .TYPE
+  434 ubind *tmp9
   435 label *label135
   436 jump *label136 equal @unit :rebindUnit.2:firstUnit
   437 label *label139
 
   445 ucontrol flag 1
   446 set *tmp135 @unit
   447 jump *label126 always
-    * set *tmp135 null
   448 label *label126
   449 set .UNIT_S2 *tmp135
   450 # "Function: inline def acquireUnit(in currentUnit)"
   451 set :acquireUnit.3:currentUnit .UNIT_P2
   452 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * jump *label142 equal :rebindUnit.3:currentUnit null
-    * ubind :rebindUnit.3:currentUnit
+  453 set :rebindUnit.3:currentUnit .UNIT_P2
+  454 jump *label142 equal :acquireUnit.3:currentUnit null
+  455 ubind :acquireUnit.3:currentUnit
   456 sensor *tmp157 @unit @dead
   457 op equal *tmp158 *tmp157 0
   458 sensor *tmp159 @unit @controller
 
   464 label *label145
   465 label *label142
   466 label *label143
-    * ubind .TYPE
+  467 ubind *tmp9
   468 set :rebindUnit.3:firstUnit @unit
   469 jump *label146 equal :rebindUnit.3:firstUnit null
   470 label *label148
 
   473 jump *label141 always
   474 label *label151
   475 label *label152
-    * ubind .TYPE
+  476 ubind *tmp9
   477 label *label149
   478 jump *label150 equal @unit :rebindUnit.3:firstUnit
   479 label *label153
 
   487 ucontrol flag 1
   488 set *tmp153 @unit
   489 jump *label140 always
-    * set *tmp153 null
   490 label *label140
   491 set .UNIT_P2 *tmp153
   492 sensor *tmp171 .UNIT_S1 @firstItem
   493 jump *label154 notEqual *tmp171 @phase-fabric
   494 label *label157
-    * sensor *tmp173 .UNIT_P2 @firstItem
+  495 sensor *tmp173 *tmp153 @firstItem
   496 jump *label154 equal *tmp173 @phase-fabric
   497 label *label156
   498 # "Function: inline void swap(in out a, in out b)"
   499 set :swap.1:a .UNIT_S1
-    * set :swap.1:b .UNIT_P2
-    * set :swap.1:t :swap.1:a
-    * set :swap.1:a :swap.1:b
+  500 set :swap.1:b *tmp153
+  501 set :swap.1:t .UNIT_S1
+  502 set :swap.1:a .UNIT_P2
   503 set :swap.1:b :swap.1:t
   504 label *label158
   505 set .UNIT_S1 :swap.1:a
-    * set .UNIT_P2 :swap.1:b
+  506 set .UNIT_P2 :swap.1:t
   507 label *label154
   508 label *label155
-    * sensor *tmp176 .UNIT_S2 @firstItem
+  509 sensor *tmp176 *tmp135 @firstItem
   510 jump *label161 equal *tmp176 @phase-fabric
   511 label *label162
   512 sensor *tmp178 .UNIT_P2 @firstItem
   513 jump *label159 notEqual *tmp178 @silicon
   514 label *label161
   515 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:a .UNIT_S2
+  516 set :swap.2:a *tmp135
   517 set :swap.2:b .UNIT_P2
-    * set :swap.2:t :swap.2:a
-    * set :swap.2:a :swap.2:b
+  518 set :swap.2:t .UNIT_S2
+  519 set :swap.2:a .UNIT_P2
   520 set :swap.2:b :swap.2:t
   521 label *label163
   522 set .UNIT_S2 :swap.2:a
-    * set .UNIT_P2 :swap.2:b
+  523 set .UNIT_P2 :swap.2:t
   524 label *label159
   525 label *label160
   526 set .GROUP1 "unit  1"
 
   535 set .UNIT_P2 null
   536 set .GROUP1 "unit"
   537 label *label125
-    * jump *label166 equal .FOUR_UNITS false
+  538 jump *label166 equal *tmp126 false
   539 label *label167
   540 sensor *tmp182 .UNIT_S1 @totalItems
   541 sensor *tmp183 .UNIT_S2 @totalItems
 
   547 set *tmp185 false
   548 label *label165
   549 set .SUPPLY_S_FIRST *tmp185
-    * jump *label170 equal .FOUR_UNITS false
+  550 jump *label170 equal *tmp126 false
   551 label *label171
   552 sensor *tmp187 .UNIT_P1 @totalItems
   553 sensor *tmp188 .UNIT_P2 @totalItems
 
   568 print "\n"
   569 print "\n"
   570 print "Unit type: [green]"
-    * print .TYPE
+  571 print *tmp9
   572 print "["
   573 print "]"
   574 print "\n"
   575 # "Function: inline void printDomeStatus(in item, in text)"
   576 set :printDomeStatus:item @silicon
   577 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
-    * print :printDomeStatus:text
-    * sensor :printDomeStatus:level .DOME :printDomeStatus:item
+  578 print "\n[green]Silicon[] status:\n"
+  579 sensor :printDomeStatus:level .DOME @silicon
   580 jump *label176 lessThanEq :printDomeStatus:level 3
   581 print "  dome:  [green]"
   582 print :printDomeStatus:level
 
   598 set :processUnit:group .GROUP1
   599 set :processUnit:supply .SUPPLY_S_FIRST
   600 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit :processUnit:unit
-    * jump *label180 equal :rebindUnit.4:currentUnit null
-    * ubind :rebindUnit.4:currentUnit
+  601 set :rebindUnit.4:currentUnit .UNIT_S1
+  602 jump *label180 equal :processUnit:unit null
+  603 ubind :processUnit:unit
   604 sensor *tmp199 @unit @dead
   605 op equal *tmp200 *tmp199 0
   606 sensor *tmp201 @unit @controller
 
   612 label *label183
   613 label *label180
   614 label *label181
-    * ubind .TYPE
+  615 ubind *tmp9
   616 set :rebindUnit.4:firstUnit @unit
   617 jump *label184 equal :rebindUnit.4:firstUnit null
   618 label *label186
 
   621 jump *label179 always
   622 label *label189
   623 label *label190
-    * ubind .TYPE
+  624 ubind *tmp9
   625 label *label187
   626 jump *label188 equal @unit :rebindUnit.4:firstUnit
   627 label *label191
 
   640 jump *label192 lessThanEq :processUnit:state 3
   641 label *label194
   642 sensor *tmp217 @unit @firstItem
-    * jump *label196 notEqual *tmp217 :processUnit:item
+  643 jump *label196 notEqual *tmp217 @silicon
   644 set :processUnit:state 3
   645 jump *label197 always
   646 label *label196
 
   663 jump *label202 notEqual :processUnit:state 2
   664 ucontrol within .CORE_X .CORE_Y 8 *tmp227
   665 jump *label204 equal *tmp227 false
-    * ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
+  666 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   667 sensor *tmp229 @unit @totalItems
   668 jump *label206 lessThan *tmp229 .UNIT_CAPACITY
   669 ucontrol approach .DOME_X .DOME_Y 6
 
   689 jump *label208 notEqual :processUnit:state 3
   690 ucontrol within .DOME_X .DOME_Y 8 *tmp241
   691 jump *label210 equal *tmp241 false
-    * jump *label212 equal :processUnit:supply false
+  692 jump *label212 equal .SUPPLY_S_FIRST false
   693 ucontrol itemDrop .DOME .UNIT_CAPACITY
   694 set .MSG ", supplying\n"
   695 jump *label213 always
 
   720 ucontrol flag :processUnit:state
   721 sensor *tmp254 @unit @totalItems
   722 print "  "
-    * print :processUnit:group
+  723 print .GROUP1
   724 print ":"
   725 print " ["
-    * print :processUnit:color
+  726 print "gold"
   727 print "]"
   728 print *tmp254
   729 print "["
 
   741 set :processUnit:unit @unit
   742 label *label178
   743 set .UNIT_S1 :processUnit:unit
-    * jump *label218 equal .FOUR_UNITS false
+  744 jump *label218 equal *tmp126 false
   745 op equal *tmp259 .SUPPLY_S_FIRST false
   746 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   747 set :processUnit.1:unit .UNIT_S2
 
   749 set :processUnit.1:group .GROUP2
   750 set :processUnit.1:supply *tmp259
   751 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * jump *label222 equal :rebindUnit.5:currentUnit null
-    * ubind :rebindUnit.5:currentUnit
+  752 set :rebindUnit.5:currentUnit .UNIT_S2
+  753 jump *label222 equal :processUnit.1:unit null
+  754 ubind :processUnit.1:unit
   755 sensor *tmp263 @unit @dead
   756 op equal *tmp264 *tmp263 0
   757 sensor *tmp265 @unit @controller
 
   763 label *label225
   764 label *label222
   765 label *label223
-    * ubind .TYPE
+  766 ubind *tmp9
   767 set :rebindUnit.5:firstUnit @unit
   768 jump *label226 equal :rebindUnit.5:firstUnit null
   769 label *label228
 
   772 jump *label221 always
   773 label *label231
   774 label *label232
-    * ubind .TYPE
+  775 ubind *tmp9
   776 label *label229
   777 jump *label230 equal @unit :rebindUnit.5:firstUnit
   778 label *label233
 
   791 jump *label234 lessThanEq :processUnit.1:state 3
   792 label *label236
   793 sensor *tmp281 @unit @firstItem
-    * jump *label238 notEqual *tmp281 :processUnit.1:item
+  794 jump *label238 notEqual *tmp281 @silicon
   795 set :processUnit.1:state 3
   796 jump *label239 always
   797 label *label238
 
   814 jump *label244 notEqual :processUnit.1:state 2
   815 ucontrol within .CORE_X .CORE_Y 8 *tmp291
   816 jump *label246 equal *tmp291 false
-    * ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
+  817 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   818 sensor *tmp293 @unit @totalItems
   819 jump *label248 lessThan *tmp293 .UNIT_CAPACITY
   820 ucontrol approach .DOME_X .DOME_Y 6
 
   840 jump *label250 notEqual :processUnit.1:state 3
   841 ucontrol within .DOME_X .DOME_Y 8 *tmp305
   842 jump *label252 equal *tmp305 false
-    * jump *label254 equal :processUnit.1:supply false
+  843 jump *label254 equal *tmp259 false
   844 ucontrol itemDrop .DOME .UNIT_CAPACITY
   845 set .MSG ", supplying\n"
   846 jump *label255 always
 
   871 ucontrol flag :processUnit.1:state
   872 sensor *tmp318 @unit @totalItems
   873 print "  "
-    * print :processUnit.1:group
+  874 print .GROUP2
   875 print ":"
   876 print " ["
-    * print :processUnit.1:color
+  877 print "gold"
   878 print "]"
   879 print *tmp318
   880 print "["
 
   893 label *label220
   894 set .UNIT_S2 :processUnit.1:unit
   895 jump *label260 equal .SUPPLY_S_FIRST false
-    * sensor *tmp323 .UNIT_S1 @totalItems
+  896 sensor *tmp323 :processUnit:unit @totalItems
   897 op greaterThan *tmp322 *tmp323 0
   898 jump *label261 always
   899 label *label260
-    * sensor *tmp325 .UNIT_S2 @totalItems
+  900 sensor *tmp325 :processUnit.1:unit @totalItems
   901 op equal *tmp322 *tmp325 0
   902 label *label261
   903 set .SUPPLY_S_FIRST *tmp322
 
   906 # "Function: inline void printDomeStatus(in item, in text)"
   907 set :printDomeStatus.1:item @phase-fabric
   908 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
-    * print :printDomeStatus.1:text
-    * sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
+  909 print "\n[green]Phase fabric[] status:\n"
+  910 sensor :printDomeStatus.1:level .DOME @phase-fabric
   911 jump *label263 lessThanEq :printDomeStatus.1:level 3
   912 print "  dome:  [green]"
   913 print :printDomeStatus.1:level
 
   929 set :processUnit.2:group .GROUP1
   930 set :processUnit.2:supply .SUPPLY_P_FIRST
   931 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * jump *label267 equal :rebindUnit.6:currentUnit null
-    * ubind :rebindUnit.6:currentUnit
+  932 set :rebindUnit.6:currentUnit .UNIT_P1
+  933 jump *label267 equal :processUnit.2:unit null
+  934 ubind :processUnit.2:unit
   935 sensor *tmp333 @unit @dead
   936 op equal *tmp334 *tmp333 0
   937 sensor *tmp335 @unit @controller
 
   943 label *label270
   944 label *label267
   945 label *label268
-    * ubind .TYPE
+  946 ubind *tmp9
   947 set :rebindUnit.6:firstUnit @unit
   948 jump *label271 equal :rebindUnit.6:firstUnit null
   949 label *label273
 
   952 jump *label266 always
   953 label *label276
   954 label *label277
-    * ubind .TYPE
+  955 ubind *tmp9
   956 label *label274
   957 jump *label275 equal @unit :rebindUnit.6:firstUnit
   958 label *label278
 
   971 jump *label279 lessThanEq :processUnit.2:state 3
   972 label *label281
   973 sensor *tmp351 @unit @firstItem
-    * jump *label283 notEqual *tmp351 :processUnit.2:item
+  974 jump *label283 notEqual *tmp351 @phase-fabric
   975 set :processUnit.2:state 3
   976 jump *label284 always
   977 label *label283
 
   994 jump *label289 notEqual :processUnit.2:state 2
   995 ucontrol within .CORE_X .CORE_Y 8 *tmp361
   996 jump *label291 equal *tmp361 false
-    * ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
+  997 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
   998 sensor *tmp363 @unit @totalItems
   999 jump *label293 lessThan *tmp363 .UNIT_CAPACITY
  1000 ucontrol approach .DOME_X .DOME_Y 6
 
  1020 jump *label295 notEqual :processUnit.2:state 3
  1021 ucontrol within .DOME_X .DOME_Y 8 *tmp375
  1022 jump *label297 equal *tmp375 false
-    * jump *label299 equal :processUnit.2:supply false
+ 1023 jump *label299 equal .SUPPLY_P_FIRST false
  1024 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1025 set .MSG ", supplying\n"
  1026 jump *label300 always
 
  1051 ucontrol flag :processUnit.2:state
  1052 sensor *tmp388 @unit @totalItems
  1053 print "  "
-    * print :processUnit.2:group
+ 1054 print .GROUP1
  1055 print ":"
  1056 print " ["
-    * print :processUnit.2:color
+ 1057 print "gold"
  1058 print "]"
  1059 print *tmp388
  1060 print "["
 
  1072 set :processUnit.2:unit @unit
  1073 label *label265
  1074 set .UNIT_P1 :processUnit.2:unit
-    * jump *label305 equal .FOUR_UNITS false
+ 1075 jump *label305 equal *tmp126 false
  1076 op equal *tmp393 .SUPPLY_P_FIRST false
  1077 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
  1078 set :processUnit.3:unit .UNIT_P2
 
  1080 set :processUnit.3:group .GROUP2
  1081 set :processUnit.3:supply *tmp393
  1082 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * jump *label309 equal :rebindUnit.7:currentUnit null
-    * ubind :rebindUnit.7:currentUnit
+ 1083 set :rebindUnit.7:currentUnit .UNIT_P2
+ 1084 jump *label309 equal :processUnit.3:unit null
+ 1085 ubind :processUnit.3:unit
  1086 sensor *tmp397 @unit @dead
  1087 op equal *tmp398 *tmp397 0
  1088 sensor *tmp399 @unit @controller
 
  1094 label *label312
  1095 label *label309
  1096 label *label310
-    * ubind .TYPE
+ 1097 ubind *tmp9
  1098 set :rebindUnit.7:firstUnit @unit
  1099 jump *label313 equal :rebindUnit.7:firstUnit null
  1100 label *label315
 
  1103 jump *label308 always
  1104 label *label318
  1105 label *label319
-    * ubind .TYPE
+ 1106 ubind *tmp9
  1107 label *label316
  1108 jump *label317 equal @unit :rebindUnit.7:firstUnit
  1109 label *label320
 
  1122 jump *label321 lessThanEq :processUnit.3:state 3
  1123 label *label323
  1124 sensor *tmp415 @unit @firstItem
-    * jump *label325 notEqual *tmp415 :processUnit.3:item
+ 1125 jump *label325 notEqual *tmp415 @phase-fabric
  1126 set :processUnit.3:state 3
  1127 jump *label326 always
  1128 label *label325
 
  1145 jump *label331 notEqual :processUnit.3:state 2
  1146 ucontrol within .CORE_X .CORE_Y 8 *tmp425
  1147 jump *label333 equal *tmp425 false
-    * ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
+ 1148 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1149 sensor *tmp427 @unit @totalItems
  1150 jump *label335 lessThan *tmp427 .UNIT_CAPACITY
  1151 ucontrol approach .DOME_X .DOME_Y 6
 
  1171 jump *label337 notEqual :processUnit.3:state 3
  1172 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1173 jump *label339 equal *tmp439 false
-    * jump *label341 equal :processUnit.3:supply false
+ 1174 jump *label341 equal *tmp393 false
  1175 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1176 set .MSG ", supplying\n"
  1177 jump *label342 always
 
  1202 ucontrol flag :processUnit.3:state
  1203 sensor *tmp452 @unit @totalItems
  1204 print "  "
-    * print :processUnit.3:group
+ 1205 print .GROUP2
  1206 print ":"
  1207 print " ["
-    * print :processUnit.3:color
+ 1208 print "gold"
  1209 print "]"
  1210 print *tmp452
  1211 print "["
 
  1224 label *label307
  1225 set .UNIT_P2 :processUnit.3:unit
  1226 jump *label347 equal .SUPPLY_P_FIRST false
-    * sensor *tmp457 .UNIT_P1 @totalItems
+ 1227 sensor *tmp457 :processUnit.2:unit @totalItems
  1228 op greaterThan *tmp456 *tmp457 0
  1229 jump *label348 always
  1230 label *label347
-    * sensor *tmp459 .UNIT_P2 @totalItems
+ 1231 sensor *tmp459 :processUnit.3:unit @totalItems
  1232 op equal *tmp456 *tmp459 0
  1233 label *label348
  1234 set .SUPPLY_P_FIRST *tmp456
 
  1242 print " "
  1243 print "ms"
  1244 printflush message1
-    * jump *label349 equal .TYPE UNIT_TYPE
+ 1245 jump *label349 equal *tmp9 UNIT_TYPE
  1246 label *label352
  1247 jump *label349 lessThanEq :unitCheck @time
  1248 label *label351
 
  1252 set :areUnitsAvailable.2:free 0
  1253 set :areUnitsAvailable.2:occupied 0
  1254 set :areUnitsAvailable.2:needed 0
-    * ubind :areUnitsAvailable.2:type
+ 1255 ubind UNIT_TYPE
  1256 set :areUnitsAvailable.2:firstUnit @unit
  1257 jump *label356 equal :areUnitsAvailable.2:firstUnit null
  1258 # "Function: inline def needsFourUnits(in unit)"
  1259 set :needsFourUnits.3:unit @unit
  1260 op sub *tmp470 .DOME_X .CORE_X
  1261 op sub *tmp471 .DOME_Y .CORE_Y
-    * op len *tmp472 *tmp470 *tmp471
-    * op mul *tmp473 2 *tmp472
+ 1262 op len *tmp472 *tmp127 *tmp128
+ 1263 op mul *tmp473 2 *tmp129
  1264 sensor *tmp474 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp473 *tmp474
+ 1265 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
  1266 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
  1267 jump *label360 always
-    * set *tmp469 null
  1268 label *label360
  1269 jump *label358 equal *tmp469 false
  1270 set *tmp477 4
 
  1281 jump *label364 notEqual *tmp480 @this
  1282 label *label366
  1283 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label368 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1284 jump *label368 lessThan :areUnitsAvailable.2:free *tmp477
  1285 set *tmp466 true
  1286 jump *label355 always
  1287 label *label368
 
  1290 label *label364
  1291 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1292 label *label365
-    * ubind :areUnitsAvailable.2:type
+ 1293 ubind UNIT_TYPE
  1294 label *label362
  1295 jump *label363 equal @unit :areUnitsAvailable.2:firstUnit
  1296 label *label370
 
  1299 label *label363
  1300 label *label356
  1301 label *label357
-    * jump *label371 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+ 1302 jump *label371 equal false false
+ 1303 print UNIT_TYPE
  1304 print ":"
  1305 print " occupied: "
  1306 print :areUnitsAvailable.2:occupied
 
  1317 label *label372
  1318 set *tmp466 false
  1319 jump *label355 always
-    * set *tmp466 null
  1320 label *label355
  1321 jump *label353 equal *tmp466 false
  1322 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-47 instructions):
 
    63 print "[gold]Looking for suitable unit type:[]"
    64 print "\n"
    65 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable:type UNIT_TYPE
-    * set :areUnitsAvailable:output true
    66 set :areUnitsAvailable:free 0
    67 set :areUnitsAvailable:occupied 0
    68 set :areUnitsAvailable:needed 0
 
   154 label *label46
   155 jump *label53 equal :chooseUnitType:type UNIT_TYPE
   156 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:type :chooseUnitType:type
-    * set :areUnitsAvailable.1:output true
   157 set :areUnitsAvailable.1:free 0
   158 set :areUnitsAvailable.1:occupied 0
   159 set :areUnitsAvailable.1:needed 0
 
   241 label *label23
   242 set *tmp9 null
   243 label *label20
-    * set .TYPE *tmp9
   244 print "[gold]Binding units..."
   245 printflush message1
   246 # "Function: inline def rebindUnits()"
   247 set .UNIT_P2 null
   248 set .UNIT_S2 null
-    * set .UNIT_P1 .UNIT_P2
-    * set .UNIT_S1 .UNIT_S2
+  249 set .UNIT_P1 null
+  250 set .UNIT_S1 null
   251 set :rebindUnits:count 0
   252 ubind *tmp9
   253 set :rebindUnits:firstUnit @unit
 
   281 # "Function: inline def acquireUnit(in currentUnit)"
   282 set :acquireUnit:currentUnit .UNIT_S1
   283 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit:currentUnit .UNIT_S1
-    * jump *label90 equal :acquireUnit:currentUnit null
-    * ubind :acquireUnit:currentUnit
+  284 jump *label90 equal .UNIT_S1 null
+  285 ubind .UNIT_S1
   286 sensor *tmp84 @unit @dead
   287 op equal *tmp85 *tmp84 0
   288 sensor *tmp86 @unit @controller
 
   322 # "Function: inline def acquireUnit(in currentUnit)"
   323 set :acquireUnit.1:currentUnit .UNIT_P1
   324 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit .UNIT_P1
-    * jump *label104 equal :acquireUnit.1:currentUnit null
-    * ubind :acquireUnit.1:currentUnit
+  325 jump *label104 equal .UNIT_P1 null
+  326 ubind .UNIT_P1
   327 sensor *tmp102 @unit @dead
   328 op equal *tmp103 *tmp102 0
   329 sensor *tmp104 @unit @controller
 
   367 jump *label116 notEqual *tmp118 @silicon
   368 label *label118
   369 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:a *tmp80
-    * set :swap:b *tmp98
-    * set :swap:t .UNIT_S1
-    * set :swap:a .UNIT_P1
-    * set :swap:b :swap:t
+  370 set :swap:t *tmp80
+  371 set :swap:a *tmp98
+  372 set :swap:b .UNIT_S1
   373 label *label120
-    * set .UNIT_S1 :swap:a
+  374 set .UNIT_S1 .UNIT_P1
   375 set .UNIT_P1 :swap:t
   376 label *label116
   377 label *label117
 
   384 label *label121
   385 label *label122
   386 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.2:unit .UNIT_S1
   387 op sub *tmp127 .DOME_X .CORE_X
   388 op sub *tmp128 .DOME_Y .CORE_Y
   389 op len *tmp129 *tmp127 *tmp128
 
   393 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   394 jump *label123 always
   395 label *label123
-    * set .FOUR_UNITS *tmp126
   396 jump *label124 equal *tmp126 false
   397 # "Function: inline def acquireUnit(in currentUnit)"
   398 set :acquireUnit.2:currentUnit .UNIT_S2
   399 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit .UNIT_S2
-    * jump *label128 equal :acquireUnit.2:currentUnit null
-    * ubind :acquireUnit.2:currentUnit
+  400 jump *label128 equal .UNIT_S2 null
+  401 ubind .UNIT_S2
   402 sensor *tmp139 @unit @dead
   403 op equal *tmp140 *tmp139 0
   404 sensor *tmp141 @unit @controller
 
   438 # "Function: inline def acquireUnit(in currentUnit)"
   439 set :acquireUnit.3:currentUnit .UNIT_P2
   440 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit .UNIT_P2
-    * jump *label142 equal :acquireUnit.3:currentUnit null
-    * ubind :acquireUnit.3:currentUnit
+  441 jump *label142 equal .UNIT_P2 null
+  442 ubind .UNIT_P2
   443 sensor *tmp157 @unit @dead
   444 op equal *tmp158 *tmp157 0
   445 sensor *tmp159 @unit @controller
 
   483 jump *label154 equal *tmp173 @phase-fabric
   484 label *label156
   485 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.1:a .UNIT_S1
-    * set :swap.1:b *tmp153
   486 set :swap.1:t .UNIT_S1
-    * set :swap.1:a .UNIT_P2
-    * set :swap.1:b :swap.1:t
+  487 set :swap.1:a *tmp153
+  488 set :swap.1:b .UNIT_S1
   489 label *label158
-    * set .UNIT_S1 :swap.1:a
+  490 set .UNIT_S1 .UNIT_P2
   491 set .UNIT_P2 :swap.1:t
   492 label *label154
   493 label *label155
 
   498 jump *label159 notEqual *tmp178 @silicon
   499 label *label161
   500 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:a *tmp135
-    * set :swap.2:b .UNIT_P2
-    * set :swap.2:t .UNIT_S2
+  501 set :swap.2:t *tmp135
   502 set :swap.2:a .UNIT_P2
-    * set :swap.2:b :swap.2:t
+  503 set :swap.2:b .UNIT_S2
   504 label *label163
-    * set .UNIT_S2 :swap.2:a
+  505 set .UNIT_S2 .UNIT_P2
   506 set .UNIT_P2 :swap.2:t
   507 label *label159
   508 label *label160
 
   556 print "]"
   557 print "\n"
   558 # "Function: inline void printDomeStatus(in item, in text)"
-    * set :printDomeStatus:item @silicon
-    * set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   559 print "\n[green]Silicon[] status:\n"
   560 sensor :printDomeStatus:level .DOME @silicon
   561 jump *label176 lessThanEq :printDomeStatus:level 3
 
   575 label *label175
   576 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   577 set :processUnit:unit .UNIT_S1
-    * set :processUnit:item @silicon
-    * set :processUnit:group .GROUP1
-    * set :processUnit:supply .SUPPLY_S_FIRST
   578 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit .UNIT_S1
-    * jump *label180 equal :processUnit:unit null
-    * ubind :processUnit:unit
+  579 jump *label180 equal .UNIT_S1 null
+  580 ubind .UNIT_S1
   581 sensor *tmp199 @unit @dead
   582 op equal *tmp200 *tmp199 0
   583 sensor *tmp201 @unit @controller
 
   611 label *label179
   612 sensor :processUnit:state @unit @flag
   613 set :processUnit:distance -1
-    * set :processUnit:color "gold"
   614 jump *label194 lessThan :processUnit:state 2
   615 label *label195
   616 jump *label192 lessThanEq :processUnit:state 3
 
   721 op equal *tmp259 .SUPPLY_S_FIRST false
   722 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   723 set :processUnit.1:unit .UNIT_S2
-    * set :processUnit.1:item @silicon
-    * set :processUnit.1:group .GROUP2
-    * set :processUnit.1:supply *tmp259
   724 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit .UNIT_S2
-    * jump *label222 equal :processUnit.1:unit null
-    * ubind :processUnit.1:unit
+  725 jump *label222 equal .UNIT_S2 null
+  726 ubind .UNIT_S2
   727 sensor *tmp263 @unit @dead
   728 op equal *tmp264 *tmp263 0
   729 sensor *tmp265 @unit @controller
 
   757 label *label221
   758 sensor :processUnit.1:state @unit @flag
   759 set :processUnit.1:distance -1
-    * set :processUnit.1:color "gold"
   760 jump *label236 lessThan :processUnit.1:state 2
   761 label *label237
   762 jump *label234 lessThanEq :processUnit.1:state 3
 
   875 label *label218
   876 label *label219
   877 # "Function: inline void printDomeStatus(in item, in text)"
-    * set :printDomeStatus.1:item @phase-fabric
-    * set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   878 print "\n[green]Phase fabric[] status:\n"
   879 sensor :printDomeStatus.1:level .DOME @phase-fabric
   880 jump *label263 lessThanEq :printDomeStatus.1:level 3
 
   894 label *label262
   895 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   896 set :processUnit.2:unit .UNIT_P1
-    * set :processUnit.2:item @phase-fabric
-    * set :processUnit.2:group .GROUP1
-    * set :processUnit.2:supply .SUPPLY_P_FIRST
   897 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit .UNIT_P1
-    * jump *label267 equal :processUnit.2:unit null
-    * ubind :processUnit.2:unit
+  898 jump *label267 equal .UNIT_P1 null
+  899 ubind .UNIT_P1
   900 sensor *tmp333 @unit @dead
   901 op equal *tmp334 *tmp333 0
   902 sensor *tmp335 @unit @controller
 
   930 label *label266
   931 sensor :processUnit.2:state @unit @flag
   932 set :processUnit.2:distance -1
-    * set :processUnit.2:color "gold"
   933 jump *label281 lessThan :processUnit.2:state 2
   934 label *label282
   935 jump *label279 lessThanEq :processUnit.2:state 3
 
  1040 op equal *tmp393 .SUPPLY_P_FIRST false
  1041 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
  1042 set :processUnit.3:unit .UNIT_P2
-    * set :processUnit.3:item @phase-fabric
-    * set :processUnit.3:group .GROUP2
-    * set :processUnit.3:supply *tmp393
  1043 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit .UNIT_P2
-    * jump *label309 equal :processUnit.3:unit null
-    * ubind :processUnit.3:unit
+ 1044 jump *label309 equal .UNIT_P2 null
+ 1045 ubind .UNIT_P2
  1046 sensor *tmp397 @unit @dead
  1047 op equal *tmp398 *tmp397 0
  1048 sensor *tmp399 @unit @controller
 
  1076 label *label308
  1077 sensor :processUnit.3:state @unit @flag
  1078 set :processUnit.3:distance -1
-    * set :processUnit.3:color "gold"
  1079 jump *label323 lessThan :processUnit.3:state 2
  1080 label *label324
  1081 jump *label321 lessThanEq :processUnit.3:state 3
 
  1206 jump *label349 lessThanEq :unitCheck @time
  1207 label *label351
  1208 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
  1209 set :areUnitsAvailable.2:free 0
  1210 set :areUnitsAvailable.2:occupied 0
  1211 set :areUnitsAvailable.2:needed 0
 
  1214 jump *label356 equal :areUnitsAvailable.2:firstUnit null
  1215 # "Function: inline def needsFourUnits(in unit)"
  1216 set :needsFourUnits.3:unit @unit
-    * op sub *tmp470 .DOME_X .CORE_X
-    * op sub *tmp471 .DOME_Y .CORE_Y
-    * op len *tmp472 *tmp127 *tmp128
-    * op mul *tmp473 2 *tmp129
  1217 sensor *tmp474 :needsFourUnits.3:unit @speed
  1218 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
  1219 op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   279 label *label82
   280 label *label77
   281 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit:currentUnit .UNIT_S1
   282 # "Function: inline def rebindUnit(in currentUnit)"
   283 jump *label90 equal .UNIT_S1 null
   284 ubind .UNIT_S1
 
   319 label *label88
   320 set .UNIT_S1 *tmp80
   321 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.1:currentUnit .UNIT_P1
   322 # "Function: inline def rebindUnit(in currentUnit)"
   323 jump *label104 equal .UNIT_P1 null
   324 ubind .UNIT_P1
 
   366 label *label118
   367 # "Function: inline void swap(in out a, in out b)"
   368 set :swap:t *tmp80
-    * set :swap:a *tmp98
-    * set :swap:b .UNIT_S1
+  369 set :swap:b *tmp80
   370 label *label120
-    * set .UNIT_S1 .UNIT_P1
-    * set .UNIT_P1 :swap:t
+  371 set .UNIT_S1 *tmp98
+  372 set .UNIT_P1 *tmp80
   373 label *label116
   374 label *label117
   375 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   392 label *label123
   393 jump *label124 equal *tmp126 false
   394 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.2:currentUnit .UNIT_S2
   395 # "Function: inline def rebindUnit(in currentUnit)"
   396 jump *label128 equal .UNIT_S2 null
   397 ubind .UNIT_S2
 
   432 label *label126
   433 set .UNIT_S2 *tmp135
   434 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.3:currentUnit .UNIT_P2
   435 # "Function: inline def rebindUnit(in currentUnit)"
   436 jump *label142 equal .UNIT_P2 null
   437 ubind .UNIT_P2
 
   479 label *label156
   480 # "Function: inline void swap(in out a, in out b)"
   481 set :swap.1:t .UNIT_S1
-    * set :swap.1:a *tmp153
-    * set :swap.1:b .UNIT_S1
   482 label *label158
-    * set .UNIT_S1 .UNIT_P2
+  483 set .UNIT_S1 *tmp153
   484 set .UNIT_P2 :swap.1:t
   485 label *label154
   486 label *label155
 
   492 label *label161
   493 # "Function: inline void swap(in out a, in out b)"
   494 set :swap.2:t *tmp135
-    * set :swap.2:a .UNIT_P2
-    * set :swap.2:b .UNIT_S2
+  495 set :swap.2:b *tmp135
   496 label *label163
   497 set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P2 :swap.2:t
+  498 set .UNIT_P2 *tmp135
   499 label *label159
   500 label *label160
   501 set .GROUP1 "unit  1"
 
   566 label *label177
   567 label *label175
   568 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit:unit .UNIT_S1
   569 # "Function: inline def rebindUnit(in currentUnit)"
   570 jump *label180 equal .UNIT_S1 null
   571 ubind .UNIT_S1
 
   711 jump *label218 equal *tmp126 false
   712 op equal *tmp259 .SUPPLY_S_FIRST false
   713 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.1:unit .UNIT_S2
   714 # "Function: inline def rebindUnit(in currentUnit)"
   715 jump *label222 equal .UNIT_S2 null
   716 ubind .UNIT_S2
 
   883 label *label264
   884 label *label262
   885 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.2:unit .UNIT_P1
   886 # "Function: inline def rebindUnit(in currentUnit)"
   887 jump *label267 equal .UNIT_P1 null
   888 ubind .UNIT_P1
 
  1028 jump *label305 equal *tmp126 false
  1029 op equal *tmp393 .SUPPLY_P_FIRST false
  1030 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.3:unit .UNIT_P2
  1031 # "Function: inline def rebindUnit(in currentUnit)"
  1032 jump *label309 equal .UNIT_P2 null
  1033 ubind .UNIT_P2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-4 instructions):
 
   365 jump *label116 notEqual *tmp118 @silicon
   366 label *label118
   367 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:t *tmp80
-    * set :swap:b *tmp80
   368 label *label120
   369 set .UNIT_S1 *tmp98
   370 set .UNIT_P1 *tmp80
 
   489 jump *label159 notEqual *tmp178 @silicon
   490 label *label161
   491 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:t *tmp135
-    * set :swap.2:b *tmp135
   492 label *label163
   493 set .UNIT_S2 .UNIT_P2
   494 set .UNIT_P2 *tmp135

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     5 set .DOME dome1
     6 label *label2
     7 jump *label4 notEqual .DOME null
+    8 label *label380
     9 print "[gold]Waiting for an overdrive dome to be connected..."
    10 printflush message1
    11 set .DOME dome1
    12 label *label3
-    * jump *label2 always
+   13 jump *label380 equal .DOME null
    14 label *label4
    15 print "[gold]Locating core..."
    16 printflush message1

Modifications by Iterated phase, Boolean Optimization, pass 1, iteration 1 (-2 instructions):
 
    91 label *label32
    92 sensor *tmp22 @unit @controlled
    93 jump *label37 equal *tmp22 0
-    * label *label38
    94 sensor *tmp24 @unit @controller
    95 jump *label35 notEqual *tmp24 @this
    96 label *label37
 
   181 label *label63
   182 sensor *tmp52 @unit @controlled
   183 jump *label68 equal *tmp52 0
-    * label *label69
   184 sensor *tmp54 @unit @controller
   185 jump *label66 notEqual *tmp54 @this
   186 label *label68
 
   359 set .UNIT_P1 *tmp98
   360 sensor *tmp116 *tmp80 @firstItem
   361 jump *label118 equal *tmp116 @phase-fabric
-    * label *label119
   362 sensor *tmp118 *tmp98 @firstItem
   363 jump *label116 notEqual *tmp118 @silicon
   364 label *label118
 
   469 set .UNIT_P2 *tmp153
   470 sensor *tmp171 .UNIT_S1 @firstItem
   471 jump *label154 notEqual *tmp171 @phase-fabric
-    * label *label157
   472 sensor *tmp173 *tmp153 @firstItem
   473 jump *label154 equal *tmp173 @phase-fabric
-    * label *label156
   474 # "Function: inline void swap(in out a, in out b)"
   475 set :swap.1:t .UNIT_S1
   476 label *label158
 
   480 label *label155
   481 sensor *tmp176 *tmp135 @firstItem
   482 jump *label161 equal *tmp176 @phase-fabric
-    * label *label162
   483 sensor *tmp178 .UNIT_P2 @firstItem
   484 jump *label159 notEqual *tmp178 @silicon
   485 label *label161
 
   501 set .UNIT_P2 null
   502 set .GROUP1 "unit"
   503 label *label125
-    * jump *label166 equal *tmp126 false
-    * label *label167
-    * sensor *tmp182 .UNIT_S1 @totalItems
-    * sensor *tmp183 .UNIT_S2 @totalItems
-    * jump *label164 greaterThanEq *tmp182 *tmp183
+  504 jump *label164 notEqual *tmp126 false
   505 label *label166
   506 set *tmp185 true
   507 jump *label165 always
   508 label *label164
-    * set *tmp185 false
+  509 sensor *tmp182 .UNIT_S1 @totalItems
+  510 sensor *tmp183 .UNIT_S2 @totalItems
+  511 op lessThan *tmp185 *tmp182 *tmp183
   512 label *label165
   513 set .SUPPLY_S_FIRST *tmp185
-    * jump *label170 equal *tmp126 false
-    * label *label171
-    * sensor *tmp187 .UNIT_P1 @totalItems
-    * sensor *tmp188 .UNIT_P2 @totalItems
-    * jump *label168 greaterThanEq *tmp187 *tmp188
+  514 jump *label168 notEqual *tmp126 false
   515 label *label170
   516 set *tmp190 true
   517 jump *label169 always
   518 label *label168
-    * set *tmp190 false
+  519 sensor *tmp187 .UNIT_P1 @totalItems
+  520 sensor *tmp188 .UNIT_P2 @totalItems
+  521 op lessThan *tmp190 *tmp187 *tmp188
   522 label *label169
   523 set .SUPPLY_P_FIRST *tmp190
   524 op add :unitCheck @time 5000
 
   590 sensor :processUnit:state @unit @flag
   591 set :processUnit:distance -1
   592 jump *label194 lessThan :processUnit:state 2
-    * label *label195
   593 jump *label192 lessThanEq :processUnit:state 3
   594 label *label194
   595 sensor *tmp217 @unit @firstItem
 
   734 sensor :processUnit.1:state @unit @flag
   735 set :processUnit.1:distance -1
   736 jump *label236 lessThan :processUnit.1:state 2
-    * label *label237
   737 jump *label234 lessThanEq :processUnit.1:state 3
   738 label *label236
   739 sensor *tmp281 @unit @firstItem
 
   905 sensor :processUnit.2:state @unit @flag
   906 set :processUnit.2:distance -1
   907 jump *label281 lessThan :processUnit.2:state 2
-    * label *label282
   908 jump *label279 lessThanEq :processUnit.2:state 3
   909 label *label281
   910 sensor *tmp351 @unit @firstItem
 
  1049 sensor :processUnit.3:state @unit @flag
  1050 set :processUnit.3:distance -1
  1051 jump *label323 lessThan :processUnit.3:state 2
-    * label *label324
  1052 jump *label321 lessThanEq :processUnit.3:state 3
  1053 label *label323
  1054 sensor *tmp415 @unit @firstItem
 
  1173 print "ms"
  1174 printflush message1
  1175 jump *label349 equal *tmp9 UNIT_TYPE
-    * label *label352
  1176 jump *label349 lessThanEq :unitCheck @time
-    * label *label351
  1177 # "Function: inline def areUnitsAvailable(in type, in output)"
  1178 set :areUnitsAvailable.2:free 0
  1179 set :areUnitsAvailable.2:occupied 0
 
  1198 label *label361
  1199 sensor *tmp478 @unit @controlled
  1200 jump *label366 equal *tmp478 0
-    * label *label367
  1201 sensor *tmp480 @unit @controller
  1202 jump *label364 notEqual *tmp480 @this
  1203 label *label366
 
  1255 ubind :locateCore:type
  1256 sensor *tmp494 @unit @controlled
  1257 jump *label378 equal *tmp494 0
-    * label *label379
  1258 sensor *tmp496 @unit @controller
  1259 jump *label376 notEqual *tmp496 @this
  1260 label *label378

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-4 instructions):
 
   502 set .GROUP1 "unit"
   503 label *label125
   504 jump *label164 notEqual *tmp126 false
-    * set *tmp185 true
+  505 set .SUPPLY_S_FIRST true
   506 jump *label165 always
   507 label *label164
   508 sensor *tmp182 .UNIT_S1 @totalItems
   509 sensor *tmp183 .UNIT_S2 @totalItems
-    * op lessThan *tmp185 *tmp182 *tmp183
+  510 op lessThan .SUPPLY_S_FIRST *tmp182 *tmp183
   511 label *label165
-    * set .SUPPLY_S_FIRST *tmp185
   512 jump *label168 notEqual *tmp126 false
-    * set *tmp190 true
+  513 set .SUPPLY_P_FIRST true
   514 jump *label169 always
   515 label *label168
   516 sensor *tmp187 .UNIT_P1 @totalItems
   517 sensor *tmp188 .UNIT_P2 @totalItems
-    * op lessThan *tmp190 *tmp187 *tmp188
+  518 op lessThan .SUPPLY_P_FIRST *tmp187 *tmp188
   519 label *label169
-    * set .SUPPLY_P_FIRST *tmp190
   520 op add :unitCheck @time 5000
   521 label *label172
   522 sensor *tmp192 switch1 @enabled
 
   836 set .UNIT_S2 :processUnit.1:unit
   837 jump *label260 equal .SUPPLY_S_FIRST false
   838 sensor *tmp323 :processUnit:unit @totalItems
-    * op greaterThan *tmp322 *tmp323 0
+  839 op greaterThan .SUPPLY_S_FIRST *tmp323 0
   840 jump *label261 always
   841 label *label260
   842 sensor *tmp325 :processUnit.1:unit @totalItems
-    * op equal *tmp322 *tmp325 0
+  843 op equal .SUPPLY_S_FIRST *tmp325 0
   844 label *label261
-    * set .SUPPLY_S_FIRST *tmp322
   845 label *label218
   846 label *label219
   847 # "Function: inline void printDomeStatus(in item, in text)"
 
  1150 set .UNIT_P2 :processUnit.3:unit
  1151 jump *label347 equal .SUPPLY_P_FIRST false
  1152 sensor *tmp457 :processUnit.2:unit @totalItems
-    * op greaterThan *tmp456 *tmp457 0
+ 1153 op greaterThan .SUPPLY_P_FIRST *tmp457 0
  1154 jump *label348 always
  1155 label *label347
  1156 sensor *tmp459 :processUnit.3:unit @totalItems
-    * op equal *tmp456 *tmp459 0
+ 1157 op equal .SUPPLY_P_FIRST *tmp459 0
  1158 label *label348
-    * set .SUPPLY_P_FIRST *tmp456
  1159 label *label305
  1160 label *label306
  1161 op sub *tmp461 @time :start

Modifications by Unroll iteration loop at line 169:9 (+7 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * set :locateDomeAndCore:type @flare
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label11 (m:marker0)
-    * set :locateDomeAndCore:type @poly
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label12 (m:marker0)
-    * set :locateDomeAndCore:type @mega
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label13 (m:marker0)
-    * set :locateDomeAndCore:type @mono
-    * set *tmp1 null
-    * label *label8
-    * set :locateCore:type :locateDomeAndCore:type
-    * call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label15 equal :locateCore*retval false
-    * jump *label1 always
-    * label *label15
-    * label *label16
-    * label *label9
-    * multijump *tmp1 0 0 (m:marker0)
-    * multilabel *label14 (m:marker0)
-    * label *label10
+   19 set :locateDomeAndCore:type @flare
+   20 label *label383
+   21 set :locateCore:type :locateDomeAndCore:type
+   22 call *label0 :locateCore*retaddr :locateCore*retval
+   23 jump *label384 equal :locateCore*retval false
+   24 jump *label1 always
+   25 label *label384
+   26 label *label385
+   27 label *label386
+   28 set :locateDomeAndCore:type @poly
+   29 label *label389
+   30 set :locateCore:type :locateDomeAndCore:type
+   31 call *label0 :locateCore*retaddr :locateCore*retval
+   32 jump *label390 equal :locateCore*retval false
+   33 jump *label1 always
+   34 label *label390
+   35 label *label391
+   36 label *label392
+   37 set :locateDomeAndCore:type @mega
+   38 label *label395
+   39 set :locateCore:type :locateDomeAndCore:type
+   40 call *label0 :locateCore*retaddr :locateCore*retval
+   41 jump *label396 equal :locateCore*retval false
+   42 jump *label1 always
+   43 label *label396
+   44 label *label397
+   45 label *label398
+   46 set :locateDomeAndCore:type @mono
+   47 label *label401
+   48 set :locateCore:type :locateDomeAndCore:type
+   49 call *label0 :locateCore*retaddr :locateCore*retval
+   50 jump *label402 equal :locateCore*retval false
+   51 jump *label1 always
+   52 label *label402
+   53 label *label403
+   54 label *label404
+   55 label *label10
    56 label *label6
    57 jump *label5 always
    58 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
     6 label *label2
-    * jump *label4 notEqual .DOME null
+    7 jump *label4 notEqual dome1 null
     8 label *label380
     9 print "[gold]Waiting for an overdrive dome to be connected..."
    10 printflush message1
    11 set .DOME dome1
    12 label *label3
-    * jump *label380 equal .DOME null
+   13 jump *label380 equal dome1 null
    14 label *label4
    15 print "[gold]Locating core..."
    16 printflush message1
 
    18 label *label5
    19 set :locateDomeAndCore:type @flare
    20 label *label383
-    * set :locateCore:type :locateDomeAndCore:type
+   21 set :locateCore:type @flare
    22 call *label0 :locateCore*retaddr :locateCore*retval
    23 jump *label384 equal :locateCore*retval false
    24 jump *label1 always
 
    27 label *label386
    28 set :locateDomeAndCore:type @poly
    29 label *label389
-    * set :locateCore:type :locateDomeAndCore:type
+   30 set :locateCore:type @poly
    31 call *label0 :locateCore*retaddr :locateCore*retval
    32 jump *label390 equal :locateCore*retval false
    33 jump *label1 always
 
    36 label *label392
    37 set :locateDomeAndCore:type @mega
    38 label *label395
-    * set :locateCore:type :locateDomeAndCore:type
+   39 set :locateCore:type @mega
    40 call *label0 :locateCore*retaddr :locateCore*retval
    41 jump *label396 equal :locateCore*retval false
    42 jump *label1 always
 
    45 label *label398
    46 set :locateDomeAndCore:type @mono
    47 label *label401
-    * set :locateCore:type :locateDomeAndCore:type
+   48 set :locateCore:type @mono
    49 call *label0 :locateCore*retaddr :locateCore*retval
    50 jump *label402 equal :locateCore*retval false
    51 jump *label1 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * set :locateDomeAndCore:type @flare
    19 label *label383
    20 set :locateCore:type @flare
    21 call *label0 :locateCore*retaddr :locateCore*retval
 
    24 label *label384
    25 label *label385
    26 label *label386
-    * set :locateDomeAndCore:type @poly
    27 label *label389
    28 set :locateCore:type @poly
    29 call *label0 :locateCore*retaddr :locateCore*retval
 
    32 label *label390
    33 label *label391
    34 label *label392
-    * set :locateDomeAndCore:type @mega
    35 label *label395
    36 set :locateCore:type @mega
    37 call *label0 :locateCore*retaddr :locateCore*retval
 
    40 label *label396
    41 label *label397
    42 label *label398
-    * set :locateDomeAndCore:type @mono
    43 label *label401
    44 set :locateCore:type @mono
    45 call *label0 :locateCore*retaddr :locateCore*retval

Modifications by Replicate loop condition at line 54:5 (+1 instructions):
 
    60 label *label17
    61 sensor *tmp7 switch1 @enabled
    62 jump *label19 notEqual *tmp7 false
+   63 label *label408
    64 print "[coral]Activate switch to begin supplying overdrive dome..."
    65 print "\n"
    66 printflush message1
    67 label *label18
-    * jump *label17 always
+   68 sensor *tmp7 switch1 @enabled
+   69 jump *label408 equal *tmp7 false
    70 label *label19
    71 # "Function: inline def chooseUnitType()"
    72 label *label21

Modifications by Replicate loop condition at line 119:5 (+1 instructions):
 
   531 label *label172
   532 sensor *tmp192 switch1 @enabled
   533 jump *label174 equal *tmp192 false
+  534 label *label409
   535 set :start @time
   536 print " === [gold]Supplying Overdrive Dome[] === "
   537 print "\n"
 
  1252 label *label349
  1253 label *label350
  1254 label *label173
-    * jump *label172 always
+ 1255 sensor *tmp192 switch1 @enabled
+ 1256 jump *label409 notEqual *tmp192 false
  1257 label *label174
  1258 end
  1259 label *label0

Modifications by Unroll iteration loop at line 201:9 (+151 instructions):
 
   147 jump *label20 always
   148 label *label24
   149 label *label25
-    * set :chooseUnitType:type @flare
-    * op add *tmp37 @counter 1
-    * jump *label46 always
-    * multilabel *label49 (m:marker1)
-    * set :chooseUnitType:type @poly
-    * op add *tmp37 @counter 1
-    * jump *label46 always
-    * multilabel *label50 (m:marker1)
-    * set :chooseUnitType:type @mega
-    * op add *tmp37 @counter 1
-    * jump *label46 always
-    * multilabel *label51 (m:marker1)
-    * set :chooseUnitType:type @mono
-    * set *tmp37 null
-    * label *label46
-    * jump *label53 equal :chooseUnitType:type UNIT_TYPE
-    * # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:free 0
-    * set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label58 equal :areUnitsAvailable.1:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp44 .DOME_X .CORE_X
-    * op sub *tmp45 .DOME_Y .CORE_Y
-    * op len *tmp46 *tmp44 *tmp45
-    * op mul *tmp47 2 *tmp46
-    * sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label62 always
-    * label *label62
-    * jump *label60 equal *tmp43 false
-    * set *tmp51 4
-    * jump *label61 always
-    * label *label60
-    * set *tmp51 2
-    * label *label61
-    * set :areUnitsAvailable.1:needed *tmp51
-    * label *label63
-    * sensor *tmp52 @unit @controlled
-    * jump *label68 equal *tmp52 0
-    * sensor *tmp54 @unit @controller
-    * jump *label66 notEqual *tmp54 @this
-    * label *label68
-    * op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label70 lessThan :areUnitsAvailable.1:free *tmp51
-    * set *tmp40 true
-    * jump *label57 always
-    * label *label70
-    * label *label71
-    * jump *label67 always
-    * label *label66
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label67
-    * ubind :chooseUnitType:type
-    * label *label64
-    * jump *label65 equal @unit :areUnitsAvailable.1:firstUnit
-    * label *label72
-    * sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
-    * jump *label63 equal *tmp61 0
-    * label *label65
-    * label *label58
-    * label *label59
-    * jump *label73 equal true false
-    * print :chooseUnitType:type
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.1:free
-    * jump *label75 lessThanEq :areUnitsAvailable.1:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.1:needed
-    * label *label75
-    * label *label76
-    * print "\n"
-    * label *label73
-    * label *label74
-    * set *tmp40 false
-    * jump *label57 always
-    * label *label57
-    * jump *label55 equal *tmp40 false
-    * printflush null
-    * set *tmp9 :chooseUnitType:type
-    * jump *label20 always
-    * label *label55
-    * label *label56
-    * label *label53
-    * label *label54
-    * label *label47
-    * multijump *tmp37 0 0 (m:marker1)
-    * multilabel *label52 (m:marker1)
-    * label *label48
+  150 set :chooseUnitType:type @flare
+  151 label *label410
+  152 jump *label432 equal :chooseUnitType:type UNIT_TYPE
+  153 # "Function: inline def areUnitsAvailable(in type, in output)"
+  154 set :areUnitsAvailable.1:free 0
+  155 set :areUnitsAvailable.1:occupied 0
+  156 set :areUnitsAvailable.1:needed 0
+  157 ubind :chooseUnitType:type
+  158 set :areUnitsAvailable.1:firstUnit @unit
+  159 jump *label423 equal :areUnitsAvailable.1:firstUnit null
+  160 # "Function: inline def needsFourUnits(in unit)"
+  161 set :needsFourUnits.1:unit @unit
+  162 op sub *tmp44 .DOME_X .CORE_X
+  163 op sub *tmp45 .DOME_Y .CORE_Y
+  164 op len *tmp46 *tmp44 *tmp45
+  165 op mul *tmp47 2 *tmp46
+  166 sensor *tmp48 :needsFourUnits.1:unit @speed
+  167 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  168 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  169 jump *label411 always
+  170 label *label411
+  171 jump *label412 equal *tmp43 false
+  172 set *tmp51 4
+  173 jump *label413 always
+  174 label *label412
+  175 set *tmp51 2
+  176 label *label413
+  177 set :areUnitsAvailable.1:needed *tmp51
+  178 label *label414
+  179 sensor *tmp52 @unit @controlled
+  180 jump *label415 equal *tmp52 0
+  181 sensor *tmp54 @unit @controller
+  182 jump *label418 notEqual *tmp54 @this
+  183 label *label415
+  184 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  185 jump *label416 lessThan :areUnitsAvailable.1:free *tmp51
+  186 set *tmp40 true
+  187 jump *label429 always
+  188 label *label416
+  189 label *label417
+  190 jump *label419 always
+  191 label *label418
+  192 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  193 label *label419
+  194 ubind :chooseUnitType:type
+  195 label *label420
+  196 jump *label422 equal @unit :areUnitsAvailable.1:firstUnit
+  197 label *label421
+  198 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  199 jump *label414 equal *tmp61 0
+  200 label *label422
+  201 label *label423
+  202 label *label424
+  203 jump *label427 equal true false
+  204 print :chooseUnitType:type
+  205 print ":"
+  206 print " occupied: "
+  207 print :areUnitsAvailable.1:occupied
+  208 print ","
+  209 print " free: "
+  210 print :areUnitsAvailable.1:free
+  211 jump *label425 lessThanEq :areUnitsAvailable.1:needed 0
+  212 print ", needed: "
+  213 print :areUnitsAvailable.1:needed
+  214 label *label425
+  215 label *label426
+  216 print "\n"
+  217 label *label427
+  218 label *label428
+  219 set *tmp40 false
+  220 jump *label429 always
+  221 label *label429
+  222 jump *label430 equal *tmp40 false
+  223 printflush null
+  224 set *tmp9 :chooseUnitType:type
+  225 jump *label20 always
+  226 label *label430
+  227 label *label431
+  228 label *label432
+  229 label *label433
+  230 label *label434
+  231 set :chooseUnitType:type @poly
+  232 label *label437
+  233 jump *label459 equal :chooseUnitType:type UNIT_TYPE
+  234 # "Function: inline def areUnitsAvailable(in type, in output)"
+  235 set :areUnitsAvailable.1:free 0
+  236 set :areUnitsAvailable.1:occupied 0
+  237 set :areUnitsAvailable.1:needed 0
+  238 ubind :chooseUnitType:type
+  239 set :areUnitsAvailable.1:firstUnit @unit
+  240 jump *label450 equal :areUnitsAvailable.1:firstUnit null
+  241 # "Function: inline def needsFourUnits(in unit)"
+  242 set :needsFourUnits.1:unit @unit
+  243 op sub *tmp44 .DOME_X .CORE_X
+  244 op sub *tmp45 .DOME_Y .CORE_Y
+  245 op len *tmp46 *tmp44 *tmp45
+  246 op mul *tmp47 2 *tmp46
+  247 sensor *tmp48 :needsFourUnits.1:unit @speed
+  248 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  249 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  250 jump *label438 always
+  251 label *label438
+  252 jump *label439 equal *tmp43 false
+  253 set *tmp51 4
+  254 jump *label440 always
+  255 label *label439
+  256 set *tmp51 2
+  257 label *label440
+  258 set :areUnitsAvailable.1:needed *tmp51
+  259 label *label441
+  260 sensor *tmp52 @unit @controlled
+  261 jump *label442 equal *tmp52 0
+  262 sensor *tmp54 @unit @controller
+  263 jump *label445 notEqual *tmp54 @this
+  264 label *label442
+  265 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  266 jump *label443 lessThan :areUnitsAvailable.1:free *tmp51
+  267 set *tmp40 true
+  268 jump *label456 always
+  269 label *label443
+  270 label *label444
+  271 jump *label446 always
+  272 label *label445
+  273 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  274 label *label446
+  275 ubind :chooseUnitType:type
+  276 label *label447
+  277 jump *label449 equal @unit :areUnitsAvailable.1:firstUnit
+  278 label *label448
+  279 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  280 jump *label441 equal *tmp61 0
+  281 label *label449
+  282 label *label450
+  283 label *label451
+  284 jump *label454 equal true false
+  285 print :chooseUnitType:type
+  286 print ":"
+  287 print " occupied: "
+  288 print :areUnitsAvailable.1:occupied
+  289 print ","
+  290 print " free: "
+  291 print :areUnitsAvailable.1:free
+  292 jump *label452 lessThanEq :areUnitsAvailable.1:needed 0
+  293 print ", needed: "
+  294 print :areUnitsAvailable.1:needed
+  295 label *label452
+  296 label *label453
+  297 print "\n"
+  298 label *label454
+  299 label *label455
+  300 set *tmp40 false
+  301 jump *label456 always
+  302 label *label456
+  303 jump *label457 equal *tmp40 false
+  304 printflush null
+  305 set *tmp9 :chooseUnitType:type
+  306 jump *label20 always
+  307 label *label457
+  308 label *label458
+  309 label *label459
+  310 label *label460
+  311 label *label461
+  312 set :chooseUnitType:type @mega
+  313 label *label464
+  314 jump *label486 equal :chooseUnitType:type UNIT_TYPE
+  315 # "Function: inline def areUnitsAvailable(in type, in output)"
+  316 set :areUnitsAvailable.1:free 0
+  317 set :areUnitsAvailable.1:occupied 0
+  318 set :areUnitsAvailable.1:needed 0
+  319 ubind :chooseUnitType:type
+  320 set :areUnitsAvailable.1:firstUnit @unit
+  321 jump *label477 equal :areUnitsAvailable.1:firstUnit null
+  322 # "Function: inline def needsFourUnits(in unit)"
+  323 set :needsFourUnits.1:unit @unit
+  324 op sub *tmp44 .DOME_X .CORE_X
+  325 op sub *tmp45 .DOME_Y .CORE_Y
+  326 op len *tmp46 *tmp44 *tmp45
+  327 op mul *tmp47 2 *tmp46
+  328 sensor *tmp48 :needsFourUnits.1:unit @speed
+  329 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  330 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  331 jump *label465 always
+  332 label *label465
+  333 jump *label466 equal *tmp43 false
+  334 set *tmp51 4
+  335 jump *label467 always
+  336 label *label466
+  337 set *tmp51 2
+  338 label *label467
+  339 set :areUnitsAvailable.1:needed *tmp51
+  340 label *label468
+  341 sensor *tmp52 @unit @controlled
+  342 jump *label469 equal *tmp52 0
+  343 sensor *tmp54 @unit @controller
+  344 jump *label472 notEqual *tmp54 @this
+  345 label *label469
+  346 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  347 jump *label470 lessThan :areUnitsAvailable.1:free *tmp51
+  348 set *tmp40 true
+  349 jump *label483 always
+  350 label *label470
+  351 label *label471
+  352 jump *label473 always
+  353 label *label472
+  354 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  355 label *label473
+  356 ubind :chooseUnitType:type
+  357 label *label474
+  358 jump *label476 equal @unit :areUnitsAvailable.1:firstUnit
+  359 label *label475
+  360 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  361 jump *label468 equal *tmp61 0
+  362 label *label476
+  363 label *label477
+  364 label *label478
+  365 jump *label481 equal true false
+  366 print :chooseUnitType:type
+  367 print ":"
+  368 print " occupied: "
+  369 print :areUnitsAvailable.1:occupied
+  370 print ","
+  371 print " free: "
+  372 print :areUnitsAvailable.1:free
+  373 jump *label479 lessThanEq :areUnitsAvailable.1:needed 0
+  374 print ", needed: "
+  375 print :areUnitsAvailable.1:needed
+  376 label *label479
+  377 label *label480
+  378 print "\n"
+  379 label *label481
+  380 label *label482
+  381 set *tmp40 false
+  382 jump *label483 always
+  383 label *label483
+  384 jump *label484 equal *tmp40 false
+  385 printflush null
+  386 set *tmp9 :chooseUnitType:type
+  387 jump *label20 always
+  388 label *label484
+  389 label *label485
+  390 label *label486
+  391 label *label487
+  392 label *label488
+  393 set :chooseUnitType:type @mono
+  394 label *label491
+  395 jump *label513 equal :chooseUnitType:type UNIT_TYPE
+  396 # "Function: inline def areUnitsAvailable(in type, in output)"
+  397 set :areUnitsAvailable.1:free 0
+  398 set :areUnitsAvailable.1:occupied 0
+  399 set :areUnitsAvailable.1:needed 0
+  400 ubind :chooseUnitType:type
+  401 set :areUnitsAvailable.1:firstUnit @unit
+  402 jump *label504 equal :areUnitsAvailable.1:firstUnit null
+  403 # "Function: inline def needsFourUnits(in unit)"
+  404 set :needsFourUnits.1:unit @unit
+  405 op sub *tmp44 .DOME_X .CORE_X
+  406 op sub *tmp45 .DOME_Y .CORE_Y
+  407 op len *tmp46 *tmp44 *tmp45
+  408 op mul *tmp47 2 *tmp46
+  409 sensor *tmp48 :needsFourUnits.1:unit @speed
+  410 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  411 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
+  412 jump *label492 always
+  413 label *label492
+  414 jump *label493 equal *tmp43 false
+  415 set *tmp51 4
+  416 jump *label494 always
+  417 label *label493
+  418 set *tmp51 2
+  419 label *label494
+  420 set :areUnitsAvailable.1:needed *tmp51
+  421 label *label495
+  422 sensor *tmp52 @unit @controlled
+  423 jump *label496 equal *tmp52 0
+  424 sensor *tmp54 @unit @controller
+  425 jump *label499 notEqual *tmp54 @this
+  426 label *label496
+  427 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  428 jump *label497 lessThan :areUnitsAvailable.1:free *tmp51
+  429 set *tmp40 true
+  430 jump *label510 always
+  431 label *label497
+  432 label *label498
+  433 jump *label500 always
+  434 label *label499
+  435 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  436 label *label500
+  437 ubind :chooseUnitType:type
+  438 label *label501
+  439 jump *label503 equal @unit :areUnitsAvailable.1:firstUnit
+  440 label *label502
+  441 sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
+  442 jump *label495 equal *tmp61 0
+  443 label *label503
+  444 label *label504
+  445 label *label505
+  446 jump *label508 equal true false
+  447 print :chooseUnitType:type
+  448 print ":"
+  449 print " occupied: "
+  450 print :areUnitsAvailable.1:occupied
+  451 print ","
+  452 print " free: "
+  453 print :areUnitsAvailable.1:free
+  454 jump *label506 lessThanEq :areUnitsAvailable.1:needed 0
+  455 print ", needed: "
+  456 print :areUnitsAvailable.1:needed
+  457 label *label506
+  458 label *label507
+  459 print "\n"
+  460 label *label508
+  461 label *label509
+  462 set *tmp40 false
+  463 jump *label510 always
+  464 label *label510
+  465 jump *label511 equal *tmp40 false
+  466 printflush null
+  467 set *tmp9 :chooseUnitType:type
+  468 jump *label20 always
+  469 label *label511
+  470 label *label512
+  471 label *label513
+  472 label *label514
+  473 label *label515
+  474 label *label48
   475 printflush message1
   476 label *label22
   477 jump *label21 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   149 label *label25
   150 set :chooseUnitType:type @flare
   151 label *label410
-    * jump *label432 equal :chooseUnitType:type UNIT_TYPE
+  152 jump *label432 equal @flare UNIT_TYPE
   153 # "Function: inline def areUnitsAvailable(in type, in output)"
   154 set :areUnitsAvailable.1:free 0
   155 set :areUnitsAvailable.1:occupied 0
   156 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  157 ubind @flare
   158 set :areUnitsAvailable.1:firstUnit @unit
   159 jump *label423 equal :areUnitsAvailable.1:firstUnit null
   160 # "Function: inline def needsFourUnits(in unit)"
 
   191 label *label418
   192 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   193 label *label419
-    * ubind :chooseUnitType:type
+  194 ubind @flare
   195 label *label420
   196 jump *label422 equal @unit :areUnitsAvailable.1:firstUnit
   197 label *label421
 
   201 label *label423
   202 label *label424
   203 jump *label427 equal true false
-    * print :chooseUnitType:type
+  204 print @flare
   205 print ":"
   206 print " occupied: "
   207 print :areUnitsAvailable.1:occupied
 
   221 label *label429
   222 jump *label430 equal *tmp40 false
   223 printflush null
-    * set *tmp9 :chooseUnitType:type
+  224 set *tmp9 @flare
   225 jump *label20 always
   226 label *label430
   227 label *label431
 
   230 label *label434
   231 set :chooseUnitType:type @poly
   232 label *label437
-    * jump *label459 equal :chooseUnitType:type UNIT_TYPE
+  233 jump *label459 equal @poly UNIT_TYPE
   234 # "Function: inline def areUnitsAvailable(in type, in output)"
   235 set :areUnitsAvailable.1:free 0
   236 set :areUnitsAvailable.1:occupied 0
   237 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  238 ubind @poly
   239 set :areUnitsAvailable.1:firstUnit @unit
   240 jump *label450 equal :areUnitsAvailable.1:firstUnit null
   241 # "Function: inline def needsFourUnits(in unit)"
 
   272 label *label445
   273 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   274 label *label446
-    * ubind :chooseUnitType:type
+  275 ubind @poly
   276 label *label447
   277 jump *label449 equal @unit :areUnitsAvailable.1:firstUnit
   278 label *label448
 
   282 label *label450
   283 label *label451
   284 jump *label454 equal true false
-    * print :chooseUnitType:type
+  285 print @poly
   286 print ":"
   287 print " occupied: "
   288 print :areUnitsAvailable.1:occupied
 
   302 label *label456
   303 jump *label457 equal *tmp40 false
   304 printflush null
-    * set *tmp9 :chooseUnitType:type
+  305 set *tmp9 @poly
   306 jump *label20 always
   307 label *label457
   308 label *label458
 
   311 label *label461
   312 set :chooseUnitType:type @mega
   313 label *label464
-    * jump *label486 equal :chooseUnitType:type UNIT_TYPE
+  314 jump *label486 equal @mega UNIT_TYPE
   315 # "Function: inline def areUnitsAvailable(in type, in output)"
   316 set :areUnitsAvailable.1:free 0
   317 set :areUnitsAvailable.1:occupied 0
   318 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  319 ubind @mega
   320 set :areUnitsAvailable.1:firstUnit @unit
   321 jump *label477 equal :areUnitsAvailable.1:firstUnit null
   322 # "Function: inline def needsFourUnits(in unit)"
 
   353 label *label472
   354 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   355 label *label473
-    * ubind :chooseUnitType:type
+  356 ubind @mega
   357 label *label474
   358 jump *label476 equal @unit :areUnitsAvailable.1:firstUnit
   359 label *label475
 
   363 label *label477
   364 label *label478
   365 jump *label481 equal true false
-    * print :chooseUnitType:type
+  366 print @mega
   367 print ":"
   368 print " occupied: "
   369 print :areUnitsAvailable.1:occupied
 
   383 label *label483
   384 jump *label484 equal *tmp40 false
   385 printflush null
-    * set *tmp9 :chooseUnitType:type
+  386 set *tmp9 @mega
   387 jump *label20 always
   388 label *label484
   389 label *label485
 
   392 label *label488
   393 set :chooseUnitType:type @mono
   394 label *label491
-    * jump *label513 equal :chooseUnitType:type UNIT_TYPE
+  395 jump *label513 equal @mono UNIT_TYPE
   396 # "Function: inline def areUnitsAvailable(in type, in output)"
   397 set :areUnitsAvailable.1:free 0
   398 set :areUnitsAvailable.1:occupied 0
   399 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  400 ubind @mono
   401 set :areUnitsAvailable.1:firstUnit @unit
   402 jump *label504 equal :areUnitsAvailable.1:firstUnit null
   403 # "Function: inline def needsFourUnits(in unit)"
 
   434 label *label499
   435 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   436 label *label500
-    * ubind :chooseUnitType:type
+  437 ubind @mono
   438 label *label501
   439 jump *label503 equal @unit :areUnitsAvailable.1:firstUnit
   440 label *label502
 
   444 label *label504
   445 label *label505
   446 jump *label508 equal true false
-    * print :chooseUnitType:type
+  447 print @mono
   448 print ":"
   449 print " occupied: "
   450 print :areUnitsAvailable.1:occupied
 
   464 label *label510
   465 jump *label511 equal *tmp40 false
   466 printflush null
-    * set *tmp9 :chooseUnitType:type
+  467 set *tmp9 @mono
   468 jump *label20 always
   469 label *label511
   470 label *label512

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
   147 jump *label20 always
   148 label *label24
   149 label *label25
-    * set :chooseUnitType:type @flare
   150 label *label410
   151 jump *label432 equal @flare UNIT_TYPE
   152 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   227 label *label432
   228 label *label433
   229 label *label434
-    * set :chooseUnitType:type @poly
   230 label *label437
   231 jump *label459 equal @poly UNIT_TYPE
   232 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   307 label *label459
   308 label *label460
   309 label *label461
-    * set :chooseUnitType:type @mega
   310 label *label464
   311 jump *label486 equal @mega UNIT_TYPE
   312 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   387 label *label486
   388 label *label487
   389 label *label488
-    * set :chooseUnitType:type @mono
   390 label *label491
   391 jump *label513 equal @mono UNIT_TYPE
   392 # "Function: inline def areUnitsAvailable(in type, in output)"

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-5 instructions):
 
   123 label *label34
   124 label *label27
   125 label *label28
-    * jump *label42 equal true false
   126 print UNIT_TYPE
   127 print ":"
   128 print " occupied: "
 
   198 label *label422
   199 label *label423
   200 label *label424
-    * jump *label427 equal true false
   201 print @flare
   202 print ":"
   203 print " occupied: "
 
   277 label *label449
   278 label *label450
   279 label *label451
-    * jump *label454 equal true false
   280 print @poly
   281 print ":"
   282 print " occupied: "
 
   356 label *label476
   357 label *label477
   358 label *label478
-    * jump *label481 equal true false
   359 print @mega
   360 print ":"
   361 print " occupied: "
 
   435 label *label503
   436 label *label504
   437 label *label505
-    * jump *label508 equal true false
   438 print @mono
   439 print ":"
   440 print " occupied: "
 
  1444 label *label363
  1445 label *label356
  1446 label *label357
-    * jump *label371 equal false false
+ 1447 jump *label371 always
  1448 print UNIT_TYPE
  1449 print ":"
  1450 print " occupied: "

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1 (-4 instructions):
 
    88 op mul *tmp17 2 *tmp16
    89 sensor *tmp18 :needsFourUnits:unit @speed
    90 op div :needsFourUnits:travel_time *tmp17 *tmp18
-    * op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    91 jump *label31 always
    92 label *label31
-    * jump *label29 equal *tmp13 false
+   93 jump *label29 lessThan :needsFourUnits:travel_time 47
    94 set *tmp21 4
    95 jump *label30 always
    96 label *label29
 
   165 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   166 jump *label411 always
   167 label *label411
-    * jump *label412 equal *tmp43 false
+  168 jump *label412 lessThan :needsFourUnits.1:travel_time 47
   169 set *tmp51 4
   170 jump *label413 always
   171 label *label412
 
   244 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   245 jump *label438 always
   246 label *label438
-    * jump *label439 equal *tmp43 false
+  247 jump *label439 lessThan :needsFourUnits.1:travel_time 47
   248 set *tmp51 4
   249 jump *label440 always
   250 label *label439
 
   323 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   324 jump *label465 always
   325 label *label465
-    * jump *label466 equal *tmp43 false
+  326 jump *label466 lessThan :needsFourUnits.1:travel_time 47
   327 set *tmp51 4
   328 jump *label467 always
   329 label *label466
 
   402 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   403 jump *label492 always
   404 label *label492
-    * jump *label493 equal *tmp43 false
+  405 jump *label493 lessThan :needsFourUnits.1:travel_time 47
   406 set *tmp51 4
   407 jump *label494 always
   408 label *label493
 
   614 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   615 jump *label123 always
   616 label *label123
-    * jump *label124 equal *tmp126 false
+  617 jump *label124 lessThan :needsFourUnits.2:travel_time 47
   618 # "Function: inline def acquireUnit(in currentUnit)"
   619 # "Function: inline def rebindUnit(in currentUnit)"
   620 jump *label128 equal .UNIT_S2 null
 
   920 label *label178
   921 set .UNIT_S1 :processUnit:unit
   922 jump *label218 equal *tmp126 false
-    * op equal *tmp259 .SUPPLY_S_FIRST false
   923 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   924 # "Function: inline def rebindUnit(in currentUnit)"
   925 jump *label222 equal .UNIT_S2 null
 
  1010 jump *label250 notEqual :processUnit.1:state 3
  1011 ucontrol within .DOME_X .DOME_Y 8 *tmp305
  1012 jump *label252 equal *tmp305 false
-    * jump *label254 equal *tmp259 false
+ 1013 jump *label254 notEqual .SUPPLY_S_FIRST false
  1014 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1015 set .MSG ", supplying\n"
  1016 jump *label255 always
 
  1233 label *label265
  1234 set .UNIT_P1 :processUnit.2:unit
  1235 jump *label305 equal *tmp126 false
-    * op equal *tmp393 .SUPPLY_P_FIRST false
  1236 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
  1237 # "Function: inline def rebindUnit(in currentUnit)"
  1238 jump *label309 equal .UNIT_P2 null
 
  1323 jump *label337 notEqual :processUnit.3:state 3
  1324 ucontrol within .DOME_X .DOME_Y 8 *tmp439
  1325 jump *label339 equal *tmp439 false
-    * jump *label341 equal *tmp393 false
+ 1326 jump *label341 notEqual .SUPPLY_P_FIRST false
  1327 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1328 set .MSG ", supplying\n"
  1329 jump *label342 always
 
  1406 set :needsFourUnits.3:unit @unit
  1407 sensor *tmp474 :needsFourUnits.3:unit @speed
  1408 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
-    * op greaterThanEq *tmp469 :needsFourUnits.3:travel_time 47
  1409 jump *label360 always
  1410 label *label360
-    * jump *label358 equal *tmp469 false
+ 1411 jump *label358 lessThan :needsFourUnits.3:travel_time 47
  1412 set *tmp477 4
  1413 jump *label359 always
  1414 label *label358

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-17 instructions):
 
    88 op mul *tmp17 2 *tmp16
    89 sensor *tmp18 :needsFourUnits:unit @speed
    90 op div :needsFourUnits:travel_time *tmp17 *tmp18
-    * jump *label31 always
    91 label *label31
    92 jump *label29 lessThan :needsFourUnits:travel_time 47
    93 set *tmp21 4
 
   137 label *label42
   138 label *label43
   139 set *tmp10 false
-    * jump *label26 always
   140 label *label26
   141 jump *label24 equal *tmp10 false
   142 set *tmp9 UNIT_TYPE
 
   161 sensor *tmp48 :needsFourUnits.1:unit @speed
   162 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   163 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label411 always
   164 label *label411
   165 jump *label412 lessThan :needsFourUnits.1:travel_time 47
   166 set *tmp51 4
 
   210 label *label427
   211 label *label428
   212 set *tmp40 false
-    * jump *label429 always
   213 label *label429
   214 jump *label430 equal *tmp40 false
   215 printflush null
 
   238 sensor *tmp48 :needsFourUnits.1:unit @speed
   239 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   240 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label438 always
   241 label *label438
   242 jump *label439 lessThan :needsFourUnits.1:travel_time 47
   243 set *tmp51 4
 
   287 label *label454
   288 label *label455
   289 set *tmp40 false
-    * jump *label456 always
   290 label *label456
   291 jump *label457 equal *tmp40 false
   292 printflush null
 
   315 sensor *tmp48 :needsFourUnits.1:unit @speed
   316 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   317 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label465 always
   318 label *label465
   319 jump *label466 lessThan :needsFourUnits.1:travel_time 47
   320 set *tmp51 4
 
   364 label *label481
   365 label *label482
   366 set *tmp40 false
-    * jump *label483 always
   367 label *label483
   368 jump *label484 equal *tmp40 false
   369 printflush null
 
   392 sensor *tmp48 :needsFourUnits.1:unit @speed
   393 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
   394 op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
-    * jump *label492 always
   395 label *label492
   396 jump *label493 lessThan :needsFourUnits.1:travel_time 47
   397 set *tmp51 4
 
   441 label *label508
   442 label *label509
   443 set *tmp40 false
-    * jump *label510 always
   444 label *label510
   445 jump *label511 equal *tmp40 false
   446 printflush null
 
   532 label *label89
   533 ucontrol flag 1
   534 set *tmp80 @unit
-    * jump *label88 always
   535 label *label88
   536 set .UNIT_S1 *tmp80
   537 # "Function: inline def acquireUnit(in currentUnit)"
 
   571 label *label103
   572 ucontrol flag 1
   573 set *tmp98 @unit
-    * jump *label102 always
   574 label *label102
   575 set .UNIT_P1 *tmp98
   576 sensor *tmp116 *tmp80 @firstItem
 
   600 sensor *tmp131 .UNIT_S1 @speed
   601 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   602 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
-    * jump *label123 always
   603 label *label123
   604 jump *label124 lessThan :needsFourUnits.2:travel_time 47
   605 # "Function: inline def acquireUnit(in currentUnit)"
 
   639 label *label127
   640 ucontrol flag 1
   641 set *tmp135 @unit
-    * jump *label126 always
   642 label *label126
   643 set .UNIT_S2 *tmp135
   644 # "Function: inline def acquireUnit(in currentUnit)"
 
   678 label *label141
   679 ucontrol flag 1
   680 set *tmp153 @unit
-    * jump *label140 always
   681 label *label140
   682 set .UNIT_P2 *tmp153
   683 sensor *tmp171 .UNIT_S1 @firstItem
 
  1391 set :needsFourUnits.3:unit @unit
  1392 sensor *tmp474 :needsFourUnits.3:unit @speed
  1393 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
-    * jump *label360 always
  1394 label *label360
  1395 jump *label358 lessThan :needsFourUnits.3:travel_time 47
  1396 set *tmp477 4
 
  1441 label *label371
  1442 label *label372
  1443 set *tmp466 false
-    * jump *label355 always
  1444 label *label355
  1445 jump *label353 equal *tmp466 false
  1446 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-6 instructions):
 
   160 op mul *tmp47 2 *tmp46
   161 sensor *tmp48 :needsFourUnits.1:unit @speed
   162 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   163 label *label411
   164 jump *label412 lessThan :needsFourUnits.1:travel_time 47
   165 set *tmp51 4
 
   236 op mul *tmp47 2 *tmp46
   237 sensor *tmp48 :needsFourUnits.1:unit @speed
   238 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   239 label *label438
   240 jump *label439 lessThan :needsFourUnits.1:travel_time 47
   241 set *tmp51 4
 
   312 op mul *tmp47 2 *tmp46
   313 sensor *tmp48 :needsFourUnits.1:unit @speed
   314 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   315 label *label465
   316 jump *label466 lessThan :needsFourUnits.1:travel_time 47
   317 set *tmp51 4
 
   388 op mul *tmp47 2 *tmp46
   389 sensor *tmp48 :needsFourUnits.1:unit @speed
   390 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * op greaterThanEq *tmp43 :needsFourUnits.1:travel_time 47
   391 label *label492
   392 jump *label493 lessThan :needsFourUnits.1:travel_time 47
   393 set *tmp51 4
 
  1379 # "Function: inline def areUnitsAvailable(in type, in output)"
  1380 set :areUnitsAvailable.2:free 0
  1381 set :areUnitsAvailable.2:occupied 0
-    * set :areUnitsAvailable.2:needed 0
  1382 ubind UNIT_TYPE
  1383 set :areUnitsAvailable.2:firstUnit @unit
  1384 jump *label356 equal :areUnitsAvailable.2:firstUnit null
 
  1393 label *label358
  1394 set *tmp477 2
  1395 label *label359
-    * set :areUnitsAvailable.2:needed *tmp477
  1396 label *label361
  1397 sensor *tmp478 @unit @controlled
  1398 jump *label366 equal *tmp478 0

Modifications by Iterated phase, Boolean Optimization, pass 2, iteration 1 (-18 instructions):
 
    80 ubind UNIT_TYPE
    81 set :areUnitsAvailable:firstUnit @unit
    82 jump *label27 equal :areUnitsAvailable:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits:unit @unit
-    * op sub *tmp14 .DOME_X .CORE_X
-    * op sub *tmp15 .DOME_Y .CORE_Y
-    * op len *tmp16 *tmp14 *tmp15
-    * op mul *tmp17 2 *tmp16
-    * sensor *tmp18 :needsFourUnits:unit @speed
-    * op div :needsFourUnits:travel_time *tmp17 *tmp18
-    * label *label31
-    * jump *label29 lessThan :needsFourUnits:travel_time 47
-    * set *tmp21 4
-    * jump *label30 always
-    * label *label29
-    * set *tmp21 2
-    * label *label30
+   83 # "Function: inline def needsFourUnits(in unit)"
+   84 set :needsFourUnits:unit @unit
+   85 op sub *tmp14 .DOME_X .CORE_X
+   86 op sub *tmp15 .DOME_Y .CORE_Y
+   87 op len *tmp16 *tmp14 *tmp15
+   88 op mul *tmp17 2 *tmp16
+   89 sensor *tmp18 :needsFourUnits:unit @speed
+   90 op div :needsFourUnits:travel_time *tmp17 *tmp18
+   91 label *label519
+   92 select *tmp21 greaterThanEq :needsFourUnits:travel_time 47 4 2
    93 set :areUnitsAvailable:needed *tmp21
    94 label *label32
    95 sensor *tmp22 @unit @controlled
 
   147 ubind @flare
   148 set :areUnitsAvailable.1:firstUnit @unit
   149 jump *label423 equal :areUnitsAvailable.1:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp44 .DOME_X .CORE_X
-    * op sub *tmp45 .DOME_Y .CORE_Y
-    * op len *tmp46 *tmp44 *tmp45
-    * op mul *tmp47 2 *tmp46
-    * sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * label *label411
-    * jump *label412 lessThan :needsFourUnits.1:travel_time 47
-    * set *tmp51 4
-    * jump *label413 always
-    * label *label412
-    * set *tmp51 2
-    * label *label413
+  150 # "Function: inline def needsFourUnits(in unit)"
+  151 set :needsFourUnits.1:unit @unit
+  152 op sub *tmp44 .DOME_X .CORE_X
+  153 op sub *tmp45 .DOME_Y .CORE_Y
+  154 op len *tmp46 *tmp44 *tmp45
+  155 op mul *tmp47 2 *tmp46
+  156 sensor *tmp48 :needsFourUnits.1:unit @speed
+  157 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  158 label *label520
+  159 select *tmp51 greaterThanEq :needsFourUnits.1:travel_time 47 4 2
   160 set :areUnitsAvailable.1:needed *tmp51
   161 label *label414
   162 sensor *tmp52 @unit @controlled
 
   218 ubind @poly
   219 set :areUnitsAvailable.1:firstUnit @unit
   220 jump *label450 equal :areUnitsAvailable.1:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp44 .DOME_X .CORE_X
-    * op sub *tmp45 .DOME_Y .CORE_Y
-    * op len *tmp46 *tmp44 *tmp45
-    * op mul *tmp47 2 *tmp46
-    * sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * label *label438
-    * jump *label439 lessThan :needsFourUnits.1:travel_time 47
-    * set *tmp51 4
-    * jump *label440 always
-    * label *label439
-    * set *tmp51 2
-    * label *label440
+  221 # "Function: inline def needsFourUnits(in unit)"
+  222 set :needsFourUnits.1:unit @unit
+  223 op sub *tmp44 .DOME_X .CORE_X
+  224 op sub *tmp45 .DOME_Y .CORE_Y
+  225 op len *tmp46 *tmp44 *tmp45
+  226 op mul *tmp47 2 *tmp46
+  227 sensor *tmp48 :needsFourUnits.1:unit @speed
+  228 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  229 label *label521
+  230 select *tmp51 greaterThanEq :needsFourUnits.1:travel_time 47 4 2
   231 set :areUnitsAvailable.1:needed *tmp51
   232 label *label441
   233 sensor *tmp52 @unit @controlled
 
   289 ubind @mega
   290 set :areUnitsAvailable.1:firstUnit @unit
   291 jump *label477 equal :areUnitsAvailable.1:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp44 .DOME_X .CORE_X
-    * op sub *tmp45 .DOME_Y .CORE_Y
-    * op len *tmp46 *tmp44 *tmp45
-    * op mul *tmp47 2 *tmp46
-    * sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * label *label465
-    * jump *label466 lessThan :needsFourUnits.1:travel_time 47
-    * set *tmp51 4
-    * jump *label467 always
-    * label *label466
-    * set *tmp51 2
-    * label *label467
+  292 # "Function: inline def needsFourUnits(in unit)"
+  293 set :needsFourUnits.1:unit @unit
+  294 op sub *tmp44 .DOME_X .CORE_X
+  295 op sub *tmp45 .DOME_Y .CORE_Y
+  296 op len *tmp46 *tmp44 *tmp45
+  297 op mul *tmp47 2 *tmp46
+  298 sensor *tmp48 :needsFourUnits.1:unit @speed
+  299 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  300 label *label522
+  301 select *tmp51 greaterThanEq :needsFourUnits.1:travel_time 47 4 2
   302 set :areUnitsAvailable.1:needed *tmp51
   303 label *label468
   304 sensor *tmp52 @unit @controlled
 
   360 ubind @mono
   361 set :areUnitsAvailable.1:firstUnit @unit
   362 jump *label504 equal :areUnitsAvailable.1:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp44 .DOME_X .CORE_X
-    * op sub *tmp45 .DOME_Y .CORE_Y
-    * op len *tmp46 *tmp44 *tmp45
-    * op mul *tmp47 2 *tmp46
-    * sensor *tmp48 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp47 *tmp48
-    * label *label492
-    * jump *label493 lessThan :needsFourUnits.1:travel_time 47
-    * set *tmp51 4
-    * jump *label494 always
-    * label *label493
-    * set *tmp51 2
-    * label *label494
+  363 # "Function: inline def needsFourUnits(in unit)"
+  364 set :needsFourUnits.1:unit @unit
+  365 op sub *tmp44 .DOME_X .CORE_X
+  366 op sub *tmp45 .DOME_Y .CORE_Y
+  367 op len *tmp46 *tmp44 *tmp45
+  368 op mul *tmp47 2 *tmp46
+  369 sensor *tmp48 :needsFourUnits.1:unit @speed
+  370 op div :needsFourUnits.1:travel_time *tmp47 *tmp48
+  371 label *label523
+  372 select *tmp51 greaterThanEq :needsFourUnits.1:travel_time 47 4 2
   373 set :areUnitsAvailable.1:needed *tmp51
   374 label *label495
   375 sensor *tmp52 @unit @controlled
 
  1357 ubind UNIT_TYPE
  1358 set :areUnitsAvailable.2:firstUnit @unit
  1359 jump *label356 equal :areUnitsAvailable.2:firstUnit null
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.3:unit @unit
-    * sensor *tmp474 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp130 *tmp474
-    * label *label360
-    * jump *label358 lessThan :needsFourUnits.3:travel_time 47
-    * set *tmp477 4
-    * jump *label359 always
-    * label *label358
-    * set *tmp477 2
-    * label *label359
+ 1360 # "Function: inline def needsFourUnits(in unit)"
+ 1361 set :needsFourUnits.3:unit @unit
+ 1362 sensor *tmp474 :needsFourUnits.3:unit @speed
+ 1363 op div :needsFourUnits.3:travel_time *tmp130 *tmp474
+ 1364 label *label524
+ 1365 select *tmp477 greaterThanEq :needsFourUnits.3:travel_time 47 4 2
  1366 label *label361
  1367 sensor *tmp478 @unit @controlled
  1368 jump *label366 equal *tmp478 0

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-21 instructions):
 
    16 label *label5
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label384 equal :locateCore*retval false
-    * jump *label1 always
+   19 jump *label1 notEqual :locateCore*retval false
    20 label *label384
    21 set :locateCore:type @poly
    22 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label390 equal :locateCore*retval false
-    * jump *label1 always
+   23 jump *label1 notEqual :locateCore*retval false
    24 label *label390
    25 set :locateCore:type @mega
    26 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label396 equal :locateCore*retval false
-    * jump *label1 always
+   27 jump *label1 notEqual :locateCore*retval false
    28 label *label396
    29 set :locateCore:type @mono
    30 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label402 equal :locateCore*retval false
-    * jump *label1 always
+   31 jump *label1 notEqual :locateCore*retval false
    32 label *label402
    33 jump *label5 always
    34 label *label1
 
   368 set .UNIT_P2 .UNIT_S1
   369 set .UNIT_S1 .UNIT_P1
   370 set .UNIT_P1 @unit
-    * jump *label85 equal .UNIT_S2 null
-    * jump *label82 always
+  371 jump *label82 notEqual .UNIT_S2 null
   372 label *label85
   373 label *label83
   374 ubind *tmp9
 
   385 sensor *tmp86 @unit @controller
   386 op equal *tmp87 *tmp86 @this
   387 op land *tmp88 *tmp85 *tmp87
-    * jump *label92 equal *tmp88 false
-    * jump *label89 always
+  388 jump *label89 notEqual *tmp88 false
   389 label *label92
   390 label *label90
   391 ubind *tmp9
 
   393 jump *label94 equal :rebindUnit:firstUnit null
   394 label *label96
   395 sensor *tmp92 @unit @controlled
-    * jump *label99 notEqual *tmp92 0
-    * jump *label89 always
+  396 jump *label89 equal *tmp92 0
   397 label *label99
   398 ubind *tmp9
   399 jump *label98 equal @unit :rebindUnit:firstUnit
 
   415 sensor *tmp104 @unit @controller
   416 op equal *tmp105 *tmp104 @this
   417 op land *tmp106 *tmp103 *tmp105
-    * jump *label106 equal *tmp106 false
-    * jump *label103 always
+  418 jump *label103 notEqual *tmp106 false
   419 label *label106
   420 label *label104
   421 ubind *tmp9
 
   423 jump *label108 equal :rebindUnit.1:firstUnit null
   424 label *label110
   425 sensor *tmp110 @unit @controlled
-    * jump *label113 notEqual *tmp110 0
-    * jump *label103 always
+  426 jump *label103 equal *tmp110 0
   427 label *label113
   428 ubind *tmp9
   429 jump *label112 equal @unit :rebindUnit.1:firstUnit
 
   470 sensor *tmp141 @unit @controller
   471 op equal *tmp142 *tmp141 @this
   472 op land *tmp143 *tmp140 *tmp142
-    * jump *label130 equal *tmp143 false
-    * jump *label127 always
+  473 jump *label127 notEqual *tmp143 false
   474 label *label130
   475 label *label128
   476 ubind *tmp9
 
   478 jump *label132 equal :rebindUnit.2:firstUnit null
   479 label *label134
   480 sensor *tmp147 @unit @controlled
-    * jump *label137 notEqual *tmp147 0
-    * jump *label127 always
+  481 jump *label127 equal *tmp147 0
   482 label *label137
   483 ubind *tmp9
   484 jump *label136 equal @unit :rebindUnit.2:firstUnit
 
   500 sensor *tmp159 @unit @controller
   501 op equal *tmp160 *tmp159 @this
   502 op land *tmp161 *tmp158 *tmp160
-    * jump *label144 equal *tmp161 false
-    * jump *label141 always
+  503 jump *label141 notEqual *tmp161 false
   504 label *label144
   505 label *label142
   506 ubind *tmp9
 
   508 jump *label146 equal :rebindUnit.3:firstUnit null
   509 label *label148
   510 sensor *tmp165 @unit @controlled
-    * jump *label151 notEqual *tmp165 0
-    * jump *label141 always
+  511 jump *label141 equal *tmp165 0
   512 label *label151
   513 ubind *tmp9
   514 jump *label150 equal @unit :rebindUnit.3:firstUnit
 
   606 sensor *tmp201 @unit @controller
   607 op equal *tmp202 *tmp201 @this
   608 op land *tmp203 *tmp200 *tmp202
-    * jump *label182 equal *tmp203 false
-    * jump *label179 always
+  609 jump *label179 notEqual *tmp203 false
   610 label *label182
   611 label *label180
   612 ubind *tmp9
 
   614 jump *label184 equal :rebindUnit.4:firstUnit null
   615 label *label186
   616 sensor *tmp207 @unit @controlled
-    * jump *label189 notEqual *tmp207 0
-    * jump *label179 always
+  617 jump *label179 equal *tmp207 0
   618 label *label189
   619 ubind *tmp9
   620 jump *label188 equal @unit :rebindUnit.4:firstUnit
 
   735 sensor *tmp265 @unit @controller
   736 op equal *tmp266 *tmp265 @this
   737 op land *tmp267 *tmp264 *tmp266
-    * jump *label224 equal *tmp267 false
-    * jump *label221 always
+  738 jump *label221 notEqual *tmp267 false
   739 label *label224
   740 label *label222
   741 ubind *tmp9
 
   743 jump *label226 equal :rebindUnit.5:firstUnit null
   744 label *label228
   745 sensor *tmp271 @unit @controlled
-    * jump *label231 notEqual *tmp271 0
-    * jump *label221 always
+  746 jump *label221 equal *tmp271 0
   747 label *label231
   748 ubind *tmp9
   749 jump *label230 equal @unit :rebindUnit.5:firstUnit
 
   889 sensor *tmp335 @unit @controller
   890 op equal *tmp336 *tmp335 @this
   891 op land *tmp337 *tmp334 *tmp336
-    * jump *label269 equal *tmp337 false
-    * jump *label266 always
+  892 jump *label266 notEqual *tmp337 false
   893 label *label269
   894 label *label267
   895 ubind *tmp9
 
   897 jump *label271 equal :rebindUnit.6:firstUnit null
   898 label *label273
   899 sensor *tmp341 @unit @controlled
-    * jump *label276 notEqual *tmp341 0
-    * jump *label266 always
+  900 jump *label266 equal *tmp341 0
   901 label *label276
   902 ubind *tmp9
   903 jump *label275 equal @unit :rebindUnit.6:firstUnit
 
  1018 sensor *tmp399 @unit @controller
  1019 op equal *tmp400 *tmp399 @this
  1020 op land *tmp401 *tmp398 *tmp400
-    * jump *label311 equal *tmp401 false
-    * jump *label308 always
+ 1021 jump *label308 notEqual *tmp401 false
  1022 label *label311
  1023 label *label309
  1024 ubind *tmp9
 
  1026 jump *label313 equal :rebindUnit.7:firstUnit null
  1027 label *label315
  1028 sensor *tmp405 @unit @controlled
-    * jump *label318 notEqual *tmp405 0
-    * jump *label308 always
+ 1029 jump *label308 equal *tmp405 0
  1030 label *label318
  1031 ubind *tmp9
  1032 jump *label317 equal @unit :rebindUnit.7:firstUnit

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @flare
 
    71 jump *label35 notEqual *tmp24 @this
    72 label *label37
    73 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label39 lessThan :areUnitsAvailable:free *tmp21
+   74 jump *label36 lessThan :areUnitsAvailable:free *tmp21
    75 set *tmp10 true
    76 jump *label26 always
    77 label *label39
 
   128 jump *label418 notEqual *tmp54 @this
   129 label *label415
   130 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label416 lessThan :areUnitsAvailable.1:free *tmp51
+  131 jump *label419 lessThan :areUnitsAvailable.1:free *tmp51
   132 set *tmp40 true
   133 jump *label429 always
   134 label *label416
 
   187 jump *label445 notEqual *tmp54 @this
   188 label *label442
   189 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label443 lessThan :areUnitsAvailable.1:free *tmp51
+  190 jump *label446 lessThan :areUnitsAvailable.1:free *tmp51
   191 set *tmp40 true
   192 jump *label456 always
   193 label *label443
 
   246 jump *label472 notEqual *tmp54 @this
   247 label *label469
   248 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label470 lessThan :areUnitsAvailable.1:free *tmp51
+  249 jump *label473 lessThan :areUnitsAvailable.1:free *tmp51
   250 set *tmp40 true
   251 jump *label483 always
   252 label *label470
 
   305 jump *label499 notEqual *tmp54 @this
   306 label *label496
   307 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label497 lessThan :areUnitsAvailable.1:free *tmp51
+  308 jump *label500 lessThan :areUnitsAvailable.1:free *tmp51
   309 set *tmp40 true
   310 jump *label510 always
   311 label *label497
 
   385 label *label90
   386 ubind *tmp9
   387 set :rebindUnit:firstUnit @unit
-    * jump *label94 equal :rebindUnit:firstUnit null
+  388 jump __start__ equal :rebindUnit:firstUnit null
   389 label *label96
   390 sensor *tmp92 @unit @controlled
   391 jump *label89 equal *tmp92 0
   392 ubind *tmp9
-    * jump *label98 equal @unit :rebindUnit:firstUnit
+  393 jump __start__ equal @unit :rebindUnit:firstUnit
   394 sensor *tmp96 :rebindUnit:firstUnit @dead
   395 jump *label96 equal *tmp96 0
   396 label *label98
 
   413 label *label104
   414 ubind *tmp9
   415 set :rebindUnit.1:firstUnit @unit
-    * jump *label108 equal :rebindUnit.1:firstUnit null
+  416 jump __start__ equal :rebindUnit.1:firstUnit null
   417 label *label110
   418 sensor *tmp110 @unit @controlled
   419 jump *label103 equal *tmp110 0
   420 ubind *tmp9
-    * jump *label112 equal @unit :rebindUnit.1:firstUnit
+  421 jump __start__ equal @unit :rebindUnit.1:firstUnit
   422 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   423 jump *label110 equal *tmp114 0
   424 label *label112
 
   466 label *label128
   467 ubind *tmp9
   468 set :rebindUnit.2:firstUnit @unit
-    * jump *label132 equal :rebindUnit.2:firstUnit null
+  469 jump __start__ equal :rebindUnit.2:firstUnit null
   470 label *label134
   471 sensor *tmp147 @unit @controlled
   472 jump *label127 equal *tmp147 0
   473 ubind *tmp9
-    * jump *label136 equal @unit :rebindUnit.2:firstUnit
+  474 jump __start__ equal @unit :rebindUnit.2:firstUnit
   475 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   476 jump *label134 equal *tmp151 0
   477 label *label136
 
   494 label *label142
   495 ubind *tmp9
   496 set :rebindUnit.3:firstUnit @unit
-    * jump *label146 equal :rebindUnit.3:firstUnit null
+  497 jump __start__ equal :rebindUnit.3:firstUnit null
   498 label *label148
   499 sensor *tmp165 @unit @controlled
   500 jump *label141 equal *tmp165 0
   501 ubind *tmp9
-    * jump *label150 equal @unit :rebindUnit.3:firstUnit
+  502 jump __start__ equal @unit :rebindUnit.3:firstUnit
   503 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   504 jump *label148 equal *tmp169 0
   505 label *label150
 
   557 label *label169
   558 op add :unitCheck @time 5000
   559 sensor *tmp192 switch1 @enabled
-    * jump *label174 equal *tmp192 false
+  560 jump __start__ equal *tmp192 false
   561 label *label409
   562 set :start @time
   563 print " === [gold]Supplying Overdrive Dome[] === "
 
   598 label *label180
   599 ubind *tmp9
   600 set :rebindUnit.4:firstUnit @unit
-    * jump *label184 equal :rebindUnit.4:firstUnit null
+  601 jump __start__ equal :rebindUnit.4:firstUnit null
   602 label *label186
   603 sensor *tmp207 @unit @controlled
   604 jump *label179 equal *tmp207 0
   605 ubind *tmp9
-    * jump *label188 equal @unit :rebindUnit.4:firstUnit
+  606 jump __start__ equal @unit :rebindUnit.4:firstUnit
   607 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   608 jump *label186 equal *tmp211 0
   609 label *label188
 
   642 jump *label206 lessThan *tmp229 .UNIT_CAPACITY
   643 ucontrol approach .DOME_X .DOME_Y 6
   644 set :processUnit:state 3
-    * jump *label207 always
+  645 jump *label205 always
   646 label *label206
   647 set .MSG ", loading\n"
   648 label *label207
 
   671 set .MSG ", waiting\n"
   672 label *label213
   673 sensor *tmp244 @unit @totalItems
-    * jump *label214 greaterThan *tmp244 0
+  674 jump *label211 greaterThan *tmp244 0
   675 ucontrol approach .CORE_X .CORE_Y 6
   676 set :processUnit:state 2
   677 label *label214
 
   725 label *label222
   726 ubind *tmp9
   727 set :rebindUnit.5:firstUnit @unit
-    * jump *label226 equal :rebindUnit.5:firstUnit null
+  728 jump __start__ equal :rebindUnit.5:firstUnit null
   729 label *label228
   730 sensor *tmp271 @unit @controlled
   731 jump *label221 equal *tmp271 0
   732 ubind *tmp9
-    * jump *label230 equal @unit :rebindUnit.5:firstUnit
+  733 jump __start__ equal @unit :rebindUnit.5:firstUnit
   734 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   735 jump *label228 equal *tmp275 0
   736 label *label230
 
   769 jump *label248 lessThan *tmp293 .UNIT_CAPACITY
   770 ucontrol approach .DOME_X .DOME_Y 6
   771 set :processUnit.1:state 3
-    * jump *label249 always
+  772 jump *label247 always
   773 label *label248
   774 set .MSG ", loading\n"
   775 label *label249
 
   798 set .MSG ", waiting\n"
   799 label *label255
   800 sensor *tmp308 @unit @totalItems
-    * jump *label256 greaterThan *tmp308 0
+  801 jump *label253 greaterThan *tmp308 0
   802 ucontrol approach .CORE_X .CORE_Y 6
   803 set :processUnit.1:state 2
   804 label *label256
 
   877 label *label267
   878 ubind *tmp9
   879 set :rebindUnit.6:firstUnit @unit
-    * jump *label271 equal :rebindUnit.6:firstUnit null
+  880 jump __start__ equal :rebindUnit.6:firstUnit null
   881 label *label273
   882 sensor *tmp341 @unit @controlled
   883 jump *label266 equal *tmp341 0
   884 ubind *tmp9
-    * jump *label275 equal @unit :rebindUnit.6:firstUnit
+  885 jump __start__ equal @unit :rebindUnit.6:firstUnit
   886 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   887 jump *label273 equal *tmp345 0
   888 label *label275
 
   921 jump *label293 lessThan *tmp363 .UNIT_CAPACITY
   922 ucontrol approach .DOME_X .DOME_Y 6
   923 set :processUnit.2:state 3
-    * jump *label294 always
+  924 jump *label292 always
   925 label *label293
   926 set .MSG ", loading\n"
   927 label *label294
 
   950 set .MSG ", waiting\n"
   951 label *label300
   952 sensor *tmp378 @unit @totalItems
-    * jump *label301 greaterThan *tmp378 0
+  953 jump *label298 greaterThan *tmp378 0
   954 ucontrol approach .CORE_X .CORE_Y 6
   955 set :processUnit.2:state 2
   956 label *label301
 
  1004 label *label309
  1005 ubind *tmp9
  1006 set :rebindUnit.7:firstUnit @unit
-    * jump *label313 equal :rebindUnit.7:firstUnit null
+ 1007 jump __start__ equal :rebindUnit.7:firstUnit null
  1008 label *label315
  1009 sensor *tmp405 @unit @controlled
  1010 jump *label308 equal *tmp405 0
  1011 ubind *tmp9
-    * jump *label317 equal @unit :rebindUnit.7:firstUnit
+ 1012 jump __start__ equal @unit :rebindUnit.7:firstUnit
  1013 sensor *tmp409 :rebindUnit.7:firstUnit @dead
  1014 jump *label315 equal *tmp409 0
  1015 label *label317
 
  1048 jump *label335 lessThan *tmp427 .UNIT_CAPACITY
  1049 ucontrol approach .DOME_X .DOME_Y 6
  1050 set :processUnit.3:state 3
-    * jump *label336 always
+ 1051 jump *label334 always
  1052 label *label335
  1053 set .MSG ", loading\n"
  1054 label *label336
 
  1077 set .MSG ", waiting\n"
  1078 label *label342
  1079 sensor *tmp442 @unit @totalItems
-    * jump *label343 greaterThan *tmp442 0
+ 1080 jump *label340 greaterThan *tmp442 0
  1081 ucontrol approach .CORE_X .CORE_Y 6
  1082 set :processUnit.3:state 2
  1083 label *label343
 
  1141 set :areUnitsAvailable.2:occupied 0
  1142 ubind UNIT_TYPE
  1143 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label356 equal :areUnitsAvailable.2:firstUnit null
+ 1144 jump *label371 equal :areUnitsAvailable.2:firstUnit null
  1145 # "Function: inline def needsFourUnits(in unit)"
  1146 set :needsFourUnits.3:unit @unit
  1147 sensor *tmp474 :needsFourUnits.3:unit @speed
 
  1154 jump *label364 notEqual *tmp480 @this
  1155 label *label366
  1156 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label368 lessThan :areUnitsAvailable.2:free *tmp477
+ 1157 jump *label365 lessThan :areUnitsAvailable.2:free *tmp477
  1158 set *tmp466 true
  1159 jump *label355 always
  1160 label *label368
 
  1163 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1164 label *label365
  1165 ubind UNIT_TYPE
-    * jump *label363 equal @unit :areUnitsAvailable.2:firstUnit
+ 1166 jump *label371 equal @unit :areUnitsAvailable.2:firstUnit
  1167 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1168 jump *label361 equal *tmp487 0
  1169 label *label363

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-19 instructions):
 
    74 jump *label36 lessThan :areUnitsAvailable:free *tmp21
    75 set *tmp10 true
    76 jump *label26 always
-    * label *label39
-    * jump *label36 always
    77 label *label35
    78 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    79 label *label36
 
   129 jump *label419 lessThan :areUnitsAvailable.1:free *tmp51
   130 set *tmp40 true
   131 jump *label429 always
-    * label *label416
-    * jump *label419 always
   132 label *label418
   133 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   134 label *label419
 
   186 jump *label446 lessThan :areUnitsAvailable.1:free *tmp51
   187 set *tmp40 true
   188 jump *label456 always
-    * label *label443
-    * jump *label446 always
   189 label *label445
   190 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   191 label *label446
 
   243 jump *label473 lessThan :areUnitsAvailable.1:free *tmp51
   244 set *tmp40 true
   245 jump *label483 always
-    * label *label470
-    * jump *label473 always
   246 label *label472
   247 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   248 label *label473
 
   300 jump *label500 lessThan :areUnitsAvailable.1:free *tmp51
   301 set *tmp40 true
   302 jump *label510 always
-    * label *label497
-    * jump *label500 always
   303 label *label499
   304 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   305 label *label500
 
   331 label *label513
   332 printflush message1
   333 jump *label21 always
-    * set *tmp9 null
   334 label *label20
   335 print "[gold]Binding units..."
   336 printflush message1
 
   382 jump __start__ equal @unit :rebindUnit:firstUnit
   383 sensor *tmp96 :rebindUnit:firstUnit @dead
   384 jump *label96 equal *tmp96 0
-    * label *label98
-    * label *label94
   385 end
   386 label *label89
   387 ucontrol flag 1
 
   408 jump __start__ equal @unit :rebindUnit.1:firstUnit
   409 sensor *tmp114 :rebindUnit.1:firstUnit @dead
   410 jump *label110 equal *tmp114 0
-    * label *label112
-    * label *label108
   411 end
   412 label *label103
   413 ucontrol flag 1
 
   459 jump __start__ equal @unit :rebindUnit.2:firstUnit
   460 sensor *tmp151 :rebindUnit.2:firstUnit @dead
   461 jump *label134 equal *tmp151 0
-    * label *label136
-    * label *label132
   462 end
   463 label *label127
   464 ucontrol flag 1
 
   485 jump __start__ equal @unit :rebindUnit.3:firstUnit
   486 sensor *tmp169 :rebindUnit.3:firstUnit @dead
   487 jump *label148 equal *tmp169 0
-    * label *label150
-    * label *label146
   488 end
   489 label *label141
   490 ucontrol flag 1
 
   587 jump __start__ equal @unit :rebindUnit.4:firstUnit
   588 sensor *tmp211 :rebindUnit.4:firstUnit @dead
   589 jump *label186 equal *tmp211 0
-    * label *label188
-    * label *label184
   590 end
   591 label *label179
   592 sensor :processUnit:state @unit @flag
 
   624 jump *label205 always
   625 label *label206
   626 set .MSG ", loading\n"
-    * label *label207
   627 jump *label205 always
   628 label *label204
   629 ucontrol approach .CORE_X .CORE_Y 6
 
   652 jump *label211 greaterThan *tmp244 0
   653 ucontrol approach .CORE_X .CORE_Y 6
   654 set :processUnit:state 2
-    * label *label214
   655 jump *label211 always
   656 label *label210
   657 ucontrol approach .DOME_X .DOME_Y 6
 
   710 jump __start__ equal @unit :rebindUnit.5:firstUnit
   711 sensor *tmp275 :rebindUnit.5:firstUnit @dead
   712 jump *label228 equal *tmp275 0
-    * label *label230
-    * label *label226
   713 end
   714 label *label221
   715 sensor :processUnit.1:state @unit @flag
 
   747 jump *label247 always
   748 label *label248
   749 set .MSG ", loading\n"
-    * label *label249
   750 jump *label247 always
   751 label *label246
   752 ucontrol approach .CORE_X .CORE_Y 6
 
   775 jump *label253 greaterThan *tmp308 0
   776 ucontrol approach .CORE_X .CORE_Y 6
   777 set :processUnit.1:state 2
-    * label *label256
   778 jump *label253 always
   779 label *label252
   780 ucontrol approach .DOME_X .DOME_Y 6
 
   858 jump __start__ equal @unit :rebindUnit.6:firstUnit
   859 sensor *tmp345 :rebindUnit.6:firstUnit @dead
   860 jump *label273 equal *tmp345 0
-    * label *label275
-    * label *label271
   861 end
   862 label *label266
   863 sensor :processUnit.2:state @unit @flag
 
   895 jump *label292 always
   896 label *label293
   897 set .MSG ", loading\n"
-    * label *label294
   898 jump *label292 always
   899 label *label291
   900 ucontrol approach .CORE_X .CORE_Y 6
 
   923 jump *label298 greaterThan *tmp378 0
   924 ucontrol approach .CORE_X .CORE_Y 6
   925 set :processUnit.2:state 2
-    * label *label301
   926 jump *label298 always
   927 label *label297
   928 ucontrol approach .DOME_X .DOME_Y 6
 
   981 jump __start__ equal @unit :rebindUnit.7:firstUnit
   982 sensor *tmp409 :rebindUnit.7:firstUnit @dead
   983 jump *label315 equal *tmp409 0
-    * label *label317
-    * label *label313
   984 end
   985 label *label308
   986 sensor :processUnit.3:state @unit @flag
 
  1018 jump *label334 always
  1019 label *label335
  1020 set .MSG ", loading\n"
-    * label *label336
  1021 jump *label334 always
  1022 label *label333
  1023 ucontrol approach .CORE_X .CORE_Y 6
 
  1046 jump *label340 greaterThan *tmp442 0
  1047 ucontrol approach .CORE_X .CORE_Y 6
  1048 set :processUnit.3:state 2
-    * label *label343
  1049 jump *label340 always
  1050 label *label339
  1051 ucontrol approach .DOME_X .DOME_Y 6
 
  1122 jump *label365 lessThan :areUnitsAvailable.2:free *tmp477
  1123 set *tmp466 true
  1124 jump *label355 always
-    * label *label368
-    * jump *label365 always
  1125 label *label364
  1126 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1127 label *label365
 
  1129 jump *label371 equal @unit :areUnitsAvailable.2:firstUnit
  1130 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1131 jump *label361 equal *tmp487 0
-    * label *label363
-    * label *label356
  1132 jump *label371 always
-    * print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.2:free
-    * jump *label373 lessThanEq :areUnitsAvailable.2:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.2:needed
-    * label *label373
-    * print "\n"
  1133 label *label371
  1134 set *tmp466 false
  1135 label *label355
 
  1140 label *label349
  1141 sensor *tmp192 switch1 @enabled
  1142 jump *label409 notEqual *tmp192 false
-    * label *label174
  1143 end
  1144 label *label0
  1145 # "Function: noinline def locateCore(in type)"
 
  1153 label *label376
  1154 set :locateCore*retval .CORE
  1155 return :locateCore*retaddr
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1 (-1 instructions):
 
   434 op sub *tmp128 .DOME_Y .CORE_Y
   435 op len *tmp129 *tmp127 *tmp128
   436 op mul *tmp130 2 *tmp129
-    * sensor *tmp131 .UNIT_S1 @speed
   437 op div :needsFourUnits.2:travel_time *tmp130 .SPEED
   438 op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
   439 jump *label124 lessThan :needsFourUnits.2:travel_time 47

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
  1128 jump *label371 equal @unit :areUnitsAvailable.2:firstUnit
  1129 sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
  1130 jump *label361 equal *tmp487 0
-    * jump *label371 always
  1131 label *label371
  1132 set *tmp466 false
  1133 label *label355

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-1 instructions):
 
    26 jump *label1 notEqual :locateCore*retval false
    27 set :locateCore:type @mono
    28 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label1 notEqual :locateCore*retval false
-    * jump *label5 always
+   29 jump *label5 equal :locateCore*retval false
    30 label *label1
    31 sensor .CORE_X .CORE @x
    32 sensor .CORE_Y .CORE @y

Modifications by Final phase, Temp Variables Elimination, iteration 1:
 
  1146 sensor *tmp496 @unit @controller
  1147 jump *label376 notEqual *tmp496 @this
  1148 label *label378
-    * ulocate building core false @copper *tmp500 *tmp501 *tmp502 .CORE
+ 1149 ulocate building core false @copper 0 0 0 .CORE
  1150 label *label376
  1151 set :locateCore*retval .CORE
  1152 return :locateCore*retaddr

Modifications by Final phase, Print Merging, iteration 1 (-75 instructions):
 
    35 sensor *tmp7 switch1 @enabled
    36 jump *label19 notEqual *tmp7 false
    37 label *label408
-    * print "[coral]Activate switch to begin supplying overdrive dome..."
-    * print "\n"
+   38 print "[coral]Activate switch to begin supplying overdrive dome...\n"
    39 printflush message1
    40 sensor *tmp7 switch1 @enabled
    41 jump *label408 equal *tmp7 false
 
    43 # "Function: inline def chooseUnitType()"
    44 label *label21
    45 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   46 print "[gold]Looking for suitable unit type:[]\n"
    47 # "Function: inline def areUnitsAvailable(in type, in output)"
    48 set :areUnitsAvailable:free 0
    49 set :areUnitsAvailable:occupied 0
 
    81 label *label34
    82 label *label27
    83 print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable:occupied
-    * print ","
-    * print " free: "
+   84 print ": occupied: {0}, free: "
+   85 format :areUnitsAvailable:occupied
    86 print :areUnitsAvailable:free
    87 jump *label44 lessThanEq :areUnitsAvailable:needed 0
    88 print ", needed: "
 
   132 jump *label414 equal *tmp61 0
   133 label *label422
   134 label *label423
-    * print @flare
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  135 print "flare: occupied: {0}, free: "
+  136 format :areUnitsAvailable.1:occupied
   137 print :areUnitsAvailable.1:free
   138 jump *label425 lessThanEq :areUnitsAvailable.1:needed 0
   139 print ", needed: "
 
   185 jump *label441 equal *tmp61 0
   186 label *label449
   187 label *label450
-    * print @poly
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  188 print "poly: occupied: {0}, free: "
+  189 format :areUnitsAvailable.1:occupied
   190 print :areUnitsAvailable.1:free
   191 jump *label452 lessThanEq :areUnitsAvailable.1:needed 0
   192 print ", needed: "
 
   238 jump *label468 equal *tmp61 0
   239 label *label476
   240 label *label477
-    * print @mega
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  241 print "mega: occupied: {0}, free: "
+  242 format :areUnitsAvailable.1:occupied
   243 print :areUnitsAvailable.1:free
   244 jump *label479 lessThanEq :areUnitsAvailable.1:needed 0
   245 print ", needed: "
 
   291 jump *label495 equal *tmp61 0
   292 label *label503
   293 label *label504
-    * print @mono
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  294 print "mono: occupied: {0}, free: "
+  295 format :areUnitsAvailable.1:occupied
   296 print :areUnitsAvailable.1:free
   297 jump *label506 lessThanEq :areUnitsAvailable.1:needed 0
   298 print ", needed: "
 
   518 jump __start__ equal *tmp192 false
   519 label *label409
   520 set :start @time
-    * print " === [gold]Supplying Overdrive Dome[] === "
-    * print "\n"
-    * print "\n"
-    * print "Unit type: [green]"
-    * print *tmp9
-    * print "["
-    * print "]"
-    * print "\n"
+  521 print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
+  522 format *tmp9
   523 # "Function: inline void printDomeStatus(in item, in text)"
-    * print "\n[green]Silicon[] status:\n"
   524 sensor :printDomeStatus:level .DOME @silicon
   525 jump *label176 lessThanEq :printDomeStatus:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  526 print "  dome:  [green]{0}[]\n"
+  527 format :printDomeStatus:level
   528 jump *label177 always
   529 label *label176
-    * print "  dome:  [coral]"
-    * print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  530 print "  dome:  [coral]{0}[]\n"
+  531 format :printDomeStatus:level
   532 label *label177
   533 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   534 # "Function: inline def rebindUnit(in currentUnit)"
 
   631 label *label208
   632 ucontrol flag :processUnit:state
   633 sensor *tmp254 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp254
-    * print "["
-    * print "]"
+  634 print "  {0}: [gold]{0}[]"
+  635 format .GROUP1
+  636 format *tmp254
   637 jump *label216 lessThan :processUnit:distance 0
   638 print .MSG
   639 print :processUnit:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  640 print "[] sec\n"
   641 jump *label217 always
   642 label *label216
   643 print .MSG
 
   746 label *label250
   747 ucontrol flag :processUnit.1:state
   748 sensor *tmp318 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp318
-    * print "["
-    * print "]"
+  749 print "  {0}: [gold]{0}[]"
+  750 format .GROUP2
+  751 format *tmp318
   752 jump *label258 lessThan :processUnit.1:distance 0
   753 print .MSG
   754 print :processUnit.1:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  755 print "[] sec\n"
   756 jump *label259 always
   757 label *label258
   758 print .MSG
 
   772 print "\n[green]Phase fabric[] status:\n"
   773 sensor :printDomeStatus.1:level .DOME @phase-fabric
   774 jump *label263 lessThanEq :printDomeStatus.1:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  775 print "  dome:  [green]{0}[]\n"
+  776 format :printDomeStatus.1:level
   777 jump *label264 always
   778 label *label263
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  779 print "  dome:  [coral]{0}[]\n"
+  780 format :printDomeStatus.1:level
   781 label *label264
   782 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   783 # "Function: inline def rebindUnit(in currentUnit)"
 
   880 label *label295
   881 ucontrol flag :processUnit.2:state
   882 sensor *tmp388 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp388
-    * print "["
-    * print "]"
+  883 print "  {0}: [gold]{0}[]"
+  884 format .GROUP1
+  885 format *tmp388
   886 jump *label303 lessThan :processUnit.2:distance 0
   887 print .MSG
   888 print :processUnit.2:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  889 print "[] sec\n"
   890 jump *label304 always
   891 label *label303
   892 print .MSG
 
   995 label *label337
   996 ucontrol flag :processUnit.3:state
   997 sensor *tmp452 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp452
-    * print "["
-    * print "]"
+  998 print "  {0}: [gold]{0}[]"
+  999 format .GROUP2
+ 1000 format *tmp452
  1001 jump *label345 lessThan :processUnit.3:distance 0
  1002 print .MSG
  1003 print :processUnit.3:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1004 print "[] sec\n"
  1005 jump *label346 always
  1006 label *label345
  1007 print .MSG
 
  1019 label *label305
  1020 op sub *tmp461 @time :start
  1021 op floor *tmp462 *tmp461
-    * print "\n"
-    * print "[lightgray]Loop time: "
-    * print *tmp462
-    * print " "
-    * print "ms"
+ 1022 print "\n[lightgray]Loop time: {0} ms"
+ 1023 format *tmp462
  1024 printflush message1
  1025 jump *label349 equal *tmp9 UNIT_TYPE
  1026 jump *label349 lessThanEq :unitCheck @time

Final code before resolving virtual instructions:

label __start__
remark "This is the preferred unit type to use for bringing in supplies."
remark "If no units of this type exist, we'll try using other types."
set UNIT_TYPE @flare
remark "Do not modify anything below this line."
# "Function: inline void locateDomeAndCore()"
set .DOME dome1
jump *label4 notEqual dome1 null
label *label380
print "[gold]Waiting for an overdrive dome to be connected..."
printflush message1
set .DOME dome1
jump *label380 equal dome1 null
label *label4
print "[gold]Locating core..."
printflush message1
set .CORE null
label *label5
set :locateCore:type @flare
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @poly
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @mega
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @mono
call *label0 :locateCore*retaddr :locateCore*retval
jump *label5 equal :locateCore*retval false
label *label1
sensor .CORE_X .CORE @x
sensor .CORE_Y .CORE @y
sensor .DOME_X .DOME @x
sensor .DOME_Y .DOME @y
sensor *tmp7 switch1 @enabled
jump *label19 notEqual *tmp7 false
label *label408
print "[coral]Activate switch to begin supplying overdrive dome...\n"
printflush message1
sensor *tmp7 switch1 @enabled
jump *label408 equal *tmp7 false
label *label19
# "Function: inline def chooseUnitType()"
label *label21
printflush null
print "[gold]Looking for suitable unit type:[]\n"
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable:free 0
set :areUnitsAvailable:occupied 0
set :areUnitsAvailable:needed 0
ubind UNIT_TYPE
set :areUnitsAvailable:firstUnit @unit
jump *label27 equal :areUnitsAvailable:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits:unit @unit
op sub *tmp14 .DOME_X .CORE_X
op sub *tmp15 .DOME_Y .CORE_Y
op len *tmp16 *tmp14 *tmp15
op mul *tmp17 2 *tmp16
sensor *tmp18 :needsFourUnits:unit @speed
op div :needsFourUnits:travel_time *tmp17 *tmp18
select *tmp21 greaterThanEq :needsFourUnits:travel_time 47 4 2
set :areUnitsAvailable:needed *tmp21
label *label32
sensor *tmp22 @unit @controlled
jump *label37 equal *tmp22 0
sensor *tmp24 @unit @controller
jump *label35 notEqual *tmp24 @this
label *label37
op add :areUnitsAvailable:free :areUnitsAvailable:free 1
jump *label36 lessThan :areUnitsAvailable:free *tmp21
set *tmp10 true
jump *label26 always
label *label35
op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
label *label36
ubind UNIT_TYPE
jump *label34 equal @unit :areUnitsAvailable:firstUnit
sensor *tmp31 :areUnitsAvailable:firstUnit @dead
jump *label32 equal *tmp31 0
label *label34
label *label27
print UNIT_TYPE
print ": occupied: {0}, free: "
format :areUnitsAvailable:occupied
print :areUnitsAvailable:free
jump *label44 lessThanEq :areUnitsAvailable:needed 0
print ", needed: "
print :areUnitsAvailable:needed
label *label44
print "\n"
set *tmp10 false
label *label26
jump *label24 equal *tmp10 false
set *tmp9 UNIT_TYPE
jump *label20 always
label *label24
jump *label432 equal @flare UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @flare
set :areUnitsAvailable.1:firstUnit @unit
jump *label423 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
select *tmp51 greaterThanEq :needsFourUnits.1:travel_time 47 4 2
set :areUnitsAvailable.1:needed *tmp51
label *label414
sensor *tmp52 @unit @controlled
jump *label415 equal *tmp52 0
sensor *tmp54 @unit @controller
jump *label418 notEqual *tmp54 @this
label *label415
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label419 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump *label429 always
label *label418
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label419
ubind @flare
jump *label422 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump *label414 equal *tmp61 0
label *label422
label *label423
print "flare: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label425 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label425
print "\n"
set *tmp40 false
label *label429
jump *label430 equal *tmp40 false
printflush null
set *tmp9 @flare
jump *label20 always
label *label430
label *label432
jump *label459 equal @poly UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @poly
set :areUnitsAvailable.1:firstUnit @unit
jump *label450 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
select *tmp51 greaterThanEq :needsFourUnits.1:travel_time 47 4 2
set :areUnitsAvailable.1:needed *tmp51
label *label441
sensor *tmp52 @unit @controlled
jump *label442 equal *tmp52 0
sensor *tmp54 @unit @controller
jump *label445 notEqual *tmp54 @this
label *label442
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label446 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump *label456 always
label *label445
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label446
ubind @poly
jump *label449 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump *label441 equal *tmp61 0
label *label449
label *label450
print "poly: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label452 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label452
print "\n"
set *tmp40 false
label *label456
jump *label457 equal *tmp40 false
printflush null
set *tmp9 @poly
jump *label20 always
label *label457
label *label459
jump *label486 equal @mega UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mega
set :areUnitsAvailable.1:firstUnit @unit
jump *label477 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
select *tmp51 greaterThanEq :needsFourUnits.1:travel_time 47 4 2
set :areUnitsAvailable.1:needed *tmp51
label *label468
sensor *tmp52 @unit @controlled
jump *label469 equal *tmp52 0
sensor *tmp54 @unit @controller
jump *label472 notEqual *tmp54 @this
label *label469
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label473 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump *label483 always
label *label472
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label473
ubind @mega
jump *label476 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump *label468 equal *tmp61 0
label *label476
label *label477
print "mega: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label479 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label479
print "\n"
set *tmp40 false
label *label483
jump *label484 equal *tmp40 false
printflush null
set *tmp9 @mega
jump *label20 always
label *label484
label *label486
jump *label513 equal @mono UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mono
set :areUnitsAvailable.1:firstUnit @unit
jump *label504 equal :areUnitsAvailable.1:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp44 .DOME_X .CORE_X
op sub *tmp45 .DOME_Y .CORE_Y
op len *tmp46 *tmp44 *tmp45
op mul *tmp47 2 *tmp46
sensor *tmp48 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp47 *tmp48
select *tmp51 greaterThanEq :needsFourUnits.1:travel_time 47 4 2
set :areUnitsAvailable.1:needed *tmp51
label *label495
sensor *tmp52 @unit @controlled
jump *label496 equal *tmp52 0
sensor *tmp54 @unit @controller
jump *label499 notEqual *tmp54 @this
label *label496
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label500 lessThan :areUnitsAvailable.1:free *tmp51
set *tmp40 true
jump *label510 always
label *label499
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label500
ubind @mono
jump *label503 equal @unit :areUnitsAvailable.1:firstUnit
sensor *tmp61 :areUnitsAvailable.1:firstUnit @dead
jump *label495 equal *tmp61 0
label *label503
label *label504
print "mono: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label506 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label506
print "\n"
set *tmp40 false
label *label510
jump *label511 equal *tmp40 false
printflush null
set *tmp9 @mono
jump *label20 always
label *label511
label *label513
printflush message1
jump *label21 always
label *label20
print "[gold]Binding units..."
printflush message1
# "Function: inline def rebindUnits()"
set .UNIT_P2 null
set .UNIT_S2 null
set .UNIT_P1 null
set .UNIT_S1 null
set :rebindUnits:count 0
ubind *tmp9
set :rebindUnits:firstUnit @unit
jump *label78 notEqual :rebindUnits:firstUnit null
end
label *label78
label *label80
sensor *tmp70 @unit @controller
jump *label83 notEqual *tmp70 @this
op add :rebindUnits:count :rebindUnits:count 1
ucontrol flag 1
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 .UNIT_P1
set .UNIT_P1 @unit
jump *label82 notEqual .UNIT_S2 null
label *label83
ubind *tmp9
jump *label82 equal @unit :rebindUnits:firstUnit
sensor *tmp78 :rebindUnits:firstUnit @dead
jump *label80 equal *tmp78 0
label *label82
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label90 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp84 @unit @dead
op equal *tmp85 *tmp84 0
sensor *tmp86 @unit @controller
op equal *tmp87 *tmp86 @this
op land *tmp88 *tmp85 *tmp87
jump *label89 notEqual *tmp88 false
label *label90
ubind *tmp9
set :rebindUnit:firstUnit @unit
jump __start__ equal :rebindUnit:firstUnit null
label *label96
sensor *tmp92 @unit @controlled
jump *label89 equal *tmp92 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit:firstUnit
sensor *tmp96 :rebindUnit:firstUnit @dead
jump *label96 equal *tmp96 0
end
label *label89
ucontrol flag 1
set *tmp80 @unit
set .UNIT_S1 *tmp80
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label104 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp102 @unit @dead
op equal *tmp103 *tmp102 0
sensor *tmp104 @unit @controller
op equal *tmp105 *tmp104 @this
op land *tmp106 *tmp103 *tmp105
jump *label103 notEqual *tmp106 false
label *label104
ubind *tmp9
set :rebindUnit.1:firstUnit @unit
jump __start__ equal :rebindUnit.1:firstUnit null
label *label110
sensor *tmp110 @unit @controlled
jump *label103 equal *tmp110 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.1:firstUnit
sensor *tmp114 :rebindUnit.1:firstUnit @dead
jump *label110 equal *tmp114 0
end
label *label103
ucontrol flag 1
set *tmp98 @unit
set .UNIT_P1 *tmp98
sensor *tmp116 *tmp80 @firstItem
jump *label118 equal *tmp116 @phase-fabric
sensor *tmp118 *tmp98 @firstItem
jump *label116 notEqual *tmp118 @silicon
label *label118
# "Function: inline void swap(in out a, in out b)"
set .UNIT_S1 *tmp98
set .UNIT_P1 *tmp80
label *label116
sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
sensor .SPEED .UNIT_S1 @speed
op div .SPEED_TENTHS .SPEED 10
op strictEqual *tmp124 .SPEED null
jump *label121 equal *tmp124 false
stop
label *label121
# "Function: inline def needsFourUnits(in unit)"
op sub *tmp127 .DOME_X .CORE_X
op sub *tmp128 .DOME_Y .CORE_Y
op len *tmp129 *tmp127 *tmp128
op mul *tmp130 2 *tmp129
op div :needsFourUnits.2:travel_time *tmp130 .SPEED
op greaterThanEq *tmp126 :needsFourUnits.2:travel_time 47
jump *label124 lessThan :needsFourUnits.2:travel_time 47
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label128 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp139 @unit @dead
op equal *tmp140 *tmp139 0
sensor *tmp141 @unit @controller
op equal *tmp142 *tmp141 @this
op land *tmp143 *tmp140 *tmp142
jump *label127 notEqual *tmp143 false
label *label128
ubind *tmp9
set :rebindUnit.2:firstUnit @unit
jump __start__ equal :rebindUnit.2:firstUnit null
label *label134
sensor *tmp147 @unit @controlled
jump *label127 equal *tmp147 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.2:firstUnit
sensor *tmp151 :rebindUnit.2:firstUnit @dead
jump *label134 equal *tmp151 0
end
label *label127
ucontrol flag 1
set *tmp135 @unit
set .UNIT_S2 *tmp135
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label142 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp157 @unit @dead
op equal *tmp158 *tmp157 0
sensor *tmp159 @unit @controller
op equal *tmp160 *tmp159 @this
op land *tmp161 *tmp158 *tmp160
jump *label141 notEqual *tmp161 false
label *label142
ubind *tmp9
set :rebindUnit.3:firstUnit @unit
jump __start__ equal :rebindUnit.3:firstUnit null
label *label148
sensor *tmp165 @unit @controlled
jump *label141 equal *tmp165 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.3:firstUnit
sensor *tmp169 :rebindUnit.3:firstUnit @dead
jump *label148 equal *tmp169 0
end
label *label141
ucontrol flag 1
set *tmp153 @unit
set .UNIT_P2 *tmp153
sensor *tmp171 .UNIT_S1 @firstItem
jump *label154 notEqual *tmp171 @phase-fabric
sensor *tmp173 *tmp153 @firstItem
jump *label154 equal *tmp173 @phase-fabric
# "Function: inline void swap(in out a, in out b)"
set :swap.1:t .UNIT_S1
set .UNIT_S1 *tmp153
set .UNIT_P2 :swap.1:t
label *label154
sensor *tmp176 *tmp135 @firstItem
jump *label161 equal *tmp176 @phase-fabric
sensor *tmp178 .UNIT_P2 @firstItem
jump *label159 notEqual *tmp178 @silicon
label *label161
# "Function: inline void swap(in out a, in out b)"
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 *tmp135
label *label159
set .GROUP1 "unit  1"
set .GROUP2 "unit 2"
jump *label125 always
label *label124
ubind .UNIT_S2
ucontrol unbind
set .UNIT_S2 null
ubind .UNIT_P2
ucontrol unbind
set .UNIT_P2 null
set .GROUP1 "unit"
label *label125
jump *label164 notEqual *tmp126 false
set .SUPPLY_S_FIRST true
jump *label165 always
label *label164
sensor *tmp182 .UNIT_S1 @totalItems
sensor *tmp183 .UNIT_S2 @totalItems
op lessThan .SUPPLY_S_FIRST *tmp182 *tmp183
label *label165
jump *label168 notEqual *tmp126 false
set .SUPPLY_P_FIRST true
jump *label169 always
label *label168
sensor *tmp187 .UNIT_P1 @totalItems
sensor *tmp188 .UNIT_P2 @totalItems
op lessThan .SUPPLY_P_FIRST *tmp187 *tmp188
label *label169
op add :unitCheck @time 5000
sensor *tmp192 switch1 @enabled
jump __start__ equal *tmp192 false
label *label409
set :start @time
print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
format *tmp9
# "Function: inline void printDomeStatus(in item, in text)"
sensor :printDomeStatus:level .DOME @silicon
jump *label176 lessThanEq :printDomeStatus:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus:level
jump *label177 always
label *label176
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus:level
label *label177
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label180 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp199 @unit @dead
op equal *tmp200 *tmp199 0
sensor *tmp201 @unit @controller
op equal *tmp202 *tmp201 @this
op land *tmp203 *tmp200 *tmp202
jump *label179 notEqual *tmp203 false
label *label180
ubind *tmp9
set :rebindUnit.4:firstUnit @unit
jump __start__ equal :rebindUnit.4:firstUnit null
label *label186
sensor *tmp207 @unit @controlled
jump *label179 equal *tmp207 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.4:firstUnit
sensor *tmp211 :rebindUnit.4:firstUnit @dead
jump *label186 equal *tmp211 0
end
label *label179
sensor :processUnit:state @unit @flag
set :processUnit:distance -1
jump *label194 lessThan :processUnit:state 2
jump *label192 lessThanEq :processUnit:state 3
label *label194
sensor *tmp217 @unit @firstItem
jump *label196 notEqual *tmp217 @silicon
set :processUnit:state 3
jump *label197 always
label *label196
sensor *tmp220 @unit @totalItems
jump *label198 notEqual *tmp220 0
set :processUnit:state 2
jump *label199 always
label *label198
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp223
jump *label200 equal *tmp223 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label200
label *label199
label *label197
label *label192
jump *label202 notEqual :processUnit:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp227
jump *label204 equal *tmp227 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp229 @unit @totalItems
jump *label206 lessThan *tmp229 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit:state 3
jump *label205 always
label *label206
set .MSG ", loading\n"
jump *label205 always
label *label204
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp232 @unit @x
op sub *tmp233 .CORE_X *tmp232
sensor *tmp234 @unit @y
op sub *tmp235 .CORE_Y *tmp234
op len *tmp236 *tmp233 *tmp235
op idiv *tmp237 *tmp236 .SPEED_TENTHS
op div :processUnit:distance *tmp237 10
label *label205
label *label202
jump *label208 notEqual :processUnit:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp241
jump *label210 equal *tmp241 false
jump *label212 equal .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label213 always
label *label212
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label213
sensor *tmp244 @unit @totalItems
jump *label211 greaterThan *tmp244 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit:state 2
jump *label211 always
label *label210
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp247 @unit @x
op sub *tmp248 .DOME_X *tmp247
sensor *tmp249 @unit @y
op sub *tmp250 .DOME_Y *tmp249
op len *tmp251 *tmp248 *tmp250
op idiv *tmp252 *tmp251 .SPEED_TENTHS
op div :processUnit:distance *tmp252 10
label *label211
label *label208
ucontrol flag :processUnit:state
sensor *tmp254 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp254
jump *label216 lessThan :processUnit:distance 0
print .MSG
print :processUnit:distance
print "[] sec\n"
jump *label217 always
label *label216
print .MSG
label *label217
set :processUnit:unit @unit
set .UNIT_S1 :processUnit:unit
jump *label218 equal *tmp126 false
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label222 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp263 @unit @dead
op equal *tmp264 *tmp263 0
sensor *tmp265 @unit @controller
op equal *tmp266 *tmp265 @this
op land *tmp267 *tmp264 *tmp266
jump *label221 notEqual *tmp267 false
label *label222
ubind *tmp9
set :rebindUnit.5:firstUnit @unit
jump __start__ equal :rebindUnit.5:firstUnit null
label *label228
sensor *tmp271 @unit @controlled
jump *label221 equal *tmp271 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.5:firstUnit
sensor *tmp275 :rebindUnit.5:firstUnit @dead
jump *label228 equal *tmp275 0
end
label *label221
sensor :processUnit.1:state @unit @flag
set :processUnit.1:distance -1
jump *label236 lessThan :processUnit.1:state 2
jump *label234 lessThanEq :processUnit.1:state 3
label *label236
sensor *tmp281 @unit @firstItem
jump *label238 notEqual *tmp281 @silicon
set :processUnit.1:state 3
jump *label239 always
label *label238
sensor *tmp284 @unit @totalItems
jump *label240 notEqual *tmp284 0
set :processUnit.1:state 2
jump *label241 always
label *label240
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp287
jump *label242 equal *tmp287 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label242
label *label241
label *label239
label *label234
jump *label244 notEqual :processUnit.1:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp291
jump *label246 equal *tmp291 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp293 @unit @totalItems
jump *label248 lessThan *tmp293 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:state 3
jump *label247 always
label *label248
set .MSG ", loading\n"
jump *label247 always
label *label246
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp296 @unit @x
op sub *tmp297 .CORE_X *tmp296
sensor *tmp298 @unit @y
op sub *tmp299 .CORE_Y *tmp298
op len *tmp300 *tmp297 *tmp299
op idiv *tmp301 *tmp300 .SPEED_TENTHS
op div :processUnit.1:distance *tmp301 10
label *label247
label *label244
jump *label250 notEqual :processUnit.1:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp305
jump *label252 equal *tmp305 false
jump *label254 notEqual .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label255 always
label *label254
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label255
sensor *tmp308 @unit @totalItems
jump *label253 greaterThan *tmp308 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:state 2
jump *label253 always
label *label252
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp311 @unit @x
op sub *tmp312 .DOME_X *tmp311
sensor *tmp313 @unit @y
op sub *tmp314 .DOME_Y *tmp313
op len *tmp315 *tmp312 *tmp314
op idiv *tmp316 *tmp315 .SPEED_TENTHS
op div :processUnit.1:distance *tmp316 10
label *label253
label *label250
ucontrol flag :processUnit.1:state
sensor *tmp318 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp318
jump *label258 lessThan :processUnit.1:distance 0
print .MSG
print :processUnit.1:distance
print "[] sec\n"
jump *label259 always
label *label258
print .MSG
label *label259
set :processUnit.1:unit @unit
set .UNIT_S2 :processUnit.1:unit
jump *label260 equal .SUPPLY_S_FIRST false
sensor *tmp323 :processUnit:unit @totalItems
op greaterThan .SUPPLY_S_FIRST *tmp323 0
jump *label261 always
label *label260
sensor *tmp325 :processUnit.1:unit @totalItems
op equal .SUPPLY_S_FIRST *tmp325 0
label *label261
label *label218
# "Function: inline void printDomeStatus(in item, in text)"
print "\n[green]Phase fabric[] status:\n"
sensor :printDomeStatus.1:level .DOME @phase-fabric
jump *label263 lessThanEq :printDomeStatus.1:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.1:level
jump *label264 always
label *label263
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.1:level
label *label264
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label267 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp333 @unit @dead
op equal *tmp334 *tmp333 0
sensor *tmp335 @unit @controller
op equal *tmp336 *tmp335 @this
op land *tmp337 *tmp334 *tmp336
jump *label266 notEqual *tmp337 false
label *label267
ubind *tmp9
set :rebindUnit.6:firstUnit @unit
jump __start__ equal :rebindUnit.6:firstUnit null
label *label273
sensor *tmp341 @unit @controlled
jump *label266 equal *tmp341 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.6:firstUnit
sensor *tmp345 :rebindUnit.6:firstUnit @dead
jump *label273 equal *tmp345 0
end
label *label266
sensor :processUnit.2:state @unit @flag
set :processUnit.2:distance -1
jump *label281 lessThan :processUnit.2:state 2
jump *label279 lessThanEq :processUnit.2:state 3
label *label281
sensor *tmp351 @unit @firstItem
jump *label283 notEqual *tmp351 @phase-fabric
set :processUnit.2:state 3
jump *label284 always
label *label283
sensor *tmp354 @unit @totalItems
jump *label285 notEqual *tmp354 0
set :processUnit.2:state 2
jump *label286 always
label *label285
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp357
jump *label287 equal *tmp357 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label287
label *label286
label *label284
label *label279
jump *label289 notEqual :processUnit.2:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp361
jump *label291 equal *tmp361 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp363 @unit @totalItems
jump *label293 lessThan *tmp363 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:state 3
jump *label292 always
label *label293
set .MSG ", loading\n"
jump *label292 always
label *label291
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp366 @unit @x
op sub *tmp367 .CORE_X *tmp366
sensor *tmp368 @unit @y
op sub *tmp369 .CORE_Y *tmp368
op len *tmp370 *tmp367 *tmp369
op idiv *tmp371 *tmp370 .SPEED_TENTHS
op div :processUnit.2:distance *tmp371 10
label *label292
label *label289
jump *label295 notEqual :processUnit.2:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp375
jump *label297 equal *tmp375 false
jump *label299 equal .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label300 always
label *label299
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label300
sensor *tmp378 @unit @totalItems
jump *label298 greaterThan *tmp378 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:state 2
jump *label298 always
label *label297
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp381 @unit @x
op sub *tmp382 .DOME_X *tmp381
sensor *tmp383 @unit @y
op sub *tmp384 .DOME_Y *tmp383
op len *tmp385 *tmp382 *tmp384
op idiv *tmp386 *tmp385 .SPEED_TENTHS
op div :processUnit.2:distance *tmp386 10
label *label298
label *label295
ucontrol flag :processUnit.2:state
sensor *tmp388 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp388
jump *label303 lessThan :processUnit.2:distance 0
print .MSG
print :processUnit.2:distance
print "[] sec\n"
jump *label304 always
label *label303
print .MSG
label *label304
set :processUnit.2:unit @unit
set .UNIT_P1 :processUnit.2:unit
jump *label305 equal *tmp126 false
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label309 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp397 @unit @dead
op equal *tmp398 *tmp397 0
sensor *tmp399 @unit @controller
op equal *tmp400 *tmp399 @this
op land *tmp401 *tmp398 *tmp400
jump *label308 notEqual *tmp401 false
label *label309
ubind *tmp9
set :rebindUnit.7:firstUnit @unit
jump __start__ equal :rebindUnit.7:firstUnit null
label *label315
sensor *tmp405 @unit @controlled
jump *label308 equal *tmp405 0
ubind *tmp9
jump __start__ equal @unit :rebindUnit.7:firstUnit
sensor *tmp409 :rebindUnit.7:firstUnit @dead
jump *label315 equal *tmp409 0
end
label *label308
sensor :processUnit.3:state @unit @flag
set :processUnit.3:distance -1
jump *label323 lessThan :processUnit.3:state 2
jump *label321 lessThanEq :processUnit.3:state 3
label *label323
sensor *tmp415 @unit @firstItem
jump *label325 notEqual *tmp415 @phase-fabric
set :processUnit.3:state 3
jump *label326 always
label *label325
sensor *tmp418 @unit @totalItems
jump *label327 notEqual *tmp418 0
set :processUnit.3:state 2
jump *label328 always
label *label327
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp421
jump *label329 equal *tmp421 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label329
label *label328
label *label326
label *label321
jump *label331 notEqual :processUnit.3:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp425
jump *label333 equal *tmp425 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp427 @unit @totalItems
jump *label335 lessThan *tmp427 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:state 3
jump *label334 always
label *label335
set .MSG ", loading\n"
jump *label334 always
label *label333
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp430 @unit @x
op sub *tmp431 .CORE_X *tmp430
sensor *tmp432 @unit @y
op sub *tmp433 .CORE_Y *tmp432
op len *tmp434 *tmp431 *tmp433
op idiv *tmp435 *tmp434 .SPEED_TENTHS
op div :processUnit.3:distance *tmp435 10
label *label334
label *label331
jump *label337 notEqual :processUnit.3:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp439
jump *label339 equal *tmp439 false
jump *label341 notEqual .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label342 always
label *label341
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label342
sensor *tmp442 @unit @totalItems
jump *label340 greaterThan *tmp442 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:state 2
jump *label340 always
label *label339
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp445 @unit @x
op sub *tmp446 .DOME_X *tmp445
sensor *tmp447 @unit @y
op sub *tmp448 .DOME_Y *tmp447
op len *tmp449 *tmp446 *tmp448
op idiv *tmp450 *tmp449 .SPEED_TENTHS
op div :processUnit.3:distance *tmp450 10
label *label340
label *label337
ucontrol flag :processUnit.3:state
sensor *tmp452 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp452
jump *label345 lessThan :processUnit.3:distance 0
print .MSG
print :processUnit.3:distance
print "[] sec\n"
jump *label346 always
label *label345
print .MSG
label *label346
set :processUnit.3:unit @unit
set .UNIT_P2 :processUnit.3:unit
jump *label347 equal .SUPPLY_P_FIRST false
sensor *tmp457 :processUnit.2:unit @totalItems
op greaterThan .SUPPLY_P_FIRST *tmp457 0
jump *label348 always
label *label347
sensor *tmp459 :processUnit.3:unit @totalItems
op equal .SUPPLY_P_FIRST *tmp459 0
label *label348
label *label305
op sub *tmp461 @time :start
op floor *tmp462 *tmp461
print "\n[lightgray]Loop time: {0} ms"
format *tmp462
printflush message1
jump *label349 equal *tmp9 UNIT_TYPE
jump *label349 lessThanEq :unitCheck @time
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.2:free 0
set :areUnitsAvailable.2:occupied 0
ubind UNIT_TYPE
set :areUnitsAvailable.2:firstUnit @unit
jump *label371 equal :areUnitsAvailable.2:firstUnit null
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.3:unit @unit
sensor *tmp474 :needsFourUnits.3:unit @speed
op div :needsFourUnits.3:travel_time *tmp130 *tmp474
select *tmp477 greaterThanEq :needsFourUnits.3:travel_time 47 4 2
label *label361
sensor *tmp478 @unit @controlled
jump *label366 equal *tmp478 0
sensor *tmp480 @unit @controller
jump *label364 notEqual *tmp480 @this
label *label366
op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
jump *label365 lessThan :areUnitsAvailable.2:free *tmp477
set *tmp466 true
jump *label355 always
label *label364
op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
label *label365
ubind UNIT_TYPE
jump *label371 equal @unit :areUnitsAvailable.2:firstUnit
sensor *tmp487 :areUnitsAvailable.2:firstUnit @dead
jump *label361 equal *tmp487 0
label *label371
set *tmp466 false
label *label355
jump *label353 equal *tmp466 false
end
label *label353
op add :unitCheck @time 5000
label *label349
sensor *tmp192 switch1 @enabled
jump *label409 notEqual *tmp192 false
end
label *label0
# "Function: noinline def locateCore(in type)"
ubind :locateCore:type
sensor *tmp494 @unit @controlled
jump *label378 equal *tmp494 0
sensor *tmp496 @unit @controller
jump *label376 notEqual *tmp496 @this
label *label378
ulocate building core false @copper 0 0 0 .CORE
label *label376
set :locateCore*retval .CORE
return :locateCore*retaddr
