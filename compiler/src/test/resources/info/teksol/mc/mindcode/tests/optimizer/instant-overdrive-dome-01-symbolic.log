  1446 instructions before optimizations.
    43 instructions eliminated by Temp Variables Elimination (2 iterations).
   259 instructions eliminated by Dead Code Elimination (2 passes, 9 iterations).
     4 instructions eliminated by Jump Normalization (2 passes, 7 iterations).
    75 instructions eliminated by Jump Optimization (2 passes, 7 iterations).
    96 instructions eliminated by Single Step Elimination (3 passes, 10 iterations).
     2 instructions eliminated by If Expression Optimization (4 iterations).
    85 instructions eliminated by Data Flow Optimization (4 passes, 17 iterations).
     2 instructions added by Loop Optimization (4 iterations).
     3 loops improved by Loop Optimization.
   158 instructions added by Loop Unrolling (8 iterations).
     2 loops unrolled by Loop Unrolling.
    22 instructions eliminated by Jump Straightening (2 passes, 7 iterations).
    24 instructions updated by JumpThreading.
    19 instructions eliminated by Unreachable Code Elimination (3 iterations).
    75 instructions eliminated by Print Merging.
   926 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 184):
    Replicate loop condition at line 54:5                        size    +1, benefit       25.0, efficiency     25.000
    Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000
  * Unroll iteration loop at line 169:9                          size    +5, benefit      375.0, efficiency     75.000 (+3 instructions)
  ! Unroll iteration loop at line 201:9                          size  +213, benefit      375.0, efficiency      1.761

Pass 1: speed optimization selection (cost limit 181):
  * Replicate loop condition at line 54:5                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
    Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000
  ! Unroll iteration loop at line 201:9                          size  +213, benefit      375.0, efficiency      1.761

Pass 1: speed optimization selection (cost limit 180):
  * Replicate loop condition at line 119:5                       size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  ! Unroll iteration loop at line 201:9                          size  +213, benefit      375.0, efficiency      1.761

Pass 1: speed optimization selection (cost limit 179):
  ! Unroll iteration loop at line 201:9                          size  +213, benefit      375.0, efficiency      1.761

Pass 2: speed optimization selection (cost limit 197):
  * Unroll iteration loop at line 201:9                          size  +197, benefit      375.0, efficiency      1.904 (+147 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-173 instructions):
 
    36 call *label0 :locateCore*retaddr :locateCore*retval
    37 jump *label15 equal :locateCore*retval false
    38 jump *label1 always
-    * set *tmp2 null
    39 jump *label16 always
    40 label *label15
-    * set *tmp2 null
    41 label *label16
    42 label *label9
    43 multijump *tmp1 0 0 (m:marker0)
 
   119 label *label35
   120 set *tmp29 null
   121 label *label36
-    * set *tmp27 *tmp29
   122 jump *label34 always
   123 label *label33
   124 set *tmp30 :areUnitsAvailable:occupied
   125 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
-    * set *tmp27 *tmp30
   126 label *label34
   127 ubind :areUnitsAvailable:type
   128 label *label31
 
   132 op land *tmp34 *tmp31 *tmp33
   133 jump *label30 notEqual *tmp34 false
   134 label *label32
-    * set *tmp12 null
   135 jump *label26 always
   136 label *label25
-    * set *tmp12 null
   137 label *label26
   138 jump *label37 equal :areUnitsAvailable:output false
   139 print :areUnitsAvailable:type
 
   147 jump *label39 equal *tmp36 false
   148 print ", needed: "
   149 print :areUnitsAvailable:needed
-    * set *tmp37 null
   150 jump *label40 always
   151 label *label39
-    * set *tmp37 null
   152 label *label40
   153 print "\n"
-    * set *tmp35 null
   154 jump *label38 always
   155 label *label37
-    * set *tmp35 null
   156 label *label38
   157 set *tmp10 false
   158 jump *label24 always
 
   161 jump *label41 equal *tmp10 false
   162 set *tmp9 UNIT_TYPE
   163 jump *label20 always
-    * set *tmp38 null
   164 jump *label42 always
   165 label *label41
-    * set *tmp38 null
   166 label *label42
   167 set :chooseUnitType:type @flare
   168 op add *tmp39 @counter 1
 
   229 label *label63
   230 set *tmp61 null
   231 label *label64
-    * set *tmp59 *tmp61
   232 jump *label62 always
   233 label *label61
   234 set *tmp62 :areUnitsAvailable.1:occupied
   235 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * set *tmp59 *tmp62
   236 label *label62
   237 ubind :areUnitsAvailable.1:type
   238 label *label59
 
   242 op land *tmp66 *tmp63 *tmp65
   243 jump *label58 notEqual *tmp66 false
   244 label *label60
-    * set *tmp44 null
   245 jump *label54 always
   246 label *label53
-    * set *tmp44 null
   247 label *label54
   248 jump *label65 equal :areUnitsAvailable.1:output false
   249 print :areUnitsAvailable.1:type
 
   257 jump *label67 equal *tmp68 false
   258 print ", needed: "
   259 print :areUnitsAvailable.1:needed
-    * set *tmp69 null
   260 jump *label68 always
   261 label *label67
-    * set *tmp69 null
   262 label *label68
   263 print "\n"
-    * set *tmp67 null
   264 jump *label66 always
   265 label *label65
-    * set *tmp67 null
   266 label *label66
   267 set *tmp42 false
   268 jump *label52 always
 
   277 label *label69
   278 set *tmp70 null
   279 label *label70
-    * set *tmp41 *tmp70
   280 jump *label51 always
   281 label *label50
-    * set *tmp41 null
   282 label *label51
   283 label *label44
   284 multijump *tmp39 0 0 (m:marker1)
 
   304 op equal *tmp72 :rebindUnits:firstUnit null
   305 jump *label72 equal *tmp72 false
   306 end
-    * set *tmp73 null
   307 jump *label73 always
   308 label *label72
-    * set *tmp73 null
   309 label *label73
   310 label *label74
   311 sensor *tmp74 @unit @controller
   312 op equal *tmp75 *tmp74 @this
   313 jump *label77 equal *tmp75 false
-    * set *tmp77 :rebindUnits:count
   314 op add :rebindUnits:count :rebindUnits:count 1
   315 ucontrol flag 1
   316 set .UNIT_S2 .UNIT_P2
 
   326 label *label79
   327 set *tmp80 null
   328 label *label80
-    * set *tmp76 *tmp80
   329 jump *label78 always
   330 label *label77
-    * set *tmp76 null
   331 label *label78
   332 ubind .TYPE
   333 label *label75
 
   337 op land *tmp84 *tmp81 *tmp83
   338 jump *label74 notEqual *tmp84 false
   339 label *label76
-    * set *tmp71 :rebindUnits:count
   340 jump *label71 always
-    * set *tmp71 null
   341 label *label71
   342 # "Function: inline def acquireUnit(in currentUnit)"
   343 set :acquireUnit:currentUnit .UNIT_S1
 
   352 op equal *tmp92 *tmp91 @this
   353 op land *tmp93 *tmp90 *tmp92
   354 jump *label85 equal *tmp93 false
-    * set *tmp86 :rebindUnit:currentUnit
   355 jump *label82 always
   356 set *tmp94 null
   357 jump *label86 always
   358 label *label85
   359 set *tmp94 null
   360 label *label86
-    * set *tmp88 *tmp94
   361 jump *label84 always
   362 label *label83
-    * set *tmp88 null
   363 label *label84
   364 ubind .TYPE
   365 set :rebindUnit:firstUnit @unit
 
   369 sensor *tmp97 @unit @controlled
   370 op equal *tmp98 *tmp97 0
   371 jump *label92 equal *tmp98 false
-    * set *tmp86 @unit
   372 jump *label82 always
-    * set *tmp99 null
   373 jump *label93 always
   374 label *label92
-    * set *tmp99 null
   375 label *label93
   376 ubind .TYPE
   377 label *label90
 
   381 op land *tmp103 *tmp100 *tmp102
   382 jump *label89 notEqual *tmp103 false
   383 label *label91
-    * set *tmp96 null
   384 jump *label88 always
   385 label *label87
-    * set *tmp96 null
   386 label *label88
   387 end
-    * set *tmp86 null
   388 label *label82
   389 ucontrol flag 1
   390 set *tmp85 @unit
 
   405 op equal *tmp111 *tmp110 @this
   406 op land *tmp112 *tmp109 *tmp111
   407 jump *label98 equal *tmp112 false
-    * set *tmp105 :rebindUnit.1:currentUnit
   408 jump *label95 always
   409 set *tmp113 null
   410 jump *label99 always
   411 label *label98
   412 set *tmp113 null
   413 label *label99
-    * set *tmp107 *tmp113
   414 jump *label97 always
   415 label *label96
-    * set *tmp107 null
   416 label *label97
   417 ubind .TYPE
   418 set :rebindUnit.1:firstUnit @unit
 
   422 sensor *tmp116 @unit @controlled
   423 op equal *tmp117 *tmp116 0
   424 jump *label105 equal *tmp117 false
-    * set *tmp105 @unit
   425 jump *label95 always
-    * set *tmp118 null
   426 jump *label106 always
   427 label *label105
-    * set *tmp118 null
   428 label *label106
   429 ubind .TYPE
   430 label *label103
 
   434 op land *tmp122 *tmp119 *tmp121
   435 jump *label102 notEqual *tmp122 false
   436 label *label104
-    * set *tmp115 null
   437 jump *label101 always
   438 label *label100
-    * set *tmp115 null
   439 label *label101
   440 end
-    * set *tmp105 null
   441 label *label95
   442 ucontrol flag 1
   443 set *tmp104 @unit
 
   460 label *label109
   461 set .UNIT_S1 :swap:a
   462 set .UNIT_P1 :swap:b
-    * set *tmp128 null
   463 jump *label108 always
   464 label *label107
-    * set *tmp128 null
   465 label *label108
   466 sensor *tmp129 .UNIT_S1 @itemCapacity
   467 set .UNIT_CAPACITY *tmp129
 
   472 op strictEqual *tmp132 .SPEED null
   473 jump *label110 equal *tmp132 false
   474 stop
-    * set *tmp133 null
   475 jump *label111 always
   476 label *label110
-    * set *tmp133 null
   477 label *label111
   478 # "Function: inline def needsFourUnits(in unit)"
   479 set :needsFourUnits.2:unit .UNIT_S1
 
   504 op equal *tmp150 *tmp149 @this
   505 op land *tmp151 *tmp148 *tmp150
   506 jump *label119 equal *tmp151 false
-    * set *tmp144 :rebindUnit.2:currentUnit
   507 jump *label116 always
   508 set *tmp152 null
   509 jump *label120 always
   510 label *label119
   511 set *tmp152 null
   512 label *label120
-    * set *tmp146 *tmp152
   513 jump *label118 always
   514 label *label117
-    * set *tmp146 null
   515 label *label118
   516 ubind .TYPE
   517 set :rebindUnit.2:firstUnit @unit
 
   521 sensor *tmp155 @unit @controlled
   522 op equal *tmp156 *tmp155 0
   523 jump *label126 equal *tmp156 false
-    * set *tmp144 @unit
   524 jump *label116 always
-    * set *tmp157 null
   525 jump *label127 always
   526 label *label126
-    * set *tmp157 null
   527 label *label127
   528 ubind .TYPE
   529 label *label124
 
   533 op land *tmp161 *tmp158 *tmp160
   534 jump *label123 notEqual *tmp161 false
   535 label *label125
-    * set *tmp154 null
   536 jump *label122 always
   537 label *label121
-    * set *tmp154 null
   538 label *label122
   539 end
-    * set *tmp144 null
   540 label *label116
   541 ucontrol flag 1
   542 set *tmp143 @unit
 
   557 op equal *tmp169 *tmp168 @this
   558 op land *tmp170 *tmp167 *tmp169
   559 jump *label132 equal *tmp170 false
-    * set *tmp163 :rebindUnit.3:currentUnit
   560 jump *label129 always
   561 set *tmp171 null
   562 jump *label133 always
   563 label *label132
   564 set *tmp171 null
   565 label *label133
-    * set *tmp165 *tmp171
   566 jump *label131 always
   567 label *label130
-    * set *tmp165 null
   568 label *label131
   569 ubind .TYPE
   570 set :rebindUnit.3:firstUnit @unit
 
   574 sensor *tmp174 @unit @controlled
   575 op equal *tmp175 *tmp174 0
   576 jump *label139 equal *tmp175 false
-    * set *tmp163 @unit
   577 jump *label129 always
-    * set *tmp176 null
   578 jump *label140 always
   579 label *label139
-    * set *tmp176 null
   580 label *label140
   581 ubind .TYPE
   582 label *label137
 
   586 op land *tmp180 *tmp177 *tmp179
   587 jump *label136 notEqual *tmp180 false
   588 label *label138
-    * set *tmp173 null
   589 jump *label135 always
   590 label *label134
-    * set *tmp173 null
   591 label *label135
   592 end
-    * set *tmp163 null
   593 label *label129
   594 ucontrol flag 1
   595 set *tmp162 @unit
 
   612 label *label143
   613 set .UNIT_S1 :swap.1:a
   614 set .UNIT_P2 :swap.1:b
-    * set *tmp186 null
   615 jump *label142 always
   616 label *label141
-    * set *tmp186 null
   617 label *label142
   618 sensor *tmp187 .UNIT_S2 @firstItem
   619 op equal *tmp188 *tmp187 @phase-fabric
 
   630 label *label146
   631 set .UNIT_S2 :swap.2:a
   632 set .UNIT_P2 :swap.2:b
-    * set *tmp192 null
   633 jump *label145 always
   634 label *label144
-    * set *tmp192 null
   635 label *label145
   636 set .GROUP1 "unit  1"
   637 set .GROUP2 "unit 2"
-    * set *tmp142 .GROUP2
   638 jump *label114 always
   639 label *label113
   640 ubind .UNIT_S2
 
   644 ucontrol unbind
   645 set .UNIT_P2 null
   646 set .GROUP1 "unit"
-    * set *tmp142 .GROUP1
   647 label *label114
   648 op equal *tmp193 .FOUR_UNITS false
   649 sensor *tmp194 .UNIT_S1 @totalItems
 
   684 print "["
   685 print "]"
   686 print "\n"
-    * set *tmp207 null
   687 jump *label152 always
   688 label *label151
   689 print "  dome:  [coral]"
 
   691 print "["
   692 print "]"
   693 print "\n"
-    * set *tmp207 null
   694 label *label152
   695 label *label150
   696 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
 
   709 op equal *tmp214 *tmp213 @this
   710 op land *tmp215 *tmp212 *tmp214
   711 jump *label157 equal *tmp215 false
-    * set *tmp208 :rebindUnit.4:currentUnit
   712 jump *label154 always
   713 set *tmp216 null
   714 jump *label158 always
   715 label *label157
   716 set *tmp216 null
   717 label *label158
-    * set *tmp210 *tmp216
   718 jump *label156 always
   719 label *label155
-    * set *tmp210 null
   720 label *label156
   721 ubind .TYPE
   722 set :rebindUnit.4:firstUnit @unit
 
   726 sensor *tmp219 @unit @controlled
   727 op equal *tmp220 *tmp219 0
   728 jump *label164 equal *tmp220 false
-    * set *tmp208 @unit
   729 jump *label154 always
-    * set *tmp221 null
   730 jump *label165 always
   731 label *label164
-    * set *tmp221 null
   732 label *label165
   733 ubind .TYPE
   734 label *label162
 
   738 op land *tmp225 *tmp222 *tmp224
   739 jump *label161 notEqual *tmp225 false
   740 label *label163
-    * set *tmp218 null
   741 jump *label160 always
   742 label *label159
-    * set *tmp218 null
   743 label *label160
   744 end
-    * set *tmp208 null
   745 label *label154
   746 sensor *tmp226 @unit @flag
   747 set :processUnit:state *tmp226
 
   779 label *label171
   780 set *tmp233 *tmp236
   781 label *label169
-    * set *tmp230 *tmp233
   782 jump *label167 always
   783 label *label166
-    * set *tmp230 null
   784 label *label167
   785 op equal *tmp239 :processUnit:state 2
   786 jump *label174 equal *tmp239 false
 
   813 set :processUnit:distance *tmp252
   814 set *tmp242 :processUnit:distance
   815 label *label177
-    * set *tmp240 *tmp242
   816 jump *label175 always
   817 label *label174
-    * set *tmp240 null
   818 label *label175
   819 op equal *tmp253 :processUnit:state 3
   820 jump *label180 equal *tmp253 false
 
   823 jump *label184 equal :processUnit:supply false
   824 ucontrol itemDrop .DOME .UNIT_CAPACITY
   825 set .MSG ", supplying\n"
-    * set *tmp257 .MSG
   826 jump *label185 always
   827 label *label184
   828 ucontrol approach .DOME_X .DOME_Y 6
   829 set .MSG ", waiting\n"
-    * set *tmp257 .MSG
   830 label *label185
   831 sensor *tmp258 @unit @totalItems
   832 op lessThanEq *tmp259 *tmp258 0
 
   853 set :processUnit:distance *tmp267
   854 set *tmp256 :processUnit:distance
   855 label *label183
-    * set *tmp254 *tmp256
   856 jump *label181 always
   857 label *label180
-    * set *tmp254 null
   858 label *label181
   859 ucontrol flag :processUnit:state
   860 sensor *tmp268 @unit @totalItems
 
   874 print "["
   875 print "] sec"
   876 print "\n"
-    * set *tmp270 null
   877 jump *label189 always
   878 label *label188
   879 print .MSG
-    * set *tmp270 .MSG
   880 label *label189
   881 set *tmp271 @unit
   882 set :processUnit:unit *tmp271
 
   900 op equal *tmp280 *tmp279 @this
   901 op land *tmp281 *tmp278 *tmp280
   902 jump *label196 equal *tmp281 false
-    * set *tmp274 :rebindUnit.5:currentUnit
   903 jump *label193 always
   904 set *tmp282 null
   905 jump *label197 always
   906 label *label196
   907 set *tmp282 null
   908 label *label197
-    * set *tmp276 *tmp282
   909 jump *label195 always
   910 label *label194
-    * set *tmp276 null
   911 label *label195
   912 ubind .TYPE
   913 set :rebindUnit.5:firstUnit @unit
 
   917 sensor *tmp285 @unit @controlled
   918 op equal *tmp286 *tmp285 0
   919 jump *label203 equal *tmp286 false
-    * set *tmp274 @unit
   920 jump *label193 always
-    * set *tmp287 null
   921 jump *label204 always
   922 label *label203
-    * set *tmp287 null
   923 label *label204
   924 ubind .TYPE
   925 label *label201
 
   929 op land *tmp291 *tmp288 *tmp290
   930 jump *label200 notEqual *tmp291 false
   931 label *label202
-    * set *tmp284 null
   932 jump *label199 always
   933 label *label198
-    * set *tmp284 null
   934 label *label199
   935 end
-    * set *tmp274 null
   936 label *label193
   937 sensor *tmp292 @unit @flag
   938 set :processUnit.1:state *tmp292
 
   970 label *label210
   971 set *tmp299 *tmp302
   972 label *label208
-    * set *tmp296 *tmp299
   973 jump *label206 always
   974 label *label205
-    * set *tmp296 null
   975 label *label206
   976 op equal *tmp305 :processUnit.1:state 2
   977 jump *label213 equal *tmp305 false
 
  1004 set :processUnit.1:distance *tmp318
  1005 set *tmp308 :processUnit.1:distance
  1006 label *label216
-    * set *tmp306 *tmp308
  1007 jump *label214 always
  1008 label *label213
-    * set *tmp306 null
  1009 label *label214
  1010 op equal *tmp319 :processUnit.1:state 3
  1011 jump *label219 equal *tmp319 false
 
  1014 jump *label223 equal :processUnit.1:supply false
  1015 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1016 set .MSG ", supplying\n"
-    * set *tmp323 .MSG
  1017 jump *label224 always
  1018 label *label223
  1019 ucontrol approach .DOME_X .DOME_Y 6
  1020 set .MSG ", waiting\n"
-    * set *tmp323 .MSG
  1021 label *label224
  1022 sensor *tmp324 @unit @totalItems
  1023 op lessThanEq *tmp325 *tmp324 0
 
  1044 set :processUnit.1:distance *tmp333
  1045 set *tmp322 :processUnit.1:distance
  1046 label *label222
-    * set *tmp320 *tmp322
  1047 jump *label220 always
  1048 label *label219
-    * set *tmp320 null
  1049 label *label220
  1050 ucontrol flag :processUnit.1:state
  1051 sensor *tmp334 @unit @totalItems
 
  1065 print "["
  1066 print "] sec"
  1067 print "\n"
-    * set *tmp336 null
  1068 jump *label228 always
  1069 label *label227
  1070 print .MSG
-    * set *tmp336 .MSG
  1071 label *label228
  1072 set *tmp337 @unit
  1073 set :processUnit.1:unit *tmp337
 
  1084 set *tmp338 *tmp342
  1085 label *label230
  1086 set .SUPPLY_S_FIRST *tmp338
-    * set *tmp272 .SUPPLY_S_FIRST
  1087 jump *label191 always
  1088 label *label190
-    * set *tmp272 null
  1089 label *label191
  1090 # "Function: inline void printDomeStatus(in item, in text)"
  1091 set :printDomeStatus.1:item @phase-fabric
 
  1100 print "["
  1101 print "]"
  1102 print "\n"
-    * set *tmp345 null
  1103 jump *label233 always
  1104 label *label232
  1105 print "  dome:  [coral]"
 
  1107 print "["
  1108 print "]"
  1109 print "\n"
-    * set *tmp345 null
  1110 label *label233
  1111 label *label231
  1112 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
 
  1125 op equal *tmp352 *tmp351 @this
  1126 op land *tmp353 *tmp350 *tmp352
  1127 jump *label238 equal *tmp353 false
-    * set *tmp346 :rebindUnit.6:currentUnit
  1128 jump *label235 always
  1129 set *tmp354 null
  1130 jump *label239 always
  1131 label *label238
  1132 set *tmp354 null
  1133 label *label239
-    * set *tmp348 *tmp354
  1134 jump *label237 always
  1135 label *label236
-    * set *tmp348 null
  1136 label *label237
  1137 ubind .TYPE
  1138 set :rebindUnit.6:firstUnit @unit
 
  1142 sensor *tmp357 @unit @controlled
  1143 op equal *tmp358 *tmp357 0
  1144 jump *label245 equal *tmp358 false
-    * set *tmp346 @unit
  1145 jump *label235 always
-    * set *tmp359 null
  1146 jump *label246 always
  1147 label *label245
-    * set *tmp359 null
  1148 label *label246
  1149 ubind .TYPE
  1150 label *label243
 
  1154 op land *tmp363 *tmp360 *tmp362
  1155 jump *label242 notEqual *tmp363 false
  1156 label *label244
-    * set *tmp356 null
  1157 jump *label241 always
  1158 label *label240
-    * set *tmp356 null
  1159 label *label241
  1160 end
-    * set *tmp346 null
  1161 label *label235
  1162 sensor *tmp364 @unit @flag
  1163 set :processUnit.2:state *tmp364
 
  1195 label *label252
  1196 set *tmp371 *tmp374
  1197 label *label250
-    * set *tmp368 *tmp371
  1198 jump *label248 always
  1199 label *label247
-    * set *tmp368 null
  1200 label *label248
  1201 op equal *tmp377 :processUnit.2:state 2
  1202 jump *label255 equal *tmp377 false
 
  1229 set :processUnit.2:distance *tmp390
  1230 set *tmp380 :processUnit.2:distance
  1231 label *label258
-    * set *tmp378 *tmp380
  1232 jump *label256 always
  1233 label *label255
-    * set *tmp378 null
  1234 label *label256
  1235 op equal *tmp391 :processUnit.2:state 3
  1236 jump *label261 equal *tmp391 false
 
  1239 jump *label265 equal :processUnit.2:supply false
  1240 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1241 set .MSG ", supplying\n"
-    * set *tmp395 .MSG
  1242 jump *label266 always
  1243 label *label265
  1244 ucontrol approach .DOME_X .DOME_Y 6
  1245 set .MSG ", waiting\n"
-    * set *tmp395 .MSG
  1246 label *label266
  1247 sensor *tmp396 @unit @totalItems
  1248 op lessThanEq *tmp397 *tmp396 0
 
  1269 set :processUnit.2:distance *tmp405
  1270 set *tmp394 :processUnit.2:distance
  1271 label *label264
-    * set *tmp392 *tmp394
  1272 jump *label262 always
  1273 label *label261
-    * set *tmp392 null
  1274 label *label262
  1275 ucontrol flag :processUnit.2:state
  1276 sensor *tmp406 @unit @totalItems
 
  1290 print "["
  1291 print "] sec"
  1292 print "\n"
-    * set *tmp408 null
  1293 jump *label270 always
  1294 label *label269
  1295 print .MSG
-    * set *tmp408 .MSG
  1296 label *label270
  1297 set *tmp409 @unit
  1298 set :processUnit.2:unit *tmp409
 
  1316 op equal *tmp418 *tmp417 @this
  1317 op land *tmp419 *tmp416 *tmp418
  1318 jump *label277 equal *tmp419 false
-    * set *tmp412 :rebindUnit.7:currentUnit
  1319 jump *label274 always
  1320 set *tmp420 null
  1321 jump *label278 always
  1322 label *label277
  1323 set *tmp420 null
  1324 label *label278
-    * set *tmp414 *tmp420
  1325 jump *label276 always
  1326 label *label275
-    * set *tmp414 null
  1327 label *label276
  1328 ubind .TYPE
  1329 set :rebindUnit.7:firstUnit @unit
 
  1333 sensor *tmp423 @unit @controlled
  1334 op equal *tmp424 *tmp423 0
  1335 jump *label284 equal *tmp424 false
-    * set *tmp412 @unit
  1336 jump *label274 always
-    * set *tmp425 null
  1337 jump *label285 always
  1338 label *label284
-    * set *tmp425 null
  1339 label *label285
  1340 ubind .TYPE
  1341 label *label282
 
  1345 op land *tmp429 *tmp426 *tmp428
  1346 jump *label281 notEqual *tmp429 false
  1347 label *label283
-    * set *tmp422 null
  1348 jump *label280 always
  1349 label *label279
-    * set *tmp422 null
  1350 label *label280
  1351 end
-    * set *tmp412 null
  1352 label *label274
  1353 sensor *tmp430 @unit @flag
  1354 set :processUnit.3:state *tmp430
 
  1386 label *label291
  1387 set *tmp437 *tmp440
  1388 label *label289
-    * set *tmp434 *tmp437
  1389 jump *label287 always
  1390 label *label286
-    * set *tmp434 null
  1391 label *label287
  1392 op equal *tmp443 :processUnit.3:state 2
  1393 jump *label294 equal *tmp443 false
 
  1420 set :processUnit.3:distance *tmp456
  1421 set *tmp446 :processUnit.3:distance
  1422 label *label297
-    * set *tmp444 *tmp446
  1423 jump *label295 always
  1424 label *label294
-    * set *tmp444 null
  1425 label *label295
  1426 op equal *tmp457 :processUnit.3:state 3
  1427 jump *label300 equal *tmp457 false
 
  1430 jump *label304 equal :processUnit.3:supply false
  1431 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1432 set .MSG ", supplying\n"
-    * set *tmp461 .MSG
  1433 jump *label305 always
  1434 label *label304
  1435 ucontrol approach .DOME_X .DOME_Y 6
  1436 set .MSG ", waiting\n"
-    * set *tmp461 .MSG
  1437 label *label305
  1438 sensor *tmp462 @unit @totalItems
  1439 op lessThanEq *tmp463 *tmp462 0
 
  1460 set :processUnit.3:distance *tmp471
  1461 set *tmp460 :processUnit.3:distance
  1462 label *label303
-    * set *tmp458 *tmp460
  1463 jump *label301 always
  1464 label *label300
-    * set *tmp458 null
  1465 label *label301
  1466 ucontrol flag :processUnit.3:state
  1467 sensor *tmp472 @unit @totalItems
 
  1481 print "["
  1482 print "] sec"
  1483 print "\n"
-    * set *tmp474 null
  1484 jump *label309 always
  1485 label *label308
  1486 print .MSG
-    * set *tmp474 .MSG
  1487 label *label309
  1488 set *tmp475 @unit
  1489 set :processUnit.3:unit *tmp475
 
  1500 set *tmp476 *tmp480
  1501 label *label311
  1502 set .SUPPLY_P_FIRST *tmp476
-    * set *tmp410 .SUPPLY_P_FIRST
  1503 jump *label272 always
  1504 label *label271
-    * set *tmp410 null
  1505 label *label272
  1506 op sub *tmp481 @time :start
  1507 op floor *tmp482 *tmp481
 
  1563 label *label325
  1564 set *tmp506 null
  1565 label *label326
-    * set *tmp504 *tmp506
  1566 jump *label324 always
  1567 label *label323
  1568 set *tmp507 :areUnitsAvailable.2:occupied
  1569 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
-    * set *tmp504 *tmp507
  1570 label *label324
  1571 ubind :areUnitsAvailable.2:type
  1572 label *label321
 
  1576 op land *tmp511 *tmp508 *tmp510
  1577 jump *label320 notEqual *tmp511 false
  1578 label *label322
-    * set *tmp489 null
  1579 jump *label316 always
  1580 label *label315
-    * set *tmp489 null
  1581 label *label316
  1582 jump *label327 equal :areUnitsAvailable.2:output false
  1583 print :areUnitsAvailable.2:type
 
  1591 jump *label329 equal *tmp513 false
  1592 print ", needed: "
  1593 print :areUnitsAvailable.2:needed
-    * set *tmp514 null
  1594 jump *label330 always
  1595 label *label329
-    * set *tmp514 null
  1596 label *label330
  1597 print "\n"
-    * set *tmp512 null
  1598 jump *label328 always
  1599 label *label327
-    * set *tmp512 null
  1600 label *label328
  1601 set *tmp487 false
  1602 jump *label314 always
 
  1604 label *label314
  1605 jump *label331 equal *tmp487 false
  1606 end
-    * set *tmp515 null
  1607 jump *label332 always
  1608 label *label331
-    * set *tmp515 null
  1609 label *label332
  1610 op add *tmp516 @time 5000
  1611 set :unitCheck *tmp516
-    * set *tmp486 :unitCheck
  1612 jump *label313 always
  1613 label *label312
-    * set *tmp486 null
  1614 label *label313
  1615 label *label148
  1616 jump *label147 always
 
  1627 jump *label334 equal *tmp521 false
  1628 ulocate building core false @copper *tmp524 *tmp525 *tmp526 *tmp523
  1629 set .CORE *tmp523
-    * set *tmp522 .CORE
  1630 jump *label335 always
  1631 label *label334
-    * set *tmp522 null
  1632 label *label335
  1633 set :locateCore*retval .CORE
  1634 label *label333

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-53 instructions):
 
   114 jump *label35 equal *tmp28 false
   115 set *tmp10 true
   116 jump *label24 always
-    * set *tmp29 null
   117 jump *label36 always
   118 label *label35
-    * set *tmp29 null
   119 label *label36
   120 jump *label34 always
   121 label *label33
-    * set *tmp30 :areUnitsAvailable:occupied
   122 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   123 label *label34
   124 ubind :areUnitsAvailable:type
 
   221 jump *label63 equal *tmp60 false
   222 set *tmp42 true
   223 jump *label52 always
-    * set *tmp61 null
   224 jump *label64 always
   225 label *label63
-    * set *tmp61 null
   226 label *label64
   227 jump *label62 always
   228 label *label61
-    * set *tmp62 :areUnitsAvailable.1:occupied
   229 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   230 label *label62
   231 ubind :areUnitsAvailable.1:type
 
   266 printflush null
   267 set *tmp9 :chooseUnitType:type
   268 jump *label20 always
-    * set *tmp70 null
   269 jump *label70 always
   270 label *label69
-    * set *tmp70 null
   271 label *label70
   272 jump *label51 always
   273 label *label50
 
   313 op notEqual *tmp79 .UNIT_S2 null
   314 jump *label79 equal *tmp79 false
   315 jump *label76 always
-    * set *tmp80 null
   316 jump *label80 always
   317 label *label79
-    * set *tmp80 null
   318 label *label80
   319 jump *label78 always
   320 label *label77
 
   343 op land *tmp93 *tmp90 *tmp92
   344 jump *label85 equal *tmp93 false
   345 jump *label82 always
-    * set *tmp94 null
   346 jump *label86 always
   347 label *label85
-    * set *tmp94 null
   348 label *label86
   349 jump *label84 always
   350 label *label83
 
   394 op land *tmp112 *tmp109 *tmp111
   395 jump *label98 equal *tmp112 false
   396 jump *label95 always
-    * set *tmp113 null
   397 jump *label99 always
   398 label *label98
-    * set *tmp113 null
   399 label *label99
   400 jump *label97 always
   401 label *label96
 
   491 op land *tmp151 *tmp148 *tmp150
   492 jump *label119 equal *tmp151 false
   493 jump *label116 always
-    * set *tmp152 null
   494 jump *label120 always
   495 label *label119
-    * set *tmp152 null
   496 label *label120
   497 jump *label118 always
   498 label *label117
 
   542 op land *tmp170 *tmp167 *tmp169
   543 jump *label132 equal *tmp170 false
   544 jump *label129 always
-    * set *tmp171 null
   545 jump *label133 always
   546 label *label132
-    * set *tmp171 null
   547 label *label133
   548 jump *label131 always
   549 label *label130
 
   692 op land *tmp215 *tmp212 *tmp214
   693 jump *label157 equal *tmp215 false
   694 jump *label154 always
-    * set *tmp216 null
   695 jump *label158 always
   696 label *label157
-    * set *tmp216 null
   697 label *label158
   698 jump *label156 always
   699 label *label155
 
   735 op equal *tmp232 *tmp231 :processUnit:item
   736 jump *label168 equal *tmp232 false
   737 set :processUnit:state 3
-    * set *tmp233 :processUnit:state
   738 jump *label169 always
   739 label *label168
   740 sensor *tmp234 @unit @totalItems
 
   756 label *label173
   757 set *tmp236 *tmp238
   758 label *label171
-    * set *tmp233 *tmp236
   759 label *label169
   760 jump *label167 always
   761 label *label166
 
   776 set .MSG ", loading\n"
   777 set *tmp245 .MSG
   778 label *label179
-    * set *tmp242 *tmp245
   779 jump *label177 always
   780 label *label176
   781 ucontrol approach .CORE_X .CORE_Y 6
 
   788 op idiv *tmp251 *tmp250 .SPEED_TENTHS
   789 op div *tmp252 *tmp251 10
   790 set :processUnit:distance *tmp252
-    * set *tmp242 :processUnit:distance
   791 label *label177
   792 jump *label175 always
   793 label *label174
 
   814 label *label186
   815 set *tmp260 null
   816 label *label187
-    * set *tmp256 *tmp260
   817 jump *label183 always
   818 label *label182
   819 ucontrol approach .DOME_X .DOME_Y 6
 
   826 op idiv *tmp266 *tmp265 .SPEED_TENTHS
   827 op div *tmp267 *tmp266 10
   828 set :processUnit:distance *tmp267
-    * set *tmp256 :processUnit:distance
   829 label *label183
   830 jump *label181 always
   831 label *label180
 
   875 op land *tmp281 *tmp278 *tmp280
   876 jump *label196 equal *tmp281 false
   877 jump *label193 always
-    * set *tmp282 null
   878 jump *label197 always
   879 label *label196
-    * set *tmp282 null
   880 label *label197
   881 jump *label195 always
   882 label *label194
 
   918 op equal *tmp298 *tmp297 :processUnit.1:item
   919 jump *label207 equal *tmp298 false
   920 set :processUnit.1:state 3
-    * set *tmp299 :processUnit.1:state
   921 jump *label208 always
   922 label *label207
   923 sensor *tmp300 @unit @totalItems
 
   939 label *label212
   940 set *tmp302 *tmp304
   941 label *label210
-    * set *tmp299 *tmp302
   942 label *label208
   943 jump *label206 always
   944 label *label205
 
   959 set .MSG ", loading\n"
   960 set *tmp311 .MSG
   961 label *label218
-    * set *tmp308 *tmp311
   962 jump *label216 always
   963 label *label215
   964 ucontrol approach .CORE_X .CORE_Y 6
 
   971 op idiv *tmp317 *tmp316 .SPEED_TENTHS
   972 op div *tmp318 *tmp317 10
   973 set :processUnit.1:distance *tmp318
-    * set *tmp308 :processUnit.1:distance
   974 label *label216
   975 jump *label214 always
   976 label *label213
 
   997 label *label225
   998 set *tmp326 null
   999 label *label226
-    * set *tmp322 *tmp326
  1000 jump *label222 always
  1001 label *label221
  1002 ucontrol approach .DOME_X .DOME_Y 6
 
  1009 op idiv *tmp332 *tmp331 .SPEED_TENTHS
  1010 op div *tmp333 *tmp332 10
  1011 set :processUnit.1:distance *tmp333
-    * set *tmp322 :processUnit.1:distance
  1012 label *label222
  1013 jump *label220 always
  1014 label *label219
 
  1092 op land *tmp353 *tmp350 *tmp352
  1093 jump *label238 equal *tmp353 false
  1094 jump *label235 always
-    * set *tmp354 null
  1095 jump *label239 always
  1096 label *label238
-    * set *tmp354 null
  1097 label *label239
  1098 jump *label237 always
  1099 label *label236
 
  1135 op equal *tmp370 *tmp369 :processUnit.2:item
  1136 jump *label249 equal *tmp370 false
  1137 set :processUnit.2:state 3
-    * set *tmp371 :processUnit.2:state
  1138 jump *label250 always
  1139 label *label249
  1140 sensor *tmp372 @unit @totalItems
 
  1156 label *label254
  1157 set *tmp374 *tmp376
  1158 label *label252
-    * set *tmp371 *tmp374
  1159 label *label250
  1160 jump *label248 always
  1161 label *label247
 
  1176 set .MSG ", loading\n"
  1177 set *tmp383 .MSG
  1178 label *label260
-    * set *tmp380 *tmp383
  1179 jump *label258 always
  1180 label *label257
  1181 ucontrol approach .CORE_X .CORE_Y 6
 
  1188 op idiv *tmp389 *tmp388 .SPEED_TENTHS
  1189 op div *tmp390 *tmp389 10
  1190 set :processUnit.2:distance *tmp390
-    * set *tmp380 :processUnit.2:distance
  1191 label *label258
  1192 jump *label256 always
  1193 label *label255
 
  1214 label *label267
  1215 set *tmp398 null
  1216 label *label268
-    * set *tmp394 *tmp398
  1217 jump *label264 always
  1218 label *label263
  1219 ucontrol approach .DOME_X .DOME_Y 6
 
  1226 op idiv *tmp404 *tmp403 .SPEED_TENTHS
  1227 op div *tmp405 *tmp404 10
  1228 set :processUnit.2:distance *tmp405
-    * set *tmp394 :processUnit.2:distance
  1229 label *label264
  1230 jump *label262 always
  1231 label *label261
 
  1275 op land *tmp419 *tmp416 *tmp418
  1276 jump *label277 equal *tmp419 false
  1277 jump *label274 always
-    * set *tmp420 null
  1278 jump *label278 always
  1279 label *label277
-    * set *tmp420 null
  1280 label *label278
  1281 jump *label276 always
  1282 label *label275
 
  1318 op equal *tmp436 *tmp435 :processUnit.3:item
  1319 jump *label288 equal *tmp436 false
  1320 set :processUnit.3:state 3
-    * set *tmp437 :processUnit.3:state
  1321 jump *label289 always
  1322 label *label288
  1323 sensor *tmp438 @unit @totalItems
 
  1339 label *label293
  1340 set *tmp440 *tmp442
  1341 label *label291
-    * set *tmp437 *tmp440
  1342 label *label289
  1343 jump *label287 always
  1344 label *label286
 
  1359 set .MSG ", loading\n"
  1360 set *tmp449 .MSG
  1361 label *label299
-    * set *tmp446 *tmp449
  1362 jump *label297 always
  1363 label *label296
  1364 ucontrol approach .CORE_X .CORE_Y 6
 
  1371 op idiv *tmp455 *tmp454 .SPEED_TENTHS
  1372 op div *tmp456 *tmp455 10
  1373 set :processUnit.3:distance *tmp456
-    * set *tmp446 :processUnit.3:distance
  1374 label *label297
  1375 jump *label295 always
  1376 label *label294
 
  1397 label *label306
  1398 set *tmp464 null
  1399 label *label307
-    * set *tmp460 *tmp464
  1400 jump *label303 always
  1401 label *label302
  1402 ucontrol approach .DOME_X .DOME_Y 6
 
  1409 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1410 op div *tmp471 *tmp470 10
  1411 set :processUnit.3:distance *tmp471
-    * set *tmp460 :processUnit.3:distance
  1412 label *label303
  1413 jump *label301 always
  1414 label *label300
 
  1508 jump *label325 equal *tmp505 false
  1509 set *tmp487 true
  1510 jump *label314 always
-    * set *tmp506 null
  1511 jump *label326 always
  1512 label *label325
-    * set *tmp506 null
  1513 label *label326
  1514 jump *label324 always
  1515 label *label323
-    * set *tmp507 :areUnitsAvailable.2:occupied
  1516 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1517 label *label324
  1518 ubind :areUnitsAvailable.2:type

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-24 instructions):
 
   741 op equal *tmp235 *tmp234 0
   742 jump *label170 equal *tmp235 false
   743 set :processUnit:state 2
-    * set *tmp236 :processUnit:state
   744 jump *label171 always
   745 label *label170
   746 set .MSG ", initializing\n"
 
   753 label *label172
   754 set *tmp238 null
   755 label *label173
-    * set *tmp236 *tmp238
   756 label *label171
   757 label *label169
   758 jump *label167 always
 
   768 jump *label178 equal *tmp244 false
   769 ucontrol approach .DOME_X .DOME_Y 6
   770 set :processUnit:state 3
-    * set *tmp245 :processUnit:state
   771 jump *label179 always
   772 label *label178
   773 set .MSG ", loading\n"
-    * set *tmp245 .MSG
   774 label *label179
   775 jump *label177 always
   776 label *label176
 
   805 jump *label186 equal *tmp259 false
   806 ucontrol approach .CORE_X .CORE_Y 6
   807 set :processUnit:state 2
-    * set *tmp260 :processUnit:state
   808 jump *label187 always
   809 label *label186
-    * set *tmp260 null
   810 label *label187
   811 jump *label183 always
   812 label *label182
 
   918 op equal *tmp301 *tmp300 0
   919 jump *label209 equal *tmp301 false
   920 set :processUnit.1:state 2
-    * set *tmp302 :processUnit.1:state
   921 jump *label210 always
   922 label *label209
   923 set .MSG ", initializing\n"
 
   930 label *label211
   931 set *tmp304 null
   932 label *label212
-    * set *tmp302 *tmp304
   933 label *label210
   934 label *label208
   935 jump *label206 always
 
   945 jump *label217 equal *tmp310 false
   946 ucontrol approach .DOME_X .DOME_Y 6
   947 set :processUnit.1:state 3
-    * set *tmp311 :processUnit.1:state
   948 jump *label218 always
   949 label *label217
   950 set .MSG ", loading\n"
-    * set *tmp311 .MSG
   951 label *label218
   952 jump *label216 always
   953 label *label215
 
   982 jump *label225 equal *tmp325 false
   983 ucontrol approach .CORE_X .CORE_Y 6
   984 set :processUnit.1:state 2
-    * set *tmp326 :processUnit.1:state
   985 jump *label226 always
   986 label *label225
-    * set *tmp326 null
   987 label *label226
   988 jump *label222 always
   989 label *label221
 
  1129 op equal *tmp373 *tmp372 0
  1130 jump *label251 equal *tmp373 false
  1131 set :processUnit.2:state 2
-    * set *tmp374 :processUnit.2:state
  1132 jump *label252 always
  1133 label *label251
  1134 set .MSG ", initializing\n"
 
  1141 label *label253
  1142 set *tmp376 null
  1143 label *label254
-    * set *tmp374 *tmp376
  1144 label *label252
  1145 label *label250
  1146 jump *label248 always
 
  1156 jump *label259 equal *tmp382 false
  1157 ucontrol approach .DOME_X .DOME_Y 6
  1158 set :processUnit.2:state 3
-    * set *tmp383 :processUnit.2:state
  1159 jump *label260 always
  1160 label *label259
  1161 set .MSG ", loading\n"
-    * set *tmp383 .MSG
  1162 label *label260
  1163 jump *label258 always
  1164 label *label257
 
  1193 jump *label267 equal *tmp397 false
  1194 ucontrol approach .CORE_X .CORE_Y 6
  1195 set :processUnit.2:state 2
-    * set *tmp398 :processUnit.2:state
  1196 jump *label268 always
  1197 label *label267
-    * set *tmp398 null
  1198 label *label268
  1199 jump *label264 always
  1200 label *label263
 
  1306 op equal *tmp439 *tmp438 0
  1307 jump *label290 equal *tmp439 false
  1308 set :processUnit.3:state 2
-    * set *tmp440 :processUnit.3:state
  1309 jump *label291 always
  1310 label *label290
  1311 set .MSG ", initializing\n"
 
  1318 label *label292
  1319 set *tmp442 null
  1320 label *label293
-    * set *tmp440 *tmp442
  1321 label *label291
  1322 label *label289
  1323 jump *label287 always
 
  1333 jump *label298 equal *tmp448 false
  1334 ucontrol approach .DOME_X .DOME_Y 6
  1335 set :processUnit.3:state 3
-    * set *tmp449 :processUnit.3:state
  1336 jump *label299 always
  1337 label *label298
  1338 set .MSG ", loading\n"
-    * set *tmp449 .MSG
  1339 label *label299
  1340 jump *label297 always
  1341 label *label296
 
  1370 jump *label306 equal *tmp463 false
  1371 ucontrol approach .CORE_X .CORE_Y 6
  1372 set :processUnit.3:state 2
-    * set *tmp464 :processUnit.3:state
  1373 jump *label307 always
  1374 label *label306
-    * set *tmp464 null
  1375 label *label307
  1376 jump *label303 always
  1377 label *label302

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-8 instructions):
 
   748 ucontrol within .CORE_X .CORE_Y 8 *tmp237
   749 jump *label172 equal *tmp237 false
   750 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp238 null
   751 jump *label173 always
   752 label *label172
-    * set *tmp238 null
   753 label *label173
   754 label *label171
   755 label *label169
 
   923 ucontrol within .CORE_X .CORE_Y 8 *tmp303
   924 jump *label211 equal *tmp303 false
   925 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp304 null
   926 jump *label212 always
   927 label *label211
-    * set *tmp304 null
   928 label *label212
   929 label *label210
   930 label *label208
 
  1132 ucontrol within .CORE_X .CORE_Y 8 *tmp375
  1133 jump *label253 equal *tmp375 false
  1134 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp376 null
  1135 jump *label254 always
  1136 label *label253
-    * set *tmp376 null
  1137 label *label254
  1138 label *label252
  1139 label *label250
 
  1307 ucontrol within .CORE_X .CORE_Y 8 *tmp441
  1308 jump *label292 equal *tmp441 false
  1309 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * set *tmp442 null
  1310 jump *label293 always
  1311 label *label292
-    * set *tmp442 null
  1312 label *label293
  1313 label *label291
  1314 label *label289

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-43 instructions):
 
    47 jump *label5 always
    48 label *label7
    49 label *label1
-    * sensor *tmp3 .CORE @x
-    * set .CORE_X *tmp3
-    * sensor *tmp4 .CORE @y
-    * set .CORE_Y *tmp4
-    * sensor *tmp5 .DOME @x
-    * set .DOME_X *tmp5
-    * sensor *tmp6 .DOME @y
-    * set .DOME_Y *tmp6
+   50 sensor .CORE_X .CORE @x
+   51 sensor .CORE_Y .CORE @y
+   52 sensor .DOME_X .DOME @x
+   53 sensor .DOME_Y .DOME @y
    54 label *label17
    55 sensor *tmp7 switch1 @enabled
    56 op equal *tmp8 *tmp7 false
 
    84 op len *tmp16 *tmp14 *tmp15
    85 op mul *tmp17 2 *tmp16
    86 sensor *tmp18 :needsFourUnits:unit @speed
-    * op div *tmp19 *tmp17 *tmp18
-    * set :needsFourUnits:travel_time *tmp19
-    * op greaterThanEq *tmp20 :needsFourUnits:travel_time 47
-    * set *tmp13 *tmp20
+   87 op div :needsFourUnits:travel_time *tmp17 *tmp18
+   88 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    89 jump *label27 always
    90 set *tmp13 null
    91 label *label27
 
   189 op len *tmp48 *tmp46 *tmp47
   190 op mul *tmp49 2 *tmp48
   191 sensor *tmp50 :needsFourUnits.1:unit @speed
-    * op div *tmp51 *tmp49 *tmp50
-    * set :needsFourUnits.1:travel_time *tmp51
-    * op greaterThanEq *tmp52 :needsFourUnits.1:travel_time 47
-    * set *tmp45 *tmp52
+  192 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  193 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   194 jump *label55 always
   195 set *tmp45 null
   196 label *label55
 
   300 set .UNIT_S2 .UNIT_P2
   301 set .UNIT_P2 .UNIT_S1
   302 set .UNIT_S1 .UNIT_P1
-    * set *tmp78 @unit
-    * set .UNIT_P1 *tmp78
+  303 set .UNIT_P1 @unit
   304 op notEqual *tmp79 .UNIT_S2 null
   305 jump *label79 equal *tmp79 false
   306 jump *label76 always
 
   440 jump *label108 always
   441 label *label107
   442 label *label108
-    * sensor *tmp129 .UNIT_S1 @itemCapacity
-    * set .UNIT_CAPACITY *tmp129
-    * sensor *tmp130 .UNIT_S1 @speed
-    * set .SPEED *tmp130
-    * op div *tmp131 .SPEED 10
-    * set .SPEED_TENTHS *tmp131
+  443 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
+  444 sensor .SPEED .UNIT_S1 @speed
+  445 op div .SPEED_TENTHS .SPEED 10
   446 op strictEqual *tmp132 .SPEED null
   447 jump *label110 equal *tmp132 false
   448 stop
 
   456 op len *tmp137 *tmp135 *tmp136
   457 op mul *tmp138 2 *tmp137
   458 sensor *tmp139 :needsFourUnits.2:unit @speed
-    * op div *tmp140 *tmp138 *tmp139
-    * set :needsFourUnits.2:travel_time *tmp140
-    * op greaterThanEq *tmp141 :needsFourUnits.2:travel_time 47
-    * set *tmp134 *tmp141
+  459 op div :needsFourUnits.2:travel_time *tmp138 *tmp139
+  460 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   461 jump *label112 always
   462 set *tmp134 null
   463 label *label112
 
   617 sensor *tmp194 .UNIT_S1 @totalItems
   618 sensor *tmp195 .UNIT_S2 @totalItems
   619 op lessThan *tmp196 *tmp194 *tmp195
-    * op or *tmp197 *tmp193 *tmp196
-    * set .SUPPLY_S_FIRST *tmp197
+  620 op or .SUPPLY_S_FIRST *tmp193 *tmp196
   621 op equal *tmp198 .FOUR_UNITS false
   622 sensor *tmp199 .UNIT_P1 @totalItems
   623 sensor *tmp200 .UNIT_P2 @totalItems
   624 op lessThan *tmp201 *tmp199 *tmp200
-    * op or *tmp202 *tmp198 *tmp201
-    * set .SUPPLY_P_FIRST *tmp202
-    * op add *tmp203 @time 5000
-    * set :unitCheck *tmp203
+  625 op or .SUPPLY_P_FIRST *tmp198 *tmp201
+  626 op add :unitCheck @time 5000
   627 label *label147
   628 sensor *tmp204 switch1 @enabled
   629 jump *label149 equal *tmp204 false
 
   640 set :printDomeStatus:item @silicon
   641 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   642 print :printDomeStatus:text
-    * sensor *tmp205 .DOME :printDomeStatus:item
-    * set :printDomeStatus:level *tmp205
+  643 sensor :printDomeStatus:level .DOME :printDomeStatus:item
   644 op greaterThan *tmp206 :printDomeStatus:level 3
   645 jump *label151 equal *tmp206 false
   646 print "  dome:  [green]"
 
   705 label *label160
   706 end
   707 label *label154
-    * sensor *tmp226 @unit @flag
-    * set :processUnit:state *tmp226
+  708 sensor :processUnit:state @unit @flag
   709 set :processUnit:distance -1
   710 set :processUnit:color "gold"
   711 op lessThan *tmp227 :processUnit:state 2
 
   761 op sub *tmp249 .CORE_Y *tmp248
   762 op len *tmp250 *tmp247 *tmp249
   763 op idiv *tmp251 *tmp250 .SPEED_TENTHS
-    * op div *tmp252 *tmp251 10
-    * set :processUnit:distance *tmp252
+  764 op div :processUnit:distance *tmp251 10
   765 label *label177
   766 jump *label175 always
   767 label *label174
 
   796 op sub *tmp264 .DOME_Y *tmp263
   797 op len *tmp265 *tmp262 *tmp264
   798 op idiv *tmp266 *tmp265 .SPEED_TENTHS
-    * op div *tmp267 *tmp266 10
-    * set :processUnit:distance *tmp267
+  799 op div :processUnit:distance *tmp266 10
   800 label *label183
   801 jump *label181 always
   802 label *label180
 
   823 label *label188
   824 print .MSG
   825 label *label189
-    * set *tmp271 @unit
-    * set :processUnit:unit *tmp271
+  826 set :processUnit:unit @unit
   827 label *label153
   828 set .UNIT_S1 :processUnit:unit
   829 jump *label190 equal .FOUR_UNITS false
 
   876 label *label199
   877 end
   878 label *label193
-    * sensor *tmp292 @unit @flag
-    * set :processUnit.1:state *tmp292
+  879 sensor :processUnit.1:state @unit @flag
   880 set :processUnit.1:distance -1
   881 set :processUnit.1:color "gold"
   882 op lessThan *tmp293 :processUnit.1:state 2
 
   932 op sub *tmp315 .CORE_Y *tmp314
   933 op len *tmp316 *tmp313 *tmp315
   934 op idiv *tmp317 *tmp316 .SPEED_TENTHS
-    * op div *tmp318 *tmp317 10
-    * set :processUnit.1:distance *tmp318
+  935 op div :processUnit.1:distance *tmp317 10
   936 label *label216
   937 jump *label214 always
   938 label *label213
 
   967 op sub *tmp330 .DOME_Y *tmp329
   968 op len *tmp331 *tmp328 *tmp330
   969 op idiv *tmp332 *tmp331 .SPEED_TENTHS
-    * op div *tmp333 *tmp332 10
-    * set :processUnit.1:distance *tmp333
+  970 op div :processUnit.1:distance *tmp332 10
   971 label *label222
   972 jump *label220 always
   973 label *label219
 
   994 label *label227
   995 print .MSG
   996 label *label228
-    * set *tmp337 @unit
-    * set :processUnit.1:unit *tmp337
+  997 set :processUnit.1:unit @unit
   998 label *label192
   999 set .UNIT_S2 :processUnit.1:unit
  1000 jump *label229 equal .SUPPLY_S_FIRST false
  1001 sensor *tmp339 .UNIT_S1 @totalItems
-    * op greaterThan *tmp340 *tmp339 0
-    * set *tmp338 *tmp340
+ 1002 op greaterThan *tmp338 *tmp339 0
  1003 jump *label230 always
  1004 label *label229
  1005 sensor *tmp341 .UNIT_S2 @totalItems
-    * op equal *tmp342 *tmp341 0
-    * set *tmp338 *tmp342
+ 1006 op equal *tmp338 *tmp341 0
  1007 label *label230
  1008 set .SUPPLY_S_FIRST *tmp338
  1009 jump *label191 always
 
  1013 set :printDomeStatus.1:item @phase-fabric
  1014 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
  1015 print :printDomeStatus.1:text
-    * sensor *tmp343 .DOME :printDomeStatus.1:item
-    * set :printDomeStatus.1:level *tmp343
+ 1016 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
  1017 op greaterThan *tmp344 :printDomeStatus.1:level 3
  1018 jump *label232 equal *tmp344 false
  1019 print "  dome:  [green]"
 
  1078 label *label241
  1079 end
  1080 label *label235
-    * sensor *tmp364 @unit @flag
-    * set :processUnit.2:state *tmp364
+ 1081 sensor :processUnit.2:state @unit @flag
  1082 set :processUnit.2:distance -1
  1083 set :processUnit.2:color "gold"
  1084 op lessThan *tmp365 :processUnit.2:state 2
 
  1134 op sub *tmp387 .CORE_Y *tmp386
  1135 op len *tmp388 *tmp385 *tmp387
  1136 op idiv *tmp389 *tmp388 .SPEED_TENTHS
-    * op div *tmp390 *tmp389 10
-    * set :processUnit.2:distance *tmp390
+ 1137 op div :processUnit.2:distance *tmp389 10
  1138 label *label258
  1139 jump *label256 always
  1140 label *label255
 
  1169 op sub *tmp402 .DOME_Y *tmp401
  1170 op len *tmp403 *tmp400 *tmp402
  1171 op idiv *tmp404 *tmp403 .SPEED_TENTHS
-    * op div *tmp405 *tmp404 10
-    * set :processUnit.2:distance *tmp405
+ 1172 op div :processUnit.2:distance *tmp404 10
  1173 label *label264
  1174 jump *label262 always
  1175 label *label261
 
  1196 label *label269
  1197 print .MSG
  1198 label *label270
-    * set *tmp409 @unit
-    * set :processUnit.2:unit *tmp409
+ 1199 set :processUnit.2:unit @unit
  1200 label *label234
  1201 set .UNIT_P1 :processUnit.2:unit
  1202 jump *label271 equal .FOUR_UNITS false
 
  1249 label *label280
  1250 end
  1251 label *label274
-    * sensor *tmp430 @unit @flag
-    * set :processUnit.3:state *tmp430
+ 1252 sensor :processUnit.3:state @unit @flag
  1253 set :processUnit.3:distance -1
  1254 set :processUnit.3:color "gold"
  1255 op lessThan *tmp431 :processUnit.3:state 2
 
  1305 op sub *tmp453 .CORE_Y *tmp452
  1306 op len *tmp454 *tmp451 *tmp453
  1307 op idiv *tmp455 *tmp454 .SPEED_TENTHS
-    * op div *tmp456 *tmp455 10
-    * set :processUnit.3:distance *tmp456
+ 1308 op div :processUnit.3:distance *tmp455 10
  1309 label *label297
  1310 jump *label295 always
  1311 label *label294
 
  1340 op sub *tmp468 .DOME_Y *tmp467
  1341 op len *tmp469 *tmp466 *tmp468
  1342 op idiv *tmp470 *tmp469 .SPEED_TENTHS
-    * op div *tmp471 *tmp470 10
-    * set :processUnit.3:distance *tmp471
+ 1343 op div :processUnit.3:distance *tmp470 10
  1344 label *label303
  1345 jump *label301 always
  1346 label *label300
 
  1367 label *label308
  1368 print .MSG
  1369 label *label309
-    * set *tmp475 @unit
-    * set :processUnit.3:unit *tmp475
+ 1370 set :processUnit.3:unit @unit
  1371 label *label273
  1372 set .UNIT_P2 :processUnit.3:unit
  1373 jump *label310 equal .SUPPLY_P_FIRST false
  1374 sensor *tmp477 .UNIT_P1 @totalItems
-    * op greaterThan *tmp478 *tmp477 0
-    * set *tmp476 *tmp478
+ 1375 op greaterThan *tmp476 *tmp477 0
  1376 jump *label311 always
  1377 label *label310
  1378 sensor *tmp479 .UNIT_P2 @totalItems
-    * op equal *tmp480 *tmp479 0
-    * set *tmp476 *tmp480
+ 1379 op equal *tmp476 *tmp479 0
  1380 label *label311
  1381 set .SUPPLY_P_FIRST *tmp476
  1382 jump *label272 always
 
  1411 op len *tmp493 *tmp491 *tmp492
  1412 op mul *tmp494 2 *tmp493
  1413 sensor *tmp495 :needsFourUnits.3:unit @speed
-    * op div *tmp496 *tmp494 *tmp495
-    * set :needsFourUnits.3:travel_time *tmp496
-    * op greaterThanEq *tmp497 :needsFourUnits.3:travel_time 47
-    * set *tmp490 *tmp497
+ 1414 op div :needsFourUnits.3:travel_time *tmp494 *tmp495
+ 1415 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1416 jump *label317 always
  1417 set *tmp490 null
  1418 label *label317
 
  1481 jump *label332 always
  1482 label *label331
  1483 label *label332
-    * op add *tmp516 @time 5000
-    * set :unitCheck *tmp516
+ 1484 op add :unitCheck @time 5000
  1485 jump *label313 always
  1486 label *label312
  1487 label *label313
 
  1498 op equal *tmp520 *tmp519 @this
  1499 op or *tmp521 *tmp518 *tmp520
  1500 jump *label334 equal *tmp521 false
-    * ulocate building core false @copper *tmp524 *tmp525 *tmp526 *tmp523
-    * set .CORE *tmp523
+ 1501 ulocate building core false @copper 0 0 0 .CORE
  1502 jump *label335 always
  1503 label *label334
  1504 label *label335

Modifications by Iterated phase, Jump Normalization, pass 1, iteration 1 (-2 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * jump *label7 equal true false
    19 set :locateDomeAndCore:type @flare
    20 op add *tmp1 @counter 1
    21 jump *label8 always
 
    62 label *label19
    63 # "Function: inline def chooseUnitType()"
    64 label *label21
-    * jump *label23 equal true false
    65 printflush null
    66 print "[gold]Looking for suitable unit type:[]"
    67 print "\n"

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-69 instructions):
 
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
     6 label *label2
-    * op equal *tmp0 .DOME null
-    * jump *label4 equal *tmp0 false
+    7 jump *label4 notEqual .DOME null
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
 
    51 sensor .DOME_Y .DOME @y
    52 label *label17
    53 sensor *tmp7 switch1 @enabled
-    * op equal *tmp8 *tmp7 false
-    * jump *label19 equal *tmp8 false
+   54 jump *label19 notEqual *tmp7 false
    55 print "[coral]Activate switch to begin supplying overdrive dome..."
    56 print "\n"
    57 printflush message1
 
    71 set :areUnitsAvailable:needed 0
    72 ubind :areUnitsAvailable:type
    73 set :areUnitsAvailable:firstUnit @unit
-    * op notEqual *tmp11 :areUnitsAvailable:firstUnit null
-    * jump *label25 equal *tmp11 false
+   74 jump *label25 equal :areUnitsAvailable:firstUnit null
    75 # "Function: inline def needsFourUnits(in unit)"
    76 set :needsFourUnits:unit @unit
    77 op sub *tmp14 .DOME_X .CORE_X
 
    99 op or *tmp26 *tmp23 *tmp25
   100 jump *label33 equal *tmp26 false
   101 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * op greaterThanEq *tmp28 :areUnitsAvailable:free :areUnitsAvailable:needed
-    * jump *label35 equal *tmp28 false
+  102 jump *label35 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   103 set *tmp10 true
   104 jump *label24 always
   105 jump *label36 always
 
   128 print ","
   129 print " free: "
   130 print :areUnitsAvailable:free
-    * op greaterThan *tmp36 :areUnitsAvailable:needed 0
-    * jump *label39 equal *tmp36 false
+  131 jump *label39 lessThanEq :areUnitsAvailable:needed 0
   132 print ", needed: "
   133 print :areUnitsAvailable:needed
   134 jump *label40 always
 
   163 set :chooseUnitType:type @mono
   164 set *tmp39 null
   165 label *label43
-    * op notEqual *tmp40 :chooseUnitType:type UNIT_TYPE
-    * jump *label50 equal *tmp40 false
+  166 jump *label50 equal :chooseUnitType:type UNIT_TYPE
   167 # "Function: inline def areUnitsAvailable(in type, in output)"
   168 set :areUnitsAvailable.1:type :chooseUnitType:type
   169 set :areUnitsAvailable.1:output true
 
   172 set :areUnitsAvailable.1:needed 0
   173 ubind :areUnitsAvailable.1:type
   174 set :areUnitsAvailable.1:firstUnit @unit
-    * op notEqual *tmp43 :areUnitsAvailable.1:firstUnit null
-    * jump *label53 equal *tmp43 false
+  175 jump *label53 equal :areUnitsAvailable.1:firstUnit null
   176 # "Function: inline def needsFourUnits(in unit)"
   177 set :needsFourUnits.1:unit @unit
   178 op sub *tmp46 .DOME_X .CORE_X
 
   200 op or *tmp58 *tmp55 *tmp57
   201 jump *label61 equal *tmp58 false
   202 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * op greaterThanEq *tmp60 :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
-    * jump *label63 equal *tmp60 false
+  203 jump *label63 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   204 set *tmp42 true
   205 jump *label52 always
   206 jump *label64 always
 
   229 print ","
   230 print " free: "
   231 print :areUnitsAvailable.1:free
-    * op greaterThan *tmp68 :areUnitsAvailable.1:needed 0
-    * jump *label67 equal *tmp68 false
+  232 jump *label67 lessThanEq :areUnitsAvailable.1:needed 0
   233 print ", needed: "
   234 print :areUnitsAvailable.1:needed
   235 jump *label68 always
 
   274 set :rebindUnits:count 0
   275 ubind .TYPE
   276 set :rebindUnits:firstUnit @unit
-    * op equal *tmp72 :rebindUnits:firstUnit null
-    * jump *label72 equal *tmp72 false
+  277 jump *label72 notEqual :rebindUnits:firstUnit null
   278 end
   279 jump *label73 always
   280 label *label72
   281 label *label73
   282 label *label74
   283 sensor *tmp74 @unit @controller
-    * op equal *tmp75 *tmp74 @this
-    * jump *label77 equal *tmp75 false
+  284 jump *label77 notEqual *tmp74 @this
   285 op add :rebindUnits:count :rebindUnits:count 1
   286 ucontrol flag 1
   287 set .UNIT_S2 .UNIT_P2
   288 set .UNIT_P2 .UNIT_S1
   289 set .UNIT_S1 .UNIT_P1
   290 set .UNIT_P1 @unit
-    * op notEqual *tmp79 .UNIT_S2 null
-    * jump *label79 equal *tmp79 false
+  291 jump *label79 equal .UNIT_S2 null
   292 jump *label76 always
   293 jump *label80 always
   294 label *label79
 
   310 set :acquireUnit:currentUnit .UNIT_S1
   311 # "Function: inline def rebindUnit(in currentUnit)"
   312 set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * op notEqual *tmp87 :rebindUnit:currentUnit null
-    * jump *label83 equal *tmp87 false
+  313 jump *label83 equal :rebindUnit:currentUnit null
   314 ubind :rebindUnit:currentUnit
   315 sensor *tmp89 @unit @dead
   316 op equal *tmp90 *tmp89 0
 
   327 label *label84
   328 ubind .TYPE
   329 set :rebindUnit:firstUnit @unit
-    * op notEqual *tmp95 :rebindUnit:firstUnit null
-    * jump *label87 equal *tmp95 false
+  330 jump *label87 equal :rebindUnit:firstUnit null
   331 label *label89
   332 sensor *tmp97 @unit @controlled
-    * op equal *tmp98 *tmp97 0
-    * jump *label92 equal *tmp98 false
+  333 jump *label92 notEqual *tmp97 0
   334 jump *label82 always
   335 jump *label93 always
   336 label *label92
 
   358 set :acquireUnit.1:currentUnit .UNIT_P1
   359 # "Function: inline def rebindUnit(in currentUnit)"
   360 set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * op notEqual *tmp106 :rebindUnit.1:currentUnit null
-    * jump *label96 equal *tmp106 false
+  361 jump *label96 equal :rebindUnit.1:currentUnit null
   362 ubind :rebindUnit.1:currentUnit
   363 sensor *tmp108 @unit @dead
   364 op equal *tmp109 *tmp108 0
 
   375 label *label97
   376 ubind .TYPE
   377 set :rebindUnit.1:firstUnit @unit
-    * op notEqual *tmp114 :rebindUnit.1:firstUnit null
-    * jump *label100 equal *tmp114 false
+  378 jump *label100 equal :rebindUnit.1:firstUnit null
   379 label *label102
   380 sensor *tmp116 @unit @controlled
-    * op equal *tmp117 *tmp116 0
-    * jump *label105 equal *tmp117 false
+  381 jump *label105 notEqual *tmp116 0
   382 jump *label95 always
   383 jump *label106 always
   384 label *label105
 
   447 set :acquireUnit.2:currentUnit .UNIT_S2
   448 # "Function: inline def rebindUnit(in currentUnit)"
   449 set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * op notEqual *tmp145 :rebindUnit.2:currentUnit null
-    * jump *label117 equal *tmp145 false
+  450 jump *label117 equal :rebindUnit.2:currentUnit null
   451 ubind :rebindUnit.2:currentUnit
   452 sensor *tmp147 @unit @dead
   453 op equal *tmp148 *tmp147 0
 
   464 label *label118
   465 ubind .TYPE
   466 set :rebindUnit.2:firstUnit @unit
-    * op notEqual *tmp153 :rebindUnit.2:firstUnit null
-    * jump *label121 equal *tmp153 false
+  467 jump *label121 equal :rebindUnit.2:firstUnit null
   468 label *label123
   469 sensor *tmp155 @unit @controlled
-    * op equal *tmp156 *tmp155 0
-    * jump *label126 equal *tmp156 false
+  470 jump *label126 notEqual *tmp155 0
   471 jump *label116 always
   472 jump *label127 always
   473 label *label126
 
   495 set :acquireUnit.3:currentUnit .UNIT_P2
   496 # "Function: inline def rebindUnit(in currentUnit)"
   497 set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * op notEqual *tmp164 :rebindUnit.3:currentUnit null
-    * jump *label130 equal *tmp164 false
+  498 jump *label130 equal :rebindUnit.3:currentUnit null
   499 ubind :rebindUnit.3:currentUnit
   500 sensor *tmp166 @unit @dead
   501 op equal *tmp167 *tmp166 0
 
   512 label *label131
   513 ubind .TYPE
   514 set :rebindUnit.3:firstUnit @unit
-    * op notEqual *tmp172 :rebindUnit.3:firstUnit null
-    * jump *label134 equal *tmp172 false
+  515 jump *label134 equal :rebindUnit.3:firstUnit null
   516 label *label136
   517 sensor *tmp174 @unit @controlled
-    * op equal *tmp175 *tmp174 0
-    * jump *label139 equal *tmp175 false
+  518 jump *label139 notEqual *tmp174 0
   519 jump *label129 always
   520 jump *label140 always
   521 label *label139
 
   615 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   616 print :printDomeStatus:text
   617 sensor :printDomeStatus:level .DOME :printDomeStatus:item
-    * op greaterThan *tmp206 :printDomeStatus:level 3
-    * jump *label151 equal *tmp206 false
+  618 jump *label151 lessThanEq :printDomeStatus:level 3
   619 print "  dome:  [green]"
   620 print :printDomeStatus:level
   621 print "["
 
   637 set :processUnit:supply .SUPPLY_S_FIRST
   638 # "Function: inline def rebindUnit(in currentUnit)"
   639 set :rebindUnit.4:currentUnit :processUnit:unit
-    * op notEqual *tmp209 :rebindUnit.4:currentUnit null
-    * jump *label155 equal *tmp209 false
+  640 jump *label155 equal :rebindUnit.4:currentUnit null
   641 ubind :rebindUnit.4:currentUnit
   642 sensor *tmp211 @unit @dead
   643 op equal *tmp212 *tmp211 0
 
   654 label *label156
   655 ubind .TYPE
   656 set :rebindUnit.4:firstUnit @unit
-    * op notEqual *tmp217 :rebindUnit.4:firstUnit null
-    * jump *label159 equal *tmp217 false
+  657 jump *label159 equal :rebindUnit.4:firstUnit null
   658 label *label161
   659 sensor *tmp219 @unit @controlled
-    * op equal *tmp220 *tmp219 0
-    * jump *label164 equal *tmp220 false
+  660 jump *label164 notEqual *tmp219 0
   661 jump *label154 always
   662 jump *label165 always
   663 label *label164
 
   683 op or *tmp229 *tmp227 *tmp228
   684 jump *label166 equal *tmp229 false
   685 sensor *tmp231 @unit @firstItem
-    * op equal *tmp232 *tmp231 :processUnit:item
-    * jump *label168 equal *tmp232 false
+  686 jump *label168 notEqual *tmp231 :processUnit:item
   687 set :processUnit:state 3
   688 jump *label169 always
   689 label *label168
   690 sensor *tmp234 @unit @totalItems
-    * op equal *tmp235 *tmp234 0
-    * jump *label170 equal *tmp235 false
+  691 jump *label170 notEqual *tmp234 0
   692 set :processUnit:state 2
   693 jump *label171 always
   694 label *label170
 
   705 jump *label167 always
   706 label *label166
   707 label *label167
-    * op equal *tmp239 :processUnit:state 2
-    * jump *label174 equal *tmp239 false
+  708 jump *label174 notEqual :processUnit:state 2
   709 ucontrol within .CORE_X .CORE_Y 8 *tmp241
   710 jump *label176 equal *tmp241 false
   711 ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
   712 sensor *tmp243 @unit @totalItems
-    * op greaterThanEq *tmp244 *tmp243 .UNIT_CAPACITY
-    * jump *label178 equal *tmp244 false
+  713 jump *label178 lessThan *tmp243 .UNIT_CAPACITY
   714 ucontrol approach .DOME_X .DOME_Y 6
   715 set :processUnit:state 3
   716 jump *label179 always
 
   732 jump *label175 always
   733 label *label174
   734 label *label175
-    * op equal *tmp253 :processUnit:state 3
-    * jump *label180 equal *tmp253 false
+  735 jump *label180 notEqual :processUnit:state 3
   736 ucontrol within .DOME_X .DOME_Y 8 *tmp255
   737 jump *label182 equal *tmp255 false
   738 jump *label184 equal :processUnit:supply false
 
   744 set .MSG ", waiting\n"
   745 label *label185
   746 sensor *tmp258 @unit @totalItems
-    * op lessThanEq *tmp259 *tmp258 0
-    * jump *label186 equal *tmp259 false
+  747 jump *label186 greaterThan *tmp258 0
   748 ucontrol approach .CORE_X .CORE_Y 6
   749 set :processUnit:state 2
   750 jump *label187 always
 
   776 print *tmp268
   777 print "["
   778 print "]"
-    * op greaterThanEq *tmp269 :processUnit:distance 0
-    * jump *label188 equal *tmp269 false
+  779 jump *label188 lessThan :processUnit:distance 0
   780 print .MSG
   781 print :processUnit:distance
   782 print "["
 
   798 set :processUnit.1:supply *tmp273
   799 # "Function: inline def rebindUnit(in currentUnit)"
   800 set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * op notEqual *tmp275 :rebindUnit.5:currentUnit null
-    * jump *label194 equal *tmp275 false
+  801 jump *label194 equal :rebindUnit.5:currentUnit null
   802 ubind :rebindUnit.5:currentUnit
   803 sensor *tmp277 @unit @dead
   804 op equal *tmp278 *tmp277 0
 
   815 label *label195
   816 ubind .TYPE
   817 set :rebindUnit.5:firstUnit @unit
-    * op notEqual *tmp283 :rebindUnit.5:firstUnit null
-    * jump *label198 equal *tmp283 false
+  818 jump *label198 equal :rebindUnit.5:firstUnit null
   819 label *label200
   820 sensor *tmp285 @unit @controlled
-    * op equal *tmp286 *tmp285 0
-    * jump *label203 equal *tmp286 false
+  821 jump *label203 notEqual *tmp285 0
   822 jump *label193 always
   823 jump *label204 always
   824 label *label203
 
   844 op or *tmp295 *tmp293 *tmp294
   845 jump *label205 equal *tmp295 false
   846 sensor *tmp297 @unit @firstItem
-    * op equal *tmp298 *tmp297 :processUnit.1:item
-    * jump *label207 equal *tmp298 false
+  847 jump *label207 notEqual *tmp297 :processUnit.1:item
   848 set :processUnit.1:state 3
   849 jump *label208 always
   850 label *label207
   851 sensor *tmp300 @unit @totalItems
-    * op equal *tmp301 *tmp300 0
-    * jump *label209 equal *tmp301 false
+  852 jump *label209 notEqual *tmp300 0
   853 set :processUnit.1:state 2
   854 jump *label210 always
   855 label *label209
 
   866 jump *label206 always
   867 label *label205
   868 label *label206
-    * op equal *tmp305 :processUnit.1:state 2
-    * jump *label213 equal *tmp305 false
+  869 jump *label213 notEqual :processUnit.1:state 2
   870 ucontrol within .CORE_X .CORE_Y 8 *tmp307
   871 jump *label215 equal *tmp307 false
   872 ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
   873 sensor *tmp309 @unit @totalItems
-    * op greaterThanEq *tmp310 *tmp309 .UNIT_CAPACITY
-    * jump *label217 equal *tmp310 false
+  874 jump *label217 lessThan *tmp309 .UNIT_CAPACITY
   875 ucontrol approach .DOME_X .DOME_Y 6
   876 set :processUnit.1:state 3
   877 jump *label218 always
 
   893 jump *label214 always
   894 label *label213
   895 label *label214
-    * op equal *tmp319 :processUnit.1:state 3
-    * jump *label219 equal *tmp319 false
+  896 jump *label219 notEqual :processUnit.1:state 3
   897 ucontrol within .DOME_X .DOME_Y 8 *tmp321
   898 jump *label221 equal *tmp321 false
   899 jump *label223 equal :processUnit.1:supply false
 
   905 set .MSG ", waiting\n"
   906 label *label224
   907 sensor *tmp324 @unit @totalItems
-    * op lessThanEq *tmp325 *tmp324 0
-    * jump *label225 equal *tmp325 false
+  908 jump *label225 greaterThan *tmp324 0
   909 ucontrol approach .CORE_X .CORE_Y 6
   910 set :processUnit.1:state 2
   911 jump *label226 always
 
   937 print *tmp334
   938 print "["
   939 print "]"
-    * op greaterThanEq *tmp335 :processUnit.1:distance 0
-    * jump *label227 equal *tmp335 false
+  940 jump *label227 lessThan :processUnit.1:distance 0
   941 print .MSG
   942 print :processUnit.1:distance
   943 print "["
 
   967 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   968 print :printDomeStatus.1:text
   969 sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
-    * op greaterThan *tmp344 :printDomeStatus.1:level 3
-    * jump *label232 equal *tmp344 false
+  970 jump *label232 lessThanEq :printDomeStatus.1:level 3
   971 print "  dome:  [green]"
   972 print :printDomeStatus.1:level
   973 print "["
 
   989 set :processUnit.2:supply .SUPPLY_P_FIRST
   990 # "Function: inline def rebindUnit(in currentUnit)"
   991 set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * op notEqual *tmp347 :rebindUnit.6:currentUnit null
-    * jump *label236 equal *tmp347 false
+  992 jump *label236 equal :rebindUnit.6:currentUnit null
   993 ubind :rebindUnit.6:currentUnit
   994 sensor *tmp349 @unit @dead
   995 op equal *tmp350 *tmp349 0
 
  1006 label *label237
  1007 ubind .TYPE
  1008 set :rebindUnit.6:firstUnit @unit
-    * op notEqual *tmp355 :rebindUnit.6:firstUnit null
-    * jump *label240 equal *tmp355 false
+ 1009 jump *label240 equal :rebindUnit.6:firstUnit null
  1010 label *label242
  1011 sensor *tmp357 @unit @controlled
-    * op equal *tmp358 *tmp357 0
-    * jump *label245 equal *tmp358 false
+ 1012 jump *label245 notEqual *tmp357 0
  1013 jump *label235 always
  1014 jump *label246 always
  1015 label *label245
 
  1035 op or *tmp367 *tmp365 *tmp366
  1036 jump *label247 equal *tmp367 false
  1037 sensor *tmp369 @unit @firstItem
-    * op equal *tmp370 *tmp369 :processUnit.2:item
-    * jump *label249 equal *tmp370 false
+ 1038 jump *label249 notEqual *tmp369 :processUnit.2:item
  1039 set :processUnit.2:state 3
  1040 jump *label250 always
  1041 label *label249
  1042 sensor *tmp372 @unit @totalItems
-    * op equal *tmp373 *tmp372 0
-    * jump *label251 equal *tmp373 false
+ 1043 jump *label251 notEqual *tmp372 0
  1044 set :processUnit.2:state 2
  1045 jump *label252 always
  1046 label *label251
 
  1057 jump *label248 always
  1058 label *label247
  1059 label *label248
-    * op equal *tmp377 :processUnit.2:state 2
-    * jump *label255 equal *tmp377 false
+ 1060 jump *label255 notEqual :processUnit.2:state 2
  1061 ucontrol within .CORE_X .CORE_Y 8 *tmp379
  1062 jump *label257 equal *tmp379 false
  1063 ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
  1064 sensor *tmp381 @unit @totalItems
-    * op greaterThanEq *tmp382 *tmp381 .UNIT_CAPACITY
-    * jump *label259 equal *tmp382 false
+ 1065 jump *label259 lessThan *tmp381 .UNIT_CAPACITY
  1066 ucontrol approach .DOME_X .DOME_Y 6
  1067 set :processUnit.2:state 3
  1068 jump *label260 always
 
  1084 jump *label256 always
  1085 label *label255
  1086 label *label256
-    * op equal *tmp391 :processUnit.2:state 3
-    * jump *label261 equal *tmp391 false
+ 1087 jump *label261 notEqual :processUnit.2:state 3
  1088 ucontrol within .DOME_X .DOME_Y 8 *tmp393
  1089 jump *label263 equal *tmp393 false
  1090 jump *label265 equal :processUnit.2:supply false
 
  1096 set .MSG ", waiting\n"
  1097 label *label266
  1098 sensor *tmp396 @unit @totalItems
-    * op lessThanEq *tmp397 *tmp396 0
-    * jump *label267 equal *tmp397 false
+ 1099 jump *label267 greaterThan *tmp396 0
  1100 ucontrol approach .CORE_X .CORE_Y 6
  1101 set :processUnit.2:state 2
  1102 jump *label268 always
 
  1128 print *tmp406
  1129 print "["
  1130 print "]"
-    * op greaterThanEq *tmp407 :processUnit.2:distance 0
-    * jump *label269 equal *tmp407 false
+ 1131 jump *label269 lessThan :processUnit.2:distance 0
  1132 print .MSG
  1133 print :processUnit.2:distance
  1134 print "["
 
  1150 set :processUnit.3:supply *tmp411
  1151 # "Function: inline def rebindUnit(in currentUnit)"
  1152 set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * op notEqual *tmp413 :rebindUnit.7:currentUnit null
-    * jump *label275 equal *tmp413 false
+ 1153 jump *label275 equal :rebindUnit.7:currentUnit null
  1154 ubind :rebindUnit.7:currentUnit
  1155 sensor *tmp415 @unit @dead
  1156 op equal *tmp416 *tmp415 0
 
  1167 label *label276
  1168 ubind .TYPE
  1169 set :rebindUnit.7:firstUnit @unit
-    * op notEqual *tmp421 :rebindUnit.7:firstUnit null
-    * jump *label279 equal *tmp421 false
+ 1170 jump *label279 equal :rebindUnit.7:firstUnit null
  1171 label *label281
  1172 sensor *tmp423 @unit @controlled
-    * op equal *tmp424 *tmp423 0
-    * jump *label284 equal *tmp424 false
+ 1173 jump *label284 notEqual *tmp423 0
  1174 jump *label274 always
  1175 jump *label285 always
  1176 label *label284
 
  1196 op or *tmp433 *tmp431 *tmp432
  1197 jump *label286 equal *tmp433 false
  1198 sensor *tmp435 @unit @firstItem
-    * op equal *tmp436 *tmp435 :processUnit.3:item
-    * jump *label288 equal *tmp436 false
+ 1199 jump *label288 notEqual *tmp435 :processUnit.3:item
  1200 set :processUnit.3:state 3
  1201 jump *label289 always
  1202 label *label288
  1203 sensor *tmp438 @unit @totalItems
-    * op equal *tmp439 *tmp438 0
-    * jump *label290 equal *tmp439 false
+ 1204 jump *label290 notEqual *tmp438 0
  1205 set :processUnit.3:state 2
  1206 jump *label291 always
  1207 label *label290
 
  1218 jump *label287 always
  1219 label *label286
  1220 label *label287
-    * op equal *tmp443 :processUnit.3:state 2
-    * jump *label294 equal *tmp443 false
+ 1221 jump *label294 notEqual :processUnit.3:state 2
  1222 ucontrol within .CORE_X .CORE_Y 8 *tmp445
  1223 jump *label296 equal *tmp445 false
  1224 ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
  1225 sensor *tmp447 @unit @totalItems
-    * op greaterThanEq *tmp448 *tmp447 .UNIT_CAPACITY
-    * jump *label298 equal *tmp448 false
+ 1226 jump *label298 lessThan *tmp447 .UNIT_CAPACITY
  1227 ucontrol approach .DOME_X .DOME_Y 6
  1228 set :processUnit.3:state 3
  1229 jump *label299 always
 
  1245 jump *label295 always
  1246 label *label294
  1247 label *label295
-    * op equal *tmp457 :processUnit.3:state 3
-    * jump *label300 equal *tmp457 false
+ 1248 jump *label300 notEqual :processUnit.3:state 3
  1249 ucontrol within .DOME_X .DOME_Y 8 *tmp459
  1250 jump *label302 equal *tmp459 false
  1251 jump *label304 equal :processUnit.3:supply false
 
  1257 set .MSG ", waiting\n"
  1258 label *label305
  1259 sensor *tmp462 @unit @totalItems
-    * op lessThanEq *tmp463 *tmp462 0
-    * jump *label306 equal *tmp463 false
+ 1260 jump *label306 greaterThan *tmp462 0
  1261 ucontrol approach .CORE_X .CORE_Y 6
  1262 set :processUnit.3:state 2
  1263 jump *label307 always
 
  1289 print *tmp472
  1290 print "["
  1291 print "]"
-    * op greaterThanEq *tmp473 :processUnit.3:distance 0
-    * jump *label308 equal *tmp473 false
+ 1292 jump *label308 lessThan :processUnit.3:distance 0
  1293 print .MSG
  1294 print :processUnit.3:distance
  1295 print "["
 
  1334 set :areUnitsAvailable.2:needed 0
  1335 ubind :areUnitsAvailable.2:type
  1336 set :areUnitsAvailable.2:firstUnit @unit
-    * op notEqual *tmp488 :areUnitsAvailable.2:firstUnit null
-    * jump *label315 equal *tmp488 false
+ 1337 jump *label315 equal :areUnitsAvailable.2:firstUnit null
  1338 # "Function: inline def needsFourUnits(in unit)"
  1339 set :needsFourUnits.3:unit @unit
  1340 op sub *tmp491 .DOME_X .CORE_X
 
  1362 op or *tmp503 *tmp500 *tmp502
  1363 jump *label323 equal *tmp503 false
  1364 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * op greaterThanEq *tmp505 :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
-    * jump *label325 equal *tmp505 false
+ 1365 jump *label325 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1366 set *tmp487 true
  1367 jump *label314 always
  1368 jump *label326 always
 
  1391 print ","
  1392 print " free: "
  1393 print :areUnitsAvailable.2:free
-    * op greaterThan *tmp513 :areUnitsAvailable.2:needed 0
-    * jump *label329 equal *tmp513 false
+ 1394 jump *label329 lessThanEq :areUnitsAvailable.2:needed 0
  1395 print ", needed: "
  1396 print :areUnitsAvailable.2:needed
  1397 jump *label330 always

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-81 instructions):
 
    34 call *label0 :locateCore*retaddr :locateCore*retval
    35 jump *label15 equal :locateCore*retval false
    36 jump *label1 always
-    * jump *label16 always
    37 label *label15
    38 label *label16
    39 label *label9
 
   101 jump *label35 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
   102 set *tmp10 true
   103 jump *label24 always
-    * jump *label36 always
   104 label *label35
   105 label *label36
   106 jump *label34 always
 
   115 op land *tmp34 *tmp31 *tmp33
   116 jump *label30 notEqual *tmp34 false
   117 label *label32
-    * jump *label26 always
   118 label *label25
   119 label *label26
   120 jump *label37 equal :areUnitsAvailable:output false
 
   128 jump *label39 lessThanEq :areUnitsAvailable:needed 0
   129 print ", needed: "
   130 print :areUnitsAvailable:needed
-    * jump *label40 always
   131 label *label39
   132 label *label40
   133 print "\n"
-    * jump *label38 always
   134 label *label37
   135 label *label38
   136 set *tmp10 false
 
   140 jump *label41 equal *tmp10 false
   141 set *tmp9 UNIT_TYPE
   142 jump *label20 always
-    * jump *label42 always
   143 label *label41
   144 label *label42
   145 set :chooseUnitType:type @flare
 
   197 jump *label63 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
   198 set *tmp42 true
   199 jump *label52 always
-    * jump *label64 always
   200 label *label63
   201 label *label64
   202 jump *label62 always
 
   211 op land *tmp66 *tmp63 *tmp65
   212 jump *label58 notEqual *tmp66 false
   213 label *label60
-    * jump *label54 always
   214 label *label53
   215 label *label54
   216 jump *label65 equal :areUnitsAvailable.1:output false
 
   224 jump *label67 lessThanEq :areUnitsAvailable.1:needed 0
   225 print ", needed: "
   226 print :areUnitsAvailable.1:needed
-    * jump *label68 always
   227 label *label67
   228 label *label68
   229 print "\n"
-    * jump *label66 always
   230 label *label65
   231 label *label66
   232 set *tmp42 false
 
   237 printflush null
   238 set *tmp9 :chooseUnitType:type
   239 jump *label20 always
-    * jump *label70 always
   240 label *label69
   241 label *label70
-    * jump *label51 always
   242 label *label50
   243 label *label51
   244 label *label44
 
   264 set :rebindUnits:firstUnit @unit
   265 jump *label72 notEqual :rebindUnits:firstUnit null
   266 end
-    * jump *label73 always
   267 label *label72
   268 label *label73
   269 label *label74
 
   277 set .UNIT_P1 @unit
   278 jump *label79 equal .UNIT_S2 null
   279 jump *label76 always
-    * jump *label80 always
   280 label *label79
   281 label *label80
-    * jump *label78 always
   282 label *label77
   283 label *label78
   284 ubind .TYPE
 
   289 op land *tmp84 *tmp81 *tmp83
   290 jump *label74 notEqual *tmp84 false
   291 label *label76
-    * jump *label71 always
   292 label *label71
   293 # "Function: inline def acquireUnit(in currentUnit)"
   294 set :acquireUnit:currentUnit .UNIT_S1
 
   303 op land *tmp93 *tmp90 *tmp92
   304 jump *label85 equal *tmp93 false
   305 jump *label82 always
-    * jump *label86 always
   306 label *label85
   307 label *label86
-    * jump *label84 always
   308 label *label83
   309 label *label84
   310 ubind .TYPE
 
   314 sensor *tmp97 @unit @controlled
   315 jump *label92 notEqual *tmp97 0
   316 jump *label82 always
-    * jump *label93 always
   317 label *label92
   318 label *label93
   319 ubind .TYPE
 
   324 op land *tmp103 *tmp100 *tmp102
   325 jump *label89 notEqual *tmp103 false
   326 label *label91
-    * jump *label88 always
   327 label *label87
   328 label *label88
   329 end
 
   347 op land *tmp112 *tmp109 *tmp111
   348 jump *label98 equal *tmp112 false
   349 jump *label95 always
-    * jump *label99 always
   350 label *label98
   351 label *label99
-    * jump *label97 always
   352 label *label96
   353 label *label97
   354 ubind .TYPE
 
   358 sensor *tmp116 @unit @controlled
   359 jump *label105 notEqual *tmp116 0
   360 jump *label95 always
-    * jump *label106 always
   361 label *label105
   362 label *label106
   363 ubind .TYPE
 
   368 op land *tmp122 *tmp119 *tmp121
   369 jump *label102 notEqual *tmp122 false
   370 label *label104
-    * jump *label101 always
   371 label *label100
   372 label *label101
   373 end
 
   393 label *label109
   394 set .UNIT_S1 :swap:a
   395 set .UNIT_P1 :swap:b
-    * jump *label108 always
   396 label *label107
   397 label *label108
   398 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   401 op strictEqual *tmp132 .SPEED null
   402 jump *label110 equal *tmp132 false
   403 stop
-    * jump *label111 always
   404 label *label110
   405 label *label111
   406 # "Function: inline def needsFourUnits(in unit)"
 
   430 op land *tmp151 *tmp148 *tmp150
   431 jump *label119 equal *tmp151 false
   432 jump *label116 always
-    * jump *label120 always
   433 label *label119
   434 label *label120
-    * jump *label118 always
   435 label *label117
   436 label *label118
   437 ubind .TYPE
 
   441 sensor *tmp155 @unit @controlled
   442 jump *label126 notEqual *tmp155 0
   443 jump *label116 always
-    * jump *label127 always
   444 label *label126
   445 label *label127
   446 ubind .TYPE
 
   451 op land *tmp161 *tmp158 *tmp160
   452 jump *label123 notEqual *tmp161 false
   453 label *label125
-    * jump *label122 always
   454 label *label121
   455 label *label122
   456 end
 
   474 op land *tmp170 *tmp167 *tmp169
   475 jump *label132 equal *tmp170 false
   476 jump *label129 always
-    * jump *label133 always
   477 label *label132
   478 label *label133
-    * jump *label131 always
   479 label *label130
   480 label *label131
   481 ubind .TYPE
 
   485 sensor *tmp174 @unit @controlled
   486 jump *label139 notEqual *tmp174 0
   487 jump *label129 always
-    * jump *label140 always
   488 label *label139
   489 label *label140
   490 ubind .TYPE
 
   495 op land *tmp180 *tmp177 *tmp179
   496 jump *label136 notEqual *tmp180 false
   497 label *label138
-    * jump *label135 always
   498 label *label134
   499 label *label135
   500 end
 
   520 label *label143
   521 set .UNIT_S1 :swap.1:a
   522 set .UNIT_P2 :swap.1:b
-    * jump *label142 always
   523 label *label141
   524 label *label142
   525 sensor *tmp187 .UNIT_S2 @firstItem
 
   537 label *label146
   538 set .UNIT_S2 :swap.2:a
   539 set .UNIT_P2 :swap.2:b
-    * jump *label145 always
   540 label *label144
   541 label *label145
   542 set .GROUP1 "unit  1"
 
   610 op land *tmp215 *tmp212 *tmp214
   611 jump *label157 equal *tmp215 false
   612 jump *label154 always
-    * jump *label158 always
   613 label *label157
   614 label *label158
-    * jump *label156 always
   615 label *label155
   616 label *label156
   617 ubind .TYPE
 
   621 sensor *tmp219 @unit @controlled
   622 jump *label164 notEqual *tmp219 0
   623 jump *label154 always
-    * jump *label165 always
   624 label *label164
   625 label *label165
   626 ubind .TYPE
 
   631 op land *tmp225 *tmp222 *tmp224
   632 jump *label161 notEqual *tmp225 false
   633 label *label163
-    * jump *label160 always
   634 label *label159
   635 label *label160
   636 end
 
   657 ucontrol within .CORE_X .CORE_Y 8 *tmp237
   658 jump *label172 equal *tmp237 false
   659 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label173 always
   660 label *label172
   661 label *label173
   662 label *label171
   663 label *label169
-    * jump *label167 always
   664 label *label166
   665 label *label167
   666 jump *label174 notEqual :processUnit:state 2
 
   687 op idiv *tmp251 *tmp250 .SPEED_TENTHS
   688 op div :processUnit:distance *tmp251 10
   689 label *label177
-    * jump *label175 always
   690 label *label174
   691 label *label175
   692 jump *label180 notEqual :processUnit:state 3
 
   704 jump *label186 greaterThan *tmp258 0
   705 ucontrol approach .CORE_X .CORE_Y 6
   706 set :processUnit:state 2
-    * jump *label187 always
   707 label *label186
   708 label *label187
   709 jump *label183 always
 
   718 op idiv *tmp266 *tmp265 .SPEED_TENTHS
   719 op div :processUnit:distance *tmp266 10
   720 label *label183
-    * jump *label181 always
   721 label *label180
   722 label *label181
   723 ucontrol flag :processUnit:state
 
   762 op land *tmp281 *tmp278 *tmp280
   763 jump *label196 equal *tmp281 false
   764 jump *label193 always
-    * jump *label197 always
   765 label *label196
   766 label *label197
-    * jump *label195 always
   767 label *label194
   768 label *label195
   769 ubind .TYPE
 
   773 sensor *tmp285 @unit @controlled
   774 jump *label203 notEqual *tmp285 0
   775 jump *label193 always
-    * jump *label204 always
   776 label *label203
   777 label *label204
   778 ubind .TYPE
 
   783 op land *tmp291 *tmp288 *tmp290
   784 jump *label200 notEqual *tmp291 false
   785 label *label202
-    * jump *label199 always
   786 label *label198
   787 label *label199
   788 end
 
   809 ucontrol within .CORE_X .CORE_Y 8 *tmp303
   810 jump *label211 equal *tmp303 false
   811 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label212 always
   812 label *label211
   813 label *label212
   814 label *label210
   815 label *label208
-    * jump *label206 always
   816 label *label205
   817 label *label206
   818 jump *label213 notEqual :processUnit.1:state 2
 
   839 op idiv *tmp317 *tmp316 .SPEED_TENTHS
   840 op div :processUnit.1:distance *tmp317 10
   841 label *label216
-    * jump *label214 always
   842 label *label213
   843 label *label214
   844 jump *label219 notEqual :processUnit.1:state 3
 
   856 jump *label225 greaterThan *tmp324 0
   857 ucontrol approach .CORE_X .CORE_Y 6
   858 set :processUnit.1:state 2
-    * jump *label226 always
   859 label *label225
   860 label *label226
   861 jump *label222 always
 
   870 op idiv *tmp332 *tmp331 .SPEED_TENTHS
   871 op div :processUnit.1:distance *tmp332 10
   872 label *label222
-    * jump *label220 always
   873 label *label219
   874 label *label220
   875 ucontrol flag :processUnit.1:state
 
   905 op equal *tmp338 *tmp341 0
   906 label *label230
   907 set .SUPPLY_S_FIRST *tmp338
-    * jump *label191 always
   908 label *label190
   909 label *label191
   910 # "Function: inline void printDomeStatus(in item, in text)"
 
   943 op land *tmp353 *tmp350 *tmp352
   944 jump *label238 equal *tmp353 false
   945 jump *label235 always
-    * jump *label239 always
   946 label *label238
   947 label *label239
-    * jump *label237 always
   948 label *label236
   949 label *label237
   950 ubind .TYPE
 
   954 sensor *tmp357 @unit @controlled
   955 jump *label245 notEqual *tmp357 0
   956 jump *label235 always
-    * jump *label246 always
   957 label *label245
   958 label *label246
   959 ubind .TYPE
 
   964 op land *tmp363 *tmp360 *tmp362
   965 jump *label242 notEqual *tmp363 false
   966 label *label244
-    * jump *label241 always
   967 label *label240
   968 label *label241
   969 end
 
   990 ucontrol within .CORE_X .CORE_Y 8 *tmp375
   991 jump *label253 equal *tmp375 false
   992 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label254 always
   993 label *label253
   994 label *label254
   995 label *label252
   996 label *label250
-    * jump *label248 always
   997 label *label247
   998 label *label248
   999 jump *label255 notEqual :processUnit.2:state 2
 
  1020 op idiv *tmp389 *tmp388 .SPEED_TENTHS
  1021 op div :processUnit.2:distance *tmp389 10
  1022 label *label258
-    * jump *label256 always
  1023 label *label255
  1024 label *label256
  1025 jump *label261 notEqual :processUnit.2:state 3
 
  1037 jump *label267 greaterThan *tmp396 0
  1038 ucontrol approach .CORE_X .CORE_Y 6
  1039 set :processUnit.2:state 2
-    * jump *label268 always
  1040 label *label267
  1041 label *label268
  1042 jump *label264 always
 
  1051 op idiv *tmp404 *tmp403 .SPEED_TENTHS
  1052 op div :processUnit.2:distance *tmp404 10
  1053 label *label264
-    * jump *label262 always
  1054 label *label261
  1055 label *label262
  1056 ucontrol flag :processUnit.2:state
 
  1095 op land *tmp419 *tmp416 *tmp418
  1096 jump *label277 equal *tmp419 false
  1097 jump *label274 always
-    * jump *label278 always
  1098 label *label277
  1099 label *label278
-    * jump *label276 always
  1100 label *label275
  1101 label *label276
  1102 ubind .TYPE
 
  1106 sensor *tmp423 @unit @controlled
  1107 jump *label284 notEqual *tmp423 0
  1108 jump *label274 always
-    * jump *label285 always
  1109 label *label284
  1110 label *label285
  1111 ubind .TYPE
 
  1116 op land *tmp429 *tmp426 *tmp428
  1117 jump *label281 notEqual *tmp429 false
  1118 label *label283
-    * jump *label280 always
  1119 label *label279
  1120 label *label280
  1121 end
 
  1142 ucontrol within .CORE_X .CORE_Y 8 *tmp441
  1143 jump *label292 equal *tmp441 false
  1144 ucontrol itemDrop .CORE .UNIT_CAPACITY
-    * jump *label293 always
  1145 label *label292
  1146 label *label293
  1147 label *label291
  1148 label *label289
-    * jump *label287 always
  1149 label *label286
  1150 label *label287
  1151 jump *label294 notEqual :processUnit.3:state 2
 
  1172 op idiv *tmp455 *tmp454 .SPEED_TENTHS
  1173 op div :processUnit.3:distance *tmp455 10
  1174 label *label297
-    * jump *label295 always
  1175 label *label294
  1176 label *label295
  1177 jump *label300 notEqual :processUnit.3:state 3
 
  1189 jump *label306 greaterThan *tmp462 0
  1190 ucontrol approach .CORE_X .CORE_Y 6
  1191 set :processUnit.3:state 2
-    * jump *label307 always
  1192 label *label306
  1193 label *label307
  1194 jump *label303 always
 
  1203 op idiv *tmp470 *tmp469 .SPEED_TENTHS
  1204 op div :processUnit.3:distance *tmp470 10
  1205 label *label303
-    * jump *label301 always
  1206 label *label300
  1207 label *label301
  1208 ucontrol flag :processUnit.3:state
 
  1238 op equal *tmp476 *tmp479 0
  1239 label *label311
  1240 set .SUPPLY_P_FIRST *tmp476
-    * jump *label272 always
  1241 label *label271
  1242 label *label272
  1243 op sub *tmp481 @time :start
 
  1291 jump *label325 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
  1292 set *tmp487 true
  1293 jump *label314 always
-    * jump *label326 always
  1294 label *label325
  1295 label *label326
  1296 jump *label324 always
 
  1305 op land *tmp511 *tmp508 *tmp510
  1306 jump *label320 notEqual *tmp511 false
  1307 label *label322
-    * jump *label316 always
  1308 label *label315
  1309 label *label316
  1310 jump *label327 equal :areUnitsAvailable.2:output false
 
  1318 jump *label329 lessThanEq :areUnitsAvailable.2:needed 0
  1319 print ", needed: "
  1320 print :areUnitsAvailable.2:needed
-    * jump *label330 always
  1321 label *label329
  1322 label *label330
  1323 print "\n"
-    * jump *label328 always
  1324 label *label327
  1325 label *label328
  1326 set *tmp487 false
 
  1329 label *label314
  1330 jump *label331 equal *tmp487 false
  1331 end
-    * jump *label332 always
  1332 label *label331
  1333 label *label332
  1334 op add :unitCheck @time 5000
-    * jump *label313 always
  1335 label *label312
  1336 label *label313
  1337 label *label148
 
  1348 op or *tmp521 *tmp518 *tmp520
  1349 jump *label334 equal *tmp521 false
  1350 ulocate building core false @copper 0 0 0 .CORE
-    * jump *label335 always
  1351 label *label334
  1352 label *label335
  1353 set :locateCore*retval .CORE

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-11 instructions):
 
    68 set :areUnitsAvailable:free 0
    69 set :areUnitsAvailable:occupied 0
    70 set :areUnitsAvailable:needed 0
-    * ubind :areUnitsAvailable:type
+   71 ubind UNIT_TYPE
    72 set :areUnitsAvailable:firstUnit @unit
    73 jump *label25 equal :areUnitsAvailable:firstUnit null
    74 # "Function: inline def needsFourUnits(in unit)"
 
    81 op div :needsFourUnits:travel_time *tmp17 *tmp18
    82 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    83 jump *label27 always
-    * set *tmp13 null
    84 label *label27
    85 jump *label28 equal *tmp13 false
    86 set *tmp21 4
 
    97 op or *tmp26 *tmp23 *tmp25
    98 jump *label33 equal *tmp26 false
    99 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label35 lessThan :areUnitsAvailable:free :areUnitsAvailable:needed
+  100 jump *label35 lessThan :areUnitsAvailable:free *tmp21
   101 set *tmp10 true
   102 jump *label24 always
   103 label *label35
 
   106 label *label33
   107 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
   108 label *label34
-    * ubind :areUnitsAvailable:type
+  109 ubind UNIT_TYPE
   110 label *label31
   111 op notEqual *tmp31 @unit :areUnitsAvailable:firstUnit
   112 sensor *tmp32 :areUnitsAvailable:firstUnit @dead
 
   116 label *label32
   117 label *label25
   118 label *label26
-    * jump *label37 equal :areUnitsAvailable:output false
-    * print :areUnitsAvailable:type
+  119 jump *label37 equal true false
+  120 print UNIT_TYPE
   121 print ":"
   122 print " occupied: "
   123 print :areUnitsAvailable:occupied
 
   134 label *label38
   135 set *tmp10 false
   136 jump *label24 always
-    * set *tmp10 null
   137 label *label24
   138 jump *label41 equal *tmp10 false
   139 set *tmp9 UNIT_TYPE
 
   162 set :areUnitsAvailable.1:free 0
   163 set :areUnitsAvailable.1:occupied 0
   164 set :areUnitsAvailable.1:needed 0
-    * ubind :areUnitsAvailable.1:type
+  165 ubind :chooseUnitType:type
   166 set :areUnitsAvailable.1:firstUnit @unit
   167 jump *label53 equal :areUnitsAvailable.1:firstUnit null
   168 # "Function: inline def needsFourUnits(in unit)"
 
   175 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   176 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   177 jump *label55 always
-    * set *tmp45 null
   178 label *label55
   179 jump *label56 equal *tmp45 false
   180 set *tmp53 4
 
   191 op or *tmp58 *tmp55 *tmp57
   192 jump *label61 equal *tmp58 false
   193 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label63 lessThan :areUnitsAvailable.1:free :areUnitsAvailable.1:needed
+  194 jump *label63 lessThan :areUnitsAvailable.1:free *tmp53
   195 set *tmp42 true
   196 jump *label52 always
   197 label *label63
 
   200 label *label61
   201 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   202 label *label62
-    * ubind :areUnitsAvailable.1:type
+  203 ubind :chooseUnitType:type
   204 label *label59
   205 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   206 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   210 label *label60
   211 label *label53
   212 label *label54
-    * jump *label65 equal :areUnitsAvailable.1:output false
-    * print :areUnitsAvailable.1:type
+  213 jump *label65 equal true false
+  214 print :chooseUnitType:type
   215 print ":"
   216 print " occupied: "
   217 print :areUnitsAvailable.1:occupied
 
   228 label *label66
   229 set *tmp42 false
   230 jump *label52 always
-    * set *tmp42 null
   231 label *label52
   232 jump *label69 equal *tmp42 false
   233 printflush null
 
   252 printflush message1
   253 # "Function: inline def rebindUnits()"
   254 set .UNIT_P2 null
-    * set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P1 .UNIT_S2
-    * set .UNIT_S1 .UNIT_P1
+  255 set .UNIT_S2 null
+  256 set .UNIT_P1 .UNIT_P2
+  257 set .UNIT_S1 .UNIT_S2
   258 set :rebindUnits:count 0
-    * ubind .TYPE
+  259 ubind *tmp9
   260 set :rebindUnits:firstUnit @unit
   261 jump *label72 notEqual :rebindUnits:firstUnit null
   262 end
 
   277 label *label80
   278 label *label77
   279 label *label78
-    * ubind .TYPE
+  280 ubind *tmp9
   281 label *label75
   282 op notEqual *tmp81 @unit :rebindUnits:firstUnit
   283 sensor *tmp82 :rebindUnits:firstUnit @dead
 
   289 # "Function: inline def acquireUnit(in currentUnit)"
   290 set :acquireUnit:currentUnit .UNIT_S1
   291 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit:currentUnit :acquireUnit:currentUnit
-    * jump *label83 equal :rebindUnit:currentUnit null
-    * ubind :rebindUnit:currentUnit
+  292 set :rebindUnit:currentUnit .UNIT_S1
+  293 jump *label83 equal :acquireUnit:currentUnit null
+  294 ubind :acquireUnit:currentUnit
   295 sensor *tmp89 @unit @dead
   296 op equal *tmp90 *tmp89 0
   297 sensor *tmp91 @unit @controller
 
   303 label *label86
   304 label *label83
   305 label *label84
-    * ubind .TYPE
+  306 ubind *tmp9
   307 set :rebindUnit:firstUnit @unit
   308 jump *label87 equal :rebindUnit:firstUnit null
   309 label *label89
 
   312 jump *label82 always
   313 label *label92
   314 label *label93
-    * ubind .TYPE
+  315 ubind *tmp9
   316 label *label90
   317 op notEqual *tmp100 @unit :rebindUnit:firstUnit
   318 sensor *tmp101 :rebindUnit:firstUnit @dead
 
   327 ucontrol flag 1
   328 set *tmp85 @unit
   329 jump *label81 always
-    * set *tmp85 null
   330 label *label81
   331 set .UNIT_S1 *tmp85
   332 # "Function: inline def acquireUnit(in currentUnit)"
   333 set :acquireUnit.1:currentUnit .UNIT_P1
   334 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit :acquireUnit.1:currentUnit
-    * jump *label96 equal :rebindUnit.1:currentUnit null
-    * ubind :rebindUnit.1:currentUnit
+  335 set :rebindUnit.1:currentUnit .UNIT_P1
+  336 jump *label96 equal :acquireUnit.1:currentUnit null
+  337 ubind :acquireUnit.1:currentUnit
   338 sensor *tmp108 @unit @dead
   339 op equal *tmp109 *tmp108 0
   340 sensor *tmp110 @unit @controller
 
   346 label *label99
   347 label *label96
   348 label *label97
-    * ubind .TYPE
+  349 ubind *tmp9
   350 set :rebindUnit.1:firstUnit @unit
   351 jump *label100 equal :rebindUnit.1:firstUnit null
   352 label *label102
 
   355 jump *label95 always
   356 label *label105
   357 label *label106
-    * ubind .TYPE
+  358 ubind *tmp9
   359 label *label103
   360 op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
   361 sensor *tmp120 :rebindUnit.1:firstUnit @dead
 
   370 ucontrol flag 1
   371 set *tmp104 @unit
   372 jump *label94 always
-    * set *tmp104 null
   373 label *label94
   374 set .UNIT_P1 *tmp104
-    * sensor *tmp123 .UNIT_S1 @firstItem
+  375 sensor *tmp123 *tmp85 @firstItem
   376 op equal *tmp124 *tmp123 @phase-fabric
-    * sensor *tmp125 .UNIT_P1 @firstItem
+  377 sensor *tmp125 *tmp104 @firstItem
   378 op equal *tmp126 *tmp125 @silicon
   379 op or *tmp127 *tmp124 *tmp126
   380 jump *label107 equal *tmp127 false
   381 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:a .UNIT_S1
-    * set :swap:b .UNIT_P1
-    * set :swap:t :swap:a
-    * set :swap:a :swap:b
+  382 set :swap:a *tmp85
+  383 set :swap:b *tmp104
+  384 set :swap:t .UNIT_S1
+  385 set :swap:a .UNIT_P1
   386 set :swap:b :swap:t
   387 label *label109
   388 set .UNIT_S1 :swap:a
-    * set .UNIT_P1 :swap:b
+  389 set .UNIT_P1 :swap:t
   390 label *label107
   391 label *label108
   392 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   403 op sub *tmp136 .DOME_Y .CORE_Y
   404 op len *tmp137 *tmp135 *tmp136
   405 op mul *tmp138 2 *tmp137
-    * sensor *tmp139 :needsFourUnits.2:unit @speed
-    * op div :needsFourUnits.2:travel_time *tmp138 *tmp139
+  406 sensor *tmp139 .UNIT_S1 @speed
+  407 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   408 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   409 jump *label112 always
-    * set *tmp134 null
   410 label *label112
   411 set .FOUR_UNITS *tmp134
-    * jump *label113 equal .FOUR_UNITS false
+  412 jump *label113 equal *tmp134 false
   413 # "Function: inline def acquireUnit(in currentUnit)"
   414 set :acquireUnit.2:currentUnit .UNIT_S2
   415 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit :acquireUnit.2:currentUnit
-    * jump *label117 equal :rebindUnit.2:currentUnit null
-    * ubind :rebindUnit.2:currentUnit
+  416 set :rebindUnit.2:currentUnit .UNIT_S2
+  417 jump *label117 equal :acquireUnit.2:currentUnit null
+  418 ubind :acquireUnit.2:currentUnit
   419 sensor *tmp147 @unit @dead
   420 op equal *tmp148 *tmp147 0
   421 sensor *tmp149 @unit @controller
 
   427 label *label120
   428 label *label117
   429 label *label118
-    * ubind .TYPE
+  430 ubind *tmp9
   431 set :rebindUnit.2:firstUnit @unit
   432 jump *label121 equal :rebindUnit.2:firstUnit null
   433 label *label123
 
   436 jump *label116 always
   437 label *label126
   438 label *label127
-    * ubind .TYPE
+  439 ubind *tmp9
   440 label *label124
   441 op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
   442 sensor *tmp159 :rebindUnit.2:firstUnit @dead
 
   451 ucontrol flag 1
   452 set *tmp143 @unit
   453 jump *label115 always
-    * set *tmp143 null
   454 label *label115
   455 set .UNIT_S2 *tmp143
   456 # "Function: inline def acquireUnit(in currentUnit)"
   457 set :acquireUnit.3:currentUnit .UNIT_P2
   458 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit :acquireUnit.3:currentUnit
-    * jump *label130 equal :rebindUnit.3:currentUnit null
-    * ubind :rebindUnit.3:currentUnit
+  459 set :rebindUnit.3:currentUnit .UNIT_P2
+  460 jump *label130 equal :acquireUnit.3:currentUnit null
+  461 ubind :acquireUnit.3:currentUnit
   462 sensor *tmp166 @unit @dead
   463 op equal *tmp167 *tmp166 0
   464 sensor *tmp168 @unit @controller
 
   470 label *label133
   471 label *label130
   472 label *label131
-    * ubind .TYPE
+  473 ubind *tmp9
   474 set :rebindUnit.3:firstUnit @unit
   475 jump *label134 equal :rebindUnit.3:firstUnit null
   476 label *label136
 
   479 jump *label129 always
   480 label *label139
   481 label *label140
-    * ubind .TYPE
+  482 ubind *tmp9
   483 label *label137
   484 op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
   485 sensor *tmp178 :rebindUnit.3:firstUnit @dead
 
   494 ucontrol flag 1
   495 set *tmp162 @unit
   496 jump *label128 always
-    * set *tmp162 null
   497 label *label128
   498 set .UNIT_P2 *tmp162
   499 sensor *tmp181 .UNIT_S1 @firstItem
   500 op equal *tmp182 *tmp181 @phase-fabric
-    * sensor *tmp183 .UNIT_P2 @firstItem
+  501 sensor *tmp183 *tmp162 @firstItem
   502 op notEqual *tmp184 *tmp183 @phase-fabric
   503 op land *tmp185 *tmp182 *tmp184
   504 jump *label141 equal *tmp185 false
   505 # "Function: inline void swap(in out a, in out b)"
   506 set :swap.1:a .UNIT_S1
-    * set :swap.1:b .UNIT_P2
-    * set :swap.1:t :swap.1:a
-    * set :swap.1:a :swap.1:b
+  507 set :swap.1:b *tmp162
+  508 set :swap.1:t .UNIT_S1
+  509 set :swap.1:a .UNIT_P2
   510 set :swap.1:b :swap.1:t
   511 label *label143
   512 set .UNIT_S1 :swap.1:a
-    * set .UNIT_P2 :swap.1:b
+  513 set .UNIT_P2 :swap.1:t
   514 label *label141
   515 label *label142
-    * sensor *tmp187 .UNIT_S2 @firstItem
+  516 sensor *tmp187 *tmp143 @firstItem
   517 op equal *tmp188 *tmp187 @phase-fabric
   518 sensor *tmp189 .UNIT_P2 @firstItem
   519 op equal *tmp190 *tmp189 @silicon
   520 op or *tmp191 *tmp188 *tmp190
   521 jump *label144 equal *tmp191 false
   522 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:a .UNIT_S2
+  523 set :swap.2:a *tmp143
   524 set :swap.2:b .UNIT_P2
-    * set :swap.2:t :swap.2:a
-    * set :swap.2:a :swap.2:b
+  525 set :swap.2:t .UNIT_S2
+  526 set :swap.2:a .UNIT_P2
   527 set :swap.2:b :swap.2:t
   528 label *label146
   529 set .UNIT_S2 :swap.2:a
-    * set .UNIT_P2 :swap.2:b
+  530 set .UNIT_P2 :swap.2:t
   531 label *label144
   532 label *label145
   533 set .GROUP1 "unit  1"
 
   542 set .UNIT_P2 null
   543 set .GROUP1 "unit"
   544 label *label114
-    * op equal *tmp193 .FOUR_UNITS false
+  545 op equal *tmp193 *tmp134 false
   546 sensor *tmp194 .UNIT_S1 @totalItems
   547 sensor *tmp195 .UNIT_S2 @totalItems
   548 op lessThan *tmp196 *tmp194 *tmp195
   549 op or .SUPPLY_S_FIRST *tmp193 *tmp196
-    * op equal *tmp198 .FOUR_UNITS false
+  550 op equal *tmp198 *tmp134 false
   551 sensor *tmp199 .UNIT_P1 @totalItems
   552 sensor *tmp200 .UNIT_P2 @totalItems
   553 op lessThan *tmp201 *tmp199 *tmp200
-    * op or .SUPPLY_P_FIRST *tmp198 *tmp201
+  554 op or .SUPPLY_P_FIRST *tmp193 *tmp201
   555 op add :unitCheck @time 5000
   556 label *label147
   557 sensor *tmp204 switch1 @enabled
 
   561 print "\n"
   562 print "\n"
   563 print "Unit type: [green]"
-    * print .TYPE
+  564 print *tmp9
   565 print "["
   566 print "]"
   567 print "\n"
   568 # "Function: inline void printDomeStatus(in item, in text)"
   569 set :printDomeStatus:item @silicon
   570 set :printDomeStatus:text "\n[green]Silicon[] status:\n"
-    * print :printDomeStatus:text
-    * sensor :printDomeStatus:level .DOME :printDomeStatus:item
+  571 print "\n[green]Silicon[] status:\n"
+  572 sensor :printDomeStatus:level .DOME @silicon
   573 jump *label151 lessThanEq :printDomeStatus:level 3
   574 print "  dome:  [green]"
   575 print :printDomeStatus:level
 
   591 set :processUnit:group .GROUP1
   592 set :processUnit:supply .SUPPLY_S_FIRST
   593 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit :processUnit:unit
-    * jump *label155 equal :rebindUnit.4:currentUnit null
-    * ubind :rebindUnit.4:currentUnit
+  594 set :rebindUnit.4:currentUnit .UNIT_S1
+  595 jump *label155 equal :processUnit:unit null
+  596 ubind :processUnit:unit
   597 sensor *tmp211 @unit @dead
   598 op equal *tmp212 *tmp211 0
   599 sensor *tmp213 @unit @controller
 
   605 label *label158
   606 label *label155
   607 label *label156
-    * ubind .TYPE
+  608 ubind *tmp9
   609 set :rebindUnit.4:firstUnit @unit
   610 jump *label159 equal :rebindUnit.4:firstUnit null
   611 label *label161
 
   614 jump *label154 always
   615 label *label164
   616 label *label165
-    * ubind .TYPE
+  617 ubind *tmp9
   618 label *label162
   619 op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
   620 sensor *tmp223 :rebindUnit.4:firstUnit @dead
 
   634 op or *tmp229 *tmp227 *tmp228
   635 jump *label166 equal *tmp229 false
   636 sensor *tmp231 @unit @firstItem
-    * jump *label168 notEqual *tmp231 :processUnit:item
+  637 jump *label168 notEqual *tmp231 @silicon
   638 set :processUnit:state 3
   639 jump *label169 always
   640 label *label168
 
   657 jump *label174 notEqual :processUnit:state 2
   658 ucontrol within .CORE_X .CORE_Y 8 *tmp241
   659 jump *label176 equal *tmp241 false
-    * ucontrol itemTake .CORE :processUnit:item .UNIT_CAPACITY
+  660 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   661 sensor *tmp243 @unit @totalItems
   662 jump *label178 lessThan *tmp243 .UNIT_CAPACITY
   663 ucontrol approach .DOME_X .DOME_Y 6
 
   683 jump *label180 notEqual :processUnit:state 3
   684 ucontrol within .DOME_X .DOME_Y 8 *tmp255
   685 jump *label182 equal *tmp255 false
-    * jump *label184 equal :processUnit:supply false
+  686 jump *label184 equal .SUPPLY_S_FIRST false
   687 ucontrol itemDrop .DOME .UNIT_CAPACITY
   688 set .MSG ", supplying\n"
   689 jump *label185 always
 
   714 ucontrol flag :processUnit:state
   715 sensor *tmp268 @unit @totalItems
   716 print "  "
-    * print :processUnit:group
+  717 print .GROUP1
   718 print ":"
   719 print " ["
-    * print :processUnit:color
+  720 print "gold"
   721 print "]"
   722 print *tmp268
   723 print "["
 
   735 set :processUnit:unit @unit
   736 label *label153
   737 set .UNIT_S1 :processUnit:unit
-    * jump *label190 equal .FOUR_UNITS false
+  738 jump *label190 equal *tmp134 false
   739 op equal *tmp273 .SUPPLY_S_FIRST false
   740 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   741 set :processUnit.1:unit .UNIT_S2
 
   743 set :processUnit.1:group .GROUP2
   744 set :processUnit.1:supply *tmp273
   745 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit :processUnit.1:unit
-    * jump *label194 equal :rebindUnit.5:currentUnit null
-    * ubind :rebindUnit.5:currentUnit
+  746 set :rebindUnit.5:currentUnit .UNIT_S2
+  747 jump *label194 equal :processUnit.1:unit null
+  748 ubind :processUnit.1:unit
   749 sensor *tmp277 @unit @dead
   750 op equal *tmp278 *tmp277 0
   751 sensor *tmp279 @unit @controller
 
   757 label *label197
   758 label *label194
   759 label *label195
-    * ubind .TYPE
+  760 ubind *tmp9
   761 set :rebindUnit.5:firstUnit @unit
   762 jump *label198 equal :rebindUnit.5:firstUnit null
   763 label *label200
 
   766 jump *label193 always
   767 label *label203
   768 label *label204
-    * ubind .TYPE
+  769 ubind *tmp9
   770 label *label201
   771 op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
   772 sensor *tmp289 :rebindUnit.5:firstUnit @dead
 
   786 op or *tmp295 *tmp293 *tmp294
   787 jump *label205 equal *tmp295 false
   788 sensor *tmp297 @unit @firstItem
-    * jump *label207 notEqual *tmp297 :processUnit.1:item
+  789 jump *label207 notEqual *tmp297 @silicon
   790 set :processUnit.1:state 3
   791 jump *label208 always
   792 label *label207
 
   809 jump *label213 notEqual :processUnit.1:state 2
   810 ucontrol within .CORE_X .CORE_Y 8 *tmp307
   811 jump *label215 equal *tmp307 false
-    * ucontrol itemTake .CORE :processUnit.1:item .UNIT_CAPACITY
+  812 ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
   813 sensor *tmp309 @unit @totalItems
   814 jump *label217 lessThan *tmp309 .UNIT_CAPACITY
   815 ucontrol approach .DOME_X .DOME_Y 6
 
   835 jump *label219 notEqual :processUnit.1:state 3
   836 ucontrol within .DOME_X .DOME_Y 8 *tmp321
   837 jump *label221 equal *tmp321 false
-    * jump *label223 equal :processUnit.1:supply false
+  838 jump *label223 equal *tmp273 false
   839 ucontrol itemDrop .DOME .UNIT_CAPACITY
   840 set .MSG ", supplying\n"
   841 jump *label224 always
 
   866 ucontrol flag :processUnit.1:state
   867 sensor *tmp334 @unit @totalItems
   868 print "  "
-    * print :processUnit.1:group
+  869 print .GROUP2
   870 print ":"
   871 print " ["
-    * print :processUnit.1:color
+  872 print "gold"
   873 print "]"
   874 print *tmp334
   875 print "["
 
   888 label *label192
   889 set .UNIT_S2 :processUnit.1:unit
   890 jump *label229 equal .SUPPLY_S_FIRST false
-    * sensor *tmp339 .UNIT_S1 @totalItems
+  891 sensor *tmp339 :processUnit:unit @totalItems
   892 op greaterThan *tmp338 *tmp339 0
   893 jump *label230 always
   894 label *label229
-    * sensor *tmp341 .UNIT_S2 @totalItems
+  895 sensor *tmp341 :processUnit.1:unit @totalItems
   896 op equal *tmp338 *tmp341 0
   897 label *label230
   898 set .SUPPLY_S_FIRST *tmp338
 
   901 # "Function: inline void printDomeStatus(in item, in text)"
   902 set :printDomeStatus.1:item @phase-fabric
   903 set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
-    * print :printDomeStatus.1:text
-    * sensor :printDomeStatus.1:level .DOME :printDomeStatus.1:item
+  904 print "\n[green]Phase fabric[] status:\n"
+  905 sensor :printDomeStatus.1:level .DOME @phase-fabric
   906 jump *label232 lessThanEq :printDomeStatus.1:level 3
   907 print "  dome:  [green]"
   908 print :printDomeStatus.1:level
 
   924 set :processUnit.2:group .GROUP1
   925 set :processUnit.2:supply .SUPPLY_P_FIRST
   926 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit :processUnit.2:unit
-    * jump *label236 equal :rebindUnit.6:currentUnit null
-    * ubind :rebindUnit.6:currentUnit
+  927 set :rebindUnit.6:currentUnit .UNIT_P1
+  928 jump *label236 equal :processUnit.2:unit null
+  929 ubind :processUnit.2:unit
   930 sensor *tmp349 @unit @dead
   931 op equal *tmp350 *tmp349 0
   932 sensor *tmp351 @unit @controller
 
   938 label *label239
   939 label *label236
   940 label *label237
-    * ubind .TYPE
+  941 ubind *tmp9
   942 set :rebindUnit.6:firstUnit @unit
   943 jump *label240 equal :rebindUnit.6:firstUnit null
   944 label *label242
 
   947 jump *label235 always
   948 label *label245
   949 label *label246
-    * ubind .TYPE
+  950 ubind *tmp9
   951 label *label243
   952 op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
   953 sensor *tmp361 :rebindUnit.6:firstUnit @dead
 
   967 op or *tmp367 *tmp365 *tmp366
   968 jump *label247 equal *tmp367 false
   969 sensor *tmp369 @unit @firstItem
-    * jump *label249 notEqual *tmp369 :processUnit.2:item
+  970 jump *label249 notEqual *tmp369 @phase-fabric
   971 set :processUnit.2:state 3
   972 jump *label250 always
   973 label *label249
 
   990 jump *label255 notEqual :processUnit.2:state 2
   991 ucontrol within .CORE_X .CORE_Y 8 *tmp379
   992 jump *label257 equal *tmp379 false
-    * ucontrol itemTake .CORE :processUnit.2:item .UNIT_CAPACITY
+  993 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
   994 sensor *tmp381 @unit @totalItems
   995 jump *label259 lessThan *tmp381 .UNIT_CAPACITY
   996 ucontrol approach .DOME_X .DOME_Y 6
 
  1016 jump *label261 notEqual :processUnit.2:state 3
  1017 ucontrol within .DOME_X .DOME_Y 8 *tmp393
  1018 jump *label263 equal *tmp393 false
-    * jump *label265 equal :processUnit.2:supply false
+ 1019 jump *label265 equal .SUPPLY_P_FIRST false
  1020 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1021 set .MSG ", supplying\n"
  1022 jump *label266 always
 
  1047 ucontrol flag :processUnit.2:state
  1048 sensor *tmp406 @unit @totalItems
  1049 print "  "
-    * print :processUnit.2:group
+ 1050 print .GROUP1
  1051 print ":"
  1052 print " ["
-    * print :processUnit.2:color
+ 1053 print "gold"
  1054 print "]"
  1055 print *tmp406
  1056 print "["
 
  1068 set :processUnit.2:unit @unit
  1069 label *label234
  1070 set .UNIT_P1 :processUnit.2:unit
-    * jump *label271 equal .FOUR_UNITS false
+ 1071 jump *label271 equal *tmp134 false
  1072 op equal *tmp411 .SUPPLY_P_FIRST false
  1073 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
  1074 set :processUnit.3:unit .UNIT_P2
 
  1076 set :processUnit.3:group .GROUP2
  1077 set :processUnit.3:supply *tmp411
  1078 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit :processUnit.3:unit
-    * jump *label275 equal :rebindUnit.7:currentUnit null
-    * ubind :rebindUnit.7:currentUnit
+ 1079 set :rebindUnit.7:currentUnit .UNIT_P2
+ 1080 jump *label275 equal :processUnit.3:unit null
+ 1081 ubind :processUnit.3:unit
  1082 sensor *tmp415 @unit @dead
  1083 op equal *tmp416 *tmp415 0
  1084 sensor *tmp417 @unit @controller
 
  1090 label *label278
  1091 label *label275
  1092 label *label276
-    * ubind .TYPE
+ 1093 ubind *tmp9
  1094 set :rebindUnit.7:firstUnit @unit
  1095 jump *label279 equal :rebindUnit.7:firstUnit null
  1096 label *label281
 
  1099 jump *label274 always
  1100 label *label284
  1101 label *label285
-    * ubind .TYPE
+ 1102 ubind *tmp9
  1103 label *label282
  1104 op notEqual *tmp426 @unit :rebindUnit.7:firstUnit
  1105 sensor *tmp427 :rebindUnit.7:firstUnit @dead
 
  1119 op or *tmp433 *tmp431 *tmp432
  1120 jump *label286 equal *tmp433 false
  1121 sensor *tmp435 @unit @firstItem
-    * jump *label288 notEqual *tmp435 :processUnit.3:item
+ 1122 jump *label288 notEqual *tmp435 @phase-fabric
  1123 set :processUnit.3:state 3
  1124 jump *label289 always
  1125 label *label288
 
  1142 jump *label294 notEqual :processUnit.3:state 2
  1143 ucontrol within .CORE_X .CORE_Y 8 *tmp445
  1144 jump *label296 equal *tmp445 false
-    * ucontrol itemTake .CORE :processUnit.3:item .UNIT_CAPACITY
+ 1145 ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
  1146 sensor *tmp447 @unit @totalItems
  1147 jump *label298 lessThan *tmp447 .UNIT_CAPACITY
  1148 ucontrol approach .DOME_X .DOME_Y 6
 
  1168 jump *label300 notEqual :processUnit.3:state 3
  1169 ucontrol within .DOME_X .DOME_Y 8 *tmp459
  1170 jump *label302 equal *tmp459 false
-    * jump *label304 equal :processUnit.3:supply false
+ 1171 jump *label304 equal *tmp411 false
  1172 ucontrol itemDrop .DOME .UNIT_CAPACITY
  1173 set .MSG ", supplying\n"
  1174 jump *label305 always
 
  1199 ucontrol flag :processUnit.3:state
  1200 sensor *tmp472 @unit @totalItems
  1201 print "  "
-    * print :processUnit.3:group
+ 1202 print .GROUP2
  1203 print ":"
  1204 print " ["
-    * print :processUnit.3:color
+ 1205 print "gold"
  1206 print "]"
  1207 print *tmp472
  1208 print "["
 
  1221 label *label273
  1222 set .UNIT_P2 :processUnit.3:unit
  1223 jump *label310 equal .SUPPLY_P_FIRST false
-    * sensor *tmp477 .UNIT_P1 @totalItems
+ 1224 sensor *tmp477 :processUnit.2:unit @totalItems
  1225 op greaterThan *tmp476 *tmp477 0
  1226 jump *label311 always
  1227 label *label310
-    * sensor *tmp479 .UNIT_P2 @totalItems
+ 1228 sensor *tmp479 :processUnit.3:unit @totalItems
  1229 op equal *tmp476 *tmp479 0
  1230 label *label311
  1231 set .SUPPLY_P_FIRST *tmp476
 
  1239 print " "
  1240 print "ms"
  1241 printflush message1
-    * op notEqual *tmp483 .TYPE UNIT_TYPE
+ 1242 op notEqual *tmp483 *tmp9 UNIT_TYPE
  1243 op greaterThan *tmp484 :unitCheck @time
  1244 op land *tmp485 *tmp483 *tmp484
  1245 jump *label312 equal *tmp485 false
 
  1249 set :areUnitsAvailable.2:free 0
  1250 set :areUnitsAvailable.2:occupied 0
  1251 set :areUnitsAvailable.2:needed 0
-    * ubind :areUnitsAvailable.2:type
+ 1252 ubind UNIT_TYPE
  1253 set :areUnitsAvailable.2:firstUnit @unit
  1254 jump *label315 equal :areUnitsAvailable.2:firstUnit null
  1255 # "Function: inline def needsFourUnits(in unit)"
  1256 set :needsFourUnits.3:unit @unit
  1257 op sub *tmp491 .DOME_X .CORE_X
  1258 op sub *tmp492 .DOME_Y .CORE_Y
-    * op len *tmp493 *tmp491 *tmp492
-    * op mul *tmp494 2 *tmp493
+ 1259 op len *tmp493 *tmp135 *tmp136
+ 1260 op mul *tmp494 2 *tmp137
  1261 sensor *tmp495 :needsFourUnits.3:unit @speed
-    * op div :needsFourUnits.3:travel_time *tmp494 *tmp495
+ 1262 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1263 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1264 jump *label317 always
-    * set *tmp490 null
  1265 label *label317
  1266 jump *label318 equal *tmp490 false
  1267 set *tmp498 4
 
  1278 op or *tmp503 *tmp500 *tmp502
  1279 jump *label323 equal *tmp503 false
  1280 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label325 lessThan :areUnitsAvailable.2:free :areUnitsAvailable.2:needed
+ 1281 jump *label325 lessThan :areUnitsAvailable.2:free *tmp498
  1282 set *tmp487 true
  1283 jump *label314 always
  1284 label *label325
 
  1287 label *label323
  1288 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1289 label *label324
-    * ubind :areUnitsAvailable.2:type
+ 1290 ubind UNIT_TYPE
  1291 label *label321
  1292 op notEqual *tmp508 @unit :areUnitsAvailable.2:firstUnit
  1293 sensor *tmp509 :areUnitsAvailable.2:firstUnit @dead
 
  1297 label *label322
  1298 label *label315
  1299 label *label316
-    * jump *label327 equal :areUnitsAvailable.2:output false
-    * print :areUnitsAvailable.2:type
+ 1300 jump *label327 equal false false
+ 1301 print UNIT_TYPE
  1302 print ":"
  1303 print " occupied: "
  1304 print :areUnitsAvailable.2:occupied
 
  1315 label *label328
  1316 set *tmp487 false
  1317 jump *label314 always
-    * set *tmp487 null
  1318 label *label314
  1319 jump *label331 equal *tmp487 false
  1320 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-48 instructions):
 
    63 print "[gold]Looking for suitable unit type:[]"
    64 print "\n"
    65 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable:type UNIT_TYPE
-    * set :areUnitsAvailable:output true
    66 set :areUnitsAvailable:free 0
    67 set :areUnitsAvailable:occupied 0
    68 set :areUnitsAvailable:needed 0
 
   155 label *label43
   156 jump *label50 equal :chooseUnitType:type UNIT_TYPE
   157 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:type :chooseUnitType:type
-    * set :areUnitsAvailable.1:output true
   158 set :areUnitsAvailable.1:free 0
   159 set :areUnitsAvailable.1:occupied 0
   160 set :areUnitsAvailable.1:needed 0
 
   243 label *label23
   244 set *tmp9 null
   245 label *label20
-    * set .TYPE *tmp9
   246 print "[gold]Binding units..."
   247 printflush message1
   248 # "Function: inline def rebindUnits()"
   249 set .UNIT_P2 null
   250 set .UNIT_S2 null
-    * set .UNIT_P1 .UNIT_P2
-    * set .UNIT_S1 .UNIT_S2
+  251 set .UNIT_P1 null
+  252 set .UNIT_S1 null
   253 set :rebindUnits:count 0
   254 ubind *tmp9
   255 set :rebindUnits:firstUnit @unit
 
   284 # "Function: inline def acquireUnit(in currentUnit)"
   285 set :acquireUnit:currentUnit .UNIT_S1
   286 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit:currentUnit .UNIT_S1
-    * jump *label83 equal :acquireUnit:currentUnit null
-    * ubind :acquireUnit:currentUnit
+  287 jump *label83 equal .UNIT_S1 null
+  288 ubind .UNIT_S1
   289 sensor *tmp89 @unit @dead
   290 op equal *tmp90 *tmp89 0
   291 sensor *tmp91 @unit @controller
 
   326 # "Function: inline def acquireUnit(in currentUnit)"
   327 set :acquireUnit.1:currentUnit .UNIT_P1
   328 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.1:currentUnit .UNIT_P1
-    * jump *label96 equal :acquireUnit.1:currentUnit null
-    * ubind :acquireUnit.1:currentUnit
+  329 jump *label96 equal .UNIT_P1 null
+  330 ubind .UNIT_P1
   331 sensor *tmp108 @unit @dead
   332 op equal *tmp109 *tmp108 0
   333 sensor *tmp110 @unit @controller
 
   372 op or *tmp127 *tmp124 *tmp126
   373 jump *label107 equal *tmp127 false
   374 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:a *tmp85
-    * set :swap:b *tmp104
-    * set :swap:t .UNIT_S1
-    * set :swap:a .UNIT_P1
-    * set :swap:b :swap:t
+  375 set :swap:t *tmp85
+  376 set :swap:a *tmp104
+  377 set :swap:b .UNIT_S1
   378 label *label109
-    * set .UNIT_S1 :swap:a
+  379 set .UNIT_S1 .UNIT_P1
   380 set .UNIT_P1 :swap:t
   381 label *label107
   382 label *label108
 
   389 label *label110
   390 label *label111
   391 # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.2:unit .UNIT_S1
   392 op sub *tmp135 .DOME_X .CORE_X
   393 op sub *tmp136 .DOME_Y .CORE_Y
   394 op len *tmp137 *tmp135 *tmp136
 
   398 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   399 jump *label112 always
   400 label *label112
-    * set .FOUR_UNITS *tmp134
   401 jump *label113 equal *tmp134 false
   402 # "Function: inline def acquireUnit(in currentUnit)"
   403 set :acquireUnit.2:currentUnit .UNIT_S2
   404 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.2:currentUnit .UNIT_S2
-    * jump *label117 equal :acquireUnit.2:currentUnit null
-    * ubind :acquireUnit.2:currentUnit
+  405 jump *label117 equal .UNIT_S2 null
+  406 ubind .UNIT_S2
   407 sensor *tmp147 @unit @dead
   408 op equal *tmp148 *tmp147 0
   409 sensor *tmp149 @unit @controller
 
   444 # "Function: inline def acquireUnit(in currentUnit)"
   445 set :acquireUnit.3:currentUnit .UNIT_P2
   446 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.3:currentUnit .UNIT_P2
-    * jump *label130 equal :acquireUnit.3:currentUnit null
-    * ubind :acquireUnit.3:currentUnit
+  447 jump *label130 equal .UNIT_P2 null
+  448 ubind .UNIT_P2
   449 sensor *tmp166 @unit @dead
   450 op equal *tmp167 *tmp166 0
   451 sensor *tmp168 @unit @controller
 
   490 op land *tmp185 *tmp182 *tmp184
   491 jump *label141 equal *tmp185 false
   492 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.1:a .UNIT_S1
-    * set :swap.1:b *tmp162
   493 set :swap.1:t .UNIT_S1
-    * set :swap.1:a .UNIT_P2
-    * set :swap.1:b :swap.1:t
+  494 set :swap.1:a *tmp162
+  495 set :swap.1:b .UNIT_S1
   496 label *label143
-    * set .UNIT_S1 :swap.1:a
+  497 set .UNIT_S1 .UNIT_P2
   498 set .UNIT_P2 :swap.1:t
   499 label *label141
   500 label *label142
 
   505 op or *tmp191 *tmp188 *tmp190
   506 jump *label144 equal *tmp191 false
   507 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:a *tmp143
-    * set :swap.2:b .UNIT_P2
-    * set :swap.2:t .UNIT_S2
+  508 set :swap.2:t *tmp143
   509 set :swap.2:a .UNIT_P2
-    * set :swap.2:b :swap.2:t
+  510 set :swap.2:b .UNIT_S2
   511 label *label146
-    * set .UNIT_S2 :swap.2:a
+  512 set .UNIT_S2 .UNIT_P2
   513 set .UNIT_P2 :swap.2:t
   514 label *label144
   515 label *label145
 
   530 sensor *tmp195 .UNIT_S2 @totalItems
   531 op lessThan *tmp196 *tmp194 *tmp195
   532 op or .SUPPLY_S_FIRST *tmp193 *tmp196
-    * op equal *tmp198 *tmp134 false
   533 sensor *tmp199 .UNIT_P1 @totalItems
   534 sensor *tmp200 .UNIT_P2 @totalItems
   535 op lessThan *tmp201 *tmp199 *tmp200
 
   548 print "]"
   549 print "\n"
   550 # "Function: inline void printDomeStatus(in item, in text)"
-    * set :printDomeStatus:item @silicon
-    * set :printDomeStatus:text "\n[green]Silicon[] status:\n"
   551 print "\n[green]Silicon[] status:\n"
   552 sensor :printDomeStatus:level .DOME @silicon
   553 jump *label151 lessThanEq :printDomeStatus:level 3
 
   567 label *label150
   568 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   569 set :processUnit:unit .UNIT_S1
-    * set :processUnit:item @silicon
-    * set :processUnit:group .GROUP1
-    * set :processUnit:supply .SUPPLY_S_FIRST
   570 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.4:currentUnit .UNIT_S1
-    * jump *label155 equal :processUnit:unit null
-    * ubind :processUnit:unit
+  571 jump *label155 equal .UNIT_S1 null
+  572 ubind .UNIT_S1
   573 sensor *tmp211 @unit @dead
   574 op equal *tmp212 *tmp211 0
   575 sensor *tmp213 @unit @controller
 
   604 label *label154
   605 sensor :processUnit:state @unit @flag
   606 set :processUnit:distance -1
-    * set :processUnit:color "gold"
   607 op lessThan *tmp227 :processUnit:state 2
   608 op greaterThan *tmp228 :processUnit:state 3
   609 op or *tmp229 *tmp227 *tmp228
 
   714 op equal *tmp273 .SUPPLY_S_FIRST false
   715 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   716 set :processUnit.1:unit .UNIT_S2
-    * set :processUnit.1:item @silicon
-    * set :processUnit.1:group .GROUP2
-    * set :processUnit.1:supply *tmp273
   717 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.5:currentUnit .UNIT_S2
-    * jump *label194 equal :processUnit.1:unit null
-    * ubind :processUnit.1:unit
+  718 jump *label194 equal .UNIT_S2 null
+  719 ubind .UNIT_S2
   720 sensor *tmp277 @unit @dead
   721 op equal *tmp278 *tmp277 0
   722 sensor *tmp279 @unit @controller
 
   751 label *label193
   752 sensor :processUnit.1:state @unit @flag
   753 set :processUnit.1:distance -1
-    * set :processUnit.1:color "gold"
   754 op lessThan *tmp293 :processUnit.1:state 2
   755 op greaterThan *tmp294 :processUnit.1:state 3
   756 op or *tmp295 *tmp293 *tmp294
 
   869 label *label190
   870 label *label191
   871 # "Function: inline void printDomeStatus(in item, in text)"
-    * set :printDomeStatus.1:item @phase-fabric
-    * set :printDomeStatus.1:text "\n[green]Phase fabric[] status:\n"
   872 print "\n[green]Phase fabric[] status:\n"
   873 sensor :printDomeStatus.1:level .DOME @phase-fabric
   874 jump *label232 lessThanEq :printDomeStatus.1:level 3
 
   888 label *label231
   889 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   890 set :processUnit.2:unit .UNIT_P1
-    * set :processUnit.2:item @phase-fabric
-    * set :processUnit.2:group .GROUP1
-    * set :processUnit.2:supply .SUPPLY_P_FIRST
   891 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.6:currentUnit .UNIT_P1
-    * jump *label236 equal :processUnit.2:unit null
-    * ubind :processUnit.2:unit
+  892 jump *label236 equal .UNIT_P1 null
+  893 ubind .UNIT_P1
   894 sensor *tmp349 @unit @dead
   895 op equal *tmp350 *tmp349 0
   896 sensor *tmp351 @unit @controller
 
   925 label *label235
   926 sensor :processUnit.2:state @unit @flag
   927 set :processUnit.2:distance -1
-    * set :processUnit.2:color "gold"
   928 op lessThan *tmp365 :processUnit.2:state 2
   929 op greaterThan *tmp366 :processUnit.2:state 3
   930 op or *tmp367 *tmp365 *tmp366
 
  1035 op equal *tmp411 .SUPPLY_P_FIRST false
  1036 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
  1037 set :processUnit.3:unit .UNIT_P2
-    * set :processUnit.3:item @phase-fabric
-    * set :processUnit.3:group .GROUP2
-    * set :processUnit.3:supply *tmp411
  1038 # "Function: inline def rebindUnit(in currentUnit)"
-    * set :rebindUnit.7:currentUnit .UNIT_P2
-    * jump *label275 equal :processUnit.3:unit null
-    * ubind :processUnit.3:unit
+ 1039 jump *label275 equal .UNIT_P2 null
+ 1040 ubind .UNIT_P2
  1041 sensor *tmp415 @unit @dead
  1042 op equal *tmp416 *tmp415 0
  1043 sensor *tmp417 @unit @controller
 
  1072 label *label274
  1073 sensor :processUnit.3:state @unit @flag
  1074 set :processUnit.3:distance -1
-    * set :processUnit.3:color "gold"
  1075 op lessThan *tmp431 :processUnit.3:state 2
  1076 op greaterThan *tmp432 :processUnit.3:state 3
  1077 op or *tmp433 *tmp431 *tmp432
 
  1202 op land *tmp485 *tmp483 *tmp484
  1203 jump *label312 equal *tmp485 false
  1204 # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.2:type UNIT_TYPE
-    * set :areUnitsAvailable.2:output false
  1205 set :areUnitsAvailable.2:free 0
  1206 set :areUnitsAvailable.2:occupied 0
  1207 set :areUnitsAvailable.2:needed 0
 
  1210 jump *label315 equal :areUnitsAvailable.2:firstUnit null
  1211 # "Function: inline def needsFourUnits(in unit)"
  1212 set :needsFourUnits.3:unit @unit
-    * op sub *tmp491 .DOME_X .CORE_X
-    * op sub *tmp492 .DOME_Y .CORE_Y
-    * op len *tmp493 *tmp135 *tmp136
-    * op mul *tmp494 2 *tmp137
  1213 sensor *tmp495 :needsFourUnits.3:unit @speed
  1214 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1215 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-12 instructions):
 
   282 label *label76
   283 label *label71
   284 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit:currentUnit .UNIT_S1
   285 # "Function: inline def rebindUnit(in currentUnit)"
   286 jump *label83 equal .UNIT_S1 null
   287 ubind .UNIT_S1
 
   323 label *label81
   324 set .UNIT_S1 *tmp85
   325 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.1:currentUnit .UNIT_P1
   326 # "Function: inline def rebindUnit(in currentUnit)"
   327 jump *label96 equal .UNIT_P1 null
   328 ubind .UNIT_P1
 
   371 jump *label107 equal *tmp127 false
   372 # "Function: inline void swap(in out a, in out b)"
   373 set :swap:t *tmp85
-    * set :swap:a *tmp104
-    * set :swap:b .UNIT_S1
+  374 set :swap:b *tmp85
   375 label *label109
-    * set .UNIT_S1 .UNIT_P1
-    * set .UNIT_P1 :swap:t
+  376 set .UNIT_S1 *tmp104
+  377 set .UNIT_P1 *tmp85
   378 label *label107
   379 label *label108
   380 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
 
   397 label *label112
   398 jump *label113 equal *tmp134 false
   399 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.2:currentUnit .UNIT_S2
   400 # "Function: inline def rebindUnit(in currentUnit)"
   401 jump *label117 equal .UNIT_S2 null
   402 ubind .UNIT_S2
 
   438 label *label115
   439 set .UNIT_S2 *tmp143
   440 # "Function: inline def acquireUnit(in currentUnit)"
-    * set :acquireUnit.3:currentUnit .UNIT_P2
   441 # "Function: inline def rebindUnit(in currentUnit)"
   442 jump *label130 equal .UNIT_P2 null
   443 ubind .UNIT_P2
 
   486 jump *label141 equal *tmp185 false
   487 # "Function: inline void swap(in out a, in out b)"
   488 set :swap.1:t .UNIT_S1
-    * set :swap.1:a *tmp162
-    * set :swap.1:b .UNIT_S1
   489 label *label143
-    * set .UNIT_S1 .UNIT_P2
+  490 set .UNIT_S1 *tmp162
   491 set .UNIT_P2 :swap.1:t
   492 label *label141
   493 label *label142
 
   499 jump *label144 equal *tmp191 false
   500 # "Function: inline void swap(in out a, in out b)"
   501 set :swap.2:t *tmp143
-    * set :swap.2:a .UNIT_P2
-    * set :swap.2:b .UNIT_S2
+  502 set :swap.2:b *tmp143
   503 label *label146
   504 set .UNIT_S2 .UNIT_P2
-    * set .UNIT_P2 :swap.2:t
+  505 set .UNIT_P2 *tmp143
   506 label *label144
   507 label *label145
   508 set .GROUP1 "unit  1"
 
   558 label *label152
   559 label *label150
   560 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit:unit .UNIT_S1
   561 # "Function: inline def rebindUnit(in currentUnit)"
   562 jump *label155 equal .UNIT_S1 null
   563 ubind .UNIT_S1
 
   704 jump *label190 equal *tmp134 false
   705 op equal *tmp273 .SUPPLY_S_FIRST false
   706 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.1:unit .UNIT_S2
   707 # "Function: inline def rebindUnit(in currentUnit)"
   708 jump *label194 equal .UNIT_S2 null
   709 ubind .UNIT_S2
 
   877 label *label233
   878 label *label231
   879 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.2:unit .UNIT_P1
   880 # "Function: inline def rebindUnit(in currentUnit)"
   881 jump *label236 equal .UNIT_P1 null
   882 ubind .UNIT_P1
 
  1023 jump *label271 equal *tmp134 false
  1024 op equal *tmp411 .SUPPLY_P_FIRST false
  1025 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
-    * set :processUnit.3:unit .UNIT_P2
  1026 # "Function: inline def rebindUnit(in currentUnit)"
  1027 jump *label275 equal .UNIT_P2 null
  1028 ubind .UNIT_P2

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-4 instructions):
 
   370 op or *tmp127 *tmp124 *tmp126
   371 jump *label107 equal *tmp127 false
   372 # "Function: inline void swap(in out a, in out b)"
-    * set :swap:t *tmp85
-    * set :swap:b *tmp85
   373 label *label109
   374 set .UNIT_S1 *tmp104
   375 set .UNIT_P1 *tmp85
 
   496 op or *tmp191 *tmp188 *tmp190
   497 jump *label144 equal *tmp191 false
   498 # "Function: inline void swap(in out a, in out b)"
-    * set :swap.2:t *tmp143
-    * set :swap.2:b *tmp143
   499 label *label146
   500 set .UNIT_S2 .UNIT_P2
   501 set .UNIT_P2 *tmp143

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
     5 set .DOME dome1
     6 label *label2
     7 jump *label4 notEqual .DOME null
+    8 label *label336
     9 print "[gold]Waiting for an overdrive dome to be connected..."
    10 printflush message1
    11 set .DOME dome1
    12 label *label3
-    * jump *label2 always
+   13 jump *label336 equal .DOME null
    14 label *label4
    15 print "[gold]Locating core..."
    16 printflush message1

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-2 instructions):
 
    70 ubind UNIT_TYPE
    71 set :areUnitsAvailable:firstUnit @unit
    72 jump *label25 equal :areUnitsAvailable:firstUnit null
+   73 set *tmp21 2
    74 # "Function: inline def needsFourUnits(in unit)"
    75 set :needsFourUnits:unit @unit
    76 op sub *tmp14 .DOME_X .CORE_X
 
    82 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    83 jump *label27 always
    84 label *label27
-    * jump *label28 equal *tmp13 false
+   85 jump *label29 equal *tmp13 false
    86 set *tmp21 4
    87 jump *label29 always
-    * label *label28
-    * set *tmp21 2
    88 label *label29
    89 set :areUnitsAvailable:needed *tmp21
    90 label *label30
 
   161 ubind :chooseUnitType:type
   162 set :areUnitsAvailable.1:firstUnit @unit
   163 jump *label53 equal :areUnitsAvailable.1:firstUnit null
+  164 set *tmp53 2
   165 # "Function: inline def needsFourUnits(in unit)"
   166 set :needsFourUnits.1:unit @unit
   167 op sub *tmp46 .DOME_X .CORE_X
 
   173 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   174 jump *label55 always
   175 label *label55
-    * jump *label56 equal *tmp45 false
+  176 jump *label57 equal *tmp45 false
   177 set *tmp53 4
   178 jump *label57 always
-    * label *label56
-    * set *tmp53 2
   179 label *label57
   180 set :areUnitsAvailable.1:needed *tmp53
   181 label *label58
 
   844 set .UNIT_S2 :processUnit.1:unit
   845 jump *label229 equal .SUPPLY_S_FIRST false
   846 sensor *tmp339 :processUnit:unit @totalItems
-    * op greaterThan *tmp338 *tmp339 0
+  847 op greaterThan .SUPPLY_S_FIRST *tmp339 0
   848 jump *label230 always
   849 label *label229
   850 sensor *tmp341 :processUnit.1:unit @totalItems
-    * op equal *tmp338 *tmp341 0
+  851 op equal .SUPPLY_S_FIRST *tmp341 0
   852 label *label230
-    * set .SUPPLY_S_FIRST *tmp338
   853 label *label190
   854 label *label191
   855 # "Function: inline void printDomeStatus(in item, in text)"
 
  1162 set .UNIT_P2 :processUnit.3:unit
  1163 jump *label310 equal .SUPPLY_P_FIRST false
  1164 sensor *tmp477 :processUnit.2:unit @totalItems
-    * op greaterThan *tmp476 *tmp477 0
+ 1165 op greaterThan .SUPPLY_P_FIRST *tmp477 0
  1166 jump *label311 always
  1167 label *label310
  1168 sensor *tmp479 :processUnit.3:unit @totalItems
-    * op equal *tmp476 *tmp479 0
+ 1169 op equal .SUPPLY_P_FIRST *tmp479 0
  1170 label *label311
-    * set .SUPPLY_P_FIRST *tmp476
  1171 label *label271
  1172 label *label272
  1173 op sub *tmp481 @time :start
 
  1189 ubind UNIT_TYPE
  1190 set :areUnitsAvailable.2:firstUnit @unit
  1191 jump *label315 equal :areUnitsAvailable.2:firstUnit null
+ 1192 set *tmp498 2
  1193 # "Function: inline def needsFourUnits(in unit)"
  1194 set :needsFourUnits.3:unit @unit
  1195 sensor *tmp495 :needsFourUnits.3:unit @speed
 
  1197 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1198 jump *label317 always
  1199 label *label317
-    * jump *label318 equal *tmp490 false
+ 1200 jump *label319 equal *tmp490 false
  1201 set *tmp498 4
  1202 jump *label319 always
-    * label *label318
-    * set *tmp498 2
  1203 label *label319
  1204 set :areUnitsAvailable.2:needed *tmp498
  1205 label *label320

Modifications by Unroll iteration loop at line 169:9 (+7 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * set :locateDomeAndCore:type @flare
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label11 (m:marker0)
-    * set :locateDomeAndCore:type @poly
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label12 (m:marker0)
-    * set :locateDomeAndCore:type @mega
-    * op add *tmp1 @counter 1
-    * jump *label8 always
-    * multilabel *label13 (m:marker0)
-    * set :locateDomeAndCore:type @mono
-    * set *tmp1 null
-    * label *label8
-    * set :locateCore:type :locateDomeAndCore:type
-    * call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label15 equal :locateCore*retval false
-    * jump *label1 always
-    * label *label15
-    * label *label16
-    * label *label9
-    * multijump *tmp1 0 0 (m:marker0)
-    * multilabel *label14 (m:marker0)
-    * label *label10
+   19 set :locateDomeAndCore:type @flare
+   20 label *label337
+   21 set :locateCore:type :locateDomeAndCore:type
+   22 call *label0 :locateCore*retaddr :locateCore*retval
+   23 jump *label338 equal :locateCore*retval false
+   24 jump *label1 always
+   25 label *label338
+   26 label *label339
+   27 label *label340
+   28 set :locateDomeAndCore:type @poly
+   29 label *label343
+   30 set :locateCore:type :locateDomeAndCore:type
+   31 call *label0 :locateCore*retaddr :locateCore*retval
+   32 jump *label344 equal :locateCore*retval false
+   33 jump *label1 always
+   34 label *label344
+   35 label *label345
+   36 label *label346
+   37 set :locateDomeAndCore:type @mega
+   38 label *label349
+   39 set :locateCore:type :locateDomeAndCore:type
+   40 call *label0 :locateCore*retaddr :locateCore*retval
+   41 jump *label350 equal :locateCore*retval false
+   42 jump *label1 always
+   43 label *label350
+   44 label *label351
+   45 label *label352
+   46 set :locateDomeAndCore:type @mono
+   47 label *label355
+   48 set :locateCore:type :locateDomeAndCore:type
+   49 call *label0 :locateCore*retaddr :locateCore*retval
+   50 jump *label356 equal :locateCore*retval false
+   51 jump *label1 always
+   52 label *label356
+   53 label *label357
+   54 label *label358
+   55 label *label10
    56 label *label6
    57 jump *label5 always
    58 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
     6 label *label2
-    * jump *label4 notEqual .DOME null
+    7 jump *label4 notEqual dome1 null
     8 label *label336
     9 print "[gold]Waiting for an overdrive dome to be connected..."
    10 printflush message1
    11 set .DOME dome1
    12 label *label3
-    * jump *label336 equal .DOME null
+   13 jump *label336 equal dome1 null
    14 label *label4
    15 print "[gold]Locating core..."
    16 printflush message1
 
    18 label *label5
    19 set :locateDomeAndCore:type @flare
    20 label *label337
-    * set :locateCore:type :locateDomeAndCore:type
+   21 set :locateCore:type @flare
    22 call *label0 :locateCore*retaddr :locateCore*retval
    23 jump *label338 equal :locateCore*retval false
    24 jump *label1 always
 
    27 label *label340
    28 set :locateDomeAndCore:type @poly
    29 label *label343
-    * set :locateCore:type :locateDomeAndCore:type
+   30 set :locateCore:type @poly
    31 call *label0 :locateCore*retaddr :locateCore*retval
    32 jump *label344 equal :locateCore*retval false
    33 jump *label1 always
 
    36 label *label346
    37 set :locateDomeAndCore:type @mega
    38 label *label349
-    * set :locateCore:type :locateDomeAndCore:type
+   39 set :locateCore:type @mega
    40 call *label0 :locateCore*retaddr :locateCore*retval
    41 jump *label350 equal :locateCore*retval false
    42 jump *label1 always
 
    45 label *label352
    46 set :locateDomeAndCore:type @mono
    47 label *label355
-    * set :locateCore:type :locateDomeAndCore:type
+   48 set :locateCore:type @mono
    49 call *label0 :locateCore*retaddr :locateCore*retval
    50 jump *label356 equal :locateCore*retval false
    51 jump *label1 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-4 instructions):
 
    16 printflush message1
    17 set .CORE null
    18 label *label5
-    * set :locateDomeAndCore:type @flare
    19 label *label337
    20 set :locateCore:type @flare
    21 call *label0 :locateCore*retaddr :locateCore*retval
 
    24 label *label338
    25 label *label339
    26 label *label340
-    * set :locateDomeAndCore:type @poly
    27 label *label343
    28 set :locateCore:type @poly
    29 call *label0 :locateCore*retaddr :locateCore*retval
 
    32 label *label344
    33 label *label345
    34 label *label346
-    * set :locateDomeAndCore:type @mega
    35 label *label349
    36 set :locateCore:type @mega
    37 call *label0 :locateCore*retaddr :locateCore*retval
 
    40 label *label350
    41 label *label351
    42 label *label352
-    * set :locateDomeAndCore:type @mono
    43 label *label355
    44 set :locateCore:type @mono
    45 call *label0 :locateCore*retaddr :locateCore*retval

Modifications by Replicate loop condition at line 54:5 (+1 instructions):
 
    60 label *label17
    61 sensor *tmp7 switch1 @enabled
    62 jump *label19 notEqual *tmp7 false
+   63 label *label362
    64 print "[coral]Activate switch to begin supplying overdrive dome..."
    65 print "\n"
    66 printflush message1
    67 label *label18
-    * jump *label17 always
+   68 sensor *tmp7 switch1 @enabled
+   69 jump *label362 equal *tmp7 false
    70 label *label19
    71 # "Function: inline def chooseUnitType()"
    72 label *label21

Modifications by Replicate loop condition at line 119:5 (+1 instructions):
 
   535 label *label147
   536 sensor *tmp204 switch1 @enabled
   537 jump *label149 equal *tmp204 false
+  538 label *label363
   539 set :start @time
   540 print " === [gold]Supplying Overdrive Dome[] === "
   541 print "\n"
 
  1267 label *label312
  1268 label *label313
  1269 label *label148
-    * jump *label147 always
+ 1270 sensor *tmp204 switch1 @enabled
+ 1271 jump *label363 notEqual *tmp204 false
  1272 label *label149
  1273 end
  1274 label *label0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-2 instructions):
 
   124 label *label32
   125 label *label25
   126 label *label26
-    * jump *label37 equal true false
   127 print UNIT_TYPE
   128 print ":"
   129 print " occupied: "
 
   214 label *label60
   215 label *label53
   216 label *label54
-    * jump *label65 equal true false
   217 print :chooseUnitType:type
   218 print ":"
   219 print " occupied: "
 
  1238 label *label322
  1239 label *label315
  1240 label *label316
-    * jump *label327 equal false false
+ 1241 jump *label327 always
  1242 print UNIT_TYPE
  1243 print ":"
  1244 print " occupied: "

Modifications by Iterated phase, Single Step Elimination, pass 2, iteration 1 (-14 instructions):
 
    90 sensor *tmp18 :needsFourUnits:unit @speed
    91 op div :needsFourUnits:travel_time *tmp17 *tmp18
    92 op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
-    * jump *label27 always
    93 label *label27
    94 jump *label29 equal *tmp13 false
    95 set *tmp21 4
-    * jump *label29 always
    96 label *label29
    97 set :areUnitsAvailable:needed *tmp21
    98 label *label30
 
   138 label *label37
   139 label *label38
   140 set *tmp10 false
-    * jump *label24 always
   141 label *label24
   142 jump *label41 equal *tmp10 false
   143 set *tmp9 UNIT_TYPE
 
   177 sensor *tmp50 :needsFourUnits.1:unit @speed
   178 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
   179 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * jump *label55 always
   180 label *label55
   181 jump *label57 equal *tmp45 false
   182 set *tmp53 4
-    * jump *label57 always
   183 label *label57
   184 set :areUnitsAvailable.1:needed *tmp53
   185 label *label58
 
   225 label *label65
   226 label *label66
   227 set *tmp42 false
-    * jump *label52 always
   228 label *label52
   229 jump *label69 equal *tmp42 false
   230 printflush null
 
   320 label *label82
   321 ucontrol flag 1
   322 set *tmp85 @unit
-    * jump *label81 always
   323 label *label81
   324 set .UNIT_S1 *tmp85
   325 # "Function: inline def acquireUnit(in currentUnit)"
 
   360 label *label95
   361 ucontrol flag 1
   362 set *tmp104 @unit
-    * jump *label94 always
   363 label *label94
   364 set .UNIT_P1 *tmp104
   365 sensor *tmp123 *tmp85 @firstItem
 
   390 sensor *tmp139 .UNIT_S1 @speed
   391 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   392 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
-    * jump *label112 always
   393 label *label112
   394 jump *label113 equal *tmp134 false
   395 # "Function: inline def acquireUnit(in currentUnit)"
 
   430 label *label116
   431 ucontrol flag 1
   432 set *tmp143 @unit
-    * jump *label115 always
   433 label *label115
   434 set .UNIT_S2 *tmp143
   435 # "Function: inline def acquireUnit(in currentUnit)"
 
   470 label *label129
   471 ucontrol flag 1
   472 set *tmp162 @unit
-    * jump *label128 always
   473 label *label128
   474 set .UNIT_P2 *tmp162
   475 sensor *tmp181 .UNIT_S1 @firstItem
 
  1193 sensor *tmp495 :needsFourUnits.3:unit @speed
  1194 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
  1195 op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
-    * jump *label317 always
  1196 label *label317
  1197 jump *label319 equal *tmp490 false
  1198 set *tmp498 4
-    * jump *label319 always
  1199 label *label319
  1200 set :areUnitsAvailable.2:needed *tmp498
  1201 label *label320
 
  1242 label *label327
  1243 label *label328
  1244 set *tmp487 false
-    * jump *label314 always
  1245 label *label314
  1246 jump *label331 equal *tmp487 false
  1247 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-2 instructions):
 
  1183 # "Function: inline def areUnitsAvailable(in type, in output)"
  1184 set :areUnitsAvailable.2:free 0
  1185 set :areUnitsAvailable.2:occupied 0
-    * set :areUnitsAvailable.2:needed 0
  1186 ubind UNIT_TYPE
  1187 set :areUnitsAvailable.2:firstUnit @unit
  1188 jump *label315 equal :areUnitsAvailable.2:firstUnit null
 
  1196 jump *label319 equal *tmp490 false
  1197 set *tmp498 4
  1198 label *label319
-    * set :areUnitsAvailable.2:needed *tmp498
  1199 label *label320
  1200 sensor *tmp499 @unit @controlled
  1201 op equal *tmp500 *tmp499 0

Modifications by Unroll iteration loop at line 201:9 (+151 instructions):
 
   144 jump *label20 always
   145 label *label41
   146 label *label42
-    * set :chooseUnitType:type @flare
-    * op add *tmp39 @counter 1
-    * jump *label43 always
-    * multilabel *label46 (m:marker1)
-    * set :chooseUnitType:type @poly
-    * op add *tmp39 @counter 1
-    * jump *label43 always
-    * multilabel *label47 (m:marker1)
-    * set :chooseUnitType:type @mega
-    * op add *tmp39 @counter 1
-    * jump *label43 always
-    * multilabel *label48 (m:marker1)
-    * set :chooseUnitType:type @mono
-    * set *tmp39 null
-    * label *label43
-    * jump *label50 equal :chooseUnitType:type UNIT_TYPE
-    * # "Function: inline def areUnitsAvailable(in type, in output)"
-    * set :areUnitsAvailable.1:free 0
-    * set :areUnitsAvailable.1:occupied 0
-    * set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
-    * set :areUnitsAvailable.1:firstUnit @unit
-    * jump *label53 equal :areUnitsAvailable.1:firstUnit null
-    * set *tmp53 2
-    * # "Function: inline def needsFourUnits(in unit)"
-    * set :needsFourUnits.1:unit @unit
-    * op sub *tmp46 .DOME_X .CORE_X
-    * op sub *tmp47 .DOME_Y .CORE_Y
-    * op len *tmp48 *tmp46 *tmp47
-    * op mul *tmp49 2 *tmp48
-    * sensor *tmp50 :needsFourUnits.1:unit @speed
-    * op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
-    * label *label55
-    * jump *label57 equal *tmp45 false
-    * set *tmp53 4
-    * label *label57
-    * set :areUnitsAvailable.1:needed *tmp53
-    * label *label58
-    * sensor *tmp54 @unit @controlled
-    * op equal *tmp55 *tmp54 0
-    * sensor *tmp56 @unit @controller
-    * op equal *tmp57 *tmp56 @this
-    * op or *tmp58 *tmp55 *tmp57
-    * jump *label61 equal *tmp58 false
-    * op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label63 lessThan :areUnitsAvailable.1:free *tmp53
-    * set *tmp42 true
-    * jump *label52 always
-    * label *label63
-    * label *label64
-    * jump *label62 always
-    * label *label61
-    * op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
-    * label *label62
-    * ubind :chooseUnitType:type
-    * label *label59
-    * op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
-    * sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
-    * op equal *tmp65 *tmp64 0
-    * op land *tmp66 *tmp63 *tmp65
-    * jump *label58 notEqual *tmp66 false
-    * label *label60
-    * label *label53
-    * label *label54
-    * print :chooseUnitType:type
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.1:free
-    * jump *label67 lessThanEq :areUnitsAvailable.1:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.1:needed
-    * label *label67
-    * label *label68
-    * print "\n"
-    * label *label65
-    * label *label66
-    * set *tmp42 false
-    * label *label52
-    * jump *label69 equal *tmp42 false
-    * printflush null
-    * set *tmp9 :chooseUnitType:type
-    * jump *label20 always
-    * label *label69
-    * label *label70
-    * label *label50
-    * label *label51
-    * label *label44
-    * multijump *tmp39 0 0 (m:marker1)
-    * multilabel *label49 (m:marker1)
-    * label *label45
+  147 set :chooseUnitType:type @flare
+  148 label *label364
+  149 jump *label383 equal :chooseUnitType:type UNIT_TYPE
+  150 # "Function: inline def areUnitsAvailable(in type, in output)"
+  151 set :areUnitsAvailable.1:free 0
+  152 set :areUnitsAvailable.1:occupied 0
+  153 set :areUnitsAvailable.1:needed 0
+  154 ubind :chooseUnitType:type
+  155 set :areUnitsAvailable.1:firstUnit @unit
+  156 jump *label374 equal :areUnitsAvailable.1:firstUnit null
+  157 set *tmp53 2
+  158 # "Function: inline def needsFourUnits(in unit)"
+  159 set :needsFourUnits.1:unit @unit
+  160 op sub *tmp46 .DOME_X .CORE_X
+  161 op sub *tmp47 .DOME_Y .CORE_Y
+  162 op len *tmp48 *tmp46 *tmp47
+  163 op mul *tmp49 2 *tmp48
+  164 sensor *tmp50 :needsFourUnits.1:unit @speed
+  165 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  166 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  167 label *label365
+  168 jump *label366 equal *tmp45 false
+  169 set *tmp53 4
+  170 label *label366
+  171 set :areUnitsAvailable.1:needed *tmp53
+  172 label *label367
+  173 sensor *tmp54 @unit @controlled
+  174 op equal *tmp55 *tmp54 0
+  175 sensor *tmp56 @unit @controller
+  176 op equal *tmp57 *tmp56 @this
+  177 op or *tmp58 *tmp55 *tmp57
+  178 jump *label370 equal *tmp58 false
+  179 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  180 jump *label368 lessThan :areUnitsAvailable.1:free *tmp53
+  181 set *tmp42 true
+  182 jump *label380 always
+  183 label *label368
+  184 label *label369
+  185 jump *label371 always
+  186 label *label370
+  187 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  188 label *label371
+  189 ubind :chooseUnitType:type
+  190 label *label372
+  191 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  192 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  193 op equal *tmp65 *tmp64 0
+  194 op land *tmp66 *tmp63 *tmp65
+  195 jump *label367 notEqual *tmp66 false
+  196 label *label373
+  197 label *label374
+  198 label *label375
+  199 print :chooseUnitType:type
+  200 print ":"
+  201 print " occupied: "
+  202 print :areUnitsAvailable.1:occupied
+  203 print ","
+  204 print " free: "
+  205 print :areUnitsAvailable.1:free
+  206 jump *label376 lessThanEq :areUnitsAvailable.1:needed 0
+  207 print ", needed: "
+  208 print :areUnitsAvailable.1:needed
+  209 label *label376
+  210 label *label377
+  211 print "\n"
+  212 label *label378
+  213 label *label379
+  214 set *tmp42 false
+  215 label *label380
+  216 jump *label381 equal *tmp42 false
+  217 printflush null
+  218 set *tmp9 :chooseUnitType:type
+  219 jump *label20 always
+  220 label *label381
+  221 label *label382
+  222 label *label383
+  223 label *label384
+  224 label *label385
+  225 set :chooseUnitType:type @poly
+  226 label *label388
+  227 jump *label407 equal :chooseUnitType:type UNIT_TYPE
+  228 # "Function: inline def areUnitsAvailable(in type, in output)"
+  229 set :areUnitsAvailable.1:free 0
+  230 set :areUnitsAvailable.1:occupied 0
+  231 set :areUnitsAvailable.1:needed 0
+  232 ubind :chooseUnitType:type
+  233 set :areUnitsAvailable.1:firstUnit @unit
+  234 jump *label398 equal :areUnitsAvailable.1:firstUnit null
+  235 set *tmp53 2
+  236 # "Function: inline def needsFourUnits(in unit)"
+  237 set :needsFourUnits.1:unit @unit
+  238 op sub *tmp46 .DOME_X .CORE_X
+  239 op sub *tmp47 .DOME_Y .CORE_Y
+  240 op len *tmp48 *tmp46 *tmp47
+  241 op mul *tmp49 2 *tmp48
+  242 sensor *tmp50 :needsFourUnits.1:unit @speed
+  243 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  244 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  245 label *label389
+  246 jump *label390 equal *tmp45 false
+  247 set *tmp53 4
+  248 label *label390
+  249 set :areUnitsAvailable.1:needed *tmp53
+  250 label *label391
+  251 sensor *tmp54 @unit @controlled
+  252 op equal *tmp55 *tmp54 0
+  253 sensor *tmp56 @unit @controller
+  254 op equal *tmp57 *tmp56 @this
+  255 op or *tmp58 *tmp55 *tmp57
+  256 jump *label394 equal *tmp58 false
+  257 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  258 jump *label392 lessThan :areUnitsAvailable.1:free *tmp53
+  259 set *tmp42 true
+  260 jump *label404 always
+  261 label *label392
+  262 label *label393
+  263 jump *label395 always
+  264 label *label394
+  265 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  266 label *label395
+  267 ubind :chooseUnitType:type
+  268 label *label396
+  269 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  270 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  271 op equal *tmp65 *tmp64 0
+  272 op land *tmp66 *tmp63 *tmp65
+  273 jump *label391 notEqual *tmp66 false
+  274 label *label397
+  275 label *label398
+  276 label *label399
+  277 print :chooseUnitType:type
+  278 print ":"
+  279 print " occupied: "
+  280 print :areUnitsAvailable.1:occupied
+  281 print ","
+  282 print " free: "
+  283 print :areUnitsAvailable.1:free
+  284 jump *label400 lessThanEq :areUnitsAvailable.1:needed 0
+  285 print ", needed: "
+  286 print :areUnitsAvailable.1:needed
+  287 label *label400
+  288 label *label401
+  289 print "\n"
+  290 label *label402
+  291 label *label403
+  292 set *tmp42 false
+  293 label *label404
+  294 jump *label405 equal *tmp42 false
+  295 printflush null
+  296 set *tmp9 :chooseUnitType:type
+  297 jump *label20 always
+  298 label *label405
+  299 label *label406
+  300 label *label407
+  301 label *label408
+  302 label *label409
+  303 set :chooseUnitType:type @mega
+  304 label *label412
+  305 jump *label431 equal :chooseUnitType:type UNIT_TYPE
+  306 # "Function: inline def areUnitsAvailable(in type, in output)"
+  307 set :areUnitsAvailable.1:free 0
+  308 set :areUnitsAvailable.1:occupied 0
+  309 set :areUnitsAvailable.1:needed 0
+  310 ubind :chooseUnitType:type
+  311 set :areUnitsAvailable.1:firstUnit @unit
+  312 jump *label422 equal :areUnitsAvailable.1:firstUnit null
+  313 set *tmp53 2
+  314 # "Function: inline def needsFourUnits(in unit)"
+  315 set :needsFourUnits.1:unit @unit
+  316 op sub *tmp46 .DOME_X .CORE_X
+  317 op sub *tmp47 .DOME_Y .CORE_Y
+  318 op len *tmp48 *tmp46 *tmp47
+  319 op mul *tmp49 2 *tmp48
+  320 sensor *tmp50 :needsFourUnits.1:unit @speed
+  321 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  322 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  323 label *label413
+  324 jump *label414 equal *tmp45 false
+  325 set *tmp53 4
+  326 label *label414
+  327 set :areUnitsAvailable.1:needed *tmp53
+  328 label *label415
+  329 sensor *tmp54 @unit @controlled
+  330 op equal *tmp55 *tmp54 0
+  331 sensor *tmp56 @unit @controller
+  332 op equal *tmp57 *tmp56 @this
+  333 op or *tmp58 *tmp55 *tmp57
+  334 jump *label418 equal *tmp58 false
+  335 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  336 jump *label416 lessThan :areUnitsAvailable.1:free *tmp53
+  337 set *tmp42 true
+  338 jump *label428 always
+  339 label *label416
+  340 label *label417
+  341 jump *label419 always
+  342 label *label418
+  343 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  344 label *label419
+  345 ubind :chooseUnitType:type
+  346 label *label420
+  347 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  348 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  349 op equal *tmp65 *tmp64 0
+  350 op land *tmp66 *tmp63 *tmp65
+  351 jump *label415 notEqual *tmp66 false
+  352 label *label421
+  353 label *label422
+  354 label *label423
+  355 print :chooseUnitType:type
+  356 print ":"
+  357 print " occupied: "
+  358 print :areUnitsAvailable.1:occupied
+  359 print ","
+  360 print " free: "
+  361 print :areUnitsAvailable.1:free
+  362 jump *label424 lessThanEq :areUnitsAvailable.1:needed 0
+  363 print ", needed: "
+  364 print :areUnitsAvailable.1:needed
+  365 label *label424
+  366 label *label425
+  367 print "\n"
+  368 label *label426
+  369 label *label427
+  370 set *tmp42 false
+  371 label *label428
+  372 jump *label429 equal *tmp42 false
+  373 printflush null
+  374 set *tmp9 :chooseUnitType:type
+  375 jump *label20 always
+  376 label *label429
+  377 label *label430
+  378 label *label431
+  379 label *label432
+  380 label *label433
+  381 set :chooseUnitType:type @mono
+  382 label *label436
+  383 jump *label455 equal :chooseUnitType:type UNIT_TYPE
+  384 # "Function: inline def areUnitsAvailable(in type, in output)"
+  385 set :areUnitsAvailable.1:free 0
+  386 set :areUnitsAvailable.1:occupied 0
+  387 set :areUnitsAvailable.1:needed 0
+  388 ubind :chooseUnitType:type
+  389 set :areUnitsAvailable.1:firstUnit @unit
+  390 jump *label446 equal :areUnitsAvailable.1:firstUnit null
+  391 set *tmp53 2
+  392 # "Function: inline def needsFourUnits(in unit)"
+  393 set :needsFourUnits.1:unit @unit
+  394 op sub *tmp46 .DOME_X .CORE_X
+  395 op sub *tmp47 .DOME_Y .CORE_Y
+  396 op len *tmp48 *tmp46 *tmp47
+  397 op mul *tmp49 2 *tmp48
+  398 sensor *tmp50 :needsFourUnits.1:unit @speed
+  399 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
+  400 op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
+  401 label *label437
+  402 jump *label438 equal *tmp45 false
+  403 set *tmp53 4
+  404 label *label438
+  405 set :areUnitsAvailable.1:needed *tmp53
+  406 label *label439
+  407 sensor *tmp54 @unit @controlled
+  408 op equal *tmp55 *tmp54 0
+  409 sensor *tmp56 @unit @controller
+  410 op equal *tmp57 *tmp56 @this
+  411 op or *tmp58 *tmp55 *tmp57
+  412 jump *label442 equal *tmp58 false
+  413 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
+  414 jump *label440 lessThan :areUnitsAvailable.1:free *tmp53
+  415 set *tmp42 true
+  416 jump *label452 always
+  417 label *label440
+  418 label *label441
+  419 jump *label443 always
+  420 label *label442
+  421 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
+  422 label *label443
+  423 ubind :chooseUnitType:type
+  424 label *label444
+  425 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
+  426 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
+  427 op equal *tmp65 *tmp64 0
+  428 op land *tmp66 *tmp63 *tmp65
+  429 jump *label439 notEqual *tmp66 false
+  430 label *label445
+  431 label *label446
+  432 label *label447
+  433 print :chooseUnitType:type
+  434 print ":"
+  435 print " occupied: "
+  436 print :areUnitsAvailable.1:occupied
+  437 print ","
+  438 print " free: "
+  439 print :areUnitsAvailable.1:free
+  440 jump *label448 lessThanEq :areUnitsAvailable.1:needed 0
+  441 print ", needed: "
+  442 print :areUnitsAvailable.1:needed
+  443 label *label448
+  444 label *label449
+  445 print "\n"
+  446 label *label450
+  447 label *label451
+  448 set *tmp42 false
+  449 label *label452
+  450 jump *label453 equal *tmp42 false
+  451 printflush null
+  452 set *tmp9 :chooseUnitType:type
+  453 jump *label20 always
+  454 label *label453
+  455 label *label454
+  456 label *label455
+  457 label *label456
+  458 label *label457
+  459 label *label45
   460 printflush message1
   461 label *label22
   462 jump *label21 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   146 label *label42
   147 set :chooseUnitType:type @flare
   148 label *label364
-    * jump *label383 equal :chooseUnitType:type UNIT_TYPE
+  149 jump *label383 equal @flare UNIT_TYPE
   150 # "Function: inline def areUnitsAvailable(in type, in output)"
   151 set :areUnitsAvailable.1:free 0
   152 set :areUnitsAvailable.1:occupied 0
   153 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  154 ubind @flare
   155 set :areUnitsAvailable.1:firstUnit @unit
   156 jump *label374 equal :areUnitsAvailable.1:firstUnit null
   157 set *tmp53 2
 
   186 label *label370
   187 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   188 label *label371
-    * ubind :chooseUnitType:type
+  189 ubind @flare
   190 label *label372
   191 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   192 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   196 label *label373
   197 label *label374
   198 label *label375
-    * print :chooseUnitType:type
+  199 print @flare
   200 print ":"
   201 print " occupied: "
   202 print :areUnitsAvailable.1:occupied
 
   215 label *label380
   216 jump *label381 equal *tmp42 false
   217 printflush null
-    * set *tmp9 :chooseUnitType:type
+  218 set *tmp9 @flare
   219 jump *label20 always
   220 label *label381
   221 label *label382
 
   224 label *label385
   225 set :chooseUnitType:type @poly
   226 label *label388
-    * jump *label407 equal :chooseUnitType:type UNIT_TYPE
+  227 jump *label407 equal @poly UNIT_TYPE
   228 # "Function: inline def areUnitsAvailable(in type, in output)"
   229 set :areUnitsAvailable.1:free 0
   230 set :areUnitsAvailable.1:occupied 0
   231 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  232 ubind @poly
   233 set :areUnitsAvailable.1:firstUnit @unit
   234 jump *label398 equal :areUnitsAvailable.1:firstUnit null
   235 set *tmp53 2
 
   264 label *label394
   265 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   266 label *label395
-    * ubind :chooseUnitType:type
+  267 ubind @poly
   268 label *label396
   269 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   270 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   274 label *label397
   275 label *label398
   276 label *label399
-    * print :chooseUnitType:type
+  277 print @poly
   278 print ":"
   279 print " occupied: "
   280 print :areUnitsAvailable.1:occupied
 
   293 label *label404
   294 jump *label405 equal *tmp42 false
   295 printflush null
-    * set *tmp9 :chooseUnitType:type
+  296 set *tmp9 @poly
   297 jump *label20 always
   298 label *label405
   299 label *label406
 
   302 label *label409
   303 set :chooseUnitType:type @mega
   304 label *label412
-    * jump *label431 equal :chooseUnitType:type UNIT_TYPE
+  305 jump *label431 equal @mega UNIT_TYPE
   306 # "Function: inline def areUnitsAvailable(in type, in output)"
   307 set :areUnitsAvailable.1:free 0
   308 set :areUnitsAvailable.1:occupied 0
   309 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  310 ubind @mega
   311 set :areUnitsAvailable.1:firstUnit @unit
   312 jump *label422 equal :areUnitsAvailable.1:firstUnit null
   313 set *tmp53 2
 
   342 label *label418
   343 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   344 label *label419
-    * ubind :chooseUnitType:type
+  345 ubind @mega
   346 label *label420
   347 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   348 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   352 label *label421
   353 label *label422
   354 label *label423
-    * print :chooseUnitType:type
+  355 print @mega
   356 print ":"
   357 print " occupied: "
   358 print :areUnitsAvailable.1:occupied
 
   371 label *label428
   372 jump *label429 equal *tmp42 false
   373 printflush null
-    * set *tmp9 :chooseUnitType:type
+  374 set *tmp9 @mega
   375 jump *label20 always
   376 label *label429
   377 label *label430
 
   380 label *label433
   381 set :chooseUnitType:type @mono
   382 label *label436
-    * jump *label455 equal :chooseUnitType:type UNIT_TYPE
+  383 jump *label455 equal @mono UNIT_TYPE
   384 # "Function: inline def areUnitsAvailable(in type, in output)"
   385 set :areUnitsAvailable.1:free 0
   386 set :areUnitsAvailable.1:occupied 0
   387 set :areUnitsAvailable.1:needed 0
-    * ubind :chooseUnitType:type
+  388 ubind @mono
   389 set :areUnitsAvailable.1:firstUnit @unit
   390 jump *label446 equal :areUnitsAvailable.1:firstUnit null
   391 set *tmp53 2
 
   420 label *label442
   421 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   422 label *label443
-    * ubind :chooseUnitType:type
+  423 ubind @mono
   424 label *label444
   425 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   426 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
 
   430 label *label445
   431 label *label446
   432 label *label447
-    * print :chooseUnitType:type
+  433 print @mono
   434 print ":"
   435 print " occupied: "
   436 print :areUnitsAvailable.1:occupied
 
   449 label *label452
   450 jump *label453 equal *tmp42 false
   451 printflush null
-    * set *tmp9 :chooseUnitType:type
+  452 set *tmp9 @mono
   453 jump *label20 always
   454 label *label453
   455 label *label454

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-4 instructions):
 
   144 jump *label20 always
   145 label *label41
   146 label *label42
-    * set :chooseUnitType:type @flare
   147 label *label364
   148 jump *label383 equal @flare UNIT_TYPE
   149 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   221 label *label383
   222 label *label384
   223 label *label385
-    * set :chooseUnitType:type @poly
   224 label *label388
   225 jump *label407 equal @poly UNIT_TYPE
   226 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   298 label *label407
   299 label *label408
   300 label *label409
-    * set :chooseUnitType:type @mega
   301 label *label412
   302 jump *label431 equal @mega UNIT_TYPE
   303 # "Function: inline def areUnitsAvailable(in type, in output)"
 
   375 label *label431
   376 label *label432
   377 label *label433
-    * set :chooseUnitType:type @mono
   378 label *label436
   379 jump *label455 equal @mono UNIT_TYPE
   380 # "Function: inline def areUnitsAvailable(in type, in output)"

Modifications by Iterated phase, Jump Optimization, pass 3, iteration 1 (-6 instructions):
 
    89 op mul *tmp17 2 *tmp16
    90 sensor *tmp18 :needsFourUnits:unit @speed
    91 op div :needsFourUnits:travel_time *tmp17 *tmp18
-    * op greaterThanEq *tmp13 :needsFourUnits:travel_time 47
    92 label *label27
-    * jump *label29 equal *tmp13 false
+   93 jump *label29 lessThan :needsFourUnits:travel_time 47
    94 set *tmp21 4
    95 label *label29
    96 set :areUnitsAvailable:needed *tmp21
 
   161 op mul *tmp49 2 *tmp48
   162 sensor *tmp50 :needsFourUnits.1:unit @speed
   163 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   164 label *label365
-    * jump *label366 equal *tmp45 false
+  165 jump *label366 lessThan :needsFourUnits.1:travel_time 47
   166 set *tmp53 4
   167 label *label366
   168 set :areUnitsAvailable.1:needed *tmp53
 
   237 op mul *tmp49 2 *tmp48
   238 sensor *tmp50 :needsFourUnits.1:unit @speed
   239 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   240 label *label389
-    * jump *label390 equal *tmp45 false
+  241 jump *label390 lessThan :needsFourUnits.1:travel_time 47
   242 set *tmp53 4
   243 label *label390
   244 set :areUnitsAvailable.1:needed *tmp53
 
   313 op mul *tmp49 2 *tmp48
   314 sensor *tmp50 :needsFourUnits.1:unit @speed
   315 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   316 label *label413
-    * jump *label414 equal *tmp45 false
+  317 jump *label414 lessThan :needsFourUnits.1:travel_time 47
   318 set *tmp53 4
   319 label *label414
   320 set :areUnitsAvailable.1:needed *tmp53
 
   389 op mul *tmp49 2 *tmp48
   390 sensor *tmp50 :needsFourUnits.1:unit @speed
   391 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * op greaterThanEq *tmp45 :needsFourUnits.1:travel_time 47
   392 label *label437
-    * jump *label438 equal *tmp45 false
+  393 jump *label438 lessThan :needsFourUnits.1:travel_time 47
   394 set *tmp53 4
   395 label *label438
   396 set :areUnitsAvailable.1:needed *tmp53
 
  1401 set :needsFourUnits.3:unit @unit
  1402 sensor *tmp495 :needsFourUnits.3:unit @speed
  1403 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
-    * op greaterThanEq *tmp490 :needsFourUnits.3:travel_time 47
  1404 label *label317
-    * jump *label319 equal *tmp490 false
+ 1405 jump *label319 lessThan :needsFourUnits.3:travel_time 47
  1406 set *tmp498 4
  1407 label *label319
  1408 label *label320

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
 
     3 remark "Do not modify anything below this line."
     4 # "Function: inline void locateDomeAndCore()"
     5 set .DOME dome1
-    * label *label2
     6 jump *label4 notEqual dome1 null
     7 label *label336
     8 print "[gold]Waiting for an overdrive dome to be connected..."
     9 printflush message1
    10 set .DOME dome1
-    * label *label3
    11 jump *label336 equal dome1 null
    12 label *label4
    13 print "[gold]Locating core..."
    14 printflush message1
    15 set .CORE null
    16 label *label5
-    * label *label337
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
    19 jump *label338 equal :locateCore*retval false
    20 jump *label1 always
    21 label *label338
-    * label *label339
-    * label *label340
-    * label *label343
    22 set :locateCore:type @poly
    23 call *label0 :locateCore*retaddr :locateCore*retval
    24 jump *label344 equal :locateCore*retval false
    25 jump *label1 always
    26 label *label344
-    * label *label345
-    * label *label346
-    * label *label349
    27 set :locateCore:type @mega
    28 call *label0 :locateCore*retaddr :locateCore*retval
    29 jump *label350 equal :locateCore*retval false
    30 jump *label1 always
    31 label *label350
-    * label *label351
-    * label *label352
-    * label *label355
    32 set :locateCore:type @mono
    33 call *label0 :locateCore*retaddr :locateCore*retval
    34 jump *label356 equal :locateCore*retval false
    35 jump *label1 always
    36 label *label356
-    * label *label357
-    * label *label358
-    * label *label10
-    * label *label6
    37 jump *label5 always
-    * label *label7
    38 label *label1
    39 sensor .CORE_X .CORE @x
    40 sensor .CORE_Y .CORE @y
    41 sensor .DOME_X .DOME @x
    42 sensor .DOME_Y .DOME @y
-    * label *label17
    43 sensor *tmp7 switch1 @enabled
    44 jump *label19 notEqual *tmp7 false
    45 label *label362
    46 print "[coral]Activate switch to begin supplying overdrive dome..."
    47 print "\n"
    48 printflush message1
-    * label *label18
    49 sensor *tmp7 switch1 @enabled
    50 jump *label362 equal *tmp7 false
    51 label *label19
 
    70 op mul *tmp17 2 *tmp16
    71 sensor *tmp18 :needsFourUnits:unit @speed
    72 op div :needsFourUnits:travel_time *tmp17 *tmp18
-    * label *label27
    73 jump *label29 lessThan :needsFourUnits:travel_time 47
    74 set *tmp21 4
    75 label *label29
 
    86 set *tmp10 true
    87 jump *label24 always
    88 label *label35
-    * label *label36
    89 jump *label34 always
    90 label *label33
    91 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    92 label *label34
    93 ubind UNIT_TYPE
-    * label *label31
    94 op notEqual *tmp31 @unit :areUnitsAvailable:firstUnit
    95 sensor *tmp32 :areUnitsAvailable:firstUnit @dead
    96 op equal *tmp33 *tmp32 0
    97 op land *tmp34 *tmp31 *tmp33
    98 jump *label30 notEqual *tmp34 false
-    * label *label32
    99 label *label25
-    * label *label26
   100 print UNIT_TYPE
   101 print ":"
   102 print " occupied: "
 
   108 print ", needed: "
   109 print :areUnitsAvailable:needed
   110 label *label39
-    * label *label40
   111 print "\n"
-    * label *label37
-    * label *label38
   112 set *tmp10 false
   113 label *label24
   114 jump *label41 equal *tmp10 false
   115 set *tmp9 UNIT_TYPE
   116 jump *label20 always
   117 label *label41
-    * label *label42
-    * label *label364
   118 jump *label383 equal @flare UNIT_TYPE
   119 # "Function: inline def areUnitsAvailable(in type, in output)"
   120 set :areUnitsAvailable.1:free 0
 
   132 op mul *tmp49 2 *tmp48
   133 sensor *tmp50 :needsFourUnits.1:unit @speed
   134 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * label *label365
   135 jump *label366 lessThan :needsFourUnits.1:travel_time 47
   136 set *tmp53 4
   137 label *label366
 
   148 set *tmp42 true
   149 jump *label380 always
   150 label *label368
-    * label *label369
   151 jump *label371 always
   152 label *label370
   153 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   154 label *label371
   155 ubind @flare
-    * label *label372
   156 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   157 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
   158 op equal *tmp65 *tmp64 0
   159 op land *tmp66 *tmp63 *tmp65
   160 jump *label367 notEqual *tmp66 false
-    * label *label373
   161 label *label374
-    * label *label375
   162 print @flare
   163 print ":"
   164 print " occupied: "
 
   170 print ", needed: "
   171 print :areUnitsAvailable.1:needed
   172 label *label376
-    * label *label377
   173 print "\n"
-    * label *label378
-    * label *label379
   174 set *tmp42 false
   175 label *label380
   176 jump *label381 equal *tmp42 false
 
   178 set *tmp9 @flare
   179 jump *label20 always
   180 label *label381
-    * label *label382
   181 label *label383
-    * label *label384
-    * label *label385
-    * label *label388
   182 jump *label407 equal @poly UNIT_TYPE
   183 # "Function: inline def areUnitsAvailable(in type, in output)"
   184 set :areUnitsAvailable.1:free 0
 
   196 op mul *tmp49 2 *tmp48
   197 sensor *tmp50 :needsFourUnits.1:unit @speed
   198 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * label *label389
   199 jump *label390 lessThan :needsFourUnits.1:travel_time 47
   200 set *tmp53 4
   201 label *label390
 
   212 set *tmp42 true
   213 jump *label404 always
   214 label *label392
-    * label *label393
   215 jump *label395 always
   216 label *label394
   217 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   218 label *label395
   219 ubind @poly
-    * label *label396
   220 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   221 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
   222 op equal *tmp65 *tmp64 0
   223 op land *tmp66 *tmp63 *tmp65
   224 jump *label391 notEqual *tmp66 false
-    * label *label397
   225 label *label398
-    * label *label399
   226 print @poly
   227 print ":"
   228 print " occupied: "
 
   234 print ", needed: "
   235 print :areUnitsAvailable.1:needed
   236 label *label400
-    * label *label401
   237 print "\n"
-    * label *label402
-    * label *label403
   238 set *tmp42 false
   239 label *label404
   240 jump *label405 equal *tmp42 false
 
   242 set *tmp9 @poly
   243 jump *label20 always
   244 label *label405
-    * label *label406
   245 label *label407
-    * label *label408
-    * label *label409
-    * label *label412
   246 jump *label431 equal @mega UNIT_TYPE
   247 # "Function: inline def areUnitsAvailable(in type, in output)"
   248 set :areUnitsAvailable.1:free 0
 
   260 op mul *tmp49 2 *tmp48
   261 sensor *tmp50 :needsFourUnits.1:unit @speed
   262 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * label *label413
   263 jump *label414 lessThan :needsFourUnits.1:travel_time 47
   264 set *tmp53 4
   265 label *label414
 
   276 set *tmp42 true
   277 jump *label428 always
   278 label *label416
-    * label *label417
   279 jump *label419 always
   280 label *label418
   281 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   282 label *label419
   283 ubind @mega
-    * label *label420
   284 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   285 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
   286 op equal *tmp65 *tmp64 0
   287 op land *tmp66 *tmp63 *tmp65
   288 jump *label415 notEqual *tmp66 false
-    * label *label421
   289 label *label422
-    * label *label423
   290 print @mega
   291 print ":"
   292 print " occupied: "
 
   298 print ", needed: "
   299 print :areUnitsAvailable.1:needed
   300 label *label424
-    * label *label425
   301 print "\n"
-    * label *label426
-    * label *label427
   302 set *tmp42 false
   303 label *label428
   304 jump *label429 equal *tmp42 false
 
   306 set *tmp9 @mega
   307 jump *label20 always
   308 label *label429
-    * label *label430
   309 label *label431
-    * label *label432
-    * label *label433
-    * label *label436
   310 jump *label455 equal @mono UNIT_TYPE
   311 # "Function: inline def areUnitsAvailable(in type, in output)"
   312 set :areUnitsAvailable.1:free 0
 
   324 op mul *tmp49 2 *tmp48
   325 sensor *tmp50 :needsFourUnits.1:unit @speed
   326 op div :needsFourUnits.1:travel_time *tmp49 *tmp50
-    * label *label437
   327 jump *label438 lessThan :needsFourUnits.1:travel_time 47
   328 set *tmp53 4
   329 label *label438
 
   340 set *tmp42 true
   341 jump *label452 always
   342 label *label440
-    * label *label441
   343 jump *label443 always
   344 label *label442
   345 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   346 label *label443
   347 ubind @mono
-    * label *label444
   348 op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
   349 sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
   350 op equal *tmp65 *tmp64 0
   351 op land *tmp66 *tmp63 *tmp65
   352 jump *label439 notEqual *tmp66 false
-    * label *label445
   353 label *label446
-    * label *label447
   354 print @mono
   355 print ":"
   356 print " occupied: "
 
   362 print ", needed: "
   363 print :areUnitsAvailable.1:needed
   364 label *label448
-    * label *label449
   365 print "\n"
-    * label *label450
-    * label *label451
   366 set *tmp42 false
   367 label *label452
   368 jump *label453 equal *tmp42 false
 
   370 set *tmp9 @mono
   371 jump *label20 always
   372 label *label453
-    * label *label454
   373 label *label455
-    * label *label456
-    * label *label457
-    * label *label45
   374 printflush message1
-    * label *label22
   375 jump *label21 always
-    * label *label23
   376 set *tmp9 null
   377 label *label20
   378 print "[gold]Binding units..."
 
   388 jump *label72 notEqual :rebindUnits:firstUnit null
   389 end
   390 label *label72
-    * label *label73
   391 label *label74
   392 sensor *tmp74 @unit @controller
   393 jump *label77 notEqual *tmp74 @this
 
   400 jump *label79 equal .UNIT_S2 null
   401 jump *label76 always
   402 label *label79
-    * label *label80
   403 label *label77
-    * label *label78
   404 ubind *tmp9
-    * label *label75
   405 op notEqual *tmp81 @unit :rebindUnits:firstUnit
   406 sensor *tmp82 :rebindUnits:firstUnit @dead
   407 op equal *tmp83 *tmp82 0
   408 op land *tmp84 *tmp81 *tmp83
   409 jump *label74 notEqual *tmp84 false
   410 label *label76
-    * label *label71
   411 # "Function: inline def acquireUnit(in currentUnit)"
   412 # "Function: inline def rebindUnit(in currentUnit)"
   413 jump *label83 equal .UNIT_S1 null
 
   420 jump *label85 equal *tmp93 false
   421 jump *label82 always
   422 label *label85
-    * label *label86
   423 label *label83
-    * label *label84
   424 ubind *tmp9
   425 set :rebindUnit:firstUnit @unit
   426 jump *label87 equal :rebindUnit:firstUnit null
 
   429 jump *label92 notEqual *tmp97 0
   430 jump *label82 always
   431 label *label92
-    * label *label93
   432 ubind *tmp9
-    * label *label90
   433 op notEqual *tmp100 @unit :rebindUnit:firstUnit
   434 sensor *tmp101 :rebindUnit:firstUnit @dead
   435 op equal *tmp102 *tmp101 0
   436 op land *tmp103 *tmp100 *tmp102
   437 jump *label89 notEqual *tmp103 false
-    * label *label91
   438 label *label87
-    * label *label88
   439 end
   440 label *label82
   441 ucontrol flag 1
   442 set *tmp85 @unit
-    * label *label81
   443 set .UNIT_S1 *tmp85
   444 # "Function: inline def acquireUnit(in currentUnit)"
   445 # "Function: inline def rebindUnit(in currentUnit)"
 
   453 jump *label98 equal *tmp112 false
   454 jump *label95 always
   455 label *label98
-    * label *label99
   456 label *label96
-    * label *label97
   457 ubind *tmp9
   458 set :rebindUnit.1:firstUnit @unit
   459 jump *label100 equal :rebindUnit.1:firstUnit null
 
   462 jump *label105 notEqual *tmp116 0
   463 jump *label95 always
   464 label *label105
-    * label *label106
   465 ubind *tmp9
-    * label *label103
   466 op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
   467 sensor *tmp120 :rebindUnit.1:firstUnit @dead
   468 op equal *tmp121 *tmp120 0
   469 op land *tmp122 *tmp119 *tmp121
   470 jump *label102 notEqual *tmp122 false
-    * label *label104
   471 label *label100
-    * label *label101
   472 end
   473 label *label95
   474 ucontrol flag 1
   475 set *tmp104 @unit
-    * label *label94
   476 set .UNIT_P1 *tmp104
   477 sensor *tmp123 *tmp85 @firstItem
   478 op equal *tmp124 *tmp123 @phase-fabric
 
   481 op or *tmp127 *tmp124 *tmp126
   482 jump *label107 equal *tmp127 false
   483 # "Function: inline void swap(in out a, in out b)"
-    * label *label109
   484 set .UNIT_S1 *tmp104
   485 set .UNIT_P1 *tmp85
   486 label *label107
-    * label *label108
   487 sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
   488 sensor .SPEED .UNIT_S1 @speed
   489 op div .SPEED_TENTHS .SPEED 10
 
   491 jump *label110 equal *tmp132 false
   492 stop
   493 label *label110
-    * label *label111
   494 # "Function: inline def needsFourUnits(in unit)"
   495 op sub *tmp135 .DOME_X .CORE_X
   496 op sub *tmp136 .DOME_Y .CORE_Y
 
   499 sensor *tmp139 .UNIT_S1 @speed
   500 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   501 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
-    * label *label112
   502 jump *label113 equal *tmp134 false
   503 # "Function: inline def acquireUnit(in currentUnit)"
   504 # "Function: inline def rebindUnit(in currentUnit)"
 
   512 jump *label119 equal *tmp151 false
   513 jump *label116 always
   514 label *label119
-    * label *label120
   515 label *label117
-    * label *label118
   516 ubind *tmp9
   517 set :rebindUnit.2:firstUnit @unit
   518 jump *label121 equal :rebindUnit.2:firstUnit null
 
   521 jump *label126 notEqual *tmp155 0
   522 jump *label116 always
   523 label *label126
-    * label *label127
   524 ubind *tmp9
-    * label *label124
   525 op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
   526 sensor *tmp159 :rebindUnit.2:firstUnit @dead
   527 op equal *tmp160 *tmp159 0
   528 op land *tmp161 *tmp158 *tmp160
   529 jump *label123 notEqual *tmp161 false
-    * label *label125
   530 label *label121
-    * label *label122
   531 end
   532 label *label116
   533 ucontrol flag 1
   534 set *tmp143 @unit
-    * label *label115
   535 set .UNIT_S2 *tmp143
   536 # "Function: inline def acquireUnit(in currentUnit)"
   537 # "Function: inline def rebindUnit(in currentUnit)"
 
   545 jump *label132 equal *tmp170 false
   546 jump *label129 always
   547 label *label132
-    * label *label133
   548 label *label130
-    * label *label131
   549 ubind *tmp9
   550 set :rebindUnit.3:firstUnit @unit
   551 jump *label134 equal :rebindUnit.3:firstUnit null
 
   554 jump *label139 notEqual *tmp174 0
   555 jump *label129 always
   556 label *label139
-    * label *label140
   557 ubind *tmp9
-    * label *label137
   558 op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
   559 sensor *tmp178 :rebindUnit.3:firstUnit @dead
   560 op equal *tmp179 *tmp178 0
   561 op land *tmp180 *tmp177 *tmp179
   562 jump *label136 notEqual *tmp180 false
-    * label *label138
   563 label *label134
-    * label *label135
   564 end
   565 label *label129
   566 ucontrol flag 1
   567 set *tmp162 @unit
-    * label *label128
   568 set .UNIT_P2 *tmp162
   569 sensor *tmp181 .UNIT_S1 @firstItem
   570 op equal *tmp182 *tmp181 @phase-fabric
 
   574 jump *label141 equal *tmp185 false
   575 # "Function: inline void swap(in out a, in out b)"
   576 set :swap.1:t .UNIT_S1
-    * label *label143
   577 set .UNIT_S1 *tmp162
   578 set .UNIT_P2 :swap.1:t
   579 label *label141
-    * label *label142
   580 sensor *tmp187 *tmp143 @firstItem
   581 op equal *tmp188 *tmp187 @phase-fabric
   582 sensor *tmp189 .UNIT_P2 @firstItem
 
   584 op or *tmp191 *tmp188 *tmp190
   585 jump *label144 equal *tmp191 false
   586 # "Function: inline void swap(in out a, in out b)"
-    * label *label146
   587 set .UNIT_S2 .UNIT_P2
   588 set .UNIT_P2 *tmp143
   589 label *label144
-    * label *label145
   590 set .GROUP1 "unit  1"
   591 set .GROUP2 "unit 2"
   592 jump *label114 always
 
   609 op lessThan *tmp201 *tmp199 *tmp200
   610 op or .SUPPLY_P_FIRST *tmp193 *tmp201
   611 op add :unitCheck @time 5000
-    * label *label147
   612 sensor *tmp204 switch1 @enabled
   613 jump *label149 equal *tmp204 false
   614 label *label363
 
   638 print "]"
   639 print "\n"
   640 label *label152
-    * label *label150
   641 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   642 # "Function: inline def rebindUnit(in currentUnit)"
   643 jump *label155 equal .UNIT_S1 null
 
   650 jump *label157 equal *tmp215 false
   651 jump *label154 always
   652 label *label157
-    * label *label158
   653 label *label155
-    * label *label156
   654 ubind *tmp9
   655 set :rebindUnit.4:firstUnit @unit
   656 jump *label159 equal :rebindUnit.4:firstUnit null
 
   659 jump *label164 notEqual *tmp219 0
   660 jump *label154 always
   661 label *label164
-    * label *label165
   662 ubind *tmp9
-    * label *label162
   663 op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
   664 sensor *tmp223 :rebindUnit.4:firstUnit @dead
   665 op equal *tmp224 *tmp223 0
   666 op land *tmp225 *tmp222 *tmp224
   667 jump *label161 notEqual *tmp225 false
-    * label *label163
   668 label *label159
-    * label *label160
   669 end
   670 label *label154
   671 sensor :processUnit:state @unit @flag
 
   690 jump *label172 equal *tmp237 false
   691 ucontrol itemDrop .CORE .UNIT_CAPACITY
   692 label *label172
-    * label *label173
   693 label *label171
   694 label *label169
   695 label *label166
-    * label *label167
   696 jump *label174 notEqual :processUnit:state 2
   697 ucontrol within .CORE_X .CORE_Y 8 *tmp241
   698 jump *label176 equal *tmp241 false
 
   718 op div :processUnit:distance *tmp251 10
   719 label *label177
   720 label *label174
-    * label *label175
   721 jump *label180 notEqual :processUnit:state 3
   722 ucontrol within .DOME_X .DOME_Y 8 *tmp255
   723 jump *label182 equal *tmp255 false
 
   734 ucontrol approach .CORE_X .CORE_Y 6
   735 set :processUnit:state 2
   736 label *label186
-    * label *label187
   737 jump *label183 always
   738 label *label182
   739 ucontrol approach .DOME_X .DOME_Y 6
 
   747 op div :processUnit:distance *tmp266 10
   748 label *label183
   749 label *label180
-    * label *label181
   750 ucontrol flag :processUnit:state
   751 sensor *tmp268 @unit @totalItems
   752 print "  "
 
   769 print .MSG
   770 label *label189
   771 set :processUnit:unit @unit
-    * label *label153
   772 set .UNIT_S1 :processUnit:unit
   773 jump *label190 equal *tmp134 false
   774 op equal *tmp273 .SUPPLY_S_FIRST false
 
   784 jump *label196 equal *tmp281 false
   785 jump *label193 always
   786 label *label196
-    * label *label197
   787 label *label194
-    * label *label195
   788 ubind *tmp9
   789 set :rebindUnit.5:firstUnit @unit
   790 jump *label198 equal :rebindUnit.5:firstUnit null
 
   793 jump *label203 notEqual *tmp285 0
   794 jump *label193 always
   795 label *label203
-    * label *label204
   796 ubind *tmp9
-    * label *label201
   797 op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
   798 sensor *tmp289 :rebindUnit.5:firstUnit @dead
   799 op equal *tmp290 *tmp289 0
   800 op land *tmp291 *tmp288 *tmp290
   801 jump *label200 notEqual *tmp291 false
-    * label *label202
   802 label *label198
-    * label *label199
   803 end
   804 label *label193
   805 sensor :processUnit.1:state @unit @flag
 
   824 jump *label211 equal *tmp303 false
   825 ucontrol itemDrop .CORE .UNIT_CAPACITY
   826 label *label211
-    * label *label212
   827 label *label210
   828 label *label208
   829 label *label205
-    * label *label206
   830 jump *label213 notEqual :processUnit.1:state 2
   831 ucontrol within .CORE_X .CORE_Y 8 *tmp307
   832 jump *label215 equal *tmp307 false
 
   852 op div :processUnit.1:distance *tmp317 10
   853 label *label216
   854 label *label213
-    * label *label214
   855 jump *label219 notEqual :processUnit.1:state 3
   856 ucontrol within .DOME_X .DOME_Y 8 *tmp321
   857 jump *label221 equal *tmp321 false
 
   868 ucontrol approach .CORE_X .CORE_Y 6
   869 set :processUnit.1:state 2
   870 label *label225
-    * label *label226
   871 jump *label222 always
   872 label *label221
   873 ucontrol approach .DOME_X .DOME_Y 6
 
   881 op div :processUnit.1:distance *tmp332 10
   882 label *label222
   883 label *label219
-    * label *label220
   884 ucontrol flag :processUnit.1:state
   885 sensor *tmp334 @unit @totalItems
   886 print "  "
 
   903 print .MSG
   904 label *label228
   905 set :processUnit.1:unit @unit
-    * label *label192
   906 set .UNIT_S2 :processUnit.1:unit
   907 jump *label229 equal .SUPPLY_S_FIRST false
   908 sensor *tmp339 :processUnit:unit @totalItems
 
   913 op equal .SUPPLY_S_FIRST *tmp341 0
   914 label *label230
   915 label *label190
-    * label *label191
   916 # "Function: inline void printDomeStatus(in item, in text)"
   917 print "\n[green]Phase fabric[] status:\n"
   918 sensor :printDomeStatus.1:level .DOME @phase-fabric
 
   930 print "]"
   931 print "\n"
   932 label *label233
-    * label *label231
   933 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   934 # "Function: inline def rebindUnit(in currentUnit)"
   935 jump *label236 equal .UNIT_P1 null
 
   942 jump *label238 equal *tmp353 false
   943 jump *label235 always
   944 label *label238
-    * label *label239
   945 label *label236
-    * label *label237
   946 ubind *tmp9
   947 set :rebindUnit.6:firstUnit @unit
   948 jump *label240 equal :rebindUnit.6:firstUnit null
 
   951 jump *label245 notEqual *tmp357 0
   952 jump *label235 always
   953 label *label245
-    * label *label246
   954 ubind *tmp9
-    * label *label243
   955 op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
   956 sensor *tmp361 :rebindUnit.6:firstUnit @dead
   957 op equal *tmp362 *tmp361 0
   958 op land *tmp363 *tmp360 *tmp362
   959 jump *label242 notEqual *tmp363 false
-    * label *label244
   960 label *label240
-    * label *label241
   961 end
   962 label *label235
   963 sensor :processUnit.2:state @unit @flag
 
   982 jump *label253 equal *tmp375 false
   983 ucontrol itemDrop .CORE .UNIT_CAPACITY
   984 label *label253
-    * label *label254
   985 label *label252
   986 label *label250
   987 label *label247
-    * label *label248
   988 jump *label255 notEqual :processUnit.2:state 2
   989 ucontrol within .CORE_X .CORE_Y 8 *tmp379
   990 jump *label257 equal *tmp379 false
 
  1010 op div :processUnit.2:distance *tmp389 10
  1011 label *label258
  1012 label *label255
-    * label *label256
  1013 jump *label261 notEqual :processUnit.2:state 3
  1014 ucontrol within .DOME_X .DOME_Y 8 *tmp393
  1015 jump *label263 equal *tmp393 false
 
  1026 ucontrol approach .CORE_X .CORE_Y 6
  1027 set :processUnit.2:state 2
  1028 label *label267
-    * label *label268
  1029 jump *label264 always
  1030 label *label263
  1031 ucontrol approach .DOME_X .DOME_Y 6
 
  1039 op div :processUnit.2:distance *tmp404 10
  1040 label *label264
  1041 label *label261
-    * label *label262
  1042 ucontrol flag :processUnit.2:state
  1043 sensor *tmp406 @unit @totalItems
  1044 print "  "
 
  1061 print .MSG
  1062 label *label270
  1063 set :processUnit.2:unit @unit
-    * label *label234
  1064 set .UNIT_P1 :processUnit.2:unit
  1065 jump *label271 equal *tmp134 false
  1066 op equal *tmp411 .SUPPLY_P_FIRST false
 
  1076 jump *label277 equal *tmp419 false
  1077 jump *label274 always
  1078 label *label277
-    * label *label278
  1079 label *label275
-    * label *label276
  1080 ubind *tmp9
  1081 set :rebindUnit.7:firstUnit @unit
  1082 jump *label279 equal :rebindUnit.7:firstUnit null
 
  1085 jump *label284 notEqual *tmp423 0
  1086 jump *label274 always
  1087 label *label284
-    * label *label285
  1088 ubind *tmp9
-    * label *label282
  1089 op notEqual *tmp426 @unit :rebindUnit.7:firstUnit
  1090 sensor *tmp427 :rebindUnit.7:firstUnit @dead
  1091 op equal *tmp428 *tmp427 0
  1092 op land *tmp429 *tmp426 *tmp428
  1093 jump *label281 notEqual *tmp429 false
-    * label *label283
  1094 label *label279
-    * label *label280
  1095 end
  1096 label *label274
  1097 sensor :processUnit.3:state @unit @flag
 
  1116 jump *label292 equal *tmp441 false
  1117 ucontrol itemDrop .CORE .UNIT_CAPACITY
  1118 label *label292
-    * label *label293
  1119 label *label291
  1120 label *label289
  1121 label *label286
-    * label *label287
  1122 jump *label294 notEqual :processUnit.3:state 2
  1123 ucontrol within .CORE_X .CORE_Y 8 *tmp445
  1124 jump *label296 equal *tmp445 false
 
  1144 op div :processUnit.3:distance *tmp455 10
  1145 label *label297
  1146 label *label294
-    * label *label295
  1147 jump *label300 notEqual :processUnit.3:state 3
  1148 ucontrol within .DOME_X .DOME_Y 8 *tmp459
  1149 jump *label302 equal *tmp459 false
 
  1160 ucontrol approach .CORE_X .CORE_Y 6
  1161 set :processUnit.3:state 2
  1162 label *label306
-    * label *label307
  1163 jump *label303 always
  1164 label *label302
  1165 ucontrol approach .DOME_X .DOME_Y 6
 
  1173 op div :processUnit.3:distance *tmp470 10
  1174 label *label303
  1175 label *label300
-    * label *label301
  1176 ucontrol flag :processUnit.3:state
  1177 sensor *tmp472 @unit @totalItems
  1178 print "  "
 
  1195 print .MSG
  1196 label *label309
  1197 set :processUnit.3:unit @unit
-    * label *label273
  1198 set .UNIT_P2 :processUnit.3:unit
  1199 jump *label310 equal .SUPPLY_P_FIRST false
  1200 sensor *tmp477 :processUnit.2:unit @totalItems
 
  1205 op equal .SUPPLY_P_FIRST *tmp479 0
  1206 label *label311
  1207 label *label271
-    * label *label272
  1208 op sub *tmp481 @time :start
  1209 op floor *tmp482 *tmp481
  1210 print "\n"
 
  1228 set :needsFourUnits.3:unit @unit
  1229 sensor *tmp495 :needsFourUnits.3:unit @speed
  1230 op div :needsFourUnits.3:travel_time *tmp138 *tmp495
-    * label *label317
  1231 jump *label319 lessThan :needsFourUnits.3:travel_time 47
  1232 set *tmp498 4
  1233 label *label319
 
  1243 set *tmp487 true
  1244 jump *label314 always
  1245 label *label325
-    * label *label326
  1246 jump *label324 always
  1247 label *label323
  1248 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1249 label *label324
  1250 ubind UNIT_TYPE
-    * label *label321
  1251 op notEqual *tmp508 @unit :areUnitsAvailable.2:firstUnit
  1252 sensor *tmp509 :areUnitsAvailable.2:firstUnit @dead
  1253 op equal *tmp510 *tmp509 0
  1254 op land *tmp511 *tmp508 *tmp510
  1255 jump *label320 notEqual *tmp511 false
-    * label *label322
  1256 label *label315
-    * label *label316
  1257 jump *label327 always
  1258 print UNIT_TYPE
  1259 print ":"
 
  1266 print ", needed: "
  1267 print :areUnitsAvailable.2:needed
  1268 label *label329
-    * label *label330
  1269 print "\n"
  1270 label *label327
-    * label *label328
  1271 set *tmp487 false
  1272 label *label314
  1273 jump *label331 equal *tmp487 false
  1274 end
  1275 label *label331
-    * label *label332
  1276 op add :unitCheck @time 5000
  1277 label *label312
-    * label *label313
-    * label *label148
  1278 sensor *tmp204 switch1 @enabled
  1279 jump *label363 notEqual *tmp204 false
  1280 label *label149
 
  1290 jump *label334 equal *tmp521 false
  1291 ulocate building core false @copper 0 0 0 .CORE
  1292 label *label334
-    * label *label335
  1293 set :locateCore*retval .CORE
-    * label *label333
  1294 return :locateCore*retaddr
  1295 end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-21 instructions):
 
    16 label *label5
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label338 equal :locateCore*retval false
-    * jump *label1 always
+   19 jump *label1 notEqual :locateCore*retval false
    20 label *label338
    21 set :locateCore:type @poly
    22 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label344 equal :locateCore*retval false
-    * jump *label1 always
+   23 jump *label1 notEqual :locateCore*retval false
    24 label *label344
    25 set :locateCore:type @mega
    26 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label350 equal :locateCore*retval false
-    * jump *label1 always
+   27 jump *label1 notEqual :locateCore*retval false
    28 label *label350
    29 set :locateCore:type @mono
    30 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label356 equal :locateCore*retval false
-    * jump *label1 always
+   31 jump *label1 notEqual :locateCore*retval false
    32 label *label356
    33 jump *label5 always
    34 label *label1
 
   393 set .UNIT_P2 .UNIT_S1
   394 set .UNIT_S1 .UNIT_P1
   395 set .UNIT_P1 @unit
-    * jump *label79 equal .UNIT_S2 null
-    * jump *label76 always
+  396 jump *label76 notEqual .UNIT_S2 null
   397 label *label79
   398 label *label77
   399 ubind *tmp9
 
   412 sensor *tmp91 @unit @controller
   413 op equal *tmp92 *tmp91 @this
   414 op land *tmp93 *tmp90 *tmp92
-    * jump *label85 equal *tmp93 false
-    * jump *label82 always
+  415 jump *label82 notEqual *tmp93 false
   416 label *label85
   417 label *label83
   418 ubind *tmp9
 
   420 jump *label87 equal :rebindUnit:firstUnit null
   421 label *label89
   422 sensor *tmp97 @unit @controlled
-    * jump *label92 notEqual *tmp97 0
-    * jump *label82 always
+  423 jump *label82 equal *tmp97 0
   424 label *label92
   425 ubind *tmp9
   426 op notEqual *tmp100 @unit :rebindUnit:firstUnit
 
   443 sensor *tmp110 @unit @controller
   444 op equal *tmp111 *tmp110 @this
   445 op land *tmp112 *tmp109 *tmp111
-    * jump *label98 equal *tmp112 false
-    * jump *label95 always
+  446 jump *label95 notEqual *tmp112 false
   447 label *label98
   448 label *label96
   449 ubind *tmp9
 
   451 jump *label100 equal :rebindUnit.1:firstUnit null
   452 label *label102
   453 sensor *tmp116 @unit @controlled
-    * jump *label105 notEqual *tmp116 0
-    * jump *label95 always
+  454 jump *label95 equal *tmp116 0
   455 label *label105
   456 ubind *tmp9
   457 op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
 
   500 sensor *tmp149 @unit @controller
   501 op equal *tmp150 *tmp149 @this
   502 op land *tmp151 *tmp148 *tmp150
-    * jump *label119 equal *tmp151 false
-    * jump *label116 always
+  503 jump *label116 notEqual *tmp151 false
   504 label *label119
   505 label *label117
   506 ubind *tmp9
 
   508 jump *label121 equal :rebindUnit.2:firstUnit null
   509 label *label123
   510 sensor *tmp155 @unit @controlled
-    * jump *label126 notEqual *tmp155 0
-    * jump *label116 always
+  511 jump *label116 equal *tmp155 0
   512 label *label126
   513 ubind *tmp9
   514 op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
 
   531 sensor *tmp168 @unit @controller
   532 op equal *tmp169 *tmp168 @this
   533 op land *tmp170 *tmp167 *tmp169
-    * jump *label132 equal *tmp170 false
-    * jump *label129 always
+  534 jump *label129 notEqual *tmp170 false
   535 label *label132
   536 label *label130
   537 ubind *tmp9
 
   539 jump *label134 equal :rebindUnit.3:firstUnit null
   540 label *label136
   541 sensor *tmp174 @unit @controlled
-    * jump *label139 notEqual *tmp174 0
-    * jump *label129 always
+  542 jump *label129 equal *tmp174 0
   543 label *label139
   544 ubind *tmp9
   545 op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
 
   634 sensor *tmp213 @unit @controller
   635 op equal *tmp214 *tmp213 @this
   636 op land *tmp215 *tmp212 *tmp214
-    * jump *label157 equal *tmp215 false
-    * jump *label154 always
+  637 jump *label154 notEqual *tmp215 false
   638 label *label157
   639 label *label155
   640 ubind *tmp9
 
   642 jump *label159 equal :rebindUnit.4:firstUnit null
   643 label *label161
   644 sensor *tmp219 @unit @controlled
-    * jump *label164 notEqual *tmp219 0
-    * jump *label154 always
+  645 jump *label154 equal *tmp219 0
   646 label *label164
   647 ubind *tmp9
   648 op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
 
   766 sensor *tmp279 @unit @controller
   767 op equal *tmp280 *tmp279 @this
   768 op land *tmp281 *tmp278 *tmp280
-    * jump *label196 equal *tmp281 false
-    * jump *label193 always
+  769 jump *label193 notEqual *tmp281 false
   770 label *label196
   771 label *label194
   772 ubind *tmp9
 
   774 jump *label198 equal :rebindUnit.5:firstUnit null
   775 label *label200
   776 sensor *tmp285 @unit @controlled
-    * jump *label203 notEqual *tmp285 0
-    * jump *label193 always
+  777 jump *label193 equal *tmp285 0
   778 label *label203
   779 ubind *tmp9
   780 op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
 
   922 sensor *tmp351 @unit @controller
   923 op equal *tmp352 *tmp351 @this
   924 op land *tmp353 *tmp350 *tmp352
-    * jump *label238 equal *tmp353 false
-    * jump *label235 always
+  925 jump *label235 notEqual *tmp353 false
   926 label *label238
   927 label *label236
   928 ubind *tmp9
 
   930 jump *label240 equal :rebindUnit.6:firstUnit null
   931 label *label242
   932 sensor *tmp357 @unit @controlled
-    * jump *label245 notEqual *tmp357 0
-    * jump *label235 always
+  933 jump *label235 equal *tmp357 0
   934 label *label245
   935 ubind *tmp9
   936 op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
 
  1054 sensor *tmp417 @unit @controller
  1055 op equal *tmp418 *tmp417 @this
  1056 op land *tmp419 *tmp416 *tmp418
-    * jump *label277 equal *tmp419 false
-    * jump *label274 always
+ 1057 jump *label274 notEqual *tmp419 false
  1058 label *label277
  1059 label *label275
  1060 ubind *tmp9
 
  1062 jump *label279 equal :rebindUnit.7:firstUnit null
  1063 label *label281
  1064 sensor *tmp423 @unit @controlled
-    * jump *label284 notEqual *tmp423 0
-    * jump *label274 always
+ 1065 jump *label274 equal *tmp423 0
  1066 label *label284
  1067 ubind *tmp9
  1068 op notEqual *tmp426 @unit :rebindUnit.7:firstUnit

Modifications by Jumps phase, Jump Optimization, pass 5, iteration 1:
 
    17 set :locateCore:type @flare
    18 call *label0 :locateCore*retaddr :locateCore*retval
    19 jump *label1 notEqual :locateCore*retval false
-    * label *label338
    20 set :locateCore:type @poly
    21 call *label0 :locateCore*retaddr :locateCore*retval
    22 jump *label1 notEqual :locateCore*retval false
-    * label *label344
    23 set :locateCore:type @mega
    24 call *label0 :locateCore*retaddr :locateCore*retval
    25 jump *label1 notEqual :locateCore*retval false
-    * label *label350
    26 set :locateCore:type @mono
    27 call *label0 :locateCore*retaddr :locateCore*retval
    28 jump *label1 notEqual :locateCore*retval false
-    * label *label356
    29 jump *label5 always
    30 label *label1
    31 sensor .CORE_X .CORE @x
 
   390 set .UNIT_S1 .UNIT_P1
   391 set .UNIT_P1 @unit
   392 jump *label76 notEqual .UNIT_S2 null
-    * label *label79
   393 label *label77
   394 ubind *tmp9
   395 op notEqual *tmp81 @unit :rebindUnits:firstUnit
 
   408 op equal *tmp92 *tmp91 @this
   409 op land *tmp93 *tmp90 *tmp92
   410 jump *label82 notEqual *tmp93 false
-    * label *label85
   411 label *label83
   412 ubind *tmp9
   413 set :rebindUnit:firstUnit @unit
 
   415 label *label89
   416 sensor *tmp97 @unit @controlled
   417 jump *label82 equal *tmp97 0
-    * label *label92
   418 ubind *tmp9
   419 op notEqual *tmp100 @unit :rebindUnit:firstUnit
   420 sensor *tmp101 :rebindUnit:firstUnit @dead
 
   437 op equal *tmp111 *tmp110 @this
   438 op land *tmp112 *tmp109 *tmp111
   439 jump *label95 notEqual *tmp112 false
-    * label *label98
   440 label *label96
   441 ubind *tmp9
   442 set :rebindUnit.1:firstUnit @unit
 
   444 label *label102
   445 sensor *tmp116 @unit @controlled
   446 jump *label95 equal *tmp116 0
-    * label *label105
   447 ubind *tmp9
   448 op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
   449 sensor *tmp120 :rebindUnit.1:firstUnit @dead
 
   492 op equal *tmp150 *tmp149 @this
   493 op land *tmp151 *tmp148 *tmp150
   494 jump *label116 notEqual *tmp151 false
-    * label *label119
   495 label *label117
   496 ubind *tmp9
   497 set :rebindUnit.2:firstUnit @unit
 
   499 label *label123
   500 sensor *tmp155 @unit @controlled
   501 jump *label116 equal *tmp155 0
-    * label *label126
   502 ubind *tmp9
   503 op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
   504 sensor *tmp159 :rebindUnit.2:firstUnit @dead
 
   521 op equal *tmp169 *tmp168 @this
   522 op land *tmp170 *tmp167 *tmp169
   523 jump *label129 notEqual *tmp170 false
-    * label *label132
   524 label *label130
   525 ubind *tmp9
   526 set :rebindUnit.3:firstUnit @unit
 
   528 label *label136
   529 sensor *tmp174 @unit @controlled
   530 jump *label129 equal *tmp174 0
-    * label *label139
   531 ubind *tmp9
   532 op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
   533 sensor *tmp178 :rebindUnit.3:firstUnit @dead
 
   622 op equal *tmp214 *tmp213 @this
   623 op land *tmp215 *tmp212 *tmp214
   624 jump *label154 notEqual *tmp215 false
-    * label *label157
   625 label *label155
   626 ubind *tmp9
   627 set :rebindUnit.4:firstUnit @unit
 
   629 label *label161
   630 sensor *tmp219 @unit @controlled
   631 jump *label154 equal *tmp219 0
-    * label *label164
   632 ubind *tmp9
   633 op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
   634 sensor *tmp223 :rebindUnit.4:firstUnit @dead
 
   752 op equal *tmp280 *tmp279 @this
   753 op land *tmp281 *tmp278 *tmp280
   754 jump *label193 notEqual *tmp281 false
-    * label *label196
   755 label *label194
   756 ubind *tmp9
   757 set :rebindUnit.5:firstUnit @unit
 
   759 label *label200
   760 sensor *tmp285 @unit @controlled
   761 jump *label193 equal *tmp285 0
-    * label *label203
   762 ubind *tmp9
   763 op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
   764 sensor *tmp289 :rebindUnit.5:firstUnit @dead
 
   906 op equal *tmp352 *tmp351 @this
   907 op land *tmp353 *tmp350 *tmp352
   908 jump *label235 notEqual *tmp353 false
-    * label *label238
   909 label *label236
   910 ubind *tmp9
   911 set :rebindUnit.6:firstUnit @unit
 
   913 label *label242
   914 sensor *tmp357 @unit @controlled
   915 jump *label235 equal *tmp357 0
-    * label *label245
   916 ubind *tmp9
   917 op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
   918 sensor *tmp361 :rebindUnit.6:firstUnit @dead
 
  1036 op equal *tmp418 *tmp417 @this
  1037 op land *tmp419 *tmp416 *tmp418
  1038 jump *label274 notEqual *tmp419 false
-    * label *label277
  1039 label *label275
  1040 ubind *tmp9
  1041 set :rebindUnit.7:firstUnit @unit
 
  1043 label *label281
  1044 sensor *tmp423 @unit @controlled
  1045 jump *label274 equal *tmp423 0
-    * label *label284
  1046 ubind *tmp9
  1047 op notEqual *tmp426 @unit :rebindUnit.7:firstUnit
  1048 sensor *tmp427 :rebindUnit.7:firstUnit @dead

Modifications by Jumps phase, Jump Threading, pass 5, iteration 1:
+    0 label __start__
     1 remark "This is the preferred unit type to use for bringing in supplies."
     2 remark "If no units of this type exist, we'll try using other types."
     3 set UNIT_TYPE @flare
 
    75 op or *tmp26 *tmp23 *tmp25
    76 jump *label33 equal *tmp26 false
    77 op add :areUnitsAvailable:free :areUnitsAvailable:free 1
-    * jump *label35 lessThan :areUnitsAvailable:free *tmp21
+   78 jump *label34 lessThan :areUnitsAvailable:free *tmp21
    79 set *tmp10 true
    80 jump *label24 always
    81 label *label35
 
   137 op or *tmp58 *tmp55 *tmp57
   138 jump *label370 equal *tmp58 false
   139 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label368 lessThan :areUnitsAvailable.1:free *tmp53
+  140 jump *label371 lessThan :areUnitsAvailable.1:free *tmp53
   141 set *tmp42 true
   142 jump *label380 always
   143 label *label368
 
   201 op or *tmp58 *tmp55 *tmp57
   202 jump *label394 equal *tmp58 false
   203 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label392 lessThan :areUnitsAvailable.1:free *tmp53
+  204 jump *label395 lessThan :areUnitsAvailable.1:free *tmp53
   205 set *tmp42 true
   206 jump *label404 always
   207 label *label392
 
   265 op or *tmp58 *tmp55 *tmp57
   266 jump *label418 equal *tmp58 false
   267 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label416 lessThan :areUnitsAvailable.1:free *tmp53
+  268 jump *label419 lessThan :areUnitsAvailable.1:free *tmp53
   269 set *tmp42 true
   270 jump *label428 always
   271 label *label416
 
   329 op or *tmp58 *tmp55 *tmp57
   330 jump *label442 equal *tmp58 false
   331 op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
-    * jump *label440 lessThan :areUnitsAvailable.1:free *tmp53
+  332 jump *label443 lessThan :areUnitsAvailable.1:free *tmp53
   333 set *tmp42 true
   334 jump *label452 always
   335 label *label440
 
   412 label *label83
   413 ubind *tmp9
   414 set :rebindUnit:firstUnit @unit
-    * jump *label87 equal :rebindUnit:firstUnit null
+  415 jump __start__ equal :rebindUnit:firstUnit null
   416 label *label89
   417 sensor *tmp97 @unit @controlled
   418 jump *label82 equal *tmp97 0
 
   441 label *label96
   442 ubind *tmp9
   443 set :rebindUnit.1:firstUnit @unit
-    * jump *label100 equal :rebindUnit.1:firstUnit null
+  444 jump __start__ equal :rebindUnit.1:firstUnit null
   445 label *label102
   446 sensor *tmp116 @unit @controlled
   447 jump *label95 equal *tmp116 0
 
   496 label *label117
   497 ubind *tmp9
   498 set :rebindUnit.2:firstUnit @unit
-    * jump *label121 equal :rebindUnit.2:firstUnit null
+  499 jump __start__ equal :rebindUnit.2:firstUnit null
   500 label *label123
   501 sensor *tmp155 @unit @controlled
   502 jump *label116 equal *tmp155 0
 
   525 label *label130
   526 ubind *tmp9
   527 set :rebindUnit.3:firstUnit @unit
-    * jump *label134 equal :rebindUnit.3:firstUnit null
+  528 jump __start__ equal :rebindUnit.3:firstUnit null
   529 label *label136
   530 sensor *tmp174 @unit @controlled
   531 jump *label129 equal *tmp174 0
 
   585 op or .SUPPLY_P_FIRST *tmp193 *tmp201
   586 op add :unitCheck @time 5000
   587 sensor *tmp204 switch1 @enabled
-    * jump *label149 equal *tmp204 false
+  588 jump __start__ equal *tmp204 false
   589 label *label363
   590 set :start @time
   591 print " === [gold]Supplying Overdrive Dome[] === "
 
   626 label *label155
   627 ubind *tmp9
   628 set :rebindUnit.4:firstUnit @unit
-    * jump *label159 equal :rebindUnit.4:firstUnit null
+  629 jump __start__ equal :rebindUnit.4:firstUnit null
   630 label *label161
   631 sensor *tmp219 @unit @controlled
   632 jump *label154 equal *tmp219 0
 
   672 jump *label178 lessThan *tmp243 .UNIT_CAPACITY
   673 ucontrol approach .DOME_X .DOME_Y 6
   674 set :processUnit:state 3
-    * jump *label179 always
+  675 jump *label177 always
   676 label *label178
   677 set .MSG ", loading\n"
   678 label *label179
 
   701 set .MSG ", waiting\n"
   702 label *label185
   703 sensor *tmp258 @unit @totalItems
-    * jump *label186 greaterThan *tmp258 0
+  704 jump *label183 greaterThan *tmp258 0
   705 ucontrol approach .CORE_X .CORE_Y 6
   706 set :processUnit:state 2
   707 label *label186
 
   756 label *label194
   757 ubind *tmp9
   758 set :rebindUnit.5:firstUnit @unit
-    * jump *label198 equal :rebindUnit.5:firstUnit null
+  759 jump __start__ equal :rebindUnit.5:firstUnit null
   760 label *label200
   761 sensor *tmp285 @unit @controlled
   762 jump *label193 equal *tmp285 0
 
   802 jump *label217 lessThan *tmp309 .UNIT_CAPACITY
   803 ucontrol approach .DOME_X .DOME_Y 6
   804 set :processUnit.1:state 3
-    * jump *label218 always
+  805 jump *label216 always
   806 label *label217
   807 set .MSG ", loading\n"
   808 label *label218
 
   831 set .MSG ", waiting\n"
   832 label *label224
   833 sensor *tmp324 @unit @totalItems
-    * jump *label225 greaterThan *tmp324 0
+  834 jump *label222 greaterThan *tmp324 0
   835 ucontrol approach .CORE_X .CORE_Y 6
   836 set :processUnit.1:state 2
   837 label *label225
 
   910 label *label236
   911 ubind *tmp9
   912 set :rebindUnit.6:firstUnit @unit
-    * jump *label240 equal :rebindUnit.6:firstUnit null
+  913 jump __start__ equal :rebindUnit.6:firstUnit null
   914 label *label242
   915 sensor *tmp357 @unit @controlled
   916 jump *label235 equal *tmp357 0
 
   956 jump *label259 lessThan *tmp381 .UNIT_CAPACITY
   957 ucontrol approach .DOME_X .DOME_Y 6
   958 set :processUnit.2:state 3
-    * jump *label260 always
+  959 jump *label258 always
   960 label *label259
   961 set .MSG ", loading\n"
   962 label *label260
 
   985 set .MSG ", waiting\n"
   986 label *label266
   987 sensor *tmp396 @unit @totalItems
-    * jump *label267 greaterThan *tmp396 0
+  988 jump *label264 greaterThan *tmp396 0
   989 ucontrol approach .CORE_X .CORE_Y 6
   990 set :processUnit.2:state 2
   991 label *label267
 
  1040 label *label275
  1041 ubind *tmp9
  1042 set :rebindUnit.7:firstUnit @unit
-    * jump *label279 equal :rebindUnit.7:firstUnit null
+ 1043 jump __start__ equal :rebindUnit.7:firstUnit null
  1044 label *label281
  1045 sensor *tmp423 @unit @controlled
  1046 jump *label274 equal *tmp423 0
 
  1086 jump *label298 lessThan *tmp447 .UNIT_CAPACITY
  1087 ucontrol approach .DOME_X .DOME_Y 6
  1088 set :processUnit.3:state 3
-    * jump *label299 always
+ 1089 jump *label297 always
  1090 label *label298
  1091 set .MSG ", loading\n"
  1092 label *label299
 
  1115 set .MSG ", waiting\n"
  1116 label *label305
  1117 sensor *tmp462 @unit @totalItems
-    * jump *label306 greaterThan *tmp462 0
+ 1118 jump *label303 greaterThan *tmp462 0
  1119 ucontrol approach .CORE_X .CORE_Y 6
  1120 set :processUnit.3:state 2
  1121 label *label306
 
  1181 set :areUnitsAvailable.2:occupied 0
  1182 ubind UNIT_TYPE
  1183 set :areUnitsAvailable.2:firstUnit @unit
-    * jump *label315 equal :areUnitsAvailable.2:firstUnit null
+ 1184 jump *label327 equal :areUnitsAvailable.2:firstUnit null
  1185 set *tmp498 2
  1186 # "Function: inline def needsFourUnits(in unit)"
  1187 set :needsFourUnits.3:unit @unit
 
  1198 op or *tmp503 *tmp500 *tmp502
  1199 jump *label323 equal *tmp503 false
  1200 op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
-    * jump *label325 lessThan :areUnitsAvailable.2:free *tmp498
+ 1201 jump *label324 lessThan :areUnitsAvailable.2:free *tmp498
  1202 set *tmp487 true
  1203 jump *label314 always
  1204 label *label325

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-19 instructions):
 
    78 jump *label34 lessThan :areUnitsAvailable:free *tmp21
    79 set *tmp10 true
    80 jump *label24 always
-    * label *label35
-    * jump *label34 always
    81 label *label33
    82 op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
    83 label *label34
 
   138 jump *label371 lessThan :areUnitsAvailable.1:free *tmp53
   139 set *tmp42 true
   140 jump *label380 always
-    * label *label368
-    * jump *label371 always
   141 label *label370
   142 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   143 label *label371
 
   200 jump *label395 lessThan :areUnitsAvailable.1:free *tmp53
   201 set *tmp42 true
   202 jump *label404 always
-    * label *label392
-    * jump *label395 always
   203 label *label394
   204 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   205 label *label395
 
   262 jump *label419 lessThan :areUnitsAvailable.1:free *tmp53
   263 set *tmp42 true
   264 jump *label428 always
-    * label *label416
-    * jump *label419 always
   265 label *label418
   266 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   267 label *label419
 
   324 jump *label443 lessThan :areUnitsAvailable.1:free *tmp53
   325 set *tmp42 true
   326 jump *label452 always
-    * label *label440
-    * jump *label443 always
   327 label *label442
   328 op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
   329 label *label443
 
   356 label *label455
   357 printflush message1
   358 jump *label21 always
-    * set *tmp9 null
   359 label *label20
   360 print "[gold]Binding units..."
   361 printflush message1
 
   411 op equal *tmp102 *tmp101 0
   412 op land *tmp103 *tmp100 *tmp102
   413 jump *label89 notEqual *tmp103 false
-    * label *label87
   414 end
   415 label *label82
   416 ucontrol flag 1
 
   439 op equal *tmp121 *tmp120 0
   440 op land *tmp122 *tmp119 *tmp121
   441 jump *label102 notEqual *tmp122 false
-    * label *label100
   442 end
   443 label *label95
   444 ucontrol flag 1
 
   493 op equal *tmp160 *tmp159 0
   494 op land *tmp161 *tmp158 *tmp160
   495 jump *label123 notEqual *tmp161 false
-    * label *label121
   496 end
   497 label *label116
   498 ucontrol flag 1
 
   521 op equal *tmp179 *tmp178 0
   522 op land *tmp180 *tmp177 *tmp179
   523 jump *label136 notEqual *tmp180 false
-    * label *label134
   524 end
   525 label *label129
   526 ucontrol flag 1
 
   621 op equal *tmp224 *tmp223 0
   622 op land *tmp225 *tmp222 *tmp224
   623 jump *label161 notEqual *tmp225 false
-    * label *label159
   624 end
   625 label *label154
   626 sensor :processUnit:state @unit @flag
 
   659 jump *label177 always
   660 label *label178
   661 set .MSG ", loading\n"
-    * label *label179
   662 jump *label177 always
   663 label *label176
   664 ucontrol approach .CORE_X .CORE_Y 6
 
   687 jump *label183 greaterThan *tmp258 0
   688 ucontrol approach .CORE_X .CORE_Y 6
   689 set :processUnit:state 2
-    * label *label186
   690 jump *label183 always
   691 label *label182
   692 ucontrol approach .DOME_X .DOME_Y 6
 
   748 op equal *tmp290 *tmp289 0
   749 op land *tmp291 *tmp288 *tmp290
   750 jump *label200 notEqual *tmp291 false
-    * label *label198
   751 end
   752 label *label193
   753 sensor :processUnit.1:state @unit @flag
 
   786 jump *label216 always
   787 label *label217
   788 set .MSG ", loading\n"
-    * label *label218
   789 jump *label216 always
   790 label *label215
   791 ucontrol approach .CORE_X .CORE_Y 6
 
   814 jump *label222 greaterThan *tmp324 0
   815 ucontrol approach .CORE_X .CORE_Y 6
   816 set :processUnit.1:state 2
-    * label *label225
   817 jump *label222 always
   818 label *label221
   819 ucontrol approach .DOME_X .DOME_Y 6
 
   899 op equal *tmp362 *tmp361 0
   900 op land *tmp363 *tmp360 *tmp362
   901 jump *label242 notEqual *tmp363 false
-    * label *label240
   902 end
   903 label *label235
   904 sensor :processUnit.2:state @unit @flag
 
   937 jump *label258 always
   938 label *label259
   939 set .MSG ", loading\n"
-    * label *label260
   940 jump *label258 always
   941 label *label257
   942 ucontrol approach .CORE_X .CORE_Y 6
 
   965 jump *label264 greaterThan *tmp396 0
   966 ucontrol approach .CORE_X .CORE_Y 6
   967 set :processUnit.2:state 2
-    * label *label267
   968 jump *label264 always
   969 label *label263
   970 ucontrol approach .DOME_X .DOME_Y 6
 
  1026 op equal *tmp428 *tmp427 0
  1027 op land *tmp429 *tmp426 *tmp428
  1028 jump *label281 notEqual *tmp429 false
-    * label *label279
  1029 end
  1030 label *label274
  1031 sensor :processUnit.3:state @unit @flag
 
  1064 jump *label297 always
  1065 label *label298
  1066 set .MSG ", loading\n"
-    * label *label299
  1067 jump *label297 always
  1068 label *label296
  1069 ucontrol approach .CORE_X .CORE_Y 6
 
  1092 jump *label303 greaterThan *tmp462 0
  1093 ucontrol approach .CORE_X .CORE_Y 6
  1094 set :processUnit.3:state 2
-    * label *label306
  1095 jump *label303 always
  1096 label *label302
  1097 ucontrol approach .DOME_X .DOME_Y 6
 
  1174 jump *label324 lessThan :areUnitsAvailable.2:free *tmp498
  1175 set *tmp487 true
  1176 jump *label314 always
-    * label *label325
-    * jump *label324 always
  1177 label *label323
  1178 op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
  1179 label *label324
 
  1183 op equal *tmp510 *tmp509 0
  1184 op land *tmp511 *tmp508 *tmp510
  1185 jump *label320 notEqual *tmp511 false
-    * label *label315
  1186 jump *label327 always
-    * print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.2:occupied
-    * print ","
-    * print " free: "
-    * print :areUnitsAvailable.2:free
-    * jump *label329 lessThanEq :areUnitsAvailable.2:needed 0
-    * print ", needed: "
-    * print :areUnitsAvailable.2:needed
-    * label *label329
-    * print "\n"
  1187 label *label327
  1188 set *tmp487 false
  1189 label *label314
 
  1194 label *label312
  1195 sensor *tmp204 switch1 @enabled
  1196 jump *label363 notEqual *tmp204 false
-    * label *label149
  1197 end
  1198 label *label0
  1199 # "Function: noinline def locateCore(in type)"
 
  1208 label *label334
  1209 set :locateCore*retval .CORE
  1210 return :locateCore*retaddr
-    * end

Modifications by Jumps phase, Dead Code Elimination, pass 5, iteration 1 (-1 instructions):
 
   466 op sub *tmp136 .DOME_Y .CORE_Y
   467 op len *tmp137 *tmp135 *tmp136
   468 op mul *tmp138 2 *tmp137
-    * sensor *tmp139 .UNIT_S1 @speed
   469 op div :needsFourUnits.2:travel_time *tmp138 .SPEED
   470 op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
   471 jump *label113 equal *tmp134 false

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-1 instructions):
 
  1182 op equal *tmp510 *tmp509 0
  1183 op land *tmp511 *tmp508 *tmp510
  1184 jump *label320 notEqual *tmp511 false
-    * jump *label327 always
  1185 label *label327
  1186 set *tmp487 false
  1187 label *label314

Modifications by Jumps phase, Jump Straightening, pass 6, iteration 1 (-1 instructions):
 
    26 jump *label1 notEqual :locateCore*retval false
    27 set :locateCore:type @mono
    28 call *label0 :locateCore*retaddr :locateCore*retval
-    * jump *label1 notEqual :locateCore*retval false
-    * jump *label5 always
+   29 jump *label5 equal :locateCore*retval false
    30 label *label1
    31 sensor .CORE_X .CORE @x
    32 sensor .CORE_Y .CORE @y

Modifications by Final phase, Print Merging, iteration 1 (-75 instructions):
 
    35 sensor *tmp7 switch1 @enabled
    36 jump *label19 notEqual *tmp7 false
    37 label *label362
-    * print "[coral]Activate switch to begin supplying overdrive dome..."
-    * print "\n"
+   38 print "[coral]Activate switch to begin supplying overdrive dome...\n"
    39 printflush message1
    40 sensor *tmp7 switch1 @enabled
    41 jump *label362 equal *tmp7 false
 
    43 # "Function: inline def chooseUnitType()"
    44 label *label21
    45 printflush null
-    * print "[gold]Looking for suitable unit type:[]"
-    * print "\n"
+   46 print "[gold]Looking for suitable unit type:[]\n"
    47 # "Function: inline def areUnitsAvailable(in type, in output)"
    48 set :areUnitsAvailable:free 0
    49 set :areUnitsAvailable:occupied 0
 
    86 jump *label30 notEqual *tmp34 false
    87 label *label25
    88 print UNIT_TYPE
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable:occupied
-    * print ","
-    * print " free: "
+   89 print ": occupied: {0}, free: "
+   90 format :areUnitsAvailable:occupied
    91 print :areUnitsAvailable:free
    92 jump *label39 lessThanEq :areUnitsAvailable:needed 0
    93 print ", needed: "
 
   142 op land *tmp66 *tmp63 *tmp65
   143 jump *label367 notEqual *tmp66 false
   144 label *label374
-    * print @flare
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  145 print "flare: occupied: {0}, free: "
+  146 format :areUnitsAvailable.1:occupied
   147 print :areUnitsAvailable.1:free
   148 jump *label376 lessThanEq :areUnitsAvailable.1:needed 0
   149 print ", needed: "
 
   200 op land *tmp66 *tmp63 *tmp65
   201 jump *label391 notEqual *tmp66 false
   202 label *label398
-    * print @poly
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  203 print "poly: occupied: {0}, free: "
+  204 format :areUnitsAvailable.1:occupied
   205 print :areUnitsAvailable.1:free
   206 jump *label400 lessThanEq :areUnitsAvailable.1:needed 0
   207 print ", needed: "
 
   258 op land *tmp66 *tmp63 *tmp65
   259 jump *label415 notEqual *tmp66 false
   260 label *label422
-    * print @mega
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  261 print "mega: occupied: {0}, free: "
+  262 format :areUnitsAvailable.1:occupied
   263 print :areUnitsAvailable.1:free
   264 jump *label424 lessThanEq :areUnitsAvailable.1:needed 0
   265 print ", needed: "
 
   316 op land *tmp66 *tmp63 *tmp65
   317 jump *label439 notEqual *tmp66 false
   318 label *label446
-    * print @mono
-    * print ":"
-    * print " occupied: "
-    * print :areUnitsAvailable.1:occupied
-    * print ","
-    * print " free: "
+  319 print "mono: occupied: {0}, free: "
+  320 format :areUnitsAvailable.1:occupied
   321 print :areUnitsAvailable.1:free
   322 jump *label448 lessThanEq :areUnitsAvailable.1:needed 0
   323 print ", needed: "
 
   550 jump __start__ equal *tmp204 false
   551 label *label363
   552 set :start @time
-    * print " === [gold]Supplying Overdrive Dome[] === "
-    * print "\n"
-    * print "\n"
-    * print "Unit type: [green]"
-    * print *tmp9
-    * print "["
-    * print "]"
-    * print "\n"
+  553 print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
+  554 format *tmp9
   555 # "Function: inline void printDomeStatus(in item, in text)"
-    * print "\n[green]Silicon[] status:\n"
   556 sensor :printDomeStatus:level .DOME @silicon
   557 jump *label151 lessThanEq :printDomeStatus:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  558 print "  dome:  [green]{0}[]\n"
+  559 format :printDomeStatus:level
   560 jump *label152 always
   561 label *label151
-    * print "  dome:  [coral]"
-    * print :printDomeStatus:level
-    * print "["
-    * print "]"
-    * print "\n"
+  562 print "  dome:  [coral]{0}[]\n"
+  563 format :printDomeStatus:level
   564 label *label152
   565 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   566 # "Function: inline def rebindUnit(in currentUnit)"
 
   666 label *label180
   667 ucontrol flag :processUnit:state
   668 sensor *tmp268 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp268
-    * print "["
-    * print "]"
+  669 print "  {0}: [gold]{0}[]"
+  670 format .GROUP1
+  671 format *tmp268
   672 jump *label188 lessThan :processUnit:distance 0
   673 print .MSG
   674 print :processUnit:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  675 print "[] sec\n"
   676 jump *label189 always
   677 label *label188
   678 print .MSG
 
   785 label *label219
   786 ucontrol flag :processUnit.1:state
   787 sensor *tmp334 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp334
-    * print "["
-    * print "]"
+  788 print "  {0}: [gold]{0}[]"
+  789 format .GROUP2
+  790 format *tmp334
   791 jump *label227 lessThan :processUnit.1:distance 0
   792 print .MSG
   793 print :processUnit.1:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  794 print "[] sec\n"
   795 jump *label228 always
   796 label *label227
   797 print .MSG
 
   811 print "\n[green]Phase fabric[] status:\n"
   812 sensor :printDomeStatus.1:level .DOME @phase-fabric
   813 jump *label232 lessThanEq :printDomeStatus.1:level 3
-    * print "  dome:  [green]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  814 print "  dome:  [green]{0}[]\n"
+  815 format :printDomeStatus.1:level
   816 jump *label233 always
   817 label *label232
-    * print "  dome:  [coral]"
-    * print :printDomeStatus.1:level
-    * print "["
-    * print "]"
-    * print "\n"
+  818 print "  dome:  [coral]{0}[]\n"
+  819 format :printDomeStatus.1:level
   820 label *label233
   821 # "Function: inline void processUnit(in out unit, in item, in group, in supply)"
   822 # "Function: inline def rebindUnit(in currentUnit)"
 
   922 label *label261
   923 ucontrol flag :processUnit.2:state
   924 sensor *tmp406 @unit @totalItems
-    * print "  "
-    * print .GROUP1
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp406
-    * print "["
-    * print "]"
+  925 print "  {0}: [gold]{0}[]"
+  926 format .GROUP1
+  927 format *tmp406
   928 jump *label269 lessThan :processUnit.2:distance 0
   929 print .MSG
   930 print :processUnit.2:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+  931 print "[] sec\n"
   932 jump *label270 always
   933 label *label269
   934 print .MSG
 
  1041 label *label300
  1042 ucontrol flag :processUnit.3:state
  1043 sensor *tmp472 @unit @totalItems
-    * print "  "
-    * print .GROUP2
-    * print ":"
-    * print " ["
-    * print "gold"
-    * print "]"
-    * print *tmp472
-    * print "["
-    * print "]"
+ 1044 print "  {0}: [gold]{0}[]"
+ 1045 format .GROUP2
+ 1046 format *tmp472
  1047 jump *label308 lessThan :processUnit.3:distance 0
  1048 print .MSG
  1049 print :processUnit.3:distance
-    * print "["
-    * print "] sec"
-    * print "\n"
+ 1050 print "[] sec\n"
  1051 jump *label309 always
  1052 label *label308
  1053 print .MSG
 
  1065 label *label271
  1066 op sub *tmp481 @time :start
  1067 op floor *tmp482 *tmp481
-    * print "\n"
-    * print "[lightgray]Loop time: "
-    * print *tmp482
-    * print " "
-    * print "ms"
+ 1068 print "\n[lightgray]Loop time: {0} ms"
+ 1069 format *tmp482
  1070 printflush message1
  1071 op notEqual *tmp483 *tmp9 UNIT_TYPE
  1072 op greaterThan *tmp484 :unitCheck @time

Final code before resolving virtual instructions:

label __start__
remark "This is the preferred unit type to use for bringing in supplies."
remark "If no units of this type exist, we'll try using other types."
set UNIT_TYPE @flare
remark "Do not modify anything below this line."
# "Function: inline void locateDomeAndCore()"
set .DOME dome1
jump *label4 notEqual dome1 null
label *label336
print "[gold]Waiting for an overdrive dome to be connected..."
printflush message1
set .DOME dome1
jump *label336 equal dome1 null
label *label4
print "[gold]Locating core..."
printflush message1
set .CORE null
label *label5
set :locateCore:type @flare
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @poly
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @mega
call *label0 :locateCore*retaddr :locateCore*retval
jump *label1 notEqual :locateCore*retval false
set :locateCore:type @mono
call *label0 :locateCore*retaddr :locateCore*retval
jump *label5 equal :locateCore*retval false
label *label1
sensor .CORE_X .CORE @x
sensor .CORE_Y .CORE @y
sensor .DOME_X .DOME @x
sensor .DOME_Y .DOME @y
sensor *tmp7 switch1 @enabled
jump *label19 notEqual *tmp7 false
label *label362
print "[coral]Activate switch to begin supplying overdrive dome...\n"
printflush message1
sensor *tmp7 switch1 @enabled
jump *label362 equal *tmp7 false
label *label19
# "Function: inline def chooseUnitType()"
label *label21
printflush null
print "[gold]Looking for suitable unit type:[]\n"
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable:free 0
set :areUnitsAvailable:occupied 0
set :areUnitsAvailable:needed 0
ubind UNIT_TYPE
set :areUnitsAvailable:firstUnit @unit
jump *label25 equal :areUnitsAvailable:firstUnit null
set *tmp21 2
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits:unit @unit
op sub *tmp14 .DOME_X .CORE_X
op sub *tmp15 .DOME_Y .CORE_Y
op len *tmp16 *tmp14 *tmp15
op mul *tmp17 2 *tmp16
sensor *tmp18 :needsFourUnits:unit @speed
op div :needsFourUnits:travel_time *tmp17 *tmp18
jump *label29 lessThan :needsFourUnits:travel_time 47
set *tmp21 4
label *label29
set :areUnitsAvailable:needed *tmp21
label *label30
sensor *tmp22 @unit @controlled
op equal *tmp23 *tmp22 0
sensor *tmp24 @unit @controller
op equal *tmp25 *tmp24 @this
op or *tmp26 *tmp23 *tmp25
jump *label33 equal *tmp26 false
op add :areUnitsAvailable:free :areUnitsAvailable:free 1
jump *label34 lessThan :areUnitsAvailable:free *tmp21
set *tmp10 true
jump *label24 always
label *label33
op add :areUnitsAvailable:occupied :areUnitsAvailable:occupied 1
label *label34
ubind UNIT_TYPE
op notEqual *tmp31 @unit :areUnitsAvailable:firstUnit
sensor *tmp32 :areUnitsAvailable:firstUnit @dead
op equal *tmp33 *tmp32 0
op land *tmp34 *tmp31 *tmp33
jump *label30 notEqual *tmp34 false
label *label25
print UNIT_TYPE
print ": occupied: {0}, free: "
format :areUnitsAvailable:occupied
print :areUnitsAvailable:free
jump *label39 lessThanEq :areUnitsAvailable:needed 0
print ", needed: "
print :areUnitsAvailable:needed
label *label39
print "\n"
set *tmp10 false
label *label24
jump *label41 equal *tmp10 false
set *tmp9 UNIT_TYPE
jump *label20 always
label *label41
jump *label383 equal @flare UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @flare
set :areUnitsAvailable.1:firstUnit @unit
jump *label374 equal :areUnitsAvailable.1:firstUnit null
set *tmp53 2
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp46 .DOME_X .CORE_X
op sub *tmp47 .DOME_Y .CORE_Y
op len *tmp48 *tmp46 *tmp47
op mul *tmp49 2 *tmp48
sensor *tmp50 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp49 *tmp50
jump *label366 lessThan :needsFourUnits.1:travel_time 47
set *tmp53 4
label *label366
set :areUnitsAvailable.1:needed *tmp53
label *label367
sensor *tmp54 @unit @controlled
op equal *tmp55 *tmp54 0
sensor *tmp56 @unit @controller
op equal *tmp57 *tmp56 @this
op or *tmp58 *tmp55 *tmp57
jump *label370 equal *tmp58 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label371 lessThan :areUnitsAvailable.1:free *tmp53
set *tmp42 true
jump *label380 always
label *label370
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label371
ubind @flare
op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp65 *tmp64 0
op land *tmp66 *tmp63 *tmp65
jump *label367 notEqual *tmp66 false
label *label374
print "flare: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label376 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label376
print "\n"
set *tmp42 false
label *label380
jump *label381 equal *tmp42 false
printflush null
set *tmp9 @flare
jump *label20 always
label *label381
label *label383
jump *label407 equal @poly UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @poly
set :areUnitsAvailable.1:firstUnit @unit
jump *label398 equal :areUnitsAvailable.1:firstUnit null
set *tmp53 2
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp46 .DOME_X .CORE_X
op sub *tmp47 .DOME_Y .CORE_Y
op len *tmp48 *tmp46 *tmp47
op mul *tmp49 2 *tmp48
sensor *tmp50 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp49 *tmp50
jump *label390 lessThan :needsFourUnits.1:travel_time 47
set *tmp53 4
label *label390
set :areUnitsAvailable.1:needed *tmp53
label *label391
sensor *tmp54 @unit @controlled
op equal *tmp55 *tmp54 0
sensor *tmp56 @unit @controller
op equal *tmp57 *tmp56 @this
op or *tmp58 *tmp55 *tmp57
jump *label394 equal *tmp58 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label395 lessThan :areUnitsAvailable.1:free *tmp53
set *tmp42 true
jump *label404 always
label *label394
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label395
ubind @poly
op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp65 *tmp64 0
op land *tmp66 *tmp63 *tmp65
jump *label391 notEqual *tmp66 false
label *label398
print "poly: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label400 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label400
print "\n"
set *tmp42 false
label *label404
jump *label405 equal *tmp42 false
printflush null
set *tmp9 @poly
jump *label20 always
label *label405
label *label407
jump *label431 equal @mega UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mega
set :areUnitsAvailable.1:firstUnit @unit
jump *label422 equal :areUnitsAvailable.1:firstUnit null
set *tmp53 2
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp46 .DOME_X .CORE_X
op sub *tmp47 .DOME_Y .CORE_Y
op len *tmp48 *tmp46 *tmp47
op mul *tmp49 2 *tmp48
sensor *tmp50 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp49 *tmp50
jump *label414 lessThan :needsFourUnits.1:travel_time 47
set *tmp53 4
label *label414
set :areUnitsAvailable.1:needed *tmp53
label *label415
sensor *tmp54 @unit @controlled
op equal *tmp55 *tmp54 0
sensor *tmp56 @unit @controller
op equal *tmp57 *tmp56 @this
op or *tmp58 *tmp55 *tmp57
jump *label418 equal *tmp58 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label419 lessThan :areUnitsAvailable.1:free *tmp53
set *tmp42 true
jump *label428 always
label *label418
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label419
ubind @mega
op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp65 *tmp64 0
op land *tmp66 *tmp63 *tmp65
jump *label415 notEqual *tmp66 false
label *label422
print "mega: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label424 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label424
print "\n"
set *tmp42 false
label *label428
jump *label429 equal *tmp42 false
printflush null
set *tmp9 @mega
jump *label20 always
label *label429
label *label431
jump *label455 equal @mono UNIT_TYPE
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.1:free 0
set :areUnitsAvailable.1:occupied 0
set :areUnitsAvailable.1:needed 0
ubind @mono
set :areUnitsAvailable.1:firstUnit @unit
jump *label446 equal :areUnitsAvailable.1:firstUnit null
set *tmp53 2
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.1:unit @unit
op sub *tmp46 .DOME_X .CORE_X
op sub *tmp47 .DOME_Y .CORE_Y
op len *tmp48 *tmp46 *tmp47
op mul *tmp49 2 *tmp48
sensor *tmp50 :needsFourUnits.1:unit @speed
op div :needsFourUnits.1:travel_time *tmp49 *tmp50
jump *label438 lessThan :needsFourUnits.1:travel_time 47
set *tmp53 4
label *label438
set :areUnitsAvailable.1:needed *tmp53
label *label439
sensor *tmp54 @unit @controlled
op equal *tmp55 *tmp54 0
sensor *tmp56 @unit @controller
op equal *tmp57 *tmp56 @this
op or *tmp58 *tmp55 *tmp57
jump *label442 equal *tmp58 false
op add :areUnitsAvailable.1:free :areUnitsAvailable.1:free 1
jump *label443 lessThan :areUnitsAvailable.1:free *tmp53
set *tmp42 true
jump *label452 always
label *label442
op add :areUnitsAvailable.1:occupied :areUnitsAvailable.1:occupied 1
label *label443
ubind @mono
op notEqual *tmp63 @unit :areUnitsAvailable.1:firstUnit
sensor *tmp64 :areUnitsAvailable.1:firstUnit @dead
op equal *tmp65 *tmp64 0
op land *tmp66 *tmp63 *tmp65
jump *label439 notEqual *tmp66 false
label *label446
print "mono: occupied: {0}, free: "
format :areUnitsAvailable.1:occupied
print :areUnitsAvailable.1:free
jump *label448 lessThanEq :areUnitsAvailable.1:needed 0
print ", needed: "
print :areUnitsAvailable.1:needed
label *label448
print "\n"
set *tmp42 false
label *label452
jump *label453 equal *tmp42 false
printflush null
set *tmp9 @mono
jump *label20 always
label *label453
label *label455
printflush message1
jump *label21 always
label *label20
print "[gold]Binding units..."
printflush message1
# "Function: inline def rebindUnits()"
set .UNIT_P2 null
set .UNIT_S2 null
set .UNIT_P1 null
set .UNIT_S1 null
set :rebindUnits:count 0
ubind *tmp9
set :rebindUnits:firstUnit @unit
jump *label72 notEqual :rebindUnits:firstUnit null
end
label *label72
label *label74
sensor *tmp74 @unit @controller
jump *label77 notEqual *tmp74 @this
op add :rebindUnits:count :rebindUnits:count 1
ucontrol flag 1
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 .UNIT_S1
set .UNIT_S1 .UNIT_P1
set .UNIT_P1 @unit
jump *label76 notEqual .UNIT_S2 null
label *label77
ubind *tmp9
op notEqual *tmp81 @unit :rebindUnits:firstUnit
sensor *tmp82 :rebindUnits:firstUnit @dead
op equal *tmp83 *tmp82 0
op land *tmp84 *tmp81 *tmp83
jump *label74 notEqual *tmp84 false
label *label76
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label83 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp89 @unit @dead
op equal *tmp90 *tmp89 0
sensor *tmp91 @unit @controller
op equal *tmp92 *tmp91 @this
op land *tmp93 *tmp90 *tmp92
jump *label82 notEqual *tmp93 false
label *label83
ubind *tmp9
set :rebindUnit:firstUnit @unit
jump __start__ equal :rebindUnit:firstUnit null
label *label89
sensor *tmp97 @unit @controlled
jump *label82 equal *tmp97 0
ubind *tmp9
op notEqual *tmp100 @unit :rebindUnit:firstUnit
sensor *tmp101 :rebindUnit:firstUnit @dead
op equal *tmp102 *tmp101 0
op land *tmp103 *tmp100 *tmp102
jump *label89 notEqual *tmp103 false
end
label *label82
ucontrol flag 1
set *tmp85 @unit
set .UNIT_S1 *tmp85
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label96 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp108 @unit @dead
op equal *tmp109 *tmp108 0
sensor *tmp110 @unit @controller
op equal *tmp111 *tmp110 @this
op land *tmp112 *tmp109 *tmp111
jump *label95 notEqual *tmp112 false
label *label96
ubind *tmp9
set :rebindUnit.1:firstUnit @unit
jump __start__ equal :rebindUnit.1:firstUnit null
label *label102
sensor *tmp116 @unit @controlled
jump *label95 equal *tmp116 0
ubind *tmp9
op notEqual *tmp119 @unit :rebindUnit.1:firstUnit
sensor *tmp120 :rebindUnit.1:firstUnit @dead
op equal *tmp121 *tmp120 0
op land *tmp122 *tmp119 *tmp121
jump *label102 notEqual *tmp122 false
end
label *label95
ucontrol flag 1
set *tmp104 @unit
set .UNIT_P1 *tmp104
sensor *tmp123 *tmp85 @firstItem
op equal *tmp124 *tmp123 @phase-fabric
sensor *tmp125 *tmp104 @firstItem
op equal *tmp126 *tmp125 @silicon
op or *tmp127 *tmp124 *tmp126
jump *label107 equal *tmp127 false
# "Function: inline void swap(in out a, in out b)"
set .UNIT_S1 *tmp104
set .UNIT_P1 *tmp85
label *label107
sensor .UNIT_CAPACITY .UNIT_S1 @itemCapacity
sensor .SPEED .UNIT_S1 @speed
op div .SPEED_TENTHS .SPEED 10
op strictEqual *tmp132 .SPEED null
jump *label110 equal *tmp132 false
stop
label *label110
# "Function: inline def needsFourUnits(in unit)"
op sub *tmp135 .DOME_X .CORE_X
op sub *tmp136 .DOME_Y .CORE_Y
op len *tmp137 *tmp135 *tmp136
op mul *tmp138 2 *tmp137
op div :needsFourUnits.2:travel_time *tmp138 .SPEED
op greaterThanEq *tmp134 :needsFourUnits.2:travel_time 47
jump *label113 equal *tmp134 false
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label117 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp147 @unit @dead
op equal *tmp148 *tmp147 0
sensor *tmp149 @unit @controller
op equal *tmp150 *tmp149 @this
op land *tmp151 *tmp148 *tmp150
jump *label116 notEqual *tmp151 false
label *label117
ubind *tmp9
set :rebindUnit.2:firstUnit @unit
jump __start__ equal :rebindUnit.2:firstUnit null
label *label123
sensor *tmp155 @unit @controlled
jump *label116 equal *tmp155 0
ubind *tmp9
op notEqual *tmp158 @unit :rebindUnit.2:firstUnit
sensor *tmp159 :rebindUnit.2:firstUnit @dead
op equal *tmp160 *tmp159 0
op land *tmp161 *tmp158 *tmp160
jump *label123 notEqual *tmp161 false
end
label *label116
ucontrol flag 1
set *tmp143 @unit
set .UNIT_S2 *tmp143
# "Function: inline def acquireUnit(in currentUnit)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label130 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp166 @unit @dead
op equal *tmp167 *tmp166 0
sensor *tmp168 @unit @controller
op equal *tmp169 *tmp168 @this
op land *tmp170 *tmp167 *tmp169
jump *label129 notEqual *tmp170 false
label *label130
ubind *tmp9
set :rebindUnit.3:firstUnit @unit
jump __start__ equal :rebindUnit.3:firstUnit null
label *label136
sensor *tmp174 @unit @controlled
jump *label129 equal *tmp174 0
ubind *tmp9
op notEqual *tmp177 @unit :rebindUnit.3:firstUnit
sensor *tmp178 :rebindUnit.3:firstUnit @dead
op equal *tmp179 *tmp178 0
op land *tmp180 *tmp177 *tmp179
jump *label136 notEqual *tmp180 false
end
label *label129
ucontrol flag 1
set *tmp162 @unit
set .UNIT_P2 *tmp162
sensor *tmp181 .UNIT_S1 @firstItem
op equal *tmp182 *tmp181 @phase-fabric
sensor *tmp183 *tmp162 @firstItem
op notEqual *tmp184 *tmp183 @phase-fabric
op land *tmp185 *tmp182 *tmp184
jump *label141 equal *tmp185 false
# "Function: inline void swap(in out a, in out b)"
set :swap.1:t .UNIT_S1
set .UNIT_S1 *tmp162
set .UNIT_P2 :swap.1:t
label *label141
sensor *tmp187 *tmp143 @firstItem
op equal *tmp188 *tmp187 @phase-fabric
sensor *tmp189 .UNIT_P2 @firstItem
op equal *tmp190 *tmp189 @silicon
op or *tmp191 *tmp188 *tmp190
jump *label144 equal *tmp191 false
# "Function: inline void swap(in out a, in out b)"
set .UNIT_S2 .UNIT_P2
set .UNIT_P2 *tmp143
label *label144
set .GROUP1 "unit  1"
set .GROUP2 "unit 2"
jump *label114 always
label *label113
ubind .UNIT_S2
ucontrol unbind
set .UNIT_S2 null
ubind .UNIT_P2
ucontrol unbind
set .UNIT_P2 null
set .GROUP1 "unit"
label *label114
op equal *tmp193 *tmp134 false
sensor *tmp194 .UNIT_S1 @totalItems
sensor *tmp195 .UNIT_S2 @totalItems
op lessThan *tmp196 *tmp194 *tmp195
op or .SUPPLY_S_FIRST *tmp193 *tmp196
sensor *tmp199 .UNIT_P1 @totalItems
sensor *tmp200 .UNIT_P2 @totalItems
op lessThan *tmp201 *tmp199 *tmp200
op or .SUPPLY_P_FIRST *tmp193 *tmp201
op add :unitCheck @time 5000
sensor *tmp204 switch1 @enabled
jump __start__ equal *tmp204 false
label *label363
set :start @time
print " === [gold]Supplying Overdrive Dome[] === \n\nUnit type: [green]{0}[]\n\n[green]Silicon[] status:\n"
format *tmp9
# "Function: inline void printDomeStatus(in item, in text)"
sensor :printDomeStatus:level .DOME @silicon
jump *label151 lessThanEq :printDomeStatus:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus:level
jump *label152 always
label *label151
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus:level
label *label152
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label155 equal .UNIT_S1 null
ubind .UNIT_S1
sensor *tmp211 @unit @dead
op equal *tmp212 *tmp211 0
sensor *tmp213 @unit @controller
op equal *tmp214 *tmp213 @this
op land *tmp215 *tmp212 *tmp214
jump *label154 notEqual *tmp215 false
label *label155
ubind *tmp9
set :rebindUnit.4:firstUnit @unit
jump __start__ equal :rebindUnit.4:firstUnit null
label *label161
sensor *tmp219 @unit @controlled
jump *label154 equal *tmp219 0
ubind *tmp9
op notEqual *tmp222 @unit :rebindUnit.4:firstUnit
sensor *tmp223 :rebindUnit.4:firstUnit @dead
op equal *tmp224 *tmp223 0
op land *tmp225 *tmp222 *tmp224
jump *label161 notEqual *tmp225 false
end
label *label154
sensor :processUnit:state @unit @flag
set :processUnit:distance -1
op lessThan *tmp227 :processUnit:state 2
op greaterThan *tmp228 :processUnit:state 3
op or *tmp229 *tmp227 *tmp228
jump *label166 equal *tmp229 false
sensor *tmp231 @unit @firstItem
jump *label168 notEqual *tmp231 @silicon
set :processUnit:state 3
jump *label169 always
label *label168
sensor *tmp234 @unit @totalItems
jump *label170 notEqual *tmp234 0
set :processUnit:state 2
jump *label171 always
label *label170
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp237
jump *label172 equal *tmp237 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label172
label *label171
label *label169
label *label166
jump *label174 notEqual :processUnit:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp241
jump *label176 equal *tmp241 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp243 @unit @totalItems
jump *label178 lessThan *tmp243 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit:state 3
jump *label177 always
label *label178
set .MSG ", loading\n"
jump *label177 always
label *label176
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp246 @unit @x
op sub *tmp247 .CORE_X *tmp246
sensor *tmp248 @unit @y
op sub *tmp249 .CORE_Y *tmp248
op len *tmp250 *tmp247 *tmp249
op idiv *tmp251 *tmp250 .SPEED_TENTHS
op div :processUnit:distance *tmp251 10
label *label177
label *label174
jump *label180 notEqual :processUnit:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp255
jump *label182 equal *tmp255 false
jump *label184 equal .SUPPLY_S_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label185 always
label *label184
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label185
sensor *tmp258 @unit @totalItems
jump *label183 greaterThan *tmp258 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit:state 2
jump *label183 always
label *label182
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp261 @unit @x
op sub *tmp262 .DOME_X *tmp261
sensor *tmp263 @unit @y
op sub *tmp264 .DOME_Y *tmp263
op len *tmp265 *tmp262 *tmp264
op idiv *tmp266 *tmp265 .SPEED_TENTHS
op div :processUnit:distance *tmp266 10
label *label183
label *label180
ucontrol flag :processUnit:state
sensor *tmp268 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp268
jump *label188 lessThan :processUnit:distance 0
print .MSG
print :processUnit:distance
print "[] sec\n"
jump *label189 always
label *label188
print .MSG
label *label189
set :processUnit:unit @unit
set .UNIT_S1 :processUnit:unit
jump *label190 equal *tmp134 false
op equal *tmp273 .SUPPLY_S_FIRST false
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label194 equal .UNIT_S2 null
ubind .UNIT_S2
sensor *tmp277 @unit @dead
op equal *tmp278 *tmp277 0
sensor *tmp279 @unit @controller
op equal *tmp280 *tmp279 @this
op land *tmp281 *tmp278 *tmp280
jump *label193 notEqual *tmp281 false
label *label194
ubind *tmp9
set :rebindUnit.5:firstUnit @unit
jump __start__ equal :rebindUnit.5:firstUnit null
label *label200
sensor *tmp285 @unit @controlled
jump *label193 equal *tmp285 0
ubind *tmp9
op notEqual *tmp288 @unit :rebindUnit.5:firstUnit
sensor *tmp289 :rebindUnit.5:firstUnit @dead
op equal *tmp290 *tmp289 0
op land *tmp291 *tmp288 *tmp290
jump *label200 notEqual *tmp291 false
end
label *label193
sensor :processUnit.1:state @unit @flag
set :processUnit.1:distance -1
op lessThan *tmp293 :processUnit.1:state 2
op greaterThan *tmp294 :processUnit.1:state 3
op or *tmp295 *tmp293 *tmp294
jump *label205 equal *tmp295 false
sensor *tmp297 @unit @firstItem
jump *label207 notEqual *tmp297 @silicon
set :processUnit.1:state 3
jump *label208 always
label *label207
sensor *tmp300 @unit @totalItems
jump *label209 notEqual *tmp300 0
set :processUnit.1:state 2
jump *label210 always
label *label209
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp303
jump *label211 equal *tmp303 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label211
label *label210
label *label208
label *label205
jump *label213 notEqual :processUnit.1:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp307
jump *label215 equal *tmp307 false
ucontrol itemTake .CORE @silicon .UNIT_CAPACITY
sensor *tmp309 @unit @totalItems
jump *label217 lessThan *tmp309 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.1:state 3
jump *label216 always
label *label217
set .MSG ", loading\n"
jump *label216 always
label *label215
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp312 @unit @x
op sub *tmp313 .CORE_X *tmp312
sensor *tmp314 @unit @y
op sub *tmp315 .CORE_Y *tmp314
op len *tmp316 *tmp313 *tmp315
op idiv *tmp317 *tmp316 .SPEED_TENTHS
op div :processUnit.1:distance *tmp317 10
label *label216
label *label213
jump *label219 notEqual :processUnit.1:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp321
jump *label221 equal *tmp321 false
jump *label223 equal *tmp273 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label224 always
label *label223
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label224
sensor *tmp324 @unit @totalItems
jump *label222 greaterThan *tmp324 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.1:state 2
jump *label222 always
label *label221
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp327 @unit @x
op sub *tmp328 .DOME_X *tmp327
sensor *tmp329 @unit @y
op sub *tmp330 .DOME_Y *tmp329
op len *tmp331 *tmp328 *tmp330
op idiv *tmp332 *tmp331 .SPEED_TENTHS
op div :processUnit.1:distance *tmp332 10
label *label222
label *label219
ucontrol flag :processUnit.1:state
sensor *tmp334 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp334
jump *label227 lessThan :processUnit.1:distance 0
print .MSG
print :processUnit.1:distance
print "[] sec\n"
jump *label228 always
label *label227
print .MSG
label *label228
set :processUnit.1:unit @unit
set .UNIT_S2 :processUnit.1:unit
jump *label229 equal .SUPPLY_S_FIRST false
sensor *tmp339 :processUnit:unit @totalItems
op greaterThan .SUPPLY_S_FIRST *tmp339 0
jump *label230 always
label *label229
sensor *tmp341 :processUnit.1:unit @totalItems
op equal .SUPPLY_S_FIRST *tmp341 0
label *label230
label *label190
# "Function: inline void printDomeStatus(in item, in text)"
print "\n[green]Phase fabric[] status:\n"
sensor :printDomeStatus.1:level .DOME @phase-fabric
jump *label232 lessThanEq :printDomeStatus.1:level 3
print "  dome:  [green]{0}[]\n"
format :printDomeStatus.1:level
jump *label233 always
label *label232
print "  dome:  [coral]{0}[]\n"
format :printDomeStatus.1:level
label *label233
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label236 equal .UNIT_P1 null
ubind .UNIT_P1
sensor *tmp349 @unit @dead
op equal *tmp350 *tmp349 0
sensor *tmp351 @unit @controller
op equal *tmp352 *tmp351 @this
op land *tmp353 *tmp350 *tmp352
jump *label235 notEqual *tmp353 false
label *label236
ubind *tmp9
set :rebindUnit.6:firstUnit @unit
jump __start__ equal :rebindUnit.6:firstUnit null
label *label242
sensor *tmp357 @unit @controlled
jump *label235 equal *tmp357 0
ubind *tmp9
op notEqual *tmp360 @unit :rebindUnit.6:firstUnit
sensor *tmp361 :rebindUnit.6:firstUnit @dead
op equal *tmp362 *tmp361 0
op land *tmp363 *tmp360 *tmp362
jump *label242 notEqual *tmp363 false
end
label *label235
sensor :processUnit.2:state @unit @flag
set :processUnit.2:distance -1
op lessThan *tmp365 :processUnit.2:state 2
op greaterThan *tmp366 :processUnit.2:state 3
op or *tmp367 *tmp365 *tmp366
jump *label247 equal *tmp367 false
sensor *tmp369 @unit @firstItem
jump *label249 notEqual *tmp369 @phase-fabric
set :processUnit.2:state 3
jump *label250 always
label *label249
sensor *tmp372 @unit @totalItems
jump *label251 notEqual *tmp372 0
set :processUnit.2:state 2
jump *label252 always
label *label251
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp375
jump *label253 equal *tmp375 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label253
label *label252
label *label250
label *label247
jump *label255 notEqual :processUnit.2:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp379
jump *label257 equal *tmp379 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp381 @unit @totalItems
jump *label259 lessThan *tmp381 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.2:state 3
jump *label258 always
label *label259
set .MSG ", loading\n"
jump *label258 always
label *label257
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp384 @unit @x
op sub *tmp385 .CORE_X *tmp384
sensor *tmp386 @unit @y
op sub *tmp387 .CORE_Y *tmp386
op len *tmp388 *tmp385 *tmp387
op idiv *tmp389 *tmp388 .SPEED_TENTHS
op div :processUnit.2:distance *tmp389 10
label *label258
label *label255
jump *label261 notEqual :processUnit.2:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp393
jump *label263 equal *tmp393 false
jump *label265 equal .SUPPLY_P_FIRST false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label266 always
label *label265
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label266
sensor *tmp396 @unit @totalItems
jump *label264 greaterThan *tmp396 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.2:state 2
jump *label264 always
label *label263
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp399 @unit @x
op sub *tmp400 .DOME_X *tmp399
sensor *tmp401 @unit @y
op sub *tmp402 .DOME_Y *tmp401
op len *tmp403 *tmp400 *tmp402
op idiv *tmp404 *tmp403 .SPEED_TENTHS
op div :processUnit.2:distance *tmp404 10
label *label264
label *label261
ucontrol flag :processUnit.2:state
sensor *tmp406 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP1
format *tmp406
jump *label269 lessThan :processUnit.2:distance 0
print .MSG
print :processUnit.2:distance
print "[] sec\n"
jump *label270 always
label *label269
print .MSG
label *label270
set :processUnit.2:unit @unit
set .UNIT_P1 :processUnit.2:unit
jump *label271 equal *tmp134 false
op equal *tmp411 .SUPPLY_P_FIRST false
# "Function: inline void processUnit(in out unit, in item, in group, in supply)"
# "Function: inline def rebindUnit(in currentUnit)"
jump *label275 equal .UNIT_P2 null
ubind .UNIT_P2
sensor *tmp415 @unit @dead
op equal *tmp416 *tmp415 0
sensor *tmp417 @unit @controller
op equal *tmp418 *tmp417 @this
op land *tmp419 *tmp416 *tmp418
jump *label274 notEqual *tmp419 false
label *label275
ubind *tmp9
set :rebindUnit.7:firstUnit @unit
jump __start__ equal :rebindUnit.7:firstUnit null
label *label281
sensor *tmp423 @unit @controlled
jump *label274 equal *tmp423 0
ubind *tmp9
op notEqual *tmp426 @unit :rebindUnit.7:firstUnit
sensor *tmp427 :rebindUnit.7:firstUnit @dead
op equal *tmp428 *tmp427 0
op land *tmp429 *tmp426 *tmp428
jump *label281 notEqual *tmp429 false
end
label *label274
sensor :processUnit.3:state @unit @flag
set :processUnit.3:distance -1
op lessThan *tmp431 :processUnit.3:state 2
op greaterThan *tmp432 :processUnit.3:state 3
op or *tmp433 *tmp431 *tmp432
jump *label286 equal *tmp433 false
sensor *tmp435 @unit @firstItem
jump *label288 notEqual *tmp435 @phase-fabric
set :processUnit.3:state 3
jump *label289 always
label *label288
sensor *tmp438 @unit @totalItems
jump *label290 notEqual *tmp438 0
set :processUnit.3:state 2
jump *label291 always
label *label290
set .MSG ", initializing\n"
ucontrol approach .CORE_X .CORE_Y 6
ucontrol within .CORE_X .CORE_Y 8 *tmp441
jump *label292 equal *tmp441 false
ucontrol itemDrop .CORE .UNIT_CAPACITY
label *label292
label *label291
label *label289
label *label286
jump *label294 notEqual :processUnit.3:state 2
ucontrol within .CORE_X .CORE_Y 8 *tmp445
jump *label296 equal *tmp445 false
ucontrol itemTake .CORE @phase-fabric .UNIT_CAPACITY
sensor *tmp447 @unit @totalItems
jump *label298 lessThan *tmp447 .UNIT_CAPACITY
ucontrol approach .DOME_X .DOME_Y 6
set :processUnit.3:state 3
jump *label297 always
label *label298
set .MSG ", loading\n"
jump *label297 always
label *label296
ucontrol approach .CORE_X .CORE_Y 6
set .MSG ", fetching in [gold]"
sensor *tmp450 @unit @x
op sub *tmp451 .CORE_X *tmp450
sensor *tmp452 @unit @y
op sub *tmp453 .CORE_Y *tmp452
op len *tmp454 *tmp451 *tmp453
op idiv *tmp455 *tmp454 .SPEED_TENTHS
op div :processUnit.3:distance *tmp455 10
label *label297
label *label294
jump *label300 notEqual :processUnit.3:state 3
ucontrol within .DOME_X .DOME_Y 8 *tmp459
jump *label302 equal *tmp459 false
jump *label304 equal *tmp411 false
ucontrol itemDrop .DOME .UNIT_CAPACITY
set .MSG ", supplying\n"
jump *label305 always
label *label304
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", waiting\n"
label *label305
sensor *tmp462 @unit @totalItems
jump *label303 greaterThan *tmp462 0
ucontrol approach .CORE_X .CORE_Y 6
set :processUnit.3:state 2
jump *label303 always
label *label302
ucontrol approach .DOME_X .DOME_Y 6
set .MSG ", returning in [gold]"
sensor *tmp465 @unit @x
op sub *tmp466 .DOME_X *tmp465
sensor *tmp467 @unit @y
op sub *tmp468 .DOME_Y *tmp467
op len *tmp469 *tmp466 *tmp468
op idiv *tmp470 *tmp469 .SPEED_TENTHS
op div :processUnit.3:distance *tmp470 10
label *label303
label *label300
ucontrol flag :processUnit.3:state
sensor *tmp472 @unit @totalItems
print "  {0}: [gold]{0}[]"
format .GROUP2
format *tmp472
jump *label308 lessThan :processUnit.3:distance 0
print .MSG
print :processUnit.3:distance
print "[] sec\n"
jump *label309 always
label *label308
print .MSG
label *label309
set :processUnit.3:unit @unit
set .UNIT_P2 :processUnit.3:unit
jump *label310 equal .SUPPLY_P_FIRST false
sensor *tmp477 :processUnit.2:unit @totalItems
op greaterThan .SUPPLY_P_FIRST *tmp477 0
jump *label311 always
label *label310
sensor *tmp479 :processUnit.3:unit @totalItems
op equal .SUPPLY_P_FIRST *tmp479 0
label *label311
label *label271
op sub *tmp481 @time :start
op floor *tmp482 *tmp481
print "\n[lightgray]Loop time: {0} ms"
format *tmp482
printflush message1
op notEqual *tmp483 *tmp9 UNIT_TYPE
op greaterThan *tmp484 :unitCheck @time
op land *tmp485 *tmp483 *tmp484
jump *label312 equal *tmp485 false
# "Function: inline def areUnitsAvailable(in type, in output)"
set :areUnitsAvailable.2:free 0
set :areUnitsAvailable.2:occupied 0
ubind UNIT_TYPE
set :areUnitsAvailable.2:firstUnit @unit
jump *label327 equal :areUnitsAvailable.2:firstUnit null
set *tmp498 2
# "Function: inline def needsFourUnits(in unit)"
set :needsFourUnits.3:unit @unit
sensor *tmp495 :needsFourUnits.3:unit @speed
op div :needsFourUnits.3:travel_time *tmp138 *tmp495
jump *label319 lessThan :needsFourUnits.3:travel_time 47
set *tmp498 4
label *label319
label *label320
sensor *tmp499 @unit @controlled
op equal *tmp500 *tmp499 0
sensor *tmp501 @unit @controller
op equal *tmp502 *tmp501 @this
op or *tmp503 *tmp500 *tmp502
jump *label323 equal *tmp503 false
op add :areUnitsAvailable.2:free :areUnitsAvailable.2:free 1
jump *label324 lessThan :areUnitsAvailable.2:free *tmp498
set *tmp487 true
jump *label314 always
label *label323
op add :areUnitsAvailable.2:occupied :areUnitsAvailable.2:occupied 1
label *label324
ubind UNIT_TYPE
op notEqual *tmp508 @unit :areUnitsAvailable.2:firstUnit
sensor *tmp509 :areUnitsAvailable.2:firstUnit @dead
op equal *tmp510 *tmp509 0
op land *tmp511 *tmp508 *tmp510
jump *label320 notEqual *tmp511 false
label *label327
set *tmp487 false
label *label314
jump *label331 equal *tmp487 false
end
label *label331
op add :unitCheck @time 5000
label *label312
sensor *tmp204 switch1 @enabled
jump *label363 notEqual *tmp204 false
end
label *label0
# "Function: noinline def locateCore(in type)"
ubind :locateCore:type
sensor *tmp517 @unit @controlled
op equal *tmp518 *tmp517 0
sensor *tmp519 @unit @controller
op equal *tmp520 *tmp519 @this
op or *tmp521 *tmp518 *tmp520
jump *label334 equal *tmp521 false
ulocate building core false @copper 0 0 0 .CORE
label *label334
set :locateCore*retval .CORE
return :locateCore*retaddr
