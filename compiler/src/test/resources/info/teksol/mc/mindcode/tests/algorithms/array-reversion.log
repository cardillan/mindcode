   114 instructions before optimizations.
     2 instructions eliminated by Temp Variables Elimination (2 iterations).
    12 instructions eliminated by Dead Code Elimination (2 passes, 5 iterations).
     5 instructions eliminated by Jump Normalization (5 iterations).
     1 instructions eliminated by Jump Optimization (5 iterations).
     4 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
   201 instructions eliminated by Expression Optimization (3 iterations).
    54 instructions eliminated by Data Flow Optimization (4 passes, 35 iterations).
     1 instructions eliminated by Loop Optimization (3 iterations).
     1 loops improved by Loop Optimization.
   204 instructions added by Loop Unrolling (6 iterations).
     2 loops unrolled by Loop Unrolling.
     1 jump tables inlined by Array Optimization.
     4 instructions updated by Jump Threading.
    23 instructions eliminated by Unreachable Code Elimination (2 iterations).
     9 instructions eliminated by Print Merging.
     3 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 896):
    Unroll loop at line 6:5                                      size    +3, benefit      500.0, efficiency    166.667
  * Unroll iteration loop at line 18:5                           size   -39, benefit       69.0, efficiency   Infinity (-14 instructions)
    Inline write jump table of array 'array'                     size    -3, benefit       50.0, efficiency   Infinity
    Inline 'array' write access at line 7:9                      size   +17, benefit       50.0, efficiency      2.941

Pass 1: speed optimization selection (cost limit 910):
    Unroll loop at line 6:5                                      size    +3, benefit      500.0, efficiency    166.667
  * Inline write jump table of array 'array'                     size    -3, benefit       50.0, efficiency   Infinity (-3 instructions)
    Inline 'array' write access at line 7:9                      size   +17, benefit       50.0, efficiency      2.941

Pass 1: speed optimization selection (cost limit 913):
  * Unroll loop at line 6:5                                      size   -14, benefit      500.0, efficiency   Infinity (+186 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    79 op lessThan *tmp4 :reverse:count 0
    80 jump *label17 equal *tmp4 false
    81 jump *label6 always
-    * set *tmp5 null
    82 jump *label18 always
    83 label *label17
-    * set *tmp5 null
    84 label *label18
    85 set :reverse:t :reverse:i
    86 set :reverse:i :reverse:j

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-2 instructions):
     0 set :i 0
     1 label *label0
     2 jump *label2 greaterThanEq :i 10
-    * set *tmp0 :i
-    * writearr<regular> :i .array[] *tmp0
+    3 writearr<regular> :i .array[] :i
     4 label *label1
     5 op add :i :i 1
     6 jump *label0 always
     7 label *label2
-    * op idiv *tmp2 10 2
-    * set :reverse:count *tmp2
+    8 op idiv :reverse:count 10 2
     9 set :reverse:i .array*0
    10 set :reverse:j .array*9
    11 setaddr *tmp3 *label7

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-1 instructions):
 
    74 setaddr *tmp3 *label16
    75 label *label4
    76 op sub :reverse:count :reverse:count 1
-    * op lessThan *tmp4 :reverse:count 0
-    * jump *label17 equal *tmp4 false
+   77 jump *label17 greaterThanEq :reverse:count 0
    78 jump *label6 always
    79 jump *label18 always
    80 label *label17

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-1 instructions):
 
    76 op sub :reverse:count :reverse:count 1
    77 jump *label17 greaterThanEq :reverse:count 0
    78 jump *label6 always
-    * jump *label18 always
    79 label *label17
    80 label *label18
    81 set :reverse:t :reverse:i

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    12 jump *label4 always
    13 multilabel *label7 (m:marker0)
    14 set .array*0 :reverse:i
-    * set .array*9 :reverse:j
+   15 set .array*9 :reverse:t
    16 set :reverse:i .array*1
    17 set :reverse:j .array*8
    18 setaddr *tmp3 *label8
    19 jump *label4 always
    20 multilabel *label8 (m:marker0)
    21 set .array*1 :reverse:i
-    * set .array*8 :reverse:j
+   22 set .array*8 :reverse:t
    23 set :reverse:i .array*2
    24 set :reverse:j .array*7
    25 setaddr *tmp3 *label9
    26 jump *label4 always
    27 multilabel *label9 (m:marker0)
    28 set .array*2 :reverse:i
-    * set .array*7 :reverse:j
+   29 set .array*7 :reverse:t
    30 set :reverse:i .array*3
    31 set :reverse:j .array*6
    32 setaddr *tmp3 *label10
    33 jump *label4 always
    34 multilabel *label10 (m:marker0)
    35 set .array*3 :reverse:i
-    * set .array*6 :reverse:j
+   36 set .array*6 :reverse:t
    37 set :reverse:i .array*4
    38 set :reverse:j .array*5
    39 setaddr *tmp3 *label11
    40 jump *label4 always
    41 multilabel *label11 (m:marker0)
    42 set .array*4 :reverse:i
-    * set .array*5 :reverse:j
+   43 set .array*5 :reverse:t
    44 set :reverse:i .array*5
    45 set :reverse:j .array*4
    46 setaddr *tmp3 *label12
    47 jump *label4 always
    48 multilabel *label12 (m:marker0)
    49 set .array*5 :reverse:i
-    * set .array*4 :reverse:j
+   50 set .array*4 :reverse:t
    51 set :reverse:i .array*6
    52 set :reverse:j .array*3
    53 setaddr *tmp3 *label13
    54 jump *label4 always
    55 multilabel *label13 (m:marker0)
    56 set .array*6 :reverse:i
-    * set .array*3 :reverse:j
+   57 set .array*3 :reverse:t
    58 set :reverse:i .array*7
    59 set :reverse:j .array*2
    60 setaddr *tmp3 *label14
    61 jump *label4 always
    62 multilabel *label14 (m:marker0)
    63 set .array*7 :reverse:i
-    * set .array*2 :reverse:j
+   64 set .array*2 :reverse:t
    65 set :reverse:i .array*8
    66 set :reverse:j .array*1
    67 setaddr *tmp3 *label15
    68 jump *label4 always
    69 multilabel *label15 (m:marker0)
    70 set .array*8 :reverse:i
-    * set .array*1 :reverse:j
+   71 set .array*1 :reverse:t
    72 set :reverse:i .array*9
    73 set :reverse:j .array*0
    74 setaddr *tmp3 *label16
 
    85 multijump *tmp3 0 0 (m:marker0)
    86 multilabel *label16 (m:marker0)
    87 set .array*9 :reverse:i
-    * set .array*0 :reverse:j
+   88 set .array*0 :reverse:t
    89 label *label6
    90 label *label3
    91 assertflush

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    80 label *label18
    81 set :reverse:t :reverse:i
    82 set :reverse:i :reverse:j
-    * set :reverse:j :reverse:t
    83 label *label5
    84 multijump *tmp3 0 0 (m:marker0)
    85 multilabel *label16 (m:marker0)

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3:
 
    11 setaddr *tmp3 *label7
    12 jump *label4 always
    13 multilabel *label7 (m:marker0)
-    * set .array*0 :reverse:i
+   14 set .array*0 :reverse:j
    15 set .array*9 :reverse:t
    16 set :reverse:i .array*1
    17 set :reverse:j .array*8
    18 setaddr *tmp3 *label8
    19 jump *label4 always
    20 multilabel *label8 (m:marker0)
-    * set .array*1 :reverse:i
+   21 set .array*1 :reverse:j
    22 set .array*8 :reverse:t
    23 set :reverse:i .array*2
    24 set :reverse:j .array*7
    25 setaddr *tmp3 *label9
    26 jump *label4 always
    27 multilabel *label9 (m:marker0)
-    * set .array*2 :reverse:i
+   28 set .array*2 :reverse:j
    29 set .array*7 :reverse:t
    30 set :reverse:i .array*3
    31 set :reverse:j .array*6
    32 setaddr *tmp3 *label10
    33 jump *label4 always
    34 multilabel *label10 (m:marker0)
-    * set .array*3 :reverse:i
+   35 set .array*3 :reverse:j
    36 set .array*6 :reverse:t
    37 set :reverse:i .array*4
    38 set :reverse:j .array*5
    39 setaddr *tmp3 *label11
    40 jump *label4 always
    41 multilabel *label11 (m:marker0)
-    * set .array*4 :reverse:i
+   42 set .array*4 :reverse:j
    43 set .array*5 :reverse:t
    44 set :reverse:i .array*5
    45 set :reverse:j .array*4
    46 setaddr *tmp3 *label12
    47 jump *label4 always
    48 multilabel *label12 (m:marker0)
-    * set .array*5 :reverse:i
+   49 set .array*5 :reverse:j
    50 set .array*4 :reverse:t
    51 set :reverse:i .array*6
    52 set :reverse:j .array*3
    53 setaddr *tmp3 *label13
    54 jump *label4 always
    55 multilabel *label13 (m:marker0)
-    * set .array*6 :reverse:i
+   56 set .array*6 :reverse:j
    57 set .array*3 :reverse:t
    58 set :reverse:i .array*7
    59 set :reverse:j .array*2
    60 setaddr *tmp3 *label14
    61 jump *label4 always
    62 multilabel *label14 (m:marker0)
-    * set .array*7 :reverse:i
+   63 set .array*7 :reverse:j
    64 set .array*2 :reverse:t
    65 set :reverse:i .array*8
    66 set :reverse:j .array*1
    67 setaddr *tmp3 *label15
    68 jump *label4 always
    69 multilabel *label15 (m:marker0)
-    * set .array*8 :reverse:i
+   70 set .array*8 :reverse:j
    71 set .array*1 :reverse:t
    72 set :reverse:i .array*9
    73 set :reverse:j .array*0
 
    83 label *label5
    84 multijump *tmp3 0 0 (m:marker0)
    85 multilabel *label16 (m:marker0)
-    * set .array*9 :reverse:i
+   86 set .array*9 :reverse:j
    87 set .array*0 :reverse:t
    88 label *label6
    89 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-1 instructions):
 
    79 label *label17
    80 label *label18
    81 set :reverse:t :reverse:i
-    * set :reverse:i :reverse:j
    82 label *label5
    83 multijump *tmp3 0 0 (m:marker0)
    84 multilabel *label16 (m:marker0)

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 5:
 
    12 jump *label4 always
    13 multilabel *label7 (m:marker0)
    14 set .array*0 :reverse:j
-    * set .array*9 :reverse:t
+   15 set .array*9 :reverse:i
    16 set :reverse:i .array*1
    17 set :reverse:j .array*8
    18 setaddr *tmp3 *label8
    19 jump *label4 always
    20 multilabel *label8 (m:marker0)
    21 set .array*1 :reverse:j
-    * set .array*8 :reverse:t
+   22 set .array*8 :reverse:i
    23 set :reverse:i .array*2
    24 set :reverse:j .array*7
    25 setaddr *tmp3 *label9
    26 jump *label4 always
    27 multilabel *label9 (m:marker0)
    28 set .array*2 :reverse:j
-    * set .array*7 :reverse:t
+   29 set .array*7 :reverse:i
    30 set :reverse:i .array*3
    31 set :reverse:j .array*6
    32 setaddr *tmp3 *label10
    33 jump *label4 always
    34 multilabel *label10 (m:marker0)
    35 set .array*3 :reverse:j
-    * set .array*6 :reverse:t
+   36 set .array*6 :reverse:i
    37 set :reverse:i .array*4
    38 set :reverse:j .array*5
    39 setaddr *tmp3 *label11
    40 jump *label4 always
    41 multilabel *label11 (m:marker0)
    42 set .array*4 :reverse:j
-    * set .array*5 :reverse:t
+   43 set .array*5 :reverse:i
    44 set :reverse:i .array*5
    45 set :reverse:j .array*4
    46 setaddr *tmp3 *label12
    47 jump *label4 always
    48 multilabel *label12 (m:marker0)
    49 set .array*5 :reverse:j
-    * set .array*4 :reverse:t
+   50 set .array*4 :reverse:i
    51 set :reverse:i .array*6
    52 set :reverse:j .array*3
    53 setaddr *tmp3 *label13
    54 jump *label4 always
    55 multilabel *label13 (m:marker0)
    56 set .array*6 :reverse:j
-    * set .array*3 :reverse:t
+   57 set .array*3 :reverse:i
    58 set :reverse:i .array*7
    59 set :reverse:j .array*2
    60 setaddr *tmp3 *label14
    61 jump *label4 always
    62 multilabel *label14 (m:marker0)
    63 set .array*7 :reverse:j
-    * set .array*2 :reverse:t
+   64 set .array*2 :reverse:i
    65 set :reverse:i .array*8
    66 set :reverse:j .array*1
    67 setaddr *tmp3 *label15
    68 jump *label4 always
    69 multilabel *label15 (m:marker0)
    70 set .array*8 :reverse:j
-    * set .array*1 :reverse:t
+   71 set .array*1 :reverse:i
    72 set :reverse:i .array*9
    73 set :reverse:j .array*0
    74 setaddr *tmp3 *label16
 
    83 multijump *tmp3 0 0 (m:marker0)
    84 multilabel *label16 (m:marker0)
    85 set .array*9 :reverse:j
-    * set .array*0 :reverse:t
+   86 set .array*0 :reverse:i
    87 label *label6
    88 label *label3
    89 assertflush

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 6 (-1 instructions):
 
    78 jump *label6 always
    79 label *label17
    80 label *label18
-    * set :reverse:t :reverse:i
    81 label *label5
    82 multijump *tmp3 0 0 (m:marker0)
    83 multilabel *label16 (m:marker0)

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
     0 set :i 0
     1 label *label0
-    * jump *label2 greaterThanEq :i 10
+    2 label *label19
     3 writearr<regular> :i .array[] :i
     4 label *label1
     5 op add :i :i 1
-    * jump *label0 always
+    6 jump *label19 lessThan :i 10
     7 label *label2
     8 op idiv :reverse:count 10 2
     9 set :reverse:i .array*0

Modifications by Unroll iteration loop at line 18:5 (+7 instructions):
 
     6 jump *label19 lessThan :i 10
     7 label *label2
     8 op idiv :reverse:count 10 2
-    * set :reverse:i .array*0
-    * set :reverse:j .array*9
-    * setaddr *tmp3 *label7
-    * jump *label4 always
-    * multilabel *label7 (m:marker0)
-    * set .array*0 :reverse:j
-    * set .array*9 :reverse:i
-    * set :reverse:i .array*1
-    * set :reverse:j .array*8
-    * setaddr *tmp3 *label8
-    * jump *label4 always
-    * multilabel *label8 (m:marker0)
-    * set .array*1 :reverse:j
-    * set .array*8 :reverse:i
-    * set :reverse:i .array*2
-    * set :reverse:j .array*7
-    * setaddr *tmp3 *label9
-    * jump *label4 always
-    * multilabel *label9 (m:marker0)
-    * set .array*2 :reverse:j
-    * set .array*7 :reverse:i
-    * set :reverse:i .array*3
-    * set :reverse:j .array*6
-    * setaddr *tmp3 *label10
-    * jump *label4 always
-    * multilabel *label10 (m:marker0)
-    * set .array*3 :reverse:j
-    * set .array*6 :reverse:i
-    * set :reverse:i .array*4
-    * set :reverse:j .array*5
-    * setaddr *tmp3 *label11
-    * jump *label4 always
-    * multilabel *label11 (m:marker0)
-    * set .array*4 :reverse:j
-    * set .array*5 :reverse:i
-    * set :reverse:i .array*5
-    * set :reverse:j .array*4
-    * setaddr *tmp3 *label12
-    * jump *label4 always
-    * multilabel *label12 (m:marker0)
-    * set .array*5 :reverse:j
-    * set .array*4 :reverse:i
-    * set :reverse:i .array*6
-    * set :reverse:j .array*3
-    * setaddr *tmp3 *label13
-    * jump *label4 always
-    * multilabel *label13 (m:marker0)
-    * set .array*6 :reverse:j
-    * set .array*3 :reverse:i
-    * set :reverse:i .array*7
-    * set :reverse:j .array*2
-    * setaddr *tmp3 *label14
-    * jump *label4 always
-    * multilabel *label14 (m:marker0)
-    * set .array*7 :reverse:j
-    * set .array*2 :reverse:i
-    * set :reverse:i .array*8
-    * set :reverse:j .array*1
-    * setaddr *tmp3 *label15
-    * jump *label4 always
-    * multilabel *label15 (m:marker0)
-    * set .array*8 :reverse:j
-    * set .array*1 :reverse:i
-    * set :reverse:i .array*9
-    * set :reverse:j .array*0
-    * setaddr *tmp3 *label16
-    * label *label4
-    * op sub :reverse:count :reverse:count 1
-    * jump *label17 greaterThanEq :reverse:count 0
-    * jump *label6 always
-    * label *label17
-    * label *label18
-    * label *label5
-    * multijump *tmp3 0 0 (m:marker0)
-    * multilabel *label16 (m:marker0)
-    * set .array*9 :reverse:j
-    * set .array*0 :reverse:i
-    * label *label6
+    9 set :reverse:i .array*0
+   10 set :reverse:j .array*9
+   11 label *label20
+   12 op sub :reverse:count :reverse:count 1
+   13 jump *label21 greaterThanEq :reverse:count 0
+   14 jump *label6 always
+   15 label *label21
+   16 label *label22
+   17 label *label23
+   18 set .array*0 :reverse:j
+   19 set .array*9 :reverse:i
+   20 set :reverse:i .array*1
+   21 set :reverse:j .array*8
+   22 label *label26
+   23 op sub :reverse:count :reverse:count 1
+   24 jump *label27 greaterThanEq :reverse:count 0
+   25 jump *label6 always
+   26 label *label27
+   27 label *label28
+   28 label *label29
+   29 set .array*1 :reverse:j
+   30 set .array*8 :reverse:i
+   31 set :reverse:i .array*2
+   32 set :reverse:j .array*7
+   33 label *label32
+   34 op sub :reverse:count :reverse:count 1
+   35 jump *label33 greaterThanEq :reverse:count 0
+   36 jump *label6 always
+   37 label *label33
+   38 label *label34
+   39 label *label35
+   40 set .array*2 :reverse:j
+   41 set .array*7 :reverse:i
+   42 set :reverse:i .array*3
+   43 set :reverse:j .array*6
+   44 label *label38
+   45 op sub :reverse:count :reverse:count 1
+   46 jump *label39 greaterThanEq :reverse:count 0
+   47 jump *label6 always
+   48 label *label39
+   49 label *label40
+   50 label *label41
+   51 set .array*3 :reverse:j
+   52 set .array*6 :reverse:i
+   53 set :reverse:i .array*4
+   54 set :reverse:j .array*5
+   55 label *label44
+   56 op sub :reverse:count :reverse:count 1
+   57 jump *label45 greaterThanEq :reverse:count 0
+   58 jump *label6 always
+   59 label *label45
+   60 label *label46
+   61 label *label47
+   62 set .array*4 :reverse:j
+   63 set .array*5 :reverse:i
+   64 set :reverse:i .array*5
+   65 set :reverse:j .array*4
+   66 label *label50
+   67 op sub :reverse:count :reverse:count 1
+   68 jump *label51 greaterThanEq :reverse:count 0
+   69 jump *label6 always
+   70 label *label51
+   71 label *label52
+   72 label *label53
+   73 set .array*5 :reverse:j
+   74 set .array*4 :reverse:i
+   75 set :reverse:i .array*6
+   76 set :reverse:j .array*3
+   77 label *label56
+   78 op sub :reverse:count :reverse:count 1
+   79 jump *label57 greaterThanEq :reverse:count 0
+   80 jump *label6 always
+   81 label *label57
+   82 label *label58
+   83 label *label59
+   84 set .array*6 :reverse:j
+   85 set .array*3 :reverse:i
+   86 set :reverse:i .array*7
+   87 set :reverse:j .array*2
+   88 label *label62
+   89 op sub :reverse:count :reverse:count 1
+   90 jump *label63 greaterThanEq :reverse:count 0
+   91 jump *label6 always
+   92 label *label63
+   93 label *label64
+   94 label *label65
+   95 set .array*7 :reverse:j
+   96 set .array*2 :reverse:i
+   97 set :reverse:i .array*8
+   98 set :reverse:j .array*1
+   99 label *label68
+  100 op sub :reverse:count :reverse:count 1
+  101 jump *label69 greaterThanEq :reverse:count 0
+  102 jump *label6 always
+  103 label *label69
+  104 label *label70
+  105 label *label71
+  106 set .array*8 :reverse:j
+  107 set .array*1 :reverse:i
+  108 set :reverse:i .array*9
+  109 set :reverse:j .array*0
+  110 label *label74
+  111 op sub :reverse:count :reverse:count 1
+  112 jump *label75 greaterThanEq :reverse:count 0
+  113 jump *label6 always
+  114 label *label75
+  115 label *label76
+  116 label *label77
+  117 set .array*9 :reverse:j
+  118 set .array*0 :reverse:i
+  119 label *label6
   120 label *label3
   121 assertflush
   122 print .array*0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     9 set :reverse:i .array*0
    10 set :reverse:j .array*9
    11 label *label20
-    * op sub :reverse:count :reverse:count 1
-    * jump *label21 greaterThanEq :reverse:count 0
+   12 op sub :reverse:count 5 1
+   13 jump *label21 greaterThanEq 4 0
    14 jump *label6 always
    15 label *label21
    16 label *label22
    17 label *label23
-    * set .array*0 :reverse:j
+   18 set .array*0 .array*9
    19 set .array*9 :reverse:i
    20 set :reverse:i .array*1
    21 set :reverse:j .array*8
    22 label *label26
-    * op sub :reverse:count :reverse:count 1
-    * jump *label27 greaterThanEq :reverse:count 0
+   23 op sub :reverse:count 4 1
+   24 jump *label27 greaterThanEq 3 0
    25 jump *label6 always
    26 label *label27
    27 label *label28
    28 label *label29
-    * set .array*1 :reverse:j
+   29 set .array*1 .array*8
    30 set .array*8 :reverse:i
    31 set :reverse:i .array*2
    32 set :reverse:j .array*7
    33 label *label32
-    * op sub :reverse:count :reverse:count 1
-    * jump *label33 greaterThanEq :reverse:count 0
+   34 op sub :reverse:count 3 1
+   35 jump *label33 greaterThanEq 2 0
    36 jump *label6 always
    37 label *label33
    38 label *label34
    39 label *label35
-    * set .array*2 :reverse:j
+   40 set .array*2 .array*7
    41 set .array*7 :reverse:i
    42 set :reverse:i .array*3
    43 set :reverse:j .array*6
    44 label *label38
-    * op sub :reverse:count :reverse:count 1
-    * jump *label39 greaterThanEq :reverse:count 0
+   45 op sub :reverse:count 2 1
+   46 jump *label39 greaterThanEq 1 0
    47 jump *label6 always
    48 label *label39
    49 label *label40
    50 label *label41
-    * set .array*3 :reverse:j
+   51 set .array*3 .array*6
    52 set .array*6 :reverse:i
    53 set :reverse:i .array*4
    54 set :reverse:j .array*5
    55 label *label44
-    * op sub :reverse:count :reverse:count 1
-    * jump *label45 greaterThanEq :reverse:count 0
+   56 op sub :reverse:count 1 1
+   57 jump *label45 greaterThanEq 0 0
    58 jump *label6 always
    59 label *label45
    60 label *label46
    61 label *label47
-    * set .array*4 :reverse:j
+   62 set .array*4 .array*5
    63 set .array*5 :reverse:i
-    * set :reverse:i .array*5
-    * set :reverse:j .array*4
+   64 set :reverse:i :reverse:i
+   65 set :reverse:j :reverse:j
    66 label *label50
-    * op sub :reverse:count :reverse:count 1
-    * jump *label51 greaterThanEq :reverse:count 0
+   67 op sub :reverse:count 0 1
+   68 jump *label51 greaterThanEq -1 0
    69 jump *label6 always
    70 label *label51
    71 label *label52
    72 label *label53
-    * set .array*5 :reverse:j
+   73 set .array*5 .array*4
    74 set .array*4 :reverse:i
    75 set :reverse:i .array*6
    76 set :reverse:j .array*3
    77 label *label56
-    * op sub :reverse:count :reverse:count 1
-    * jump *label57 greaterThanEq :reverse:count 0
+   78 op sub :reverse:count -1 1
+   79 jump *label57 greaterThanEq -2 0
    80 jump *label6 always
    81 label *label57
    82 label *label58
    83 label *label59
-    * set .array*6 :reverse:j
+   84 set .array*6 .array*3
    85 set .array*3 :reverse:i
    86 set :reverse:i .array*7
    87 set :reverse:j .array*2
    88 label *label62
-    * op sub :reverse:count :reverse:count 1
-    * jump *label63 greaterThanEq :reverse:count 0
+   89 op sub :reverse:count -2 1
+   90 jump *label63 greaterThanEq -3 0
    91 jump *label6 always
    92 label *label63
    93 label *label64
    94 label *label65
-    * set .array*7 :reverse:j
+   95 set .array*7 .array*2
    96 set .array*2 :reverse:i
    97 set :reverse:i .array*8
    98 set :reverse:j .array*1
    99 label *label68
-    * op sub :reverse:count :reverse:count 1
-    * jump *label69 greaterThanEq :reverse:count 0
+  100 op sub :reverse:count -3 1
+  101 jump *label69 greaterThanEq -4 0
   102 jump *label6 always
   103 label *label69
   104 label *label70
   105 label *label71
-    * set .array*8 :reverse:j
+  106 set .array*8 .array*1
   107 set .array*1 :reverse:i
   108 set :reverse:i .array*9
   109 set :reverse:j .array*0
   110 label *label74
-    * op sub :reverse:count :reverse:count 1
-    * jump *label75 greaterThanEq :reverse:count 0
+  111 op sub :reverse:count -4 1
+  112 jump *label75 greaterThanEq -5 0
   113 jump *label6 always
   114 label *label75
   115 label *label76
   116 label *label77
-    * set .array*9 :reverse:j
+  117 set .array*9 .array*0
   118 set .array*0 :reverse:i
   119 label *label6
   120 label *label3

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-20 instructions):
 
     5 op add :i :i 1
     6 jump *label19 lessThan :i 10
     7 label *label2
-    * op idiv :reverse:count 10 2
     8 set :reverse:i .array*0
-    * set :reverse:j .array*9
     9 label *label20
-    * op sub :reverse:count 5 1
    10 jump *label21 greaterThanEq 4 0
    11 jump *label6 always
    12 label *label21
 
    15 set .array*0 .array*9
    16 set .array*9 :reverse:i
    17 set :reverse:i .array*1
-    * set :reverse:j .array*8
    18 label *label26
-    * op sub :reverse:count 4 1
    19 jump *label27 greaterThanEq 3 0
    20 jump *label6 always
    21 label *label27
 
    24 set .array*1 .array*8
    25 set .array*8 :reverse:i
    26 set :reverse:i .array*2
-    * set :reverse:j .array*7
    27 label *label32
-    * op sub :reverse:count 3 1
    28 jump *label33 greaterThanEq 2 0
    29 jump *label6 always
    30 label *label33
 
    33 set .array*2 .array*7
    34 set .array*7 :reverse:i
    35 set :reverse:i .array*3
-    * set :reverse:j .array*6
    36 label *label38
-    * op sub :reverse:count 2 1
    37 jump *label39 greaterThanEq 1 0
    38 jump *label6 always
    39 label *label39
 
    44 set :reverse:i .array*4
    45 set :reverse:j .array*5
    46 label *label44
-    * op sub :reverse:count 1 1
    47 jump *label45 greaterThanEq 0 0
    48 jump *label6 always
    49 label *label45
 
    52 set .array*4 .array*5
    53 set .array*5 :reverse:i
    54 set :reverse:i :reverse:i
-    * set :reverse:j :reverse:j
    55 label *label50
-    * op sub :reverse:count 0 1
    56 jump *label51 greaterThanEq -1 0
    57 jump *label6 always
    58 label *label51
 
    61 set .array*5 .array*4
    62 set .array*4 :reverse:i
    63 set :reverse:i .array*6
-    * set :reverse:j .array*3
    64 label *label56
-    * op sub :reverse:count -1 1
    65 jump *label57 greaterThanEq -2 0
    66 jump *label6 always
    67 label *label57
 
    70 set .array*6 .array*3
    71 set .array*3 :reverse:i
    72 set :reverse:i .array*7
-    * set :reverse:j .array*2
    73 label *label62
-    * op sub :reverse:count -2 1
    74 jump *label63 greaterThanEq -3 0
    75 jump *label6 always
    76 label *label63
 
    79 set .array*7 .array*2
    80 set .array*2 :reverse:i
    81 set :reverse:i .array*8
-    * set :reverse:j .array*1
    82 label *label68
-    * op sub :reverse:count -3 1
    83 jump *label69 greaterThanEq -4 0
    84 jump *label6 always
    85 label *label69
 
    88 set .array*8 .array*1
    89 set .array*1 :reverse:i
    90 set :reverse:i .array*9
-    * set :reverse:j .array*0
    91 label *label74
-    * op sub :reverse:count -4 1
    92 jump *label75 greaterThanEq -5 0
    93 jump *label6 always
    94 label *label75

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-1 instructions):
 
    42 set .array*3 .array*6
    43 set .array*6 :reverse:i
    44 set :reverse:i .array*4
-    * set :reverse:j .array*5
    45 label *label44
    46 jump *label45 greaterThanEq 0 0
    47 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-3 instructions):
     0 set :i 0
     1 label *label0
     2 label *label19
-    * writearr<regular> :i .array[] :i
+    3 writearr<inlined> :i .array[] :i
     4 label *label1
     5 op add :i :i 1
     6 jump *label19 lessThan :i 10

Modifications by Unroll loop at line 6:5 (+197 instructions):
-    * set :i 0
-    * label *label0
-    * label *label19
-    * writearr<inlined> :i .array[] :i
-    * label *label1
-    * op add :i :i 1
-    * jump *label19 lessThan :i 10
-    * label *label2
+    0 set :i 0
+    1 label *label81
+    2 label *label82
+    3 writearr<inlined> :i .array[] :i
+    4 label *label83
+    5 op add :i :i 1
+    6 label *label84
+    7 writearr<inlined> :i .array[] :i
+    8 label *label85
+    9 op add :i :i 1
+   10 label *label86
+   11 writearr<inlined> :i .array[] :i
+   12 label *label87
+   13 op add :i :i 1
+   14 label *label88
+   15 writearr<inlined> :i .array[] :i
+   16 label *label89
+   17 op add :i :i 1
+   18 label *label90
+   19 writearr<inlined> :i .array[] :i
+   20 label *label91
+   21 op add :i :i 1
+   22 label *label92
+   23 writearr<inlined> :i .array[] :i
+   24 label *label93
+   25 op add :i :i 1
+   26 label *label94
+   27 writearr<inlined> :i .array[] :i
+   28 label *label95
+   29 op add :i :i 1
+   30 label *label96
+   31 writearr<inlined> :i .array[] :i
+   32 label *label97
+   33 op add :i :i 1
+   34 label *label98
+   35 writearr<inlined> :i .array[] :i
+   36 label *label99
+   37 op add :i :i 1
+   38 label *label100
+   39 writearr<inlined> :i .array[] :i
+   40 label *label101
+   41 op add :i :i 1
+   42 label *label2
    43 set :reverse:i .array*0
    44 label *label20
    45 jump *label21 greaterThanEq 4 0

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set :i 0
     1 label *label81
     2 label *label82
-    * writearr<inlined> :i .array[] :i
+    3 writearr<inlined> 0 .array[] 0
     4 label *label83
-    * op add :i :i 1
+    5 op add :i 0 1
     6 label *label84
-    * writearr<inlined> :i .array[] :i
+    7 writearr<inlined> 1 .array[] 1
     8 label *label85
-    * op add :i :i 1
+    9 op add :i 1 1
    10 label *label86
-    * writearr<inlined> :i .array[] :i
+   11 writearr<inlined> 2 .array[] 2
    12 label *label87
-    * op add :i :i 1
+   13 op add :i 2 1
    14 label *label88
-    * writearr<inlined> :i .array[] :i
+   15 writearr<inlined> 3 .array[] 3
    16 label *label89
-    * op add :i :i 1
+   17 op add :i 3 1
    18 label *label90
-    * writearr<inlined> :i .array[] :i
+   19 writearr<inlined> 4 .array[] 4
    20 label *label91
-    * op add :i :i 1
+   21 op add :i 4 1
    22 label *label92
-    * writearr<inlined> :i .array[] :i
+   23 writearr<inlined> 5 .array[] 5
    24 label *label93
-    * op add :i :i 1
+   25 op add :i 5 1
    26 label *label94
-    * writearr<inlined> :i .array[] :i
+   27 writearr<inlined> 6 .array[] 6
    28 label *label95
-    * op add :i :i 1
+   29 op add :i 6 1
    30 label *label96
-    * writearr<inlined> :i .array[] :i
+   31 writearr<inlined> 7 .array[] 7
    32 label *label97
-    * op add :i :i 1
+   33 op add :i 7 1
    34 label *label98
-    * writearr<inlined> :i .array[] :i
+   35 writearr<inlined> 8 .array[] 8
    36 label *label99
-    * op add :i :i 1
+   37 op add :i 8 1
    38 label *label100
-    * writearr<inlined> :i .array[] :i
+   39 writearr<inlined> 9 .array[] 9
    40 label *label101
-    * op add :i :i 1
+   41 op add :i 9 1
    42 label *label2
    43 set :reverse:i .array*0
    44 label *label20

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-11 instructions):
-    * set :i 0
     0 label *label81
     1 label *label82
     2 writearr<inlined> 0 .array[] 0
     3 label *label83
-    * op add :i 0 1
     4 label *label84
     5 writearr<inlined> 1 .array[] 1
     6 label *label85
-    * op add :i 1 1
     7 label *label86
     8 writearr<inlined> 2 .array[] 2
     9 label *label87
-    * op add :i 2 1
    10 label *label88
    11 writearr<inlined> 3 .array[] 3
    12 label *label89
-    * op add :i 3 1
    13 label *label90
    14 writearr<inlined> 4 .array[] 4
    15 label *label91
-    * op add :i 4 1
    16 label *label92
    17 writearr<inlined> 5 .array[] 5
    18 label *label93
-    * op add :i 5 1
    19 label *label94
    20 writearr<inlined> 6 .array[] 6
    21 label *label95
-    * op add :i 6 1
    22 label *label96
    23 writearr<inlined> 7 .array[] 7
    24 label *label97
-    * op add :i 7 1
    25 label *label98
    26 writearr<inlined> 8 .array[] 8
    27 label *label99
-    * op add :i 8 1
    28 label *label100
    29 writearr<inlined> 9 .array[] 9
    30 label *label101
-    * op add :i 9 1
    31 label *label2
    32 set :reverse:i .array*0
    33 label *label20

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-5 instructions):
 
    31 label *label2
    32 set :reverse:i .array*0
    33 label *label20
-    * jump *label21 greaterThanEq 4 0
+   34 jump *label21 always
    35 jump *label6 always
    36 label *label21
    37 label *label22
 
    40 set .array*9 :reverse:i
    41 set :reverse:i .array*1
    42 label *label26
-    * jump *label27 greaterThanEq 3 0
+   43 jump *label27 always
    44 jump *label6 always
    45 label *label27
    46 label *label28
 
    49 set .array*8 :reverse:i
    50 set :reverse:i .array*2
    51 label *label32
-    * jump *label33 greaterThanEq 2 0
+   52 jump *label33 always
    53 jump *label6 always
    54 label *label33
    55 label *label34
 
    58 set .array*7 :reverse:i
    59 set :reverse:i .array*3
    60 label *label38
-    * jump *label39 greaterThanEq 1 0
+   61 jump *label39 always
    62 jump *label6 always
    63 label *label39
    64 label *label40
 
    67 set .array*6 :reverse:i
    68 set :reverse:i .array*4
    69 label *label44
-    * jump *label45 greaterThanEq 0 0
+   70 jump *label45 always
    71 jump *label6 always
    72 label *label45
    73 label *label46
 
    76 set .array*5 :reverse:i
    77 set :reverse:i :reverse:i
    78 label *label50
-    * jump *label51 greaterThanEq -1 0
    79 jump *label6 always
    80 label *label51
    81 label *label52
 
    84 set .array*4 :reverse:i
    85 set :reverse:i .array*6
    86 label *label56
-    * jump *label57 greaterThanEq -2 0
    87 jump *label6 always
    88 label *label57
    89 label *label58
 
    92 set .array*3 :reverse:i
    93 set :reverse:i .array*7
    94 label *label62
-    * jump *label63 greaterThanEq -3 0
    95 jump *label6 always
    96 label *label63
    97 label *label64
 
   100 set .array*2 :reverse:i
   101 set :reverse:i .array*8
   102 label *label68
-    * jump *label69 greaterThanEq -4 0
   103 jump *label6 always
   104 label *label69
   105 label *label70
 
   108 set .array*1 :reverse:i
   109 set :reverse:i .array*9
   110 label *label74
-    * jump *label75 greaterThanEq -5 0
   111 jump *label6 always
   112 label *label75
   113 label *label76

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1 (-201 instructions):
     0 label *label81
     1 label *label82
-    * writearr<inlined> 0 .array[] 0
+    2 set .array*0 0
     3 label *label83
     4 label *label84
-    * writearr<inlined> 1 .array[] 1
+    5 set .array*1 1
     6 label *label85
     7 label *label86
-    * writearr<inlined> 2 .array[] 2
+    8 set .array*2 2
     9 label *label87
    10 label *label88
-    * writearr<inlined> 3 .array[] 3
+   11 set .array*3 3
    12 label *label89
    13 label *label90
-    * writearr<inlined> 4 .array[] 4
+   14 set .array*4 4
    15 label *label91
    16 label *label92
-    * writearr<inlined> 5 .array[] 5
+   17 set .array*5 5
    18 label *label93
    19 label *label94
-    * writearr<inlined> 6 .array[] 6
+   20 set .array*6 6
    21 label *label95
    22 label *label96
-    * writearr<inlined> 7 .array[] 7
+   23 set .array*7 7
    24 label *label97
    25 label *label98
-    * writearr<inlined> 8 .array[] 8
+   26 set .array*8 8
    27 label *label99
    28 label *label100
-    * writearr<inlined> 9 .array[] 9
+   29 set .array*9 9
    30 label *label101
    31 label *label2
    32 set :reverse:i .array*0
 
    74 label *label47
    75 set .array*4 .array*5
    76 set .array*5 :reverse:i
-    * set :reverse:i :reverse:i
    77 label *label50
    78 jump *label6 always
    79 label *label51

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
     0 label *label81
     1 label *label82
-    * set .array*0 0
+    2 set :reverse:i 0
     3 label *label83
     4 label *label84
     5 set .array*1 1
 
    29 set .array*9 9
    30 label *label101
    31 label *label2
-    * set :reverse:i .array*0
    32 label *label20
    33 jump *label21 always
    34 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2 (-1 instructions):
 
    26 set .array*8 8
    27 label *label99
    28 label *label100
-    * set .array*9 9
+   29 set .array*0 9
    30 label *label101
    31 label *label2
    32 label *label20
 
    35 label *label21
    36 label *label22
    37 label *label23
-    * set .array*0 .array*9
    38 set .array*9 :reverse:i
    39 set :reverse:i .array*1
    40 label *label26

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 3 (-1 instructions):
     0 label *label81
     1 label *label82
-    * set :reverse:i 0
+    2 set .array*9 0
     3 label *label83
     4 label *label84
     5 set .array*1 1
 
    35 label *label21
    36 label *label22
    37 label *label23
-    * set .array*9 :reverse:i
    38 set :reverse:i .array*1
    39 label *label26
    40 jump *label27 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 4 (-1 instructions):
 
     2 set .array*9 0
     3 label *label83
     4 label *label84
-    * set .array*1 1
+    5 set :reverse:i 1
     6 label *label85
     7 label *label86
     8 set .array*2 2
 
    35 label *label21
    36 label *label22
    37 label *label23
-    * set :reverse:i .array*1
    38 label *label26
    39 jump *label27 always
    40 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 5 (-1 instructions):
 
    23 set .array*7 7
    24 label *label97
    25 label *label98
-    * set .array*8 8
+   26 set .array*1 8
    27 label *label99
    28 label *label100
    29 set .array*0 9
 
    41 label *label27
    42 label *label28
    43 label *label29
-    * set .array*1 .array*8
    44 set .array*8 :reverse:i
    45 set :reverse:i .array*2
    46 label *label32

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 6 (-1 instructions):
 
     2 set .array*9 0
     3 label *label83
     4 label *label84
-    * set :reverse:i 1
+    5 set .array*8 1
     6 label *label85
     7 label *label86
     8 set .array*2 2
 
    41 label *label27
    42 label *label28
    43 label *label29
-    * set .array*8 :reverse:i
    44 set :reverse:i .array*2
    45 label *label32
    46 jump *label33 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 7 (-1 instructions):
 
     5 set .array*8 1
     6 label *label85
     7 label *label86
-    * set .array*2 2
+    8 set :reverse:i 2
     9 label *label87
    10 label *label88
    11 set .array*3 3
 
    41 label *label27
    42 label *label28
    43 label *label29
-    * set :reverse:i .array*2
    44 label *label32
    45 jump *label33 always
    46 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 8 (-1 instructions):
 
    20 set .array*6 6
    21 label *label95
    22 label *label96
-    * set .array*7 7
+   23 set .array*2 7
    24 label *label97
    25 label *label98
    26 set .array*1 8
 
    47 label *label33
    48 label *label34
    49 label *label35
-    * set .array*2 .array*7
    50 set .array*7 :reverse:i
    51 set :reverse:i .array*3
    52 label *label38

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 9 (-1 instructions):
 
     5 set .array*8 1
     6 label *label85
     7 label *label86
-    * set :reverse:i 2
+    8 set .array*7 2
     9 label *label87
    10 label *label88
    11 set .array*3 3
 
    47 label *label33
    48 label *label34
    49 label *label35
-    * set .array*7 :reverse:i
    50 set :reverse:i .array*3
    51 label *label38
    52 jump *label39 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 10 (-1 instructions):
 
     8 set .array*7 2
     9 label *label87
    10 label *label88
-    * set .array*3 3
+   11 set :reverse:i 3
    12 label *label89
    13 label *label90
    14 set .array*4 4
 
    47 label *label33
    48 label *label34
    49 label *label35
-    * set :reverse:i .array*3
    50 label *label38
    51 jump *label39 always
    52 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 11 (-1 instructions):
 
    17 set .array*5 5
    18 label *label93
    19 label *label94
-    * set .array*6 6
+   20 set .array*3 6
    21 label *label95
    22 label *label96
    23 set .array*2 7
 
    53 label *label39
    54 label *label40
    55 label *label41
-    * set .array*3 .array*6
    56 set .array*6 :reverse:i
    57 set :reverse:i .array*4
    58 label *label44

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 12 (-1 instructions):
 
     8 set .array*7 2
     9 label *label87
    10 label *label88
-    * set :reverse:i 3
+   11 set .array*6 3
    12 label *label89
    13 label *label90
    14 set .array*4 4
 
    53 label *label39
    54 label *label40
    55 label *label41
-    * set .array*6 :reverse:i
    56 set :reverse:i .array*4
    57 label *label44
    58 jump *label45 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 13 (-1 instructions):
 
    11 set .array*6 3
    12 label *label89
    13 label *label90
-    * set .array*4 4
+   14 set :reverse:i 4
    15 label *label91
    16 label *label92
    17 set .array*5 5
 
    53 label *label39
    54 label *label40
    55 label *label41
-    * set :reverse:i .array*4
    56 label *label44
    57 jump *label45 always
    58 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 14 (-1 instructions):
 
    14 set :reverse:i 4
    15 label *label91
    16 label *label92
-    * set .array*5 5
+   17 set .array*4 5
    18 label *label93
    19 label *label94
    20 set .array*3 6
 
    59 label *label45
    60 label *label46
    61 label *label47
-    * set .array*4 .array*5
    62 set .array*5 :reverse:i
    63 label *label50
    64 jump *label6 always

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 15:
 
    59 label *label45
    60 label *label46
    61 label *label47
-    * set .array*5 :reverse:i
+   62 set .array*5 4
    63 label *label50
    64 jump *label6 always
    65 label *label51
    66 label *label52
    67 label *label53
-    * set .array*5 .array*4
-    * set .array*4 :reverse:i
-    * set :reverse:i .array*6
+   68 set .array*5 5
+   69 set .array*4 4
+   70 set :reverse:i 3
    71 label *label56
    72 jump *label6 always
    73 label *label57
    74 label *label58
    75 label *label59
-    * set .array*6 .array*3
+   76 set .array*6 6
    77 set .array*3 :reverse:i
-    * set :reverse:i .array*7
+   78 set :reverse:i 2
    79 label *label62
    80 jump *label6 always
    81 label *label63
    82 label *label64
    83 label *label65
-    * set .array*7 .array*2
+   84 set .array*7 7
    85 set .array*2 :reverse:i
-    * set :reverse:i .array*8
+   86 set :reverse:i 1
    87 label *label68
    88 jump *label6 always
    89 label *label69
    90 label *label70
    91 label *label71
-    * set .array*8 .array*1
+   92 set .array*8 8
    93 set .array*1 :reverse:i
-    * set :reverse:i .array*9
+   94 set :reverse:i 0
    95 label *label74
    96 jump *label6 always
    97 label *label75
    98 label *label76
    99 label *label77
-    * set .array*9 .array*0
+  100 set .array*9 9
   101 set .array*0 :reverse:i
   102 label *label6
   103 label *label3
   104 assertflush
-    * print .array*0
-    * print .array*1
-    * print .array*2
-    * print .array*3
-    * print .array*4
-    * print .array*5
-    * print .array*6
-    * print .array*7
-    * print .array*8
-    * print .array*9
+  105 print 9
+  106 print 8
+  107 print 7
+  108 print 6
+  109 print 5
+  110 print :reverse:i
+  111 print 3
+  112 print 2
+  113 print 1
+  114 print 0
   115 assertprints "9876543210" "reverse array"
   116 end

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 16 (-4 instructions):
 
    67 label *label53
    68 set .array*5 5
    69 set .array*4 4
-    * set :reverse:i 3
+   70 set .array*3 3
    71 label *label56
    72 jump *label6 always
    73 label *label57
    74 label *label58
    75 label *label59
    76 set .array*6 6
-    * set .array*3 :reverse:i
-    * set :reverse:i 2
+   77 set .array*2 2
    78 label *label62
    79 jump *label6 always
    80 label *label63
    81 label *label64
    82 label *label65
    83 set .array*7 7
-    * set .array*2 :reverse:i
-    * set :reverse:i 1
+   84 set .array*1 1
    85 label *label68
    86 jump *label6 always
    87 label *label69
    88 label *label70
    89 label *label71
    90 set .array*8 8
-    * set .array*1 :reverse:i
-    * set :reverse:i 0
+   91 set .array*0 0
    92 label *label74
    93 jump *label6 always
    94 label *label75
    95 label *label76
    96 label *label77
    97 set .array*9 9
-    * set .array*0 :reverse:i
    98 label *label6
    99 label *label3
   100 assertflush

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 17:
 
   103 print 7
   104 print 6
   105 print 5
-    * print :reverse:i
+  106 print 4
   107 print 3
   108 print 2
   109 print 1

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 18 (-1 instructions):
 
    11 set .array*6 3
    12 label *label89
    13 label *label90
-    * set :reverse:i 4
    14 label *label91
    15 label *label92
    16 set .array*4 5

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
-    * label *label81
-    * label *label82
     0 set .array*9 0
-    * label *label83
-    * label *label84
     1 set .array*8 1
-    * label *label85
-    * label *label86
     2 set .array*7 2
-    * label *label87
-    * label *label88
     3 set .array*6 3
-    * label *label89
-    * label *label90
-    * label *label91
-    * label *label92
     4 set .array*4 5
-    * label *label93
-    * label *label94
     5 set .array*3 6
-    * label *label95
-    * label *label96
     6 set .array*2 7
-    * label *label97
-    * label *label98
     7 set .array*1 8
-    * label *label99
-    * label *label100
     8 set .array*0 9
-    * label *label101
-    * label *label2
-    * label *label20
     9 jump *label21 always
    10 jump *label6 always
    11 label *label21
-    * label *label22
-    * label *label23
-    * label *label26
    12 jump *label27 always
    13 jump *label6 always
    14 label *label27
-    * label *label28
-    * label *label29
-    * label *label32
    15 jump *label33 always
    16 jump *label6 always
    17 label *label33
-    * label *label34
-    * label *label35
-    * label *label38
    18 jump *label39 always
    19 jump *label6 always
    20 label *label39
-    * label *label40
-    * label *label41
-    * label *label44
    21 jump *label45 always
    22 jump *label6 always
    23 label *label45
-    * label *label46
-    * label *label47
    24 set .array*5 4
-    * label *label50
    25 jump *label6 always
-    * label *label51
-    * label *label52
-    * label *label53
    26 set .array*5 5
    27 set .array*4 4
    28 set .array*3 3
-    * label *label56
    29 jump *label6 always
-    * label *label57
-    * label *label58
-    * label *label59
    30 set .array*6 6
    31 set .array*2 2
-    * label *label62
    32 jump *label6 always
-    * label *label63
-    * label *label64
-    * label *label65
    33 set .array*7 7
    34 set .array*1 1
-    * label *label68
    35 jump *label6 always
-    * label *label69
-    * label *label70
-    * label *label71
    36 set .array*8 8
    37 set .array*0 0
-    * label *label74
    38 jump *label6 always
-    * label *label75
-    * label *label76
-    * label *label77
    39 set .array*9 9
    40 label *label6
-    * label *label3
    41 assertflush
    42 print 9
    43 print 8

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
     6 set .array*2 7
     7 set .array*1 8
     8 set .array*0 9
-    * jump *label21 always
+    9 jump *label45 always
    10 jump *label6 always
    11 label *label21
-    * jump *label27 always
+   12 jump *label45 always
    13 jump *label6 always
    14 label *label27
-    * jump *label33 always
+   15 jump *label45 always
    16 jump *label6 always
    17 label *label33
-    * jump *label39 always
+   18 jump *label45 always
    19 jump *label6 always
    20 label *label39
    21 jump *label45 always

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-23 instructions):
 
     7 set .array*1 8
     8 set .array*0 9
     9 jump *label45 always
-    * jump *label6 always
-    * label *label21
-    * jump *label45 always
-    * jump *label6 always
-    * label *label27
-    * jump *label45 always
-    * jump *label6 always
-    * label *label33
-    * jump *label45 always
-    * jump *label6 always
-    * label *label39
-    * jump *label45 always
-    * jump *label6 always
    10 label *label45
    11 set .array*5 4
    12 jump *label6 always
-    * set .array*5 5
-    * set .array*4 4
-    * set .array*3 3
-    * jump *label6 always
-    * set .array*6 6
-    * set .array*2 2
-    * jump *label6 always
-    * set .array*7 7
-    * set .array*1 1
-    * jump *label6 always
-    * set .array*8 8
-    * set .array*0 0
-    * jump *label6 always
-    * set .array*9 9
    13 label *label6
    14 assertflush
    15 print 9

Modifications by Jumps phase, Dead Code Elimination, pass 4, iteration 1 (-10 instructions):
-    * set .array*9 0
-    * set .array*8 1
-    * set .array*7 2
-    * set .array*6 3
-    * set .array*4 5
-    * set .array*3 6
-    * set .array*2 7
-    * set .array*1 8
-    * set .array*0 9
     0 jump *label45 always
     1 label *label45
-    * set .array*5 4
     2 jump *label6 always
     3 label *label6
     4 assertflush

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-3 instructions):
-    * jump *label45 always
     0 label *label45
-    * jump *label6 always
     1 label *label6
     2 assertflush
     3 print 9
 
    11 print 1
    12 print 0
    13 assertprints "9876543210" "reverse array"
-    * end

Modifications by Jumps phase, Jump Normalization, pass 5, iteration 1:
-    * label *label45
-    * label *label6
     0 assertflush
     1 print 9
     2 print 8

Modifications by Final phase, Print Merging, iteration 1 (-9 instructions):
     0 assertflush
-    * print 9
-    * print 8
-    * print 7
-    * print 6
-    * print 5
-    * print 4
-    * print 3
-    * print 2
-    * print 1
-    * print 0
+    1 print "9876543210"
     2 assertprints "9876543210" "reverse array"

Final code before resolving virtual instructions:

assertflush
print "9876543210"
assertprints "9876543210" "reverse array"
