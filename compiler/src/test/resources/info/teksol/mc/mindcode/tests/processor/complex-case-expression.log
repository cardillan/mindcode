    70 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (6 iterations).
     1 instructions eliminated by Case Expression Optimization.
     1 instructions eliminated by Dead Code Elimination (5 iterations).
     3 instructions eliminated by Data Flow Optimization (2 passes, 6 iterations).
     1 instructions modified by Loop Optimization (3 iterations).
     1 loops improved by Loop Optimization.
     7 instructions eliminated by Jump Straightening (3 passes, 6 iterations).
     1 instructions updated by Jump Threading.
     3 instructions eliminated by Unreachable Code Elimination (3 iterations).
    49 instructions after optimizations.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    12 set :test:i *tmp1
    13 label *label4
    14 jump *label6 greaterThan :test:i *tmp3
-    * set *tmp5 :test:i
    15 set :d:n 1
    16 setaddr :d*retaddr *label10 (h:*label10)
    17 call *label0 *invalid :d*retval (m:*label10) (h:*label10)
    18 label *label10
    19 set *tmp6 :d*retval
-    * jump *label9 equal *tmp5 *tmp6
+   20 jump *label9 equal :test:i *tmp6
    21 jump *label8 always
    22 label *label9
    23 set *tmp4 "A"
 
    28 call *label0 *invalid :d*retval (m:*label13) (h:*label13)
    29 label *label13
    30 set *tmp7 :d*retval
-    * jump *label12 equal *tmp5 *tmp7
+   31 jump *label12 equal :test:i *tmp7
    32 set :d:n 3
    33 setaddr :d*retaddr *label14 (h:*label14)
    34 call *label0 *invalid :d*retval (m:*label14) (h:*label14)
    35 label *label14
    36 set *tmp8 :d*retval
-    * jump *label12 equal *tmp5 *tmp8
-    * jump *label12 equal *tmp5 4
+   37 jump *label12 equal :test:i *tmp8
+   38 jump *label12 equal :test:i 4
    39 jump *label11 always
    40 label *label12
    41 set *tmp4 "B"
    42 jump *label7 always
    43 label *label11
-    * jump *label16 equal *tmp5 5
+   44 jump *label16 equal :test:i 5
    45 jump *label15 always
    46 label *label16
    47 jump *label5 always
 
    53 call *label0 *invalid :d*retval (m:*label20) (h:*label20)
    54 label *label20
    55 set *tmp9 :d*retval
-    * jump *label19 lessThan *tmp5 *tmp9
+   56 jump *label19 lessThan :test:i *tmp9
    57 set :d:n 8
    58 setaddr :d*retaddr *label21 (h:*label21)
    59 call *label0 *invalid :d*retval (m:*label21) (h:*label21)
    60 label *label21
    61 set *tmp10 :d*retval
-    * jump *label18 lessThanEq *tmp5 *tmp10
+   62 jump *label18 lessThanEq :test:i *tmp10
    63 label *label19
    64 jump *label17 always
    65 label *label18
    66 set *tmp4 "C"
    67 jump *label7 always
    68 label *label17
-    * jump *label23 equal *tmp5 10
+   69 jump *label23 equal :test:i 10
    70 jump *label22 always
    71 label *label23
    72 jump *label6 always

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-1 instructions):
 
    81 op add :test:i :test:i 1
    82 jump *label4 always
    83 label *label6
-    * set *tmp0 null
    84 label *label1
    85 assertprints "ABBBCCCD" "complex-case-expression"
    86 stop

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
     7 setaddr :d*retaddr *label3 (h:*label3)
     8 call *label0 *invalid :d*retval (m:*label3) (h:*label3)
     9 label *label3
-    * set *tmp2 :d*retval
-    * set *tmp3 *tmp2
+   10 set *tmp3 :d*retval
    11 set :test:i *tmp1
    12 label *label4
    13 jump *label6 greaterThan :test:i *tmp3
 
    15 setaddr :d*retaddr *label10 (h:*label10)
    16 call *label0 *invalid :d*retval (m:*label10) (h:*label10)
    17 label *label10
-    * set *tmp6 :d*retval
-    * jump *label9 equal :test:i *tmp6
+   18 jump *label9 equal :test:i :d*retval
    19 jump *label8 always
    20 label *label9
    21 set *tmp4 "A"
 
    25 setaddr :d*retaddr *label13 (h:*label13)
    26 call *label0 *invalid :d*retval (m:*label13) (h:*label13)
    27 label *label13
-    * set *tmp7 :d*retval
-    * jump *label12 equal :test:i *tmp7
+   28 jump *label12 equal :test:i :d*retval
    29 set :d:n 3
    30 setaddr :d*retaddr *label14 (h:*label14)
    31 call *label0 *invalid :d*retval (m:*label14) (h:*label14)
    32 label *label14
-    * set *tmp8 :d*retval
-    * jump *label12 equal :test:i *tmp8
+   33 jump *label12 equal :test:i :d*retval
    34 jump *label12 equal :test:i 4
    35 jump *label11 always
    36 label *label12
 
    48 setaddr :d*retaddr *label20 (h:*label20)
    49 call *label0 *invalid :d*retval (m:*label20) (h:*label20)
    50 label *label20
-    * set *tmp9 :d*retval
-    * jump *label19 lessThan :test:i *tmp9
+   51 jump *label19 lessThan :test:i :d*retval
    52 set :d:n 8
    53 setaddr :d*retaddr *label21 (h:*label21)
    54 call *label0 *invalid :d*retval (m:*label21) (h:*label21)
    55 label *label21
-    * set *tmp10 :d*retval
-    * jump *label18 lessThanEq :test:i *tmp10
+   56 jump *label18 lessThanEq :test:i :d*retval
    57 label *label19
    58 jump *label17 always
    59 label *label18

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-3 instructions):
 
    31 call *label0 *invalid :d*retval (m:*label14) (h:*label14)
    32 label *label14
    33 jump *label12 equal :test:i :d*retval
-    * jump *label12 equal :test:i 4
-    * jump *label11 always
+   34 jump *label11 notEqual :test:i 4
    35 label *label12
    36 set *tmp4 "B"
    37 jump *label7 always
    38 label *label11
-    * jump *label16 equal :test:i 5
-    * jump *label15 always
+   39 jump *label15 notEqual :test:i 5
    40 label *label16
    41 jump *label5 always
    42 set *tmp4 null
 
    58 set *tmp4 "C"
    59 jump *label7 always
    60 label *label17
-    * jump *label23 equal :test:i 10
-    * jump *label22 always
+   61 jump *label22 notEqual :test:i 10
    62 label *label23
    63 jump *label6 always
    64 set *tmp4 null

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
    39 jump *label15 notEqual :test:i 5
    40 label *label16
    41 jump *label5 always
-    * set *tmp4 null
    42 jump *label7 always
    43 label *label15
    44 set :d:n 6
 
    60 jump *label22 notEqual :test:i 10
    61 label *label23
    62 jump *label6 always
-    * set *tmp4 null
    63 jump *label7 always
    64 label *label22
    65 set *tmp4 "D"
    66 label *label7
    67 set :test:str *tmp4
-    * print :test:str
+   68 print *tmp4
    69 label *label5
    70 op add :test:i :test:i 1
    71 jump *label4 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
    64 label *label22
    65 set *tmp4 "D"
    66 label *label7
-    * set :test:str *tmp4
    67 print *tmp4
    68 label *label5
    69 op add :test:i :test:i 1

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    11 set :test:i *tmp1
    12 label *label4
    13 jump *label6 greaterThan :test:i *tmp3
+   14 label *label25
    15 set :d:n 1
    16 setaddr :d*retaddr *label10 (h:*label10)
    17 call *label0 *invalid :d*retval (m:*label10) (h:*label10)
 
    68 print *tmp4
    69 label *label5
    70 op add :test:i :test:i 1
-    * jump *label4 always
+   71 jump *label25 lessThanEq :test:i *tmp3
    72 label *label6
    73 label *label1
    74 assertprints "ABBBCCCD" "complex-case-expression"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
    10 set *tmp3 :d*retval
    11 set :test:i *tmp1
    12 label *label4
-    * jump *label6 greaterThan :test:i *tmp3
+   13 jump *label6 greaterThan *tmp1 :d*retval
    14 label *label25
    15 set :d:n 1
    16 setaddr :d*retaddr *label10 (h:*label10)

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
     9 label *label3
    10 set *tmp3 :d*retval
    11 set :test:i *tmp1
-    * label *label4
    12 jump *label6 greaterThan *tmp1 :d*retval
    13 label *label25
    14 set :d:n 1
 
    37 jump *label7 always
    38 label *label11
    39 jump *label15 notEqual :test:i 5
-    * label *label16
    40 jump *label5 always
    41 jump *label7 always
    42 label *label15
 
    57 jump *label7 always
    58 label *label17
    59 jump *label22 notEqual :test:i 10
-    * label *label23
    60 jump *label6 always
    61 jump *label7 always
    62 label *label22
 
    67 op add :test:i :test:i 1
    68 jump *label25 lessThanEq :test:i *tmp3
    69 label *label6
-    * label *label1
    70 assertprints "ABBBCCCD" "complex-case-expression"
    71 stop
    72 end
    73 label *label0
    74 set :d*retval :d:n
-    * label *label24
    75 return :d*retaddr
    76 end

Modifications by Jumps phase, Jump Straightening, pass 4, iteration 1 (-1 instructions):
 
    15 setaddr :d*retaddr *label10 (h:*label10)
    16 call *label0 *invalid :d*retval (m:*label10) (h:*label10)
    17 label *label10
-    * jump *label9 equal :test:i :d*retval
-    * jump *label8 always
+   18 jump *label8 notEqual :test:i :d*retval
    19 label *label9
    20 set *tmp4 "A"
    21 jump *label7 always

Modifications by Jumps phase, Jump Optimization, pass 4, iteration 1:
 
    16 call *label0 *invalid :d*retval (m:*label10) (h:*label10)
    17 label *label10
    18 jump *label8 notEqual :test:i :d*retval
-    * label *label9
    19 set *tmp4 "A"
    20 jump *label7 always
    21 label *label8

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    42 setaddr :d*retaddr *label20 (h:*label20)
    43 call *label0 *invalid :d*retval (m:*label20) (h:*label20)
    44 label *label20
-    * jump *label19 lessThan :test:i :d*retval
+   45 jump *label17 lessThan :test:i :d*retval
    46 set :d:n 8
    47 setaddr :d*retaddr *label21 (h:*label21)
    48 call *label0 *invalid :d*retval (m:*label21) (h:*label21)

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1 (-3 instructions):
 
    36 label *label11
    37 jump *label15 notEqual :test:i 5
    38 jump *label5 always
-    * jump *label7 always
    39 label *label15
    40 set :d:n 6
    41 setaddr :d*retaddr *label20 (h:*label20)
 
    47 call *label0 *invalid :d*retval (m:*label21) (h:*label21)
    48 label *label21
    49 jump *label18 lessThanEq :test:i :d*retval
-    * label *label19
    50 jump *label17 always
    51 label *label18
    52 set *tmp4 "C"
 
    54 label *label17
    55 jump *label22 notEqual :test:i 10
    56 jump *label6 always
-    * jump *label7 always
    57 label *label22
    58 set *tmp4 "D"
    59 label *label7
 
    68 label *label0
    69 set :d*retval :d:n
    70 return :d*retaddr
-    * end

Modifications by Jumps phase, Jump Straightening, pass 5, iteration 1 (-3 instructions):
 
    34 set *tmp4 "B"
    35 jump *label7 always
    36 label *label11
-    * jump *label15 notEqual :test:i 5
-    * jump *label5 always
+   37 jump *label5 equal :test:i 5
    38 label *label15
    39 set :d:n 6
    40 setaddr :d*retaddr *label20 (h:*label20)
 
    45 setaddr :d*retaddr *label21 (h:*label21)
    46 call *label0 *invalid :d*retval (m:*label21) (h:*label21)
    47 label *label21
-    * jump *label18 lessThanEq :test:i :d*retval
-    * jump *label17 always
+   48 jump *label17 greaterThan :test:i :d*retval
    49 label *label18
    50 set *tmp4 "C"
    51 jump *label7 always
    52 label *label17
-    * jump *label22 notEqual :test:i 10
-    * jump *label6 always
+   53 jump *label6 equal :test:i 10
    54 label *label22
    55 set *tmp4 "D"
    56 label *label7

Modifications by Jumps phase, Jump Optimization, pass 5, iteration 1:
 
    35 jump *label7 always
    36 label *label11
    37 jump *label5 equal :test:i 5
-    * label *label15
    38 set :d:n 6
    39 setaddr :d*retaddr *label20 (h:*label20)
    40 call *label0 *invalid :d*retval (m:*label20) (h:*label20)
 
    45 call *label0 *invalid :d*retval (m:*label21) (h:*label21)
    46 label *label21
    47 jump *label17 greaterThan :test:i :d*retval
-    * label *label18
    48 set *tmp4 "C"
    49 jump *label7 always
    50 label *label17
    51 jump *label6 equal :test:i 10
-    * label *label22
    52 set *tmp4 "D"
    53 label *label7
    54 print *tmp4

Final code before resolving virtual instructions:

assertflush
set :d:n 1
setaddr :d*retaddr *label2
call *label0 *invalid :d*retval
label *label2
set *tmp1 :d*retval
set :d:n 10
setaddr :d*retaddr *label3
call *label0 *invalid :d*retval
label *label3
set *tmp3 :d*retval
set :test:i *tmp1
jump *label6 greaterThan *tmp1 :d*retval
label *label25
set :d:n 1
setaddr :d*retaddr *label10
call *label0 *invalid :d*retval
label *label10
jump *label8 notEqual :test:i :d*retval
set *tmp4 "A"
jump *label7 always
label *label8
set :d:n 2
setaddr :d*retaddr *label13
call *label0 *invalid :d*retval
label *label13
jump *label12 equal :test:i :d*retval
set :d:n 3
setaddr :d*retaddr *label14
call *label0 *invalid :d*retval
label *label14
jump *label12 equal :test:i :d*retval
jump *label11 notEqual :test:i 4
label *label12
set *tmp4 "B"
jump *label7 always
label *label11
jump *label5 equal :test:i 5
set :d:n 6
setaddr :d*retaddr *label20
call *label0 *invalid :d*retval
label *label20
jump *label17 lessThan :test:i :d*retval
set :d:n 8
setaddr :d*retaddr *label21
call *label0 *invalid :d*retval
label *label21
jump *label17 greaterThan :test:i :d*retval
set *tmp4 "C"
jump *label7 always
label *label17
jump *label6 equal :test:i 10
set *tmp4 "D"
label *label7
print *tmp4
label *label5
op add :test:i :test:i 1
jump *label25 lessThanEq :test:i *tmp3
label *label6
assertprints "ABBBCCCD" "complex-case-expression"
stop
end
label *label0
set :d*retval :d:n
return :d*retaddr
