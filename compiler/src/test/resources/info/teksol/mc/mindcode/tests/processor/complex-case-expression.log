    70 instructions before optimizations.
     1 instructions eliminated by Temp Variables Elimination.
     1 instructions eliminated by Case Expression Optimization.
     1 instructions eliminated by Dead Code Elimination (3 iterations).
     9 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     1 instructions modified by Loop Optimization (3 iterations).
     1 loops improved by Loop Optimization.
     4 instructions eliminated by Jump Straightening (4 iterations).
     1 instructions updated by JumpThreading.
     3 instructions eliminated by Unreachable Code Elimination.
    51 instructions after optimizations.

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    12 set :fn1:i *tmp1
    13 label *label4
    14 jump *label6 greaterThan :fn1:i *tmp3
-    * set *tmp5 :fn1:i
    15 set :fn0:n 1
    16 setaddr :fn0*retaddr *label10
    17 call *label0 :fn0*retval
    18 label *label10
    19 set *tmp6 :fn0*retval
-    * jump *label9 equal *tmp5 *tmp6
+   20 jump *label9 equal :fn1:i *tmp6
    21 jump *label8 always
    22 label *label9
    23 set *tmp4 "A"
 
    28 call *label0 :fn0*retval
    29 label *label13
    30 set *tmp7 :fn0*retval
-    * jump *label12 equal *tmp5 *tmp7
+   31 jump *label12 equal :fn1:i *tmp7
    32 set :fn0:n 3
    33 setaddr :fn0*retaddr *label14
    34 call *label0 :fn0*retval
    35 label *label14
    36 set *tmp8 :fn0*retval
-    * jump *label12 equal *tmp5 *tmp8
-    * jump *label12 equal *tmp5 4
+   37 jump *label12 equal :fn1:i *tmp8
+   38 jump *label12 equal :fn1:i 4
    39 jump *label11 always
    40 label *label12
    41 set *tmp4 "B"
    42 jump *label7 always
    43 label *label11
-    * jump *label16 equal *tmp5 5
+   44 jump *label16 equal :fn1:i 5
    45 jump *label15 always
    46 label *label16
    47 jump *label5 always
 
    53 call *label0 :fn0*retval
    54 label *label20
    55 set *tmp9 :fn0*retval
-    * jump *label19 lessThan *tmp5 *tmp9
+   56 jump *label19 lessThan :fn1:i *tmp9
    57 set :fn0:n 8
    58 setaddr :fn0*retaddr *label21
    59 call *label0 :fn0*retval
    60 label *label21
    61 set *tmp10 :fn0*retval
-    * jump *label18 lessThanEq *tmp5 *tmp10
+   62 jump *label18 lessThanEq :fn1:i *tmp10
    63 label *label19
    64 jump *label17 always
    65 label *label18
    66 set *tmp4 "C"
    67 jump *label7 always
    68 label *label17
-    * jump *label23 equal *tmp5 10
+   69 jump *label23 equal :fn1:i 10
    70 jump *label22 always
    71 label *label23
    72 jump *label6 always

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-1 instructions):
 
    81 op add :fn1:i :fn1:i 1
    82 jump *label4 always
    83 label *label6
-    * set *tmp0 null
    84 label *label1
    85 assertprints "ABBBCCCD" "complex-case-expression"
    86 stop

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-1 instructions):
 
     7 setaddr :fn0*retaddr *label3
     8 call *label0 :fn0*retval
     9 label *label3
-    * set *tmp2 :fn0*retval
-    * set *tmp3 *tmp2
+   10 set *tmp3 :fn0*retval
    11 set :fn1:i *tmp1
    12 label *label4
    13 jump *label6 greaterThan :fn1:i *tmp3

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-4 instructions):
 
    16 call *label0 :fn0*retval
    17 label *label10
    18 set *tmp6 :fn0*retval
-    * jump *label9 equal :fn1:i *tmp6
-    * jump *label8 always
+   19 jump *label8 notEqual :fn1:i *tmp6
    20 label *label9
    21 set *tmp4 "A"
    22 jump *label7 always
 
    33 label *label14
    34 set *tmp8 :fn0*retval
    35 jump *label12 equal :fn1:i *tmp8
-    * jump *label12 equal :fn1:i 4
-    * jump *label11 always
+   36 jump *label11 notEqual :fn1:i 4
    37 label *label12
    38 set *tmp4 "B"
    39 jump *label7 always
    40 label *label11
-    * jump *label16 equal :fn1:i 5
-    * jump *label15 always
+   41 jump *label15 notEqual :fn1:i 5
    42 label *label16
    43 jump *label5 always
    44 set *tmp4 null
 
    62 set *tmp4 "C"
    63 jump *label7 always
    64 label *label17
-    * jump *label23 equal :fn1:i 10
-    * jump *label22 always
+   65 jump *label22 notEqual :fn1:i 10
    66 label *label23
    67 jump *label6 always
    68 set *tmp4 null

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1 (-2 instructions):
 
    16 call *label0 :fn0*retval
    17 label *label10
    18 set *tmp6 :fn0*retval
-    * jump *label8 notEqual :fn1:i *tmp6
+   19 jump *label8 notEqual :fn1:i :fn0*retval
    20 label *label9
    21 set *tmp4 "A"
    22 jump *label7 always
 
    26 call *label0 :fn0*retval
    27 label *label13
    28 set *tmp7 :fn0*retval
-    * jump *label12 equal :fn1:i *tmp7
+   29 jump *label12 equal :fn1:i :fn0*retval
    30 set :fn0:n 3
    31 setaddr :fn0*retaddr *label14
    32 call *label0 :fn0*retval
    33 label *label14
    34 set *tmp8 :fn0*retval
-    * jump *label12 equal :fn1:i *tmp8
+   35 jump *label12 equal :fn1:i :fn0*retval
    36 jump *label11 notEqual :fn1:i 4
    37 label *label12
    38 set *tmp4 "B"
 
    41 jump *label15 notEqual :fn1:i 5
    42 label *label16
    43 jump *label5 always
-    * set *tmp4 null
    44 jump *label7 always
    45 label *label15
    46 set :fn0:n 6
 
    48 call *label0 :fn0*retval
    49 label *label20
    50 set *tmp9 :fn0*retval
-    * jump *label19 lessThan :fn1:i *tmp9
+   51 jump *label19 lessThan :fn1:i :fn0*retval
    52 set :fn0:n 8
    53 setaddr :fn0*retaddr *label21
    54 call *label0 :fn0*retval
    55 label *label21
    56 set *tmp10 :fn0*retval
-    * jump *label18 lessThanEq :fn1:i *tmp10
+   57 jump *label18 lessThanEq :fn1:i :fn0*retval
    58 label *label19
    59 jump *label17 always
    60 label *label18
 
    64 jump *label22 notEqual :fn1:i 10
    65 label *label23
    66 jump *label6 always
-    * set *tmp4 null
    67 jump *label7 always
    68 label *label22
    69 set *tmp4 "D"
    70 label *label7
    71 set :fn1:str *tmp4
-    * print :fn1:str
+   72 print *tmp4
    73 label *label5
    74 op add :fn1:i :fn1:i 1
    75 jump *label4 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-6 instructions):
 
    15 setaddr :fn0*retaddr *label10
    16 call *label0 :fn0*retval
    17 label *label10
-    * set *tmp6 :fn0*retval
    18 jump *label8 notEqual :fn1:i :fn0*retval
    19 label *label9
    20 set *tmp4 "A"
 
    24 setaddr :fn0*retaddr *label13
    25 call *label0 :fn0*retval
    26 label *label13
-    * set *tmp7 :fn0*retval
    27 jump *label12 equal :fn1:i :fn0*retval
    28 set :fn0:n 3
    29 setaddr :fn0*retaddr *label14
    30 call *label0 :fn0*retval
    31 label *label14
-    * set *tmp8 :fn0*retval
    32 jump *label12 equal :fn1:i :fn0*retval
    33 jump *label11 notEqual :fn1:i 4
    34 label *label12
 
    44 setaddr :fn0*retaddr *label20
    45 call *label0 :fn0*retval
    46 label *label20
-    * set *tmp9 :fn0*retval
    47 jump *label19 lessThan :fn1:i :fn0*retval
    48 set :fn0:n 8
    49 setaddr :fn0*retaddr *label21
    50 call *label0 :fn0*retval
    51 label *label21
-    * set *tmp10 :fn0*retval
    52 jump *label18 lessThanEq :fn1:i :fn0*retval
    53 label *label19
    54 jump *label17 always
 
    63 label *label22
    64 set *tmp4 "D"
    65 label *label7
-    * set :fn1:str *tmp4
    66 print *tmp4
    67 label *label5
    68 op add :fn1:i :fn1:i 1

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    11 set :fn1:i *tmp1
    12 label *label4
    13 jump *label6 greaterThan :fn1:i *tmp3
+   14 label *label25
    15 set :fn0:n 1
    16 setaddr :fn0*retaddr *label10
    17 call *label0 :fn0*retval
 
    67 print *tmp4
    68 label *label5
    69 op add :fn1:i :fn1:i 1
-    * jump *label4 always
+   70 jump *label25 lessThanEq :fn1:i *tmp3
    71 label *label6
    72 label *label1
    73 assertprints "ABBBCCCD" "complex-case-expression"

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1 (-1 instructions):
 
     2 setaddr :fn0*retaddr *label2
     3 call *label0 :fn0*retval
     4 label *label2
-    * set *tmp1 :fn0*retval
+    5 set :fn1:i :fn0*retval
     6 set :fn0:n 10
     7 setaddr :fn0*retaddr *label3
     8 call *label0 :fn0*retval
     9 label *label3
    10 set *tmp3 :fn0*retval
-    * set :fn1:i *tmp1
    11 label *label4
    12 jump *label6 greaterThan :fn1:i *tmp3
    13 label *label25

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 2:
 
     9 label *label3
    10 set *tmp3 :fn0*retval
    11 label *label4
-    * jump *label6 greaterThan :fn1:i *tmp3
+   12 jump *label6 greaterThan :fn1:i :fn0*retval
    13 label *label25
    14 set :fn0:n 1
    15 setaddr :fn0*retaddr *label10

Modifications by Final phase, Jump Threading, iteration 1:
 
    44 setaddr :fn0*retaddr *label20
    45 call *label0 :fn0*retval
    46 label *label20
-    * jump *label19 lessThan :fn1:i :fn0*retval
+   47 jump *label17 lessThan :fn1:i :fn0*retval
    48 set :fn0:n 8
    49 setaddr :fn0*retaddr *label21
    50 call *label0 :fn0*retval

Modifications by Final phase, Unreachable Code Elimination, iteration 1 (-3 instructions):
 
    38 jump *label15 notEqual :fn1:i 5
    39 label *label16
    40 jump *label5 always
-    * jump *label7 always
    41 label *label15
    42 set :fn0:n 6
    43 setaddr :fn0*retaddr *label20
 
    58 jump *label22 notEqual :fn1:i 10
    59 label *label23
    60 jump *label6 always
-    * jump *label7 always
    61 label *label22
    62 set *tmp4 "D"
    63 label *label7
 
    74 set :fn0*retval :fn0:n
    75 label *label24
    76 return :fn0*retaddr
-    * end

Final code before resolving virtual instructions:

assertflush
set :fn0:n 1
setaddr :fn0*retaddr *label2
call *label0 :fn0*retval
label *label2
set :fn1:i :fn0*retval
set :fn0:n 10
setaddr :fn0*retaddr *label3
call *label0 :fn0*retval
label *label3
set *tmp3 :fn0*retval
jump *label6 greaterThan :fn1:i :fn0*retval
label *label25
set :fn0:n 1
setaddr :fn0*retaddr *label10
call *label0 :fn0*retval
label *label10
jump *label8 notEqual :fn1:i :fn0*retval
set *tmp4 "A"
jump *label7 always 0 0
label *label8
set :fn0:n 2
setaddr :fn0*retaddr *label13
call *label0 :fn0*retval
label *label13
jump *label12 equal :fn1:i :fn0*retval
set :fn0:n 3
setaddr :fn0*retaddr *label14
call *label0 :fn0*retval
label *label14
jump *label12 equal :fn1:i :fn0*retval
jump *label11 notEqual :fn1:i 4
label *label12
set *tmp4 "B"
jump *label7 always 0 0
label *label11
jump *label15 notEqual :fn1:i 5
jump *label5 always 0 0
label *label15
set :fn0:n 6
setaddr :fn0*retaddr *label20
call *label0 :fn0*retval
label *label20
jump *label17 lessThan :fn1:i :fn0*retval
set :fn0:n 8
setaddr :fn0*retaddr *label21
call *label0 :fn0*retval
label *label21
jump *label18 lessThanEq :fn1:i :fn0*retval
jump *label17 always 0 0
label *label18
set *tmp4 "C"
jump *label7 always 0 0
label *label17
jump *label22 notEqual :fn1:i 10
jump *label6 always 0 0
label *label22
set *tmp4 "D"
label *label7
print *tmp4
label *label5
op add :fn1:i :fn1:i 1
jump *label25 lessThanEq :fn1:i *tmp3
label *label6
assertprints "ABBBCCCD" "complex-case-expression"
stop
end
label *label0
set :fn0*retval :fn0:n
return :fn0*retaddr
