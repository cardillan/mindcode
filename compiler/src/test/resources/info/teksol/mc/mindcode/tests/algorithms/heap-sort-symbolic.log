    99 instructions before optimizations.
    21 instructions eliminated by Temp Variables Elimination (6 iterations).
    10 instructions eliminated by Dead Code Elimination (6 iterations).
     7 instructions eliminated by Condition Optimization (2 passes, 8 iterations).
     5 instructions eliminated by Single Step Elimination (3 passes, 9 iterations).
     2 instructions modified by Expression Optimization (3 iterations).
     3 instructions eliminated by Data Flow Optimization (2 passes, 7 iterations).
     2 instructions added by Loop Rotation (3 iterations).
       5 loop conditions were partially rotated.
     2 instructions updated by Jump Threading.
     2 instructions eliminated by Unreachable Code Elimination (3 iterations).
    53 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 944):
  * Full loop rotation at line 31:5                              size    +2, benefit      650.0, efficiency    325.000 (+2 instructions)

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-8 instructions):
 
    24 set *tmp14 :up:parent
    25 write :up:iv ARRAY *tmp14
    26 set :up:index :up:parent
-    * set *tmp11 :up:index
    27 jump *label8 always
    28 label *label7
    29 jump *label6 always
-    * set *tmp11 null
    30 label *label8
    31 label *label5
    32 jump *label4 always
    33 label *label6
-    * set *tmp0 null
    34 label *label3
    35 label *label1
    36 op add :i :i 1
 
    77 label *label18
    78 set *tmp40 null
    79 label *label19
-    * set *tmp34 *tmp40
    80 jump *label17 always
    81 label *label16
-    * set *tmp34 null
    82 label *label17
    83 set *tmp44 :down:parent
    84 read *tmp46 ARRAY *tmp44
 
    90 set *tmp51 :down:child
    91 write :down:pv ARRAY *tmp51
    92 set :down:parent :down:child
-    * set *tmp48 :down:parent
    93 jump *label21 always
    94 label *label20
    95 jump *label15 always
-    * set *tmp48 null
    96 label *label21
    97 label *label14
    98 jump *label13 always
    99 label *label15
-    * set *tmp26 null
   100 label *label12
   101 label *label10
   102 jump *label9 always

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-2 instructions):
 
    72 set *tmp41 :down:child
    73 read *tmp43 ARRAY *tmp41
    74 set :down:cv *tmp43
-    * set *tmp40 :down:cv
    75 jump *label19 always
    76 label *label18
-    * set *tmp40 null
    77 label *label19
    78 jump *label17 always
    79 label *label16

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-21 instructions):
 
     9 op greaterThan *tmp1 :up:index 0
    10 jump *label6 equal *tmp1 false
    11 op sub *tmp2 :up:index 1
-    * op idiv *tmp3 *tmp2 2
-    * set :up:parent *tmp3
-    * set *tmp4 :up:index
-    * read *tmp6 ARRAY *tmp4
-    * set :up:iv *tmp6
-    * set *tmp7 :up:parent
-    * read *tmp9 ARRAY *tmp7
-    * set :up:pv *tmp9
+   12 op idiv :up:parent *tmp2 2
+   13 read :up:iv ARRAY :up:index
+   14 read :up:pv ARRAY :up:parent
    15 op lessThan *tmp10 :up:pv :up:iv
    16 jump *label7 equal *tmp10 false
-    * set *tmp12 :up:index
-    * write :up:pv ARRAY *tmp12
-    * set *tmp14 :up:parent
-    * write :up:iv ARRAY *tmp14
+   17 write :up:pv ARRAY :up:index
+   18 write :up:iv ARRAY :up:parent
    19 set :up:index :up:parent
    20 jump *label8 always
    21 label *label7
 
    29 op add :i :i 1
    30 jump *label0 always
    31 label *label2
-    * op sub *tmp16 SIZE 1
-    * set :index *tmp16
+   32 op sub :index SIZE 1
    33 label *label9
    34 op greaterThan *tmp17 :index 0
    35 jump *label11 equal *tmp17 false
-    * read *tmp19 ARRAY 0
-    * set :x *tmp19
-    * set *tmp21 :index
-    * read *tmp23 ARRAY *tmp21
+   36 read :x ARRAY 0
+   37 read *tmp23 ARRAY :index
    38 write *tmp23 ARRAY 0
-    * set *tmp24 :index
-    * write :x ARRAY *tmp24
+   39 write :x ARRAY :index
    40 op sub :index :index 1
    41 # "Function: def down(in index)"
    42 set :down:index :index
    43 set :down:parent 0
    44 label *label13
    45 op mul *tmp27 :down:parent 2
-    * op add *tmp28 *tmp27 1
-    * set :down:child *tmp28
+   46 op add :down:child *tmp27 1
    47 op lessThanEq *tmp29 :down:child :down:index
    48 jump *label15 equal *tmp29 false
-    * set *tmp30 :down:child
-    * read *tmp32 ARRAY *tmp30
-    * set :down:cv *tmp32
+   49 read :down:cv ARRAY :down:child
    50 op lessThan *tmp33 :down:child :down:index
    51 jump *label16 equal *tmp33 false
-    * op add *tmp35 :down:child 1
-    * set *tmp36 *tmp35
+   52 op add *tmp36 :down:child 1
    53 read *tmp39 ARRAY *tmp36
    54 op lessThan *tmp38 :down:cv *tmp39
    55 jump *label18 equal *tmp38 false
    56 op add :down:child :down:child 1
-    * set *tmp41 :down:child
-    * read *tmp43 ARRAY *tmp41
-    * set :down:cv *tmp43
+   57 read :down:cv ARRAY :down:child
    58 jump *label19 always
    59 label *label18
    60 label *label19
    61 jump *label17 always
    62 label *label16
    63 label *label17
-    * set *tmp44 :down:parent
-    * read *tmp46 ARRAY *tmp44
-    * set :down:pv *tmp46
+   64 read :down:pv ARRAY :down:parent
    65 op lessThan *tmp47 :down:pv :down:cv
    66 jump *label20 equal *tmp47 false
-    * set *tmp49 :down:parent
-    * write :down:cv ARRAY *tmp49
-    * set *tmp51 :down:child
-    * write :down:pv ARRAY *tmp51
+   67 write :down:cv ARRAY :down:parent
+   68 write :down:pv ARRAY :down:child
    69 set :down:parent :down:child
    70 jump *label21 always
    71 label *label20

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-7 instructions):
 
     6 # "Function: def up(in index)"
     7 set :up:index :i
     8 label *label4
-    * op greaterThan *tmp1 :up:index 0
-    * jump *label6 equal *tmp1 false
+    9 jump *label6 lessThanEq :up:index 0
    10 op sub *tmp2 :up:index 1
    11 op idiv :up:parent *tmp2 2
    12 read :up:iv ARRAY :up:index
    13 read :up:pv ARRAY :up:parent
-    * op lessThan *tmp10 :up:pv :up:iv
-    * jump *label7 equal *tmp10 false
+   14 jump *label7 greaterThanEq :up:pv :up:iv
    15 write :up:pv ARRAY :up:index
    16 write :up:iv ARRAY :up:parent
    17 set :up:index :up:parent
 
    29 label *label2
    30 op sub :index SIZE 1
    31 label *label9
-    * op greaterThan *tmp17 :index 0
-    * jump *label11 equal *tmp17 false
+   32 jump *label11 lessThanEq :index 0
    33 read :x ARRAY 0
    34 read *tmp23 ARRAY :index
    35 write *tmp23 ARRAY 0
 
    41 label *label13
    42 op mul *tmp27 :down:parent 2
    43 op add :down:child *tmp27 1
-    * op lessThanEq *tmp29 :down:child :down:index
-    * jump *label15 equal *tmp29 false
+   44 jump *label15 greaterThan :down:child :down:index
    45 read :down:cv ARRAY :down:child
-    * op lessThan *tmp33 :down:child :down:index
-    * jump *label16 equal *tmp33 false
+   46 jump *label16 greaterThanEq :down:child :down:index
    47 op add *tmp36 :down:child 1
    48 read *tmp39 ARRAY *tmp36
-    * op lessThan *tmp38 :down:cv *tmp39
-    * jump *label18 equal *tmp38 false
+   49 jump *label18 greaterThanEq :down:cv *tmp39
    50 op add :down:child :down:child 1
    51 read :down:cv ARRAY :down:child
    52 jump *label19 always
 
    56 label *label16
    57 label *label17
    58 read :down:pv ARRAY :down:parent
-    * op lessThan *tmp47 :down:pv :down:cv
-    * jump *label20 equal *tmp47 false
+   59 jump *label20 greaterThanEq :down:pv :down:cv
    60 write :down:cv ARRAY :down:parent
    61 write :down:pv ARRAY :down:child
    62 set :down:parent :down:child

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-2 instructions):
 
    49 jump *label18 greaterThanEq :down:cv *tmp39
    50 op add :down:child :down:child 1
    51 read :down:cv ARRAY :down:child
-    * jump *label19 always
    52 label *label18
    53 label *label19
-    * jump *label17 always
    54 label *label16
    55 label *label17
    56 read :down:pv ARRAY :down:parent

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    41 label *label13
    42 op mul *tmp27 :down:parent 2
    43 op add :down:child *tmp27 1
-    * jump *label15 greaterThan :down:child :down:index
+   44 jump *label15 greaterThan :down:child :index
    45 read :down:cv ARRAY :down:child
-    * jump *label16 greaterThanEq :down:child :down:index
+   46 jump *label16 greaterThanEq :down:child :index
    47 op add *tmp36 :down:child 1
    48 read *tmp39 ARRAY *tmp36
    49 jump *label18 greaterThanEq :down:cv *tmp39
-    * op add :down:child :down:child 1
+   50 op add :down:child *tmp27 2
    51 read :down:cv ARRAY :down:child
    52 label *label18
    53 label *label19
 
    74 jump *label24 greaterThanEq :i SIZE
    75 set *tmp53 :i
    76 set *tmp55 :i
-    * read *tmp57 FINAL *tmp53
-    * read *tmp58 ARRAY *tmp55
+   77 read *tmp57 FINAL :i
+   78 read *tmp58 ARRAY :i
    79 assertequals *tmp57 *tmp58 "unexpected value"
    80 label *label23
    81 op add :i :i 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-3 instructions):
 
    36 write :x ARRAY :index
    37 op sub :index :index 1
    38 # "Function: def down(in index)"
-    * set :down:index :index
    39 set :down:parent 0
    40 label *label13
    41 op mul *tmp27 :down:parent 2
 
    71 set :i 0
    72 label *label22
    73 jump *label24 greaterThanEq :i SIZE
-    * set *tmp53 :i
-    * set *tmp55 :i
    74 read *tmp57 FINAL :i
    75 read *tmp58 ARRAY :i
    76 assertequals *tmp57 *tmp58 "unexpected value"

Modifications by Iterated phase, Loop Rotation, pass 1, iteration 1:
 
     3 set :i 1
     4 label *label0
     5 jump *label2 greaterThanEq :i SIZE
+    6 label *label29
     7 # "Function: def up(in index)"
     8 set :up:index :i
     9 label *label4
    10 jump *label6 lessThanEq :up:index 0
+   11 label *label30
    12 op sub *tmp2 :up:index 1
    13 op idiv :up:parent *tmp2 2
    14 read :up:iv ARRAY :up:index
 
    22 jump *label6 always
    23 label *label8
    24 label *label5
-    * jump *label4 always
+   25 jump *label30 greaterThan :up:index 0
    26 label *label6
    27 label *label3
    28 label *label1
    29 op add :i :i 1
-    * jump *label0 always
+   30 jump *label29 lessThan :i SIZE
    31 label *label2
    32 op sub :index SIZE 1
    33 label *label9
    34 jump *label11 lessThanEq :index 0
+   35 label *label31
    36 read :x ARRAY 0
    37 read *tmp23 ARRAY :index
    38 write *tmp23 ARRAY 0
 
    69 label *label15
    70 label *label12
    71 label *label10
-    * jump *label9 always
+   72 jump *label31 greaterThan :index 0
    73 label *label11
    74 set :i 0
    75 label *label22
    76 jump *label24 greaterThanEq :i SIZE
+   77 label *label32
    78 read *tmp57 FINAL :i
    79 read *tmp58 ARRAY :i
    80 assertequals *tmp57 *tmp58 "unexpected value"
    81 label *label23
    82 op add :i :i 1
-    * jump *label22 always
+   83 jump *label32 lessThan :i SIZE
    84 label *label24
    85 stop
    86 end

Modifications by Full loop rotation at line 31:5 (+2 instructions):
 
    44 op mul *tmp27 :down:parent 2
    45 op add :down:child *tmp27 1
    46 jump *label15 greaterThan :down:child :index
+   47 label *label33
    48 read :down:cv ARRAY :down:child
    49 jump *label16 greaterThanEq :down:child :index
    50 op add *tmp36 :down:child 1
 
    66 jump *label15 always
    67 label *label21
    68 label *label14
-    * jump *label13 always
+   69 op mul *tmp27 :down:parent 2
+   70 op add :down:child *tmp27 1
+   71 jump *label33 lessThanEq :down:child :index
    72 label *label15
    73 label *label12
    74 label *label10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set FINAL bank3
     3 set :i 1
     4 label *label0
-    * jump *label2 greaterThanEq :i SIZE
+    5 jump *label2 greaterThanEq 1 SIZE
     6 label *label29
     7 # "Function: def up(in index)"
     8 set :up:index :i
     9 label *label4
-    * jump *label6 lessThanEq :up:index 0
+   10 jump *label6 lessThanEq :i 0
    11 label *label30
    12 op sub *tmp2 :up:index 1
    13 op idiv :up:parent *tmp2 2
 
    22 jump *label6 always
    23 label *label8
    24 label *label5
-    * jump *label30 greaterThan :up:index 0
+   25 jump *label30 greaterThan :up:parent 0
    26 label *label6
    27 label *label3
    28 label *label1
 
    41 # "Function: def down(in index)"
    42 set :down:parent 0
    43 label *label13
-    * op mul *tmp27 :down:parent 2
-    * op add :down:child *tmp27 1
-    * jump *label15 greaterThan :down:child :index
+   44 op mul *tmp27 0 2
+   45 op add :down:child 0 1
+   46 jump *label15 greaterThan 1 :index
    47 label *label33
    48 read :down:cv ARRAY :down:child
    49 jump *label16 greaterThanEq :down:child :index
 
    66 jump *label15 always
    67 label *label21
    68 label *label14
-    * op mul *tmp27 :down:parent 2
+   69 op mul *tmp27 :down:child 2
    70 op add :down:child *tmp27 1
    71 jump *label33 lessThanEq :down:child :index
    72 label *label15
 
    76 label *label11
    77 set :i 0
    78 label *label22
-    * jump *label24 greaterThanEq :i SIZE
+   79 jump *label24 greaterThanEq 0 SIZE
    80 label *label32
    81 read *tmp57 FINAL :i
    82 read *tmp58 ARRAY :i

Modifications by Iterated phase, Condition Optimization, pass 2, iteration 1:
 
    31 label *label2
    32 op sub :index SIZE 1
    33 label *label9
-    * jump *label11 lessThanEq :index 0
+   34 jump *label11 lessThanEq SIZE 1
    35 label *label31
    36 read :x ARRAY 0
    37 read *tmp23 ARRAY :index

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    41 # "Function: def down(in index)"
    42 set :down:parent 0
    43 label *label13
-    * op mul *tmp27 0 2
-    * op add :down:child 0 1
+   44 set *tmp27 0
+   45 set :down:child 1
    46 jump *label15 greaterThan 1 :index
    47 label *label33
    48 read :down:cv ARRAY :down:child

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
 
    11 op idiv :up:parent *tmp2 2
    12 read :up:iv ARRAY :up:index
    13 read :up:pv ARRAY :up:parent
-    * jump *label7 greaterThanEq :up:pv :up:iv
+   14 jump *label6 greaterThanEq :up:pv :up:iv
    15 write :up:pv ARRAY :up:index
    16 write :up:iv ARRAY :up:parent
    17 set :up:index :up:parent
 
    48 label *label18
    49 label *label16
    50 read :down:pv ARRAY :down:parent
-    * jump *label20 greaterThanEq :down:pv :down:cv
+   51 jump *label15 greaterThanEq :down:pv :down:cv
    52 write :down:cv ARRAY :down:parent
    53 write :down:pv ARRAY :down:child
    54 set :down:parent :down:child

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
    70 jump *label32 lessThan :i SIZE
    71 label *label24
    72 stop
-    * end

Modifications by Jumps phase, Unreachable Code Elimination, pass 5, iteration 1 (-2 instructions):
 
    16 write :up:iv ARRAY :up:parent
    17 set :up:index :up:parent
    18 jump *label8 always
-    * jump *label6 always
    19 label *label8
    20 jump *label30 greaterThan :up:parent 0
    21 label *label6
 
    51 write :down:pv ARRAY :down:child
    52 set :down:parent :down:child
    53 jump *label21 always
-    * jump *label15 always
    54 label *label21
    55 op mul *tmp27 :down:child 2
    56 op add :down:child *tmp27 1

Modifications by Jumps phase, Single Step Elimination, pass 5, iteration 1 (-2 instructions):
 
    15 write :up:pv ARRAY :up:index
    16 write :up:iv ARRAY :up:parent
    17 set :up:index :up:parent
-    * jump *label8 always
    18 label *label8
    19 jump *label30 greaterThan :up:parent 0
    20 label *label6
 
    49 write :down:cv ARRAY :down:parent
    50 write :down:pv ARRAY :down:child
    51 set :down:parent :down:child
-    * jump *label21 always
    52 label *label21
    53 op mul *tmp27 :down:child 2
    54 op add :down:child *tmp27 1

Final code before resolving virtual instructions:

set SIZE 512
set ARRAY bank2
set FINAL bank3
set :i 1
jump *label2 greaterThanEq 1 SIZE
label *label29
# "Function: def up(in index)"
set :up:index :i
jump *label6 lessThanEq :i 0
label *label30
op sub *tmp2 :up:index 1
op idiv :up:parent *tmp2 2
read :up:iv ARRAY :up:index
read :up:pv ARRAY :up:parent
jump *label6 greaterThanEq :up:pv :up:iv
write :up:pv ARRAY :up:index
write :up:iv ARRAY :up:parent
set :up:index :up:parent
jump *label30 greaterThan :up:parent 0
label *label6
op add :i :i 1
jump *label29 lessThan :i SIZE
label *label2
op sub :index SIZE 1
jump *label11 lessThanEq SIZE 1
label *label31
read :x ARRAY 0
read *tmp23 ARRAY :index
write *tmp23 ARRAY 0
write :x ARRAY :index
op sub :index :index 1
# "Function: def down(in index)"
set :down:parent 0
set *tmp27 0
set :down:child 1
jump *label15 greaterThan 1 :index
label *label33
read :down:cv ARRAY :down:child
jump *label16 greaterThanEq :down:child :index
op add *tmp36 :down:child 1
read *tmp39 ARRAY *tmp36
jump *label18 greaterThanEq :down:cv *tmp39
op add :down:child *tmp27 2
read :down:cv ARRAY :down:child
label *label18
label *label16
read :down:pv ARRAY :down:parent
jump *label15 greaterThanEq :down:pv :down:cv
write :down:cv ARRAY :down:parent
write :down:pv ARRAY :down:child
set :down:parent :down:child
op mul *tmp27 :down:child 2
op add :down:child *tmp27 1
jump *label33 lessThanEq :down:child :index
label *label15
jump *label31 greaterThan :index 0
label *label11
set :i 0
jump *label24 greaterThanEq 0 SIZE
label *label32
read *tmp57 FINAL :i
read *tmp58 ARRAY :i
assertequals *tmp57 *tmp58 "unexpected value"
op add :i :i 1
jump *label32 lessThan :i SIZE
label *label24
stop
