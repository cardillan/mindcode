   261 instructions before optimizations.
    22 instructions eliminated by Temp Variables Elimination (2 passes, 7 iterations).
     1 instructions eliminated by Case Expression Optimization.
    27 instructions eliminated by Dead Code Elimination (7 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    10 instructions eliminated by Jump Optimization (5 iterations).
     7 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     2 instructions modified by Expression Optimization (3 iterations).
     9 instructions eliminated by If Expression Optimization (4 iterations).
     7 instructions eliminated by Data Flow Optimization (3 passes, 11 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
    15 instructions eliminated by Case Switching (5 iterations).
     1 case expressions converted to switched jumps Case Switching.
     7 instructions eliminated by Jump Straightening (5 iterations).
     2 instructions updated by Jump Threading.
    35 instructions eliminated by Print Merging.
   121 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 825):
  * Replicate loop condition at line 72:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  o Convert case at line 26:9 (segments: 1, padded low)          size   -15, benefit     4062.5, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 824):
  * Convert case at line 26:9 (segments: 1, padded low)          size   -15, benefit     4062.5, efficiency   Infinity (-15 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    26 print :block
    27 print "\n"
    28 sensor *tmp5 :block @type
-    * set *tmp6 *tmp5
-    * jump *label8 equal *tmp6 @message
+   29 jump *label8 equal *tmp5 @message
    30 jump *label7 always
    31 label *label8
    32 set .MESSAGE :block
    33 set *tmp4 .MESSAGE
    34 jump *label6 always
    35 label *label7
-    * jump *label10 equal *tmp6 @switch
+   36 jump *label10 equal *tmp5 @switch
    37 jump *label9 always
    38 label *label10
    39 set .SWITCH :block
    40 set *tmp4 .SWITCH
    41 jump *label6 always
    42 label *label9
-    * jump *label12 equal *tmp6 @sorter
-    * jump *label12 equal *tmp6 @inverted-sorter
-    * jump *label12 equal *tmp6 @unloader
+   43 jump *label12 equal *tmp5 @sorter
+   44 jump *label12 equal *tmp5 @inverted-sorter
+   45 jump *label12 equal *tmp5 @unloader
    46 jump *label11 always
    47 label *label12
    48 set .SORTER :block
    49 set *tmp4 .SORTER
    50 jump *label6 always
    51 label *label11
-    * jump *label14 equal *tmp6 @vault
-    * jump *label14 equal *tmp6 @container
-    * jump *label14 equal *tmp6 @core-shard
-    * jump *label14 equal *tmp6 @core-foundation
-    * jump *label14 equal *tmp6 @core-nucleus
+   52 jump *label14 equal *tmp5 @vault
+   53 jump *label14 equal *tmp5 @container
+   54 jump *label14 equal *tmp5 @core-shard
+   55 jump *label14 equal *tmp5 @core-foundation
+   56 jump *label14 equal *tmp5 @core-nucleus
    57 jump *label13 always
    58 label *label14
    59 set .CONTAINER :block
 
    64 set *tmp4 .START
    65 jump *label6 always
    66 label *label13
-    * jump *label16 equal *tmp6 @liquid-tank
-    * jump *label16 equal *tmp6 @liquid-container
-    * jump *label16 equal *tmp6 @liquid-router
+   67 jump *label16 equal *tmp5 @liquid-tank
+   68 jump *label16 equal *tmp5 @liquid-container
+   69 jump *label16 equal *tmp5 @liquid-router
    70 jump *label15 always
    71 label *label16
    72 set .CONTAINER :block
 
    77 set *tmp4 .START
    78 jump *label6 always
    79 label *label15
-    * jump *label18 equal *tmp6 @battery
-    * jump *label18 equal *tmp6 @battery-large
+   80 jump *label18 equal *tmp5 @battery
+   81 jump *label18 equal *tmp5 @battery-large
    82 jump *label17 always
    83 label *label18
    84 set .CONTAINER :block
 
    89 set *tmp4 .START
    90 jump *label6 always
    91 label *label17
-    * jump *label20 equal *tmp6 @power-node
-    * jump *label20 equal *tmp6 @power-node-large
-    * jump *label20 equal *tmp6 @surge-tower
+   92 jump *label20 equal *tmp5 @power-node
+   93 jump *label20 equal *tmp5 @power-node-large
+   94 jump *label20 equal *tmp5 @surge-tower
    95 jump *label19 always
    96 label *label20
    97 set .CONTAINER :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-17 instructions):
 
    30 jump *label7 always
    31 label *label8
    32 set .MESSAGE :block
-    * set *tmp4 .MESSAGE
    33 jump *label6 always
    34 label *label7
    35 jump *label10 equal *tmp5 @switch
    36 jump *label9 always
    37 label *label10
    38 set .SWITCH :block
-    * set *tmp4 .SWITCH
    39 jump *label6 always
    40 label *label9
    41 jump *label12 equal *tmp5 @sorter
 
    44 jump *label11 always
    45 label *label12
    46 set .SORTER :block
-    * set *tmp4 .SORTER
    47 jump *label6 always
    48 label *label11
    49 jump *label14 equal *tmp5 @vault
 
    58 set .MAXIMUM @itemCapacity
    59 op add *tmp7 :n 1
    60 set .START *tmp7
-    * set *tmp4 .START
    61 jump *label6 always
    62 label *label13
    63 jump *label16 equal *tmp5 @liquid-tank
 
    70 set .MAXIMUM @liquidCapacity
    71 op add *tmp8 :n 1
    72 set .START *tmp8
-    * set *tmp4 .START
    73 jump *label6 always
    74 label *label15
    75 jump *label18 equal *tmp5 @battery
 
    81 set .MAXIMUM @powerCapacity
    82 op add *tmp9 :n 1
    83 set .START *tmp9
-    * set *tmp4 .START
    84 jump *label6 always
    85 label *label17
    86 jump *label20 equal *tmp5 @power-node
 
    93 set .MAXIMUM @powerNetCapacity
    94 op add *tmp10 :n 1
    95 set .START *tmp10
-    * set *tmp4 .START
    96 jump *label6 always
    97 label *label19
-    * set *tmp4 null
    98 label *label6
    99 label *label4
   100 jump *label3 always
 
   115 jump *label21 equal *tmp11 false
   116 print "No container."
   117 print "\n"
-    * set *tmp12 "No container."
   118 jump *label22 always
   119 label *label21
-    * set *tmp12 null
   120 label *label22
   121 printflush .MESSAGE
   122 label *label1
 
   145 label *label24
   146 set *tmp18 null
   147 label *label25
-    * set *tmp16 *tmp18
   148 label *label23
   149 set *tmp21 .SWITCH
   150 control enabled *tmp21 0
 
   163 set :item .SENSOR
   164 print "Measuring [gold]total[] in "
   165 print .CONTAINER
-    * set *tmp30 null
   166 jump *label32 always
   167 label *label31
   168 print "Measuring [gold]"
 
   170 print "["
   171 print "] in "
   172 print .CONTAINER
-    * set *tmp30 null
   173 label *label32
   174 sensor *tmp31 .CONTAINER .MAXIMUM
   175 set :max *tmp31
 
   201 label *label37
   202 set *tmp37 *tmp39
   203 label *label35
-    * set *tmp36 *tmp37
   204 jump *label34 always
   205 label *label33
   206 op greaterThanEq *tmp42 :pct PCT_HIGH
 
   231 label *label40
   232 set *tmp43 null
   233 label *label41
-    * set *tmp36 *tmp43
   234 label *label34
   235 print "\n"
   236 print "Level: [gold]"
 
   248 print PCT_LOW
   249 print "%"
   250 print "[]"
-    * set *tmp49 null
   251 jump *label48 always
   252 label *label47
   253 print "\n"
 
   260 print PCT_HIGH
   261 print "%"
   262 print "[]"
-    * set *tmp49 null
   263 label *label48
   264 print .ACTIVE_TEXT
   265 set :n .START

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
   140 set *tmp20 "\nCurrently inactive:[salmon]"
   141 label *label27
   142 set .ACTIVE_TEXT *tmp20
-    * set *tmp18 .ACTIVE_TEXT
   143 jump *label25 always
   144 label *label24
-    * set *tmp18 null
   145 label *label25
   146 label *label23
   147 set *tmp21 .SWITCH
 
   197 label *label36
   198 set *tmp39 null
   199 label *label37
-    * set *tmp37 *tmp39
   200 label *label35
   201 jump *label34 always
   202 label *label33
 
   223 label *label44
   224 set *tmp44 *tmp46
   225 label *label42
-    * set *tmp43 *tmp44
   226 jump *label41 always
   227 label *label40
-    * set *tmp43 null
   228 label *label41
   229 label *label34
   230 print "\n"

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-3 instructions):
 
   192 set *tmp41 "\nCurrently inactive:[salmon]"
   193 label *label39
   194 set .ACTIVE_TEXT *tmp41
-    * set *tmp39 .ACTIVE_TEXT
   195 jump *label37 always
   196 label *label36
-    * set *tmp39 null
   197 label *label37
   198 label *label35
   199 jump *label34 always
 
   219 label *label43
   220 set *tmp46 null
   221 label *label44
-    * set *tmp44 *tmp46
   222 label *label42
   223 jump *label41 always
   224 label *label40

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   214 set *tmp48 "\nCurrently inactive:[salmon]"
   215 label *label46
   216 set .ACTIVE_TEXT *tmp48
-    * set *tmp46 .ACTIVE_TEXT
   217 jump *label44 always
   218 label *label43
-    * set *tmp46 null
   219 label *label44
   220 label *label42
   221 jump *label41 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-19 instructions):
 
    13 label *label0
    14 print "Configuring regulator..."
    15 print "\n"
-    * set *tmp0 @links
-    * set :n *tmp0
+   16 set :n @links
    17 label *label3
    18 op greaterThan *tmp1 :n 0
    19 jump *label5 equal *tmp1 false
-    * op sub *tmp2 :n 1
-    * set :n *tmp2
-    * getlink *tmp3 :n
-    * set :block *tmp3
+   20 op sub :n :n 1
+   21 getlink :block :n
    22 print "Found: "
    23 print :block
    24 print "\n"
 
    53 set .CONTAINER :block
    54 set .SENSOR @totalItems
    55 set .MAXIMUM @itemCapacity
-    * op add *tmp7 :n 1
-    * set .START *tmp7
+   56 op add .START :n 1
    57 jump *label6 always
    58 label *label13
    59 jump *label16 equal *tmp5 @liquid-tank
 
    64 set .CONTAINER :block
    65 set .SENSOR @totalLiquids
    66 set .MAXIMUM @liquidCapacity
-    * op add *tmp8 :n 1
-    * set .START *tmp8
+   67 op add .START :n 1
    68 jump *label6 always
    69 label *label15
    70 jump *label18 equal *tmp5 @battery
 
    74 set .CONTAINER :block
    75 set .SENSOR @totalPower
    76 set .MAXIMUM @powerCapacity
-    * op add *tmp9 :n 1
-    * set .START *tmp9
+   77 op add .START :n 1
    78 jump *label6 always
    79 label *label17
    80 jump *label20 equal *tmp5 @power-node
 
    85 set .CONTAINER :block
    86 set .SENSOR @powerNetStored
    87 set .MAXIMUM @powerNetCapacity
-    * op add *tmp10 :n 1
-    * set .START *tmp10
+   88 op add .START :n 1
    89 jump *label6 always
    90 label *label19
    91 label *label6
 
   117 jump *label0 notEqual *tmp13 false
   118 label *label2
   119 sensor *tmp14 .SORTER @type
-    * op strictEqual *tmp15 *tmp14 @inverted-sorter
-    * set .INVERTED *tmp15
+  120 op strictEqual .INVERTED *tmp14 @inverted-sorter
   121 set :setState:newState true
   122 op notEqual *tmp17 .STATE :setState:newState
   123 jump *label24 equal *tmp17 false
   124 set .STATE :setState:newState
   125 op add .CYCLES .CYCLES 1
-    * op xor *tmp19 .INVERTED .STATE
-    * set .ON *tmp19
+  126 op xor .ON .INVERTED .STATE
   127 jump *label26 equal .ON false
   128 set *tmp20 "\nCurrently active:[green]"
   129 jump *label27 always
 
   135 label *label24
   136 label *label25
   137 label *label23
-    * set *tmp21 .SWITCH
-    * control enabled *tmp21 0
+  138 control enabled .SWITCH 0
   139 label *label28
   140 sensor *tmp23 .SWITCH @enabled
   141 op equal *tmp24 *tmp23 0
   142 jump *label30 equal *tmp24 false
-    * set *tmp25 @time
-    * set :start *tmp25
-    * sensor *tmp26 .SORTER @config
-    * set :item *tmp26
+  143 set :start @time
+  144 sensor :item .SORTER @config
   145 op equal *tmp27 :item null
   146 op notEqual *tmp28 .SENSOR @totalItems
   147 op or *tmp29 *tmp27 *tmp28
 
   157 print "] in "
   158 print .CONTAINER
   159 label *label32
-    * sensor *tmp31 .CONTAINER .MAXIMUM
-    * set :max *tmp31
-    * sensor *tmp32 .CONTAINER :item
-    * set :amount *tmp32
+  160 sensor :max .CONTAINER .MAXIMUM
+  161 sensor :amount .CONTAINER :item
   162 op mul *tmp33 100 :amount
-    * op idiv *tmp34 *tmp33 :max
-    * set :pct *tmp34
+  163 op idiv :pct *tmp33 :max
   164 op lessThanEq *tmp35 :pct PCT_LOW
   165 jump *label33 equal *tmp35 false
   166 set :setState.1:newState true
 
   168 jump *label36 equal *tmp38 false
   169 set .STATE :setState.1:newState
   170 op add .CYCLES .CYCLES 1
-    * op xor *tmp40 .INVERTED .STATE
-    * set .ON *tmp40
+  171 op xor .ON .INVERTED .STATE
   172 jump *label38 equal .ON false
   173 set *tmp41 "\nCurrently active:[green]"
   174 jump *label39 always
 
   189 jump *label43 equal *tmp45 false
   190 set .STATE :setState.2:newState
   191 op add .CYCLES .CYCLES 1
-    * op xor *tmp47 .INVERTED .STATE
-    * set .ON *tmp47
+  192 op xor .ON .INVERTED .STATE
   193 jump *label45 equal .ON false
   194 set *tmp48 "\nCurrently active:[green]"
   195 jump *label46 always
 
   239 label *label49
   240 op lessThan *tmp50 :n @links
   241 jump *label51 equal *tmp50 false
-    * getlink *tmp51 :n
-    * set :block *tmp51
-    * set *tmp52 :block
-    * control enabled *tmp52 .ON
+  242 getlink :block :n
+  243 control enabled :block .ON
   244 print "\n    "
   245 print :block
   246 op add :n :n 1

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    23 print :block
    24 print "\n"
    25 sensor *tmp5 :block @type
-    * jump *label8 equal *tmp5 @message
-    * jump *label7 always
+   26 jump *label7 notEqual *tmp5 @message
    27 label *label8
    28 set .MESSAGE :block
    29 jump *label6 always
    30 label *label7
-    * jump *label10 equal *tmp5 @switch
-    * jump *label9 always
+   31 jump *label9 notEqual *tmp5 @switch
    32 label *label10
    33 set .SWITCH :block
    34 jump *label6 always
    35 label *label9
    36 jump *label12 equal *tmp5 @sorter
    37 jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label12 equal *tmp5 @unloader
-    * jump *label11 always
+   38 jump *label11 notEqual *tmp5 @unloader
    39 label *label12
    40 set .SORTER :block
    41 jump *label6 always
 
    44 jump *label14 equal *tmp5 @container
    45 jump *label14 equal *tmp5 @core-shard
    46 jump *label14 equal *tmp5 @core-foundation
-    * jump *label14 equal *tmp5 @core-nucleus
-    * jump *label13 always
+   47 jump *label13 notEqual *tmp5 @core-nucleus
    48 label *label14
    49 set .CONTAINER :block
    50 set .SENSOR @totalItems
 
    54 label *label13
    55 jump *label16 equal *tmp5 @liquid-tank
    56 jump *label16 equal *tmp5 @liquid-container
-    * jump *label16 equal *tmp5 @liquid-router
-    * jump *label15 always
+   57 jump *label15 notEqual *tmp5 @liquid-router
    58 label *label16
    59 set .CONTAINER :block
    60 set .SENSOR @totalLiquids
 
    63 jump *label6 always
    64 label *label15
    65 jump *label18 equal *tmp5 @battery
-    * jump *label18 equal *tmp5 @battery-large
-    * jump *label17 always
+   66 jump *label17 notEqual *tmp5 @battery-large
    67 label *label18
    68 set .CONTAINER :block
    69 set .SENSOR @totalPower
 
    73 label *label17
    74 jump *label20 equal *tmp5 @power-node
    75 jump *label20 equal *tmp5 @power-node-large
-    * jump *label20 equal *tmp5 @surge-tower
-    * jump *label19 always
+   76 jump *label19 notEqual *tmp5 @surge-tower
    77 label *label20
    78 set .CONTAINER :block
    79 set .SENSOR @powerNetStored

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-10 instructions):
 
    15 print "\n"
    16 set :n @links
    17 label *label3
-    * op greaterThan *tmp1 :n 0
-    * jump *label5 equal *tmp1 false
+   18 jump *label5 lessThanEq :n 0
    19 op sub :n :n 1
    20 getlink :block :n
    21 print "Found: "
 
    96 print "Container: "
    97 print .CONTAINER
    98 print "\n"
-    * op equal *tmp11 .CONTAINER null
-    * jump *label21 equal *tmp11 false
+   99 jump *label21 notEqual .CONTAINER null
   100 print "No container."
   101 print "\n"
   102 jump *label22 always
 
   104 label *label22
   105 printflush .MESSAGE
   106 label *label1
-    * op equal *tmp13 .CONTAINER null
-    * jump *label0 notEqual *tmp13 false
+  107 jump *label0 equal .CONTAINER null
   108 label *label2
   109 sensor *tmp14 .SORTER @type
   110 op strictEqual .INVERTED *tmp14 @inverted-sorter
   111 set :setState:newState true
-    * op notEqual *tmp17 .STATE :setState:newState
-    * jump *label24 equal *tmp17 false
+  112 jump *label24 equal .STATE :setState:newState
   113 set .STATE :setState:newState
   114 op add .CYCLES .CYCLES 1
   115 op xor .ON .INVERTED .STATE
 
   127 control enabled .SWITCH 0
   128 label *label28
   129 sensor *tmp23 .SWITCH @enabled
-    * op equal *tmp24 *tmp23 0
-    * jump *label30 equal *tmp24 false
+  130 jump *label30 notEqual *tmp23 0
   131 set :start @time
   132 sensor :item .SORTER @config
   133 op equal *tmp27 :item null
 
   149 sensor :amount .CONTAINER :item
   150 op mul *tmp33 100 :amount
   151 op idiv :pct *tmp33 :max
-    * op lessThanEq *tmp35 :pct PCT_LOW
-    * jump *label33 equal *tmp35 false
+  152 jump *label33 greaterThan :pct PCT_LOW
   153 set :setState.1:newState true
-    * op notEqual *tmp38 .STATE :setState.1:newState
-    * jump *label36 equal *tmp38 false
+  154 jump *label36 equal .STATE :setState.1:newState
   155 set .STATE :setState.1:newState
   156 op add .CYCLES .CYCLES 1
   157 op xor .ON .INVERTED .STATE
 
   168 label *label35
   169 jump *label34 always
   170 label *label33
-    * op greaterThanEq *tmp42 :pct PCT_HIGH
-    * jump *label40 equal *tmp42 false
+  171 jump *label40 lessThan :pct PCT_HIGH
   172 set :setState.2:newState false
-    * op notEqual *tmp45 .STATE :setState.2:newState
-    * jump *label43 equal *tmp45 false
+  173 jump *label43 equal .STATE :setState.2:newState
   174 set .STATE :setState.2:newState
   175 op add .CYCLES .CYCLES 1
   176 op xor .ON .INVERTED .STATE
 
   221 print .ACTIVE_TEXT
   222 set :n .START
   223 label *label49
-    * op lessThan *tmp50 :n @links
-    * jump *label51 equal *tmp50 false
+  224 jump *label51 greaterThanEq :n @links
   225 getlink :block :n
   226 control enabled :block .ON
   227 print "\n    "

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-6 instructions):
 
    78 set .SENSOR @powerNetStored
    79 set .MAXIMUM @powerNetCapacity
    80 op add .START :n 1
-    * jump *label6 always
    81 label *label19
    82 label *label6
    83 label *label4
 
    98 jump *label21 notEqual .CONTAINER null
    99 print "No container."
   100 print "\n"
-    * jump *label22 always
   101 label *label21
   102 label *label22
   103 printflush .MESSAGE
 
   118 set *tmp20 "\nCurrently inactive:[salmon]"
   119 label *label27
   120 set .ACTIVE_TEXT *tmp20
-    * jump *label25 always
   121 label *label24
   122 label *label25
   123 label *label23
 
   159 set *tmp41 "\nCurrently inactive:[salmon]"
   160 label *label39
   161 set .ACTIVE_TEXT *tmp41
-    * jump *label37 always
   162 label *label36
   163 label *label37
   164 label *label35
 
   177 set *tmp48 "\nCurrently inactive:[salmon]"
   178 label *label46
   179 set .ACTIVE_TEXT *tmp48
-    * jump *label44 always
   180 label *label43
   181 label *label44
   182 label *label42
-    * jump *label41 always
   183 label *label40
   184 label *label41
   185 label *label34

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set .CONTAINER null
     3 set .SORTER null
     4 set .SWITCH null
-    * set .STATE .SWITCH
-    * set .START .STATE
-    * set .SENSOR .START
-    * set .ON .SENSOR
-    * set .MESSAGE .ON
-    * set .MAXIMUM .MESSAGE
-    * set .ACTIVE_TEXT .MAXIMUM
+    5 set .STATE null
+    6 set .START .SWITCH
+    7 set .SENSOR .STATE
+    8 set .ON .START
+    9 set .MESSAGE .SENSOR
+   10 set .MAXIMUM .ON
+   11 set .ACTIVE_TEXT .MESSAGE
    12 set .CYCLES 0
    13 label *label0
    14 print "Configuring regulator..."
 
   107 sensor *tmp14 .SORTER @type
   108 op strictEqual .INVERTED *tmp14 @inverted-sorter
   109 set :setState:newState true
-    * jump *label24 equal .STATE :setState:newState
-    * set .STATE :setState:newState
-    * op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  110 jump *label24 equal .STATE true
+  111 set .STATE true
+  112 op add .CYCLES 0 1
+  113 op xor .ON .INVERTED :setState:newState
   114 jump *label26 equal .ON false
   115 set *tmp20 "\nCurrently active:[green]"
   116 jump *label27 always
 
   148 op idiv :pct *tmp33 :max
   149 jump *label33 greaterThan :pct PCT_LOW
   150 set :setState.1:newState true
-    * jump *label36 equal .STATE :setState.1:newState
-    * set .STATE :setState.1:newState
+  151 jump *label36 equal .STATE true
+  152 set .STATE true
   153 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  154 op xor .ON .INVERTED :setState.1:newState
   155 jump *label38 equal .ON false
   156 set *tmp41 "\nCurrently active:[green]"
   157 jump *label39 always
 
   166 label *label33
   167 jump *label40 lessThan :pct PCT_HIGH
   168 set :setState.2:newState false
-    * jump *label43 equal .STATE :setState.2:newState
-    * set .STATE :setState.2:newState
+  169 jump *label43 equal .STATE false
+  170 set .STATE false
   171 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  172 op xor .ON .INVERTED :setState.2:newState
   173 jump *label45 equal .ON false
   174 set *tmp48 "\nCurrently active:[green]"
   175 jump *label46 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
 
     3 set .SORTER null
     4 set .SWITCH null
     5 set .STATE null
-    * set .START .SWITCH
-    * set .SENSOR .STATE
-    * set .ON .START
-    * set .MESSAGE .SENSOR
-    * set .MAXIMUM .ON
-    * set .ACTIVE_TEXT .MESSAGE
-    * set .CYCLES 0
+    6 set .START null
+    7 set .SENSOR null
+    8 set .ON .SWITCH
+    9 set .MESSAGE .STATE
+   10 set .MAXIMUM .START
+   11 set .ACTIVE_TEXT .SENSOR
    12 label *label0
    13 print "Configuring regulator..."
    14 print "\n"
 
   106 sensor *tmp14 .SORTER @type
   107 op strictEqual .INVERTED *tmp14 @inverted-sorter
   108 set :setState:newState true
-    * jump *label24 equal .STATE true
+  109 jump *label24 equal null true
   110 set .STATE true
   111 op add .CYCLES 0 1
-    * op xor .ON .INVERTED :setState:newState
+  112 op xor .ON .INVERTED true
   113 jump *label26 equal .ON false
   114 set *tmp20 "\nCurrently active:[green]"
   115 jump *label27 always
 
   150 jump *label36 equal .STATE true
   151 set .STATE true
   152 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.1:newState
+  153 op xor .ON .INVERTED true
   154 jump *label38 equal .ON false
   155 set *tmp41 "\nCurrently active:[green]"
   156 jump *label39 always
 
   168 jump *label43 equal .STATE false
   169 set .STATE false
   170 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.2:newState
+  171 op xor .ON .INVERTED false
   172 jump *label45 equal .ON false
   173 set *tmp48 "\nCurrently active:[green]"
   174 jump *label46 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
     5 set .STATE null
     6 set .START null
     7 set .SENSOR null
-    * set .ON .SWITCH
-    * set .MESSAGE .STATE
-    * set .MAXIMUM .START
-    * set .ACTIVE_TEXT .SENSOR
+    8 set .ON null
+    9 set .MESSAGE null
+   10 set .MAXIMUM null
+   11 set .ACTIVE_TEXT null
    12 label *label0
    13 print "Configuring regulator..."
    14 print "\n"
 
   105 label *label2
   106 sensor *tmp14 .SORTER @type
   107 op strictEqual .INVERTED *tmp14 @inverted-sorter
-    * set :setState:newState true
   108 jump *label24 equal null true
   109 set .STATE true
   110 op add .CYCLES 0 1
 
   145 op mul *tmp33 100 :amount
   146 op idiv :pct *tmp33 :max
   147 jump *label33 greaterThan :pct PCT_LOW
-    * set :setState.1:newState true
   148 jump *label36 equal .STATE true
   149 set .STATE true
   150 op add .CYCLES .CYCLES 1
 
   162 jump *label34 always
   163 label *label33
   164 jump *label40 lessThan :pct PCT_HIGH
-    * set :setState.2:newState false
   165 jump *label43 equal .STATE false
   166 set .STATE false
   167 op add .CYCLES .CYCLES 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4 (-3 instructions):
 
     2 set .CONTAINER null
     3 set .SORTER null
     4 set .SWITCH null
-    * set .STATE null
     5 set .START null
     6 set .SENSOR null
-    * set .ON null
     7 set .MESSAGE null
     8 set .MAXIMUM null
-    * set .ACTIVE_TEXT null
     9 label *label0
    10 print "Configuring regulator..."
    11 print "\n"

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    12 set :n @links
    13 label *label3
    14 jump *label5 lessThanEq :n 0
+   15 label *label52
    16 op sub :n :n 1
    17 getlink :block :n
    18 print "Found: "
 
    78 label *label19
    79 label *label6
    80 label *label4
-    * jump *label3 always
+   81 jump *label52 greaterThan :n 0
    82 label *label5
    83 print "Message: "
    84 print .MESSAGE
 
   210 set :n .START
   211 label *label49
   212 jump *label51 greaterThanEq :n @links
+  213 label *label53
   214 getlink :block :n
   215 control enabled :block .ON
   216 print "\n    "
   217 print :block
   218 op add :n :n 1
   219 label *label50
-    * jump *label49 always
+  220 jump *label53 lessThan :n @links
   221 label *label51
   222 print "[]"
   223 print "\n"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-9 instructions):
 
   107 set .STATE true
   108 op add .CYCLES 0 1
   109 op xor .ON .INVERTED true
-    * jump *label26 equal .ON false
-    * set *tmp20 "\nCurrently active:[green]"
-    * jump *label27 always
-    * label *label26
-    * set *tmp20 "\nCurrently inactive:[salmon]"
-    * label *label27
+  110 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   111 set .ACTIVE_TEXT *tmp20
   112 label *label24
   113 label *label25
 
   142 set .STATE true
   143 op add .CYCLES .CYCLES 1
   144 op xor .ON .INVERTED true
-    * jump *label38 equal .ON false
-    * set *tmp41 "\nCurrently active:[green]"
-    * jump *label39 always
-    * label *label38
-    * set *tmp41 "\nCurrently inactive:[salmon]"
-    * label *label39
+  145 select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   146 set .ACTIVE_TEXT *tmp41
   147 label *label36
   148 label *label37
 
   154 set .STATE false
   155 op add .CYCLES .CYCLES 1
   156 op xor .ON .INVERTED false
-    * jump *label45 equal .ON false
-    * set *tmp48 "\nCurrently active:[green]"
-    * jump *label46 always
-    * label *label45
-    * set *tmp48 "\nCurrently inactive:[salmon]"
-    * label *label46
+  157 select *tmp48 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   158 set .ACTIVE_TEXT *tmp48
   159 label *label43
   160 label *label44

Modifications by Replicate loop condition at line 72:1 (+1 instructions):
 
   116 label *label28
   117 sensor *tmp23 .SWITCH @enabled
   118 jump *label30 notEqual *tmp23 0
+  119 label *label54
   120 set :start @time
   121 sensor :item .SORTER @config
   122 op equal *tmp27 :item null
 
   218 print "ms"
   219 printflush .MESSAGE
   220 label *label29
-    * jump *label28 always
+  221 sensor *tmp23 .SWITCH @enabled
+  222 jump *label54 equal *tmp23 0
   223 label *label30
   224 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   195 print .ACTIVE_TEXT
   196 set :n .START
   197 label *label49
-    * jump *label51 greaterThanEq :n @links
+  198 jump *label51 greaterThanEq .START @links
   199 label *label53
   200 getlink :block :n
   201 control enabled :block .ON

Modifications by Convert case at line 26:9 (segments: 1, padded low) (-15 instructions):
 
    19 print :block
    20 print "\n"
    21 sensor *tmp5 :block @type
-    * jump *label7 notEqual *tmp5 @message
+   22 sensor *tmp71 *tmp5 @id
+   23 jump *label55 greaterThanEq *tmp71 147
+   24 multijump *tmp71 0 0 (m:*label56)
+   25 multilabel *label63 (m:*label56)
    26 label *label8
    27 set .MESSAGE :block
    28 jump *label6 always
    29 label *label7
-    * jump *label9 notEqual *tmp5 @switch
+   30 multilabel *label64 (m:*label56)
    31 label *label10
    32 set .SWITCH :block
    33 jump *label6 always
    34 label *label9
-    * jump *label12 equal *tmp5 @sorter
-    * jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label11 notEqual *tmp5 @unloader
+   35 multilabel *label58 (m:*label56)
    36 label *label12
    37 set .SORTER :block
    38 jump *label6 always
    39 label *label11
-    * jump *label14 equal *tmp5 @vault
-    * jump *label14 equal *tmp5 @container
-    * jump *label14 equal *tmp5 @core-shard
-    * jump *label14 equal *tmp5 @core-foundation
-    * jump *label13 notEqual *tmp5 @core-nucleus
+   40 multilabel *label62 (m:*label56)
    41 label *label14
    42 set .CONTAINER :block
    43 set .SENSOR @totalItems
 
    45 op add .START :n 1
    46 jump *label6 always
    47 label *label13
-    * jump *label16 equal *tmp5 @liquid-tank
-    * jump *label16 equal *tmp5 @liquid-container
-    * jump *label15 notEqual *tmp5 @liquid-router
+   48 multilabel *label59 (m:*label56)
    49 label *label16
    50 set .CONTAINER :block
    51 set .SENSOR @totalLiquids
 
    53 op add .START :n 1
    54 jump *label6 always
    55 label *label15
-    * jump *label18 equal *tmp5 @battery
-    * jump *label17 notEqual *tmp5 @battery-large
+   56 multilabel *label61 (m:*label56)
    57 label *label18
    58 set .CONTAINER :block
    59 set .SENSOR @totalPower
 
    61 op add .START :n 1
    62 jump *label6 always
    63 label *label17
-    * jump *label20 equal *tmp5 @power-node
-    * jump *label20 equal *tmp5 @power-node-large
-    * jump *label19 notEqual *tmp5 @surge-tower
+   64 multilabel *label60 (m:*label56)
    65 label *label20
    66 set .CONTAINER :block
    67 set .SENSOR @powerNetStored
    68 set .MAXIMUM @powerNetCapacity
    69 op add .START :n 1
    70 label *label19
+   71 multilabel *label57 (m:*label56)
+   72 label *label55
    73 label *label6
    74 label *label4
    75 jump *label52 greaterThan :n 0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
    97 label *label2
    98 sensor *tmp14 .SORTER @type
    99 op strictEqual .INVERTED *tmp14 @inverted-sorter
-    * jump *label24 equal null true
   100 set .STATE true
   101 op add .CYCLES 0 1
   102 op xor .ON .INVERTED true

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
    98 sensor *tmp14 .SORTER @type
    99 op strictEqual .INVERTED *tmp14 @inverted-sorter
   100 set .STATE true
-    * op add .CYCLES 0 1
+  101 set .CYCLES 1
   102 op xor .ON .INVERTED true
   103 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   104 set .ACTIVE_TEXT *tmp20
 
   147 jump *label43 equal .STATE false
   148 set .STATE false
   149 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED false
+  150 set .ON .INVERTED
   151 select *tmp48 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   152 set .ACTIVE_TEXT *tmp48
   153 label *label43

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   148 set .STATE false
   149 op add .CYCLES .CYCLES 1
   150 set .ON .INVERTED
-    * select *tmp48 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
+  151 select *tmp48 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   152 set .ACTIVE_TEXT *tmp48
   153 label *label43
   154 label *label44

Modifications by Iterated phase, Temp Variables Elimination, pass 2, iteration 1 (-3 instructions):
 
   100 set .STATE true
   101 set .CYCLES 1
   102 op xor .ON .INVERTED true
-    * select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * set .ACTIVE_TEXT *tmp20
+  103 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   104 label *label24
   105 label *label25
   106 label *label23
 
   135 set .STATE true
   136 op add .CYCLES .CYCLES 1
   137 op xor .ON .INVERTED true
-    * select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * set .ACTIVE_TEXT *tmp41
+  138 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   139 label *label36
   140 label *label37
   141 label *label35
 
   146 set .STATE false
   147 op add .CYCLES .CYCLES 1
   148 set .ON .INVERTED
-    * select *tmp48 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * set .ACTIVE_TEXT *tmp48
+  149 select .ACTIVE_TEXT notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   150 label *label43
   151 label *label44
   152 label *label42

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    10 print "Configuring regulator..."
    11 print "\n"
    12 set :n @links
-    * label *label3
    13 jump *label5 lessThanEq :n 0
    14 label *label52
    15 op sub :n :n 1
 
    22 jump *label55 greaterThanEq *tmp71 147
    23 multijump *tmp71 0 0 (m:*label56)
    24 multilabel *label63 (m:*label56)
-    * label *label8
    25 set .MESSAGE :block
    26 jump *label6 always
-    * label *label7
    27 multilabel *label64 (m:*label56)
-    * label *label10
    28 set .SWITCH :block
    29 jump *label6 always
-    * label *label9
    30 multilabel *label58 (m:*label56)
-    * label *label12
    31 set .SORTER :block
    32 jump *label6 always
-    * label *label11
    33 multilabel *label62 (m:*label56)
-    * label *label14
    34 set .CONTAINER :block
    35 set .SENSOR @totalItems
    36 set .MAXIMUM @itemCapacity
    37 op add .START :n 1
    38 jump *label6 always
-    * label *label13
    39 multilabel *label59 (m:*label56)
-    * label *label16
    40 set .CONTAINER :block
    41 set .SENSOR @totalLiquids
    42 set .MAXIMUM @liquidCapacity
    43 op add .START :n 1
    44 jump *label6 always
-    * label *label15
    45 multilabel *label61 (m:*label56)
-    * label *label18
    46 set .CONTAINER :block
    47 set .SENSOR @totalPower
    48 set .MAXIMUM @powerCapacity
    49 op add .START :n 1
    50 jump *label6 always
-    * label *label17
    51 multilabel *label60 (m:*label56)
-    * label *label20
    52 set .CONTAINER :block
    53 set .SENSOR @powerNetStored
    54 set .MAXIMUM @powerNetCapacity
    55 op add .START :n 1
-    * label *label19
    56 multilabel *label57 (m:*label56)
    57 label *label55
    58 label *label6
-    * label *label4
    59 jump *label52 greaterThan :n 0
    60 label *label5
    61 print "Message: "
 
    74 print "No container."
    75 print "\n"
    76 label *label21
-    * label *label22
    77 printflush .MESSAGE
-    * label *label1
    78 jump *label0 equal .CONTAINER null
-    * label *label2
    79 sensor *tmp14 .SORTER @type
    80 op strictEqual .INVERTED *tmp14 @inverted-sorter
    81 set .STATE true
    82 set .CYCLES 1
    83 op xor .ON .INVERTED true
    84 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label24
-    * label *label25
-    * label *label23
    85 control enabled .SWITCH 0
-    * label *label28
    86 sensor *tmp23 .SWITCH @enabled
    87 jump *label30 notEqual *tmp23 0
    88 label *label54
 
   114 op xor .ON .INVERTED true
   115 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   116 label *label36
-    * label *label37
-    * label *label35
   117 jump *label34 always
   118 label *label33
   119 jump *label40 lessThan :pct PCT_HIGH
 
   123 set .ON .INVERTED
   124 select .ACTIVE_TEXT notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   125 label *label43
-    * label *label44
-    * label *label42
   126 label *label40
-    * label *label41
   127 label *label34
   128 print "\n"
   129 print "Level: [gold]"
 
   156 label *label48
   157 print .ACTIVE_TEXT
   158 set :n .START
-    * label *label49
   159 jump *label51 greaterThanEq .START @links
   160 label *label53
   161 getlink :block :n
 
   163 print "\n    "
   164 print :block
   165 op add :n :n 1
-    * label *label50
   166 jump *label53 lessThan :n @links
   167 label *label51
   168 print "[]"
 
   177 print " "
   178 print "ms"
   179 printflush .MESSAGE
-    * label *label29
   180 sensor *tmp23 .SWITCH @enabled
   181 jump *label54 equal *tmp23 0
   182 label *label30

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 set PCT_LOW 60
     2 set PCT_HIGH 80
     3 set .CONTAINER null
 
    85 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
    86 control enabled .SWITCH 0
    87 sensor *tmp23 .SWITCH @enabled
-    * jump *label30 notEqual *tmp23 0
+   88 jump __start__ notEqual *tmp23 0
    89 label *label54
    90 set :start @time
    91 sensor :item .SORTER @config
 
   109 op mul *tmp33 100 :amount
   110 op idiv :pct *tmp33 :max
   111 jump *label33 greaterThan :pct PCT_LOW
-    * jump *label36 equal .STATE true
+  112 jump *label34 equal .STATE true
   113 set .STATE true
   114 op add .CYCLES .CYCLES 1
   115 op xor .ON .INVERTED true

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1:
 
   114 op add .CYCLES .CYCLES 1
   115 op xor .ON .INVERTED true
   116 select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label36
   117 jump *label34 always
   118 label *label33
   119 jump *label40 lessThan :pct PCT_HIGH
 
   179 printflush .MESSAGE
   180 sensor *tmp23 .SWITCH @enabled
   181 jump *label54 equal *tmp23 0
-    * label *label30
   182 end

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   179 printflush .MESSAGE
   180 sensor *tmp23 .SWITCH @enabled
   181 jump *label54 equal *tmp23 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-35 instructions):
 
     8 set .MESSAGE null
     9 set .MAXIMUM null
    10 label *label0
-    * print "Configuring regulator..."
-    * print "\n"
+   11 print "Configuring regulator...\n"
    12 set :n @links
    13 jump *label5 lessThanEq :n 0
    14 label *label52
    15 op sub :n :n 1
    16 getlink :block :n
-    * print "Found: "
-    * print :block
-    * print "\n"
+   17 print "Found: {0}\n"
+   18 format :block
    19 sensor *tmp5 :block @type
    20 sensor *tmp71 *tmp5 @id
    21 jump *label55 greaterThanEq *tmp71 147
 
    57 label *label6
    58 jump *label52 greaterThan :n 0
    59 label *label5
-    * print "Message: "
-    * print .MESSAGE
-    * print "\n"
-    * print "Switch: "
-    * print .SWITCH
-    * print "\n"
-    * print "Sorter: "
-    * print .SORTER
-    * print "\n"
-    * print "Container: "
-    * print .CONTAINER
-    * print "\n"
+   60 print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
+   61 format .MESSAGE
+   62 format .SWITCH
+   63 format .SORTER
+   64 format .CONTAINER
    65 jump *label21 notEqual .CONTAINER null
-    * print "No container."
-    * print "\n"
+   66 print "No container.\n"
    67 label *label21
    68 printflush .MESSAGE
    69 jump *label0 equal .CONTAINER null
 
    88 print .CONTAINER
    89 jump *label32 always
    90 label *label31
-    * print "Measuring [gold]"
-    * print :item
-    * print "["
-    * print "] in "
+   91 print "Measuring [gold]{0}[] in "
+   92 format :item
    93 print .CONTAINER
    94 label *label32
    95 sensor :max .CONTAINER .MAXIMUM
 
   113 label *label43
   114 label *label40
   115 label *label34
-    * print "\n"
-    * print "Level: [gold]"
-    * print :pct
-    * print "%"
-    * print "[]"
+  116 print "\nLevel: [gold]{0}%[]"
+  117 format :pct
   118 jump *label47 equal .INVERTED false
-    * print "\n"
-    * print "Activate above [green]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate below [salmon]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
+  119 print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
+  120 format PCT_HIGH
+  121 format PCT_LOW
   122 jump *label48 always
   123 label *label47
-    * print "\n"
-    * print "Activate below [green]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate above [salmon]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
+  124 print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
+  125 format PCT_LOW
+  126 format PCT_HIGH
   127 label *label48
   128 print .ACTIVE_TEXT
   129 set :n .START
 
   136 op add :n :n 1
   137 jump *label53 lessThan :n @links
   138 label *label51
-    * print "[]"
-    * print "\n"
-    * print "# of cycles: "
-    * print .CYCLES
+  139 print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
+  140 format .CYCLES
   141 op sub *tmp54 @time :start
   142 op floor *tmp55 *tmp54
-    * print "\n"
-    * print "[lightgray]Loop: "
-    * print *tmp55
-    * print " "
-    * print "ms"
+  143 format *tmp55
   144 printflush .MESSAGE
   145 sensor *tmp23 .SWITCH @enabled
   146 jump *label54 equal *tmp23 0

Final code before resolving virtual instructions:

label __start__
set PCT_LOW 60
set PCT_HIGH 80
set .CONTAINER null
set .SORTER null
set .SWITCH null
set .START null
set .SENSOR null
set .MESSAGE null
set .MAXIMUM null
label *label0
print "Configuring regulator...\n"
set :n @links
jump *label5 lessThanEq :n 0
label *label52
op sub :n :n 1
getlink :block :n
print "Found: {0}\n"
format :block
sensor *tmp5 :block @type
sensor *tmp71 *tmp5 @id
jump *label55 greaterThanEq *tmp71 147
multijump *tmp71 0 0
multilabel *label63
set .MESSAGE :block
jump *label6 always
multilabel *label64
set .SWITCH :block
jump *label6 always
multilabel *label58
set .SORTER :block
jump *label6 always
multilabel *label62
set .CONTAINER :block
set .SENSOR @totalItems
set .MAXIMUM @itemCapacity
op add .START :n 1
jump *label6 always
multilabel *label59
set .CONTAINER :block
set .SENSOR @totalLiquids
set .MAXIMUM @liquidCapacity
op add .START :n 1
jump *label6 always
multilabel *label61
set .CONTAINER :block
set .SENSOR @totalPower
set .MAXIMUM @powerCapacity
op add .START :n 1
jump *label6 always
multilabel *label60
set .CONTAINER :block
set .SENSOR @powerNetStored
set .MAXIMUM @powerNetCapacity
op add .START :n 1
multilabel *label57
label *label55
label *label6
jump *label52 greaterThan :n 0
label *label5
print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
format .MESSAGE
format .SWITCH
format .SORTER
format .CONTAINER
jump *label21 notEqual .CONTAINER null
print "No container.\n"
label *label21
printflush .MESSAGE
jump *label0 equal .CONTAINER null
sensor *tmp14 .SORTER @type
op strictEqual .INVERTED *tmp14 @inverted-sorter
set .STATE true
set .CYCLES 1
op xor .ON .INVERTED true
select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
control enabled .SWITCH 0
sensor *tmp23 .SWITCH @enabled
jump __start__ notEqual *tmp23 0
label *label54
set :start @time
sensor :item .SORTER @config
op equal *tmp27 :item null
op notEqual *tmp28 .SENSOR @totalItems
op or *tmp29 *tmp27 *tmp28
jump *label31 equal *tmp29 false
set :item .SENSOR
print "Measuring [gold]total[] in "
print .CONTAINER
jump *label32 always
label *label31
print "Measuring [gold]{0}[] in "
format :item
print .CONTAINER
label *label32
sensor :max .CONTAINER .MAXIMUM
sensor :amount .CONTAINER :item
op mul *tmp33 100 :amount
op idiv :pct *tmp33 :max
jump *label33 greaterThan :pct PCT_LOW
jump *label34 equal .STATE true
set .STATE true
op add .CYCLES .CYCLES 1
op xor .ON .INVERTED true
select .ACTIVE_TEXT notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
jump *label34 always
label *label33
jump *label40 lessThan :pct PCT_HIGH
jump *label43 equal .STATE false
set .STATE false
op add .CYCLES .CYCLES 1
set .ON .INVERTED
select .ACTIVE_TEXT notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
label *label43
label *label40
label *label34
print "\nLevel: [gold]{0}%[]"
format :pct
jump *label47 equal .INVERTED false
print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
format PCT_HIGH
format PCT_LOW
jump *label48 always
label *label47
print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
format PCT_LOW
format PCT_HIGH
label *label48
print .ACTIVE_TEXT
set :n .START
jump *label51 greaterThanEq .START @links
label *label53
getlink :block :n
control enabled :block .ON
print "\n    "
print :block
op add :n :n 1
jump *label53 lessThan :n @links
label *label51
print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
format .CYCLES
op sub *tmp54 @time :start
op floor *tmp55 *tmp54
format *tmp55
printflush .MESSAGE
sensor *tmp23 .SWITCH @enabled
jump *label54 equal *tmp23 0
