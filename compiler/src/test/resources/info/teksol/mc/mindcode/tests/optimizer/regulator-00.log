   261 instructions before optimizations.
    19 instructions eliminated by Temp Variables Elimination (2 iterations).
     1 instructions eliminated by Case Expression Optimization.
    27 instructions eliminated by Dead Code Elimination (7 iterations).
     1 instructions eliminated by Jump Normalization (5 iterations).
    10 instructions eliminated by Jump Optimization (5 iterations).
     7 instructions eliminated by Single Step Elimination (2 passes, 7 iterations).
     2 instructions modified by Expression Optimization (3 iterations).
     9 instructions eliminated by If Expression Optimization (3 iterations).
     3 instructions eliminated by Data Flow Optimization (3 passes, 10 iterations).
     1 instructions added by Loop Optimization (3 iterations).
     3 loops improved by Loop Optimization.
    15 instructions eliminated by Case Switching (5 iterations).
     1 case expressions converted to switched jumps Case Switching.
     7 instructions eliminated by Jump Straightening (5 iterations).
     2 instructions updated by Jump Threading.
    35 instructions eliminated by Print Merging.
   128 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 821):
  * Replicate loop condition at line 72:1                        size    +1, benefit       25.0, efficiency     25.000 (+1 instructions)
  o Convert case at line 26:9 (segments: 1, padded low)          size   -15, benefit     4062.5, efficiency   Infinity

Pass 1: speed optimization selection (cost limit 820):
  * Convert case at line 26:9 (segments: 1, padded low)          size   -15, benefit     4062.5, efficiency   Infinity (-15 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    26 print :block
    27 print "\n"
    28 sensor *tmp5 :block @type
-    * set *tmp6 *tmp5
-    * jump *label8 equal *tmp6 @message
+   29 jump *label8 equal *tmp5 @message
    30 jump *label7 always
    31 label *label8
    32 set .MESSAGE :block
    33 set *tmp4 .MESSAGE
    34 jump *label6 always
    35 label *label7
-    * jump *label10 equal *tmp6 @switch
+   36 jump *label10 equal *tmp5 @switch
    37 jump *label9 always
    38 label *label10
    39 set .SWITCH :block
    40 set *tmp4 .SWITCH
    41 jump *label6 always
    42 label *label9
-    * jump *label12 equal *tmp6 @sorter
-    * jump *label12 equal *tmp6 @inverted-sorter
-    * jump *label12 equal *tmp6 @unloader
+   43 jump *label12 equal *tmp5 @sorter
+   44 jump *label12 equal *tmp5 @inverted-sorter
+   45 jump *label12 equal *tmp5 @unloader
    46 jump *label11 always
    47 label *label12
    48 set .SORTER :block
    49 set *tmp4 .SORTER
    50 jump *label6 always
    51 label *label11
-    * jump *label14 equal *tmp6 @vault
-    * jump *label14 equal *tmp6 @container
-    * jump *label14 equal *tmp6 @core-shard
-    * jump *label14 equal *tmp6 @core-foundation
-    * jump *label14 equal *tmp6 @core-nucleus
+   52 jump *label14 equal *tmp5 @vault
+   53 jump *label14 equal *tmp5 @container
+   54 jump *label14 equal *tmp5 @core-shard
+   55 jump *label14 equal *tmp5 @core-foundation
+   56 jump *label14 equal *tmp5 @core-nucleus
    57 jump *label13 always
    58 label *label14
    59 set .CONTAINER :block
 
    64 set *tmp4 .START
    65 jump *label6 always
    66 label *label13
-    * jump *label16 equal *tmp6 @liquid-tank
-    * jump *label16 equal *tmp6 @liquid-container
-    * jump *label16 equal *tmp6 @liquid-router
+   67 jump *label16 equal *tmp5 @liquid-tank
+   68 jump *label16 equal *tmp5 @liquid-container
+   69 jump *label16 equal *tmp5 @liquid-router
    70 jump *label15 always
    71 label *label16
    72 set .CONTAINER :block
 
    77 set *tmp4 .START
    78 jump *label6 always
    79 label *label15
-    * jump *label18 equal *tmp6 @battery
-    * jump *label18 equal *tmp6 @battery-large
+   80 jump *label18 equal *tmp5 @battery
+   81 jump *label18 equal *tmp5 @battery-large
    82 jump *label17 always
    83 label *label18
    84 set .CONTAINER :block
 
    89 set *tmp4 .START
    90 jump *label6 always
    91 label *label17
-    * jump *label20 equal *tmp6 @power-node
-    * jump *label20 equal *tmp6 @power-node-large
-    * jump *label20 equal *tmp6 @surge-tower
+   92 jump *label20 equal *tmp5 @power-node
+   93 jump *label20 equal *tmp5 @power-node-large
+   94 jump *label20 equal *tmp5 @surge-tower
    95 jump *label19 always
    96 label *label20
    97 set .CONTAINER :block

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-17 instructions):
 
    30 jump *label7 always
    31 label *label8
    32 set .MESSAGE :block
-    * set *tmp4 .MESSAGE
    33 jump *label6 always
    34 label *label7
    35 jump *label10 equal *tmp5 @switch
    36 jump *label9 always
    37 label *label10
    38 set .SWITCH :block
-    * set *tmp4 .SWITCH
    39 jump *label6 always
    40 label *label9
    41 jump *label12 equal *tmp5 @sorter
 
    44 jump *label11 always
    45 label *label12
    46 set .SORTER :block
-    * set *tmp4 .SORTER
    47 jump *label6 always
    48 label *label11
    49 jump *label14 equal *tmp5 @vault
 
    58 set .MAXIMUM @itemCapacity
    59 op add *tmp7 :n 1
    60 set .START *tmp7
-    * set *tmp4 .START
    61 jump *label6 always
    62 label *label13
    63 jump *label16 equal *tmp5 @liquid-tank
 
    70 set .MAXIMUM @liquidCapacity
    71 op add *tmp8 :n 1
    72 set .START *tmp8
-    * set *tmp4 .START
    73 jump *label6 always
    74 label *label15
    75 jump *label18 equal *tmp5 @battery
 
    81 set .MAXIMUM @powerCapacity
    82 op add *tmp9 :n 1
    83 set .START *tmp9
-    * set *tmp4 .START
    84 jump *label6 always
    85 label *label17
    86 jump *label20 equal *tmp5 @power-node
 
    93 set .MAXIMUM @powerNetCapacity
    94 op add *tmp10 :n 1
    95 set .START *tmp10
-    * set *tmp4 .START
    96 jump *label6 always
    97 label *label19
-    * set *tmp4 null
    98 label *label6
    99 label *label4
   100 jump *label3 always
 
   115 jump *label21 equal *tmp11 false
   116 print "No container."
   117 print "\n"
-    * set *tmp12 "No container."
   118 jump *label22 always
   119 label *label21
-    * set *tmp12 null
   120 label *label22
   121 printflush .MESSAGE
   122 label *label1
 
   145 label *label24
   146 set *tmp18 null
   147 label *label25
-    * set *tmp16 *tmp18
   148 label *label23
   149 set *tmp21 .SWITCH
   150 control enabled *tmp21 0
 
   163 set :item .SENSOR
   164 print "Measuring [gold]total[] in "
   165 print .CONTAINER
-    * set *tmp30 null
   166 jump *label32 always
   167 label *label31
   168 print "Measuring [gold]"
 
   170 print "["
   171 print "] in "
   172 print .CONTAINER
-    * set *tmp30 null
   173 label *label32
   174 sensor *tmp31 .CONTAINER .MAXIMUM
   175 set :max *tmp31
 
   201 label *label37
   202 set *tmp37 *tmp39
   203 label *label35
-    * set *tmp36 *tmp37
   204 jump *label34 always
   205 label *label33
   206 op greaterThanEq *tmp42 :pct PCT_HIGH
 
   231 label *label40
   232 set *tmp43 null
   233 label *label41
-    * set *tmp36 *tmp43
   234 label *label34
   235 print "\n"
   236 print "Level: [gold]"
 
   248 print PCT_LOW
   249 print "%"
   250 print "[]"
-    * set *tmp49 null
   251 jump *label48 always
   252 label *label47
   253 print "\n"
 
   260 print PCT_HIGH
   261 print "%"
   262 print "[]"
-    * set *tmp49 null
   263 label *label48
   264 print .ACTIVE_TEXT
   265 set :n .START

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-5 instructions):
 
   140 set *tmp20 "\nCurrently inactive:[salmon]"
   141 label *label27
   142 set .ACTIVE_TEXT *tmp20
-    * set *tmp18 .ACTIVE_TEXT
   143 jump *label25 always
   144 label *label24
-    * set *tmp18 null
   145 label *label25
   146 label *label23
   147 set *tmp21 .SWITCH
 
   197 label *label36
   198 set *tmp39 null
   199 label *label37
-    * set *tmp37 *tmp39
   200 label *label35
   201 jump *label34 always
   202 label *label33
 
   223 label *label44
   224 set *tmp44 *tmp46
   225 label *label42
-    * set *tmp43 *tmp44
   226 jump *label41 always
   227 label *label40
-    * set *tmp43 null
   228 label *label41
   229 label *label34
   230 print "\n"

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-3 instructions):
 
   192 set *tmp41 "\nCurrently inactive:[salmon]"
   193 label *label39
   194 set .ACTIVE_TEXT *tmp41
-    * set *tmp39 .ACTIVE_TEXT
   195 jump *label37 always
   196 label *label36
-    * set *tmp39 null
   197 label *label37
   198 label *label35
   199 jump *label34 always
 
   219 label *label43
   220 set *tmp46 null
   221 label *label44
-    * set *tmp44 *tmp46
   222 label *label42
   223 jump *label41 always
   224 label *label40

Modifications by Initial phase, Dead Code Elimination, iteration 4 (-2 instructions):
 
   214 set *tmp48 "\nCurrently inactive:[salmon]"
   215 label *label46
   216 set .ACTIVE_TEXT *tmp48
-    * set *tmp46 .ACTIVE_TEXT
   217 jump *label44 always
   218 label *label43
-    * set *tmp46 null
   219 label *label44
   220 label *label42
   221 jump *label41 always

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-19 instructions):
 
    13 label *label0
    14 print "Configuring regulator..."
    15 print "\n"
-    * set *tmp0 @links
-    * set :n *tmp0
+   16 set :n @links
    17 label *label3
    18 op greaterThan *tmp1 :n 0
    19 jump *label5 equal *tmp1 false
-    * op sub *tmp2 :n 1
-    * set :n *tmp2
-    * getlink *tmp3 :n
-    * set :block *tmp3
+   20 op sub :n :n 1
+   21 getlink :block :n
    22 print "Found: "
    23 print :block
    24 print "\n"
 
    53 set .CONTAINER :block
    54 set .SENSOR @totalItems
    55 set .MAXIMUM @itemCapacity
-    * op add *tmp7 :n 1
-    * set .START *tmp7
+   56 op add .START :n 1
    57 jump *label6 always
    58 label *label13
    59 jump *label16 equal *tmp5 @liquid-tank
 
    64 set .CONTAINER :block
    65 set .SENSOR @totalLiquids
    66 set .MAXIMUM @liquidCapacity
-    * op add *tmp8 :n 1
-    * set .START *tmp8
+   67 op add .START :n 1
    68 jump *label6 always
    69 label *label15
    70 jump *label18 equal *tmp5 @battery
 
    74 set .CONTAINER :block
    75 set .SENSOR @totalPower
    76 set .MAXIMUM @powerCapacity
-    * op add *tmp9 :n 1
-    * set .START *tmp9
+   77 op add .START :n 1
    78 jump *label6 always
    79 label *label17
    80 jump *label20 equal *tmp5 @power-node
 
    85 set .CONTAINER :block
    86 set .SENSOR @powerNetStored
    87 set .MAXIMUM @powerNetCapacity
-    * op add *tmp10 :n 1
-    * set .START *tmp10
+   88 op add .START :n 1
    89 jump *label6 always
    90 label *label19
    91 label *label6
 
   117 jump *label0 notEqual *tmp13 false
   118 label *label2
   119 sensor *tmp14 .SORTER @type
-    * op strictEqual *tmp15 *tmp14 @inverted-sorter
-    * set .INVERTED *tmp15
+  120 op strictEqual .INVERTED *tmp14 @inverted-sorter
   121 set :setState:newState true
   122 op notEqual *tmp17 .STATE :setState:newState
   123 jump *label24 equal *tmp17 false
   124 set .STATE :setState:newState
   125 op add .CYCLES .CYCLES 1
-    * op xor *tmp19 .INVERTED .STATE
-    * set .ON *tmp19
+  126 op xor .ON .INVERTED .STATE
   127 jump *label26 equal .ON false
   128 set *tmp20 "\nCurrently active:[green]"
   129 jump *label27 always
 
   135 label *label24
   136 label *label25
   137 label *label23
-    * set *tmp21 .SWITCH
-    * control enabled *tmp21 0
+  138 control enabled .SWITCH 0
   139 label *label28
   140 sensor *tmp23 .SWITCH @enabled
   141 op equal *tmp24 *tmp23 0
   142 jump *label30 equal *tmp24 false
-    * set *tmp25 @time
-    * set :start *tmp25
-    * sensor *tmp26 .SORTER @config
-    * set :item *tmp26
+  143 set :start @time
+  144 sensor :item .SORTER @config
   145 op equal *tmp27 :item null
   146 op notEqual *tmp28 .SENSOR @totalItems
   147 op or *tmp29 *tmp27 *tmp28
 
   157 print "] in "
   158 print .CONTAINER
   159 label *label32
-    * sensor *tmp31 .CONTAINER .MAXIMUM
-    * set :max *tmp31
-    * sensor *tmp32 .CONTAINER :item
-    * set :amount *tmp32
+  160 sensor :max .CONTAINER .MAXIMUM
+  161 sensor :amount .CONTAINER :item
   162 op mul *tmp33 100 :amount
-    * op idiv *tmp34 *tmp33 :max
-    * set :pct *tmp34
+  163 op idiv :pct *tmp33 :max
   164 op lessThanEq *tmp35 :pct PCT_LOW
   165 jump *label33 equal *tmp35 false
   166 set :setState.1:newState true
 
   168 jump *label36 equal *tmp38 false
   169 set .STATE :setState.1:newState
   170 op add .CYCLES .CYCLES 1
-    * op xor *tmp40 .INVERTED .STATE
-    * set .ON *tmp40
+  171 op xor .ON .INVERTED .STATE
   172 jump *label38 equal .ON false
   173 set *tmp41 "\nCurrently active:[green]"
   174 jump *label39 always
 
   189 jump *label43 equal *tmp45 false
   190 set .STATE :setState.2:newState
   191 op add .CYCLES .CYCLES 1
-    * op xor *tmp47 .INVERTED .STATE
-    * set .ON *tmp47
+  192 op xor .ON .INVERTED .STATE
   193 jump *label45 equal .ON false
   194 set *tmp48 "\nCurrently active:[green]"
   195 jump *label46 always
 
   239 label *label49
   240 op lessThan *tmp50 :n @links
   241 jump *label51 equal *tmp50 false
-    * getlink *tmp51 :n
-    * set :block *tmp51
-    * set *tmp52 :block
-    * control enabled *tmp52 .ON
+  242 getlink :block :n
+  243 control enabled :block .ON
   244 print "\n    "
   245 print :block
   246 op add :n :n 1

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-7 instructions):
 
    23 print :block
    24 print "\n"
    25 sensor *tmp5 :block @type
-    * jump *label8 equal *tmp5 @message
-    * jump *label7 always
+   26 jump *label7 notEqual *tmp5 @message
    27 label *label8
    28 set .MESSAGE :block
    29 jump *label6 always
    30 label *label7
-    * jump *label10 equal *tmp5 @switch
-    * jump *label9 always
+   31 jump *label9 notEqual *tmp5 @switch
    32 label *label10
    33 set .SWITCH :block
    34 jump *label6 always
    35 label *label9
    36 jump *label12 equal *tmp5 @sorter
    37 jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label12 equal *tmp5 @unloader
-    * jump *label11 always
+   38 jump *label11 notEqual *tmp5 @unloader
    39 label *label12
    40 set .SORTER :block
    41 jump *label6 always
 
    44 jump *label14 equal *tmp5 @container
    45 jump *label14 equal *tmp5 @core-shard
    46 jump *label14 equal *tmp5 @core-foundation
-    * jump *label14 equal *tmp5 @core-nucleus
-    * jump *label13 always
+   47 jump *label13 notEqual *tmp5 @core-nucleus
    48 label *label14
    49 set .CONTAINER :block
    50 set .SENSOR @totalItems
 
    54 label *label13
    55 jump *label16 equal *tmp5 @liquid-tank
    56 jump *label16 equal *tmp5 @liquid-container
-    * jump *label16 equal *tmp5 @liquid-router
-    * jump *label15 always
+   57 jump *label15 notEqual *tmp5 @liquid-router
    58 label *label16
    59 set .CONTAINER :block
    60 set .SENSOR @totalLiquids
 
    63 jump *label6 always
    64 label *label15
    65 jump *label18 equal *tmp5 @battery
-    * jump *label18 equal *tmp5 @battery-large
-    * jump *label17 always
+   66 jump *label17 notEqual *tmp5 @battery-large
    67 label *label18
    68 set .CONTAINER :block
    69 set .SENSOR @totalPower
 
    73 label *label17
    74 jump *label20 equal *tmp5 @power-node
    75 jump *label20 equal *tmp5 @power-node-large
-    * jump *label20 equal *tmp5 @surge-tower
-    * jump *label19 always
+   76 jump *label19 notEqual *tmp5 @surge-tower
    77 label *label20
    78 set .CONTAINER :block
    79 set .SENSOR @powerNetStored

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-10 instructions):
 
    15 print "\n"
    16 set :n @links
    17 label *label3
-    * op greaterThan *tmp1 :n 0
-    * jump *label5 equal *tmp1 false
+   18 jump *label5 lessThanEq :n 0
    19 op sub :n :n 1
    20 getlink :block :n
    21 print "Found: "
 
    96 print "Container: "
    97 print .CONTAINER
    98 print "\n"
-    * op equal *tmp11 .CONTAINER null
-    * jump *label21 equal *tmp11 false
+   99 jump *label21 notEqual .CONTAINER null
   100 print "No container."
   101 print "\n"
   102 jump *label22 always
 
   104 label *label22
   105 printflush .MESSAGE
   106 label *label1
-    * op equal *tmp13 .CONTAINER null
-    * jump *label0 notEqual *tmp13 false
+  107 jump *label0 equal .CONTAINER null
   108 label *label2
   109 sensor *tmp14 .SORTER @type
   110 op strictEqual .INVERTED *tmp14 @inverted-sorter
   111 set :setState:newState true
-    * op notEqual *tmp17 .STATE :setState:newState
-    * jump *label24 equal *tmp17 false
+  112 jump *label24 equal .STATE :setState:newState
   113 set .STATE :setState:newState
   114 op add .CYCLES .CYCLES 1
   115 op xor .ON .INVERTED .STATE
 
   127 control enabled .SWITCH 0
   128 label *label28
   129 sensor *tmp23 .SWITCH @enabled
-    * op equal *tmp24 *tmp23 0
-    * jump *label30 equal *tmp24 false
+  130 jump *label30 notEqual *tmp23 0
   131 set :start @time
   132 sensor :item .SORTER @config
   133 op equal *tmp27 :item null
 
   149 sensor :amount .CONTAINER :item
   150 op mul *tmp33 100 :amount
   151 op idiv :pct *tmp33 :max
-    * op lessThanEq *tmp35 :pct PCT_LOW
-    * jump *label33 equal *tmp35 false
+  152 jump *label33 greaterThan :pct PCT_LOW
   153 set :setState.1:newState true
-    * op notEqual *tmp38 .STATE :setState.1:newState
-    * jump *label36 equal *tmp38 false
+  154 jump *label36 equal .STATE :setState.1:newState
   155 set .STATE :setState.1:newState
   156 op add .CYCLES .CYCLES 1
   157 op xor .ON .INVERTED .STATE
 
   168 label *label35
   169 jump *label34 always
   170 label *label33
-    * op greaterThanEq *tmp42 :pct PCT_HIGH
-    * jump *label40 equal *tmp42 false
+  171 jump *label40 lessThan :pct PCT_HIGH
   172 set :setState.2:newState false
-    * op notEqual *tmp45 .STATE :setState.2:newState
-    * jump *label43 equal *tmp45 false
+  173 jump *label43 equal .STATE :setState.2:newState
   174 set .STATE :setState.2:newState
   175 op add .CYCLES .CYCLES 1
   176 op xor .ON .INVERTED .STATE
 
   221 print .ACTIVE_TEXT
   222 set :n .START
   223 label *label49
-    * op lessThan *tmp50 :n @links
-    * jump *label51 equal *tmp50 false
+  224 jump *label51 greaterThanEq :n @links
   225 getlink :block :n
   226 control enabled :block .ON
   227 print "\n    "

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-6 instructions):
 
    78 set .SENSOR @powerNetStored
    79 set .MAXIMUM @powerNetCapacity
    80 op add .START :n 1
-    * jump *label6 always
    81 label *label19
    82 label *label6
    83 label *label4
 
    98 jump *label21 notEqual .CONTAINER null
    99 print "No container."
   100 print "\n"
-    * jump *label22 always
   101 label *label21
   102 label *label22
   103 printflush .MESSAGE
 
   118 set *tmp20 "\nCurrently inactive:[salmon]"
   119 label *label27
   120 set .ACTIVE_TEXT *tmp20
-    * jump *label25 always
   121 label *label24
   122 label *label25
   123 label *label23
 
   159 set *tmp41 "\nCurrently inactive:[salmon]"
   160 label *label39
   161 set .ACTIVE_TEXT *tmp41
-    * jump *label37 always
   162 label *label36
   163 label *label37
   164 label *label35
 
   177 set *tmp48 "\nCurrently inactive:[salmon]"
   178 label *label46
   179 set .ACTIVE_TEXT *tmp48
-    * jump *label44 always
   180 label *label43
   181 label *label44
   182 label *label42
-    * jump *label41 always
   183 label *label40
   184 label *label41
   185 label *label34

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
     2 set .CONTAINER null
     3 set .SORTER null
     4 set .SWITCH null
-    * set .STATE .SWITCH
-    * set .START .STATE
-    * set .SENSOR .START
-    * set .ON .SENSOR
-    * set .MESSAGE .ON
-    * set .MAXIMUM .MESSAGE
-    * set .ACTIVE_TEXT .MAXIMUM
+    5 set .STATE null
+    6 set .START .SWITCH
+    7 set .SENSOR .STATE
+    8 set .ON .START
+    9 set .MESSAGE .SENSOR
+   10 set .MAXIMUM .ON
+   11 set .ACTIVE_TEXT .MESSAGE
    12 set .CYCLES 0
    13 label *label0
    14 print "Configuring regulator..."
 
   107 sensor *tmp14 .SORTER @type
   108 op strictEqual .INVERTED *tmp14 @inverted-sorter
   109 set :setState:newState true
-    * jump *label24 equal .STATE :setState:newState
-    * set .STATE :setState:newState
-    * op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  110 jump *label24 equal .STATE true
+  111 set .STATE true
+  112 op add .CYCLES 0 1
+  113 op xor .ON .INVERTED :setState:newState
   114 jump *label26 equal .ON false
   115 set *tmp20 "\nCurrently active:[green]"
   116 jump *label27 always
 
   148 op idiv :pct *tmp33 :max
   149 jump *label33 greaterThan :pct PCT_LOW
   150 set :setState.1:newState true
-    * jump *label36 equal .STATE :setState.1:newState
-    * set .STATE :setState.1:newState
+  151 jump *label36 equal .STATE true
+  152 set .STATE true
   153 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  154 op xor .ON .INVERTED :setState.1:newState
   155 jump *label38 equal .ON false
   156 set *tmp41 "\nCurrently active:[green]"
   157 jump *label39 always
 
   166 label *label33
   167 jump *label40 lessThan :pct PCT_HIGH
   168 set :setState.2:newState false
-    * jump *label43 equal .STATE :setState.2:newState
-    * set .STATE :setState.2:newState
+  169 jump *label43 equal .STATE false
+  170 set .STATE false
   171 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED .STATE
+  172 op xor .ON .INVERTED :setState.2:newState
   173 jump *label45 equal .ON false
   174 set *tmp48 "\nCurrently active:[green]"
   175 jump *label46 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2:
 
     3 set .SORTER null
     4 set .SWITCH null
     5 set .STATE null
-    * set .START .SWITCH
-    * set .SENSOR .STATE
-    * set .ON .START
-    * set .MESSAGE .SENSOR
-    * set .MAXIMUM .ON
-    * set .ACTIVE_TEXT .MESSAGE
+    6 set .START null
+    7 set .SENSOR null
+    8 set .ON .SWITCH
+    9 set .MESSAGE .STATE
+   10 set .MAXIMUM .START
+   11 set .ACTIVE_TEXT .SENSOR
    12 set .CYCLES 0
    13 label *label0
    14 print "Configuring regulator..."
 
   107 sensor *tmp14 .SORTER @type
   108 op strictEqual .INVERTED *tmp14 @inverted-sorter
   109 set :setState:newState true
-    * jump *label24 equal .STATE true
+  110 jump *label24 equal null true
   111 set .STATE true
   112 op add .CYCLES 0 1
-    * op xor .ON .INVERTED :setState:newState
+  113 op xor .ON .INVERTED true
   114 jump *label26 equal .ON false
   115 set *tmp20 "\nCurrently active:[green]"
   116 jump *label27 always
 
   151 jump *label36 equal .STATE true
   152 set .STATE true
   153 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.1:newState
+  154 op xor .ON .INVERTED true
   155 jump *label38 equal .ON false
   156 set *tmp41 "\nCurrently active:[green]"
   157 jump *label39 always
 
   169 jump *label43 equal .STATE false
   170 set .STATE false
   171 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED :setState.2:newState
+  172 op xor .ON .INVERTED false
   173 jump *label45 equal .ON false
   174 set *tmp48 "\nCurrently active:[green]"
   175 jump *label46 always

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3 (-3 instructions):
 
     5 set .STATE null
     6 set .START null
     7 set .SENSOR null
-    * set .ON .SWITCH
-    * set .MESSAGE .STATE
-    * set .MAXIMUM .START
-    * set .ACTIVE_TEXT .SENSOR
+    8 set .ON null
+    9 set .MESSAGE null
+   10 set .MAXIMUM null
+   11 set .ACTIVE_TEXT null
    12 set .CYCLES 0
    13 label *label0
    14 print "Configuring regulator..."
 
   106 label *label2
   107 sensor *tmp14 .SORTER @type
   108 op strictEqual .INVERTED *tmp14 @inverted-sorter
-    * set :setState:newState true
   109 jump *label24 equal null true
   110 set .STATE true
   111 op add .CYCLES 0 1
 
   146 op mul *tmp33 100 :amount
   147 op idiv :pct *tmp33 :max
   148 jump *label33 greaterThan :pct PCT_LOW
-    * set :setState.1:newState true
   149 jump *label36 equal .STATE true
   150 set .STATE true
   151 op add .CYCLES .CYCLES 1
 
   163 jump *label34 always
   164 label *label33
   165 jump *label40 lessThan :pct PCT_HIGH
-    * set :setState.2:newState false
   166 jump *label43 equal .STATE false
   167 set .STATE false
   168 op add .CYCLES .CYCLES 1

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1:
 
    16 set :n @links
    17 label *label3
    18 jump *label5 lessThanEq :n 0
+   19 label *label52
    20 op sub :n :n 1
    21 getlink :block :n
    22 print "Found: "
 
    82 label *label19
    83 label *label6
    84 label *label4
-    * jump *label3 always
+   85 jump *label52 greaterThan :n 0
    86 label *label5
    87 print "Message: "
    88 print .MESSAGE
 
   214 set :n .START
   215 label *label49
   216 jump *label51 greaterThanEq :n @links
+  217 label *label53
   218 getlink :block :n
   219 control enabled :block .ON
   220 print "\n    "
   221 print :block
   222 op add :n :n 1
   223 label *label50
-    * jump *label49 always
+  224 jump *label53 lessThan :n @links
   225 label *label51
   226 print "[]"
   227 print "\n"

Modifications by Iterated phase, If Expression Optimization, pass 1, iteration 1 (-9 instructions):
 
   111 set .STATE true
   112 op add .CYCLES 0 1
   113 op xor .ON .INVERTED true
-    * jump *label26 equal .ON false
-    * set *tmp20 "\nCurrently active:[green]"
-    * jump *label27 always
+  114 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   115 label *label26
-    * set *tmp20 "\nCurrently inactive:[salmon]"
   116 label *label27
   117 set .ACTIVE_TEXT *tmp20
   118 label *label24
 
   148 set .STATE true
   149 op add .CYCLES .CYCLES 1
   150 op xor .ON .INVERTED true
-    * jump *label38 equal .ON false
-    * set *tmp41 "\nCurrently active:[green]"
-    * jump *label39 always
+  151 select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   152 label *label38
-    * set *tmp41 "\nCurrently inactive:[salmon]"
   153 label *label39
   154 set .ACTIVE_TEXT *tmp41
   155 label *label36
 
   162 set .STATE false
   163 op add .CYCLES .CYCLES 1
   164 op xor .ON .INVERTED false
-    * jump *label45 equal .ON false
-    * set *tmp48 "\nCurrently active:[green]"
-    * jump *label46 always
+  165 select *tmp48 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   166 label *label45
-    * set *tmp48 "\nCurrently inactive:[salmon]"
   167 label *label46
   168 set .ACTIVE_TEXT *tmp48
   169 label *label43

Modifications by Replicate loop condition at line 72:1 (+1 instructions):
 
   122 label *label28
   123 sensor *tmp23 .SWITCH @enabled
   124 jump *label30 notEqual *tmp23 0
+  125 label *label54
   126 set :start @time
   127 sensor :item .SORTER @config
   128 op equal *tmp27 :item null
 
   228 print "ms"
   229 printflush .MESSAGE
   230 label *label29
-    * jump *label28 always
+  231 sensor *tmp23 .SWITCH @enabled
+  232 jump *label54 equal *tmp23 0
   233 label *label30
   234 end

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
   205 print .ACTIVE_TEXT
   206 set :n .START
   207 label *label49
-    * jump *label51 greaterThanEq :n @links
+  208 jump *label51 greaterThanEq .START @links
   209 label *label53
   210 getlink :block :n
   211 control enabled :block .ON

Modifications by Convert case at line 26:9 (segments: 1, padded low) (-15 instructions):
 
    23 print :block
    24 print "\n"
    25 sensor *tmp5 :block @type
-    * jump *label7 notEqual *tmp5 @message
+   26 sensor *tmp56 *tmp5 @id
+   27 jump *label55 greaterThanEq *tmp56 147
+   28 multijump *tmp56 0 0 (m:*label56)
+   29 multilabel *label63 (m:*label56)
    30 label *label8
    31 set .MESSAGE :block
    32 jump *label6 always
    33 label *label7
-    * jump *label9 notEqual *tmp5 @switch
+   34 multilabel *label64 (m:*label56)
    35 label *label10
    36 set .SWITCH :block
    37 jump *label6 always
    38 label *label9
-    * jump *label12 equal *tmp5 @sorter
-    * jump *label12 equal *tmp5 @inverted-sorter
-    * jump *label11 notEqual *tmp5 @unloader
+   39 multilabel *label58 (m:*label56)
    40 label *label12
    41 set .SORTER :block
    42 jump *label6 always
    43 label *label11
-    * jump *label14 equal *tmp5 @vault
-    * jump *label14 equal *tmp5 @container
-    * jump *label14 equal *tmp5 @core-shard
-    * jump *label14 equal *tmp5 @core-foundation
-    * jump *label13 notEqual *tmp5 @core-nucleus
+   44 multilabel *label62 (m:*label56)
    45 label *label14
    46 set .CONTAINER :block
    47 set .SENSOR @totalItems
 
    49 op add .START :n 1
    50 jump *label6 always
    51 label *label13
-    * jump *label16 equal *tmp5 @liquid-tank
-    * jump *label16 equal *tmp5 @liquid-container
-    * jump *label15 notEqual *tmp5 @liquid-router
+   52 multilabel *label59 (m:*label56)
    53 label *label16
    54 set .CONTAINER :block
    55 set .SENSOR @totalLiquids
 
    57 op add .START :n 1
    58 jump *label6 always
    59 label *label15
-    * jump *label18 equal *tmp5 @battery
-    * jump *label17 notEqual *tmp5 @battery-large
+   60 multilabel *label61 (m:*label56)
    61 label *label18
    62 set .CONTAINER :block
    63 set .SENSOR @totalPower
 
    65 op add .START :n 1
    66 jump *label6 always
    67 label *label17
-    * jump *label20 equal *tmp5 @power-node
-    * jump *label20 equal *tmp5 @power-node-large
-    * jump *label19 notEqual *tmp5 @surge-tower
+   68 multilabel *label60 (m:*label56)
    69 label *label20
    70 set .CONTAINER :block
    71 set .SENSOR @powerNetStored
    72 set .MAXIMUM @powerNetCapacity
    73 op add .START :n 1
    74 label *label19
+   75 multilabel *label57 (m:*label56)
+   76 label *label55
    77 label *label6
    78 label *label4
    79 jump *label52 greaterThan :n 0

Modifications by Iterated phase, Jump Normalization, pass 2, iteration 1 (-1 instructions):
 
   101 label *label2
   102 sensor *tmp14 .SORTER @type
   103 op strictEqual .INVERTED *tmp14 @inverted-sorter
-    * jump *label24 equal null true
   104 set .STATE true
   105 op add .CYCLES 0 1
   106 op xor .ON .INVERTED true

Modifications by Iterated phase, Expression Optimization, pass 2, iteration 1:
 
   102 sensor *tmp14 .SORTER @type
   103 op strictEqual .INVERTED *tmp14 @inverted-sorter
   104 set .STATE true
-    * op add .CYCLES 0 1
+  105 set .CYCLES 1
   106 op xor .ON .INVERTED true
   107 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   108 label *label26
 
   155 jump *label43 equal .STATE false
   156 set .STATE false
   157 op add .CYCLES .CYCLES 1
-    * op xor .ON .INVERTED false
+  158 set .ON .INVERTED
   159 select *tmp48 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   160 label *label45
   161 label *label46

Modifications by Iterated phase, Data Flow Optimization, pass 2, iteration 1:
 
   156 set .STATE false
   157 op add .CYCLES .CYCLES 1
   158 set .ON .INVERTED
-    * select *tmp48 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
+  159 select *tmp48 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   160 label *label45
   161 label *label46
   162 set .ACTIVE_TEXT *tmp48

Modifications by Jumps phase, Jump Normalization, pass 4, iteration 1:
 
    14 print "Configuring regulator..."
    15 print "\n"
    16 set :n @links
-    * label *label3
    17 jump *label5 lessThanEq :n 0
    18 label *label52
    19 op sub :n :n 1
 
    26 jump *label55 greaterThanEq *tmp56 147
    27 multijump *tmp56 0 0 (m:*label56)
    28 multilabel *label63 (m:*label56)
-    * label *label8
    29 set .MESSAGE :block
    30 jump *label6 always
-    * label *label7
    31 multilabel *label64 (m:*label56)
-    * label *label10
    32 set .SWITCH :block
    33 jump *label6 always
-    * label *label9
    34 multilabel *label58 (m:*label56)
-    * label *label12
    35 set .SORTER :block
    36 jump *label6 always
-    * label *label11
    37 multilabel *label62 (m:*label56)
-    * label *label14
    38 set .CONTAINER :block
    39 set .SENSOR @totalItems
    40 set .MAXIMUM @itemCapacity
    41 op add .START :n 1
    42 jump *label6 always
-    * label *label13
    43 multilabel *label59 (m:*label56)
-    * label *label16
    44 set .CONTAINER :block
    45 set .SENSOR @totalLiquids
    46 set .MAXIMUM @liquidCapacity
    47 op add .START :n 1
    48 jump *label6 always
-    * label *label15
    49 multilabel *label61 (m:*label56)
-    * label *label18
    50 set .CONTAINER :block
    51 set .SENSOR @totalPower
    52 set .MAXIMUM @powerCapacity
    53 op add .START :n 1
    54 jump *label6 always
-    * label *label17
    55 multilabel *label60 (m:*label56)
-    * label *label20
    56 set .CONTAINER :block
    57 set .SENSOR @powerNetStored
    58 set .MAXIMUM @powerNetCapacity
    59 op add .START :n 1
-    * label *label19
    60 multilabel *label57 (m:*label56)
    61 label *label55
    62 label *label6
-    * label *label4
    63 jump *label52 greaterThan :n 0
    64 label *label5
    65 print "Message: "
 
    78 print "No container."
    79 print "\n"
    80 label *label21
-    * label *label22
    81 printflush .MESSAGE
-    * label *label1
    82 jump *label0 equal .CONTAINER null
-    * label *label2
    83 sensor *tmp14 .SORTER @type
    84 op strictEqual .INVERTED *tmp14 @inverted-sorter
    85 set .STATE true
    86 set .CYCLES 1
    87 op xor .ON .INVERTED true
    88 select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label26
-    * label *label27
    89 set .ACTIVE_TEXT *tmp20
-    * label *label24
-    * label *label25
-    * label *label23
    90 control enabled .SWITCH 0
-    * label *label28
    91 sensor *tmp23 .SWITCH @enabled
    92 jump *label30 notEqual *tmp23 0
    93 label *label54
 
   118 op add .CYCLES .CYCLES 1
   119 op xor .ON .INVERTED true
   120 select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label38
-    * label *label39
   121 set .ACTIVE_TEXT *tmp41
   122 label *label36
-    * label *label37
-    * label *label35
   123 jump *label34 always
   124 label *label33
   125 jump *label40 lessThan :pct PCT_HIGH
 
   128 op add .CYCLES .CYCLES 1
   129 set .ON .INVERTED
   130 select *tmp48 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
-    * label *label45
-    * label *label46
   131 set .ACTIVE_TEXT *tmp48
   132 label *label43
-    * label *label44
-    * label *label42
   133 label *label40
-    * label *label41
   134 label *label34
   135 print "\n"
   136 print "Level: [gold]"
 
   163 label *label48
   164 print .ACTIVE_TEXT
   165 set :n .START
-    * label *label49
   166 jump *label51 greaterThanEq .START @links
   167 label *label53
   168 getlink :block :n
 
   170 print "\n    "
   171 print :block
   172 op add :n :n 1
-    * label *label50
   173 jump *label53 lessThan :n @links
   174 label *label51
   175 print "[]"
 
   184 print " "
   185 print "ms"
   186 printflush .MESSAGE
-    * label *label29
   187 sensor *tmp23 .SWITCH @enabled
   188 jump *label54 equal *tmp23 0
   189 label *label30

Modifications by Jumps phase, Jump Threading, pass 4, iteration 1:
+    0 label __start__
     1 set PCT_LOW 60
     2 set PCT_HIGH 80
     3 set .CONTAINER null
 
    90 set .ACTIVE_TEXT *tmp20
    91 control enabled .SWITCH 0
    92 sensor *tmp23 .SWITCH @enabled
-    * jump *label30 notEqual *tmp23 0
+   93 jump __start__ notEqual *tmp23 0
    94 label *label54
    95 set :start @time
    96 sensor :item .SORTER @config
 
   114 op mul *tmp33 100 :amount
   115 op idiv :pct *tmp33 :max
   116 jump *label33 greaterThan :pct PCT_LOW
-    * jump *label36 equal .STATE true
+  117 jump *label34 equal .STATE true
   118 set .STATE true
   119 op add .CYCLES .CYCLES 1
   120 op xor .ON .INVERTED true

Modifications by Jumps phase, Unreachable Code Elimination, pass 4, iteration 1:
 
   120 op xor .ON .INVERTED true
   121 select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
   122 set .ACTIVE_TEXT *tmp41
-    * label *label36
   123 jump *label34 always
   124 label *label33
   125 jump *label40 lessThan :pct PCT_HIGH
 
   186 printflush .MESSAGE
   187 sensor *tmp23 .SWITCH @enabled
   188 jump *label54 equal *tmp23 0
-    * label *label30
   189 end

Modifications by Jumps phase, Single Step Elimination, pass 4, iteration 1 (-1 instructions):
 
   186 printflush .MESSAGE
   187 sensor *tmp23 .SWITCH @enabled
   188 jump *label54 equal *tmp23 0
-    * end

Modifications by Final phase, Print Merging, iteration 1 (-35 instructions):
 
    12 set .ACTIVE_TEXT null
    13 set .CYCLES 0
    14 label *label0
-    * print "Configuring regulator..."
-    * print "\n"
+   15 print "Configuring regulator...\n"
    16 set :n @links
    17 jump *label5 lessThanEq :n 0
    18 label *label52
    19 op sub :n :n 1
    20 getlink :block :n
-    * print "Found: "
-    * print :block
-    * print "\n"
+   21 print "Found: {0}\n"
+   22 format :block
    23 sensor *tmp5 :block @type
    24 sensor *tmp56 *tmp5 @id
    25 jump *label55 greaterThanEq *tmp56 147
 
    61 label *label6
    62 jump *label52 greaterThan :n 0
    63 label *label5
-    * print "Message: "
-    * print .MESSAGE
-    * print "\n"
-    * print "Switch: "
-    * print .SWITCH
-    * print "\n"
-    * print "Sorter: "
-    * print .SORTER
-    * print "\n"
-    * print "Container: "
-    * print .CONTAINER
-    * print "\n"
+   64 print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
+   65 format .MESSAGE
+   66 format .SWITCH
+   67 format .SORTER
+   68 format .CONTAINER
    69 jump *label21 notEqual .CONTAINER null
-    * print "No container."
-    * print "\n"
+   70 print "No container.\n"
    71 label *label21
    72 printflush .MESSAGE
    73 jump *label0 equal .CONTAINER null
 
    93 print .CONTAINER
    94 jump *label32 always
    95 label *label31
-    * print "Measuring [gold]"
-    * print :item
-    * print "["
-    * print "] in "
+   96 print "Measuring [gold]{0}[] in "
+   97 format :item
    98 print .CONTAINER
    99 label *label32
   100 sensor :max .CONTAINER .MAXIMUM
 
   120 label *label43
   121 label *label40
   122 label *label34
-    * print "\n"
-    * print "Level: [gold]"
-    * print :pct
-    * print "%"
-    * print "[]"
+  123 print "\nLevel: [gold]{0}%[]"
+  124 format :pct
   125 jump *label47 equal .INVERTED false
-    * print "\n"
-    * print "Activate above [green]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate below [salmon]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
+  126 print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
+  127 format PCT_HIGH
+  128 format PCT_LOW
   129 jump *label48 always
   130 label *label47
-    * print "\n"
-    * print "Activate below [green]"
-    * print PCT_LOW
-    * print "%"
-    * print "[]"
-    * print "\n"
-    * print "Deactivate above [salmon]"
-    * print PCT_HIGH
-    * print "%"
-    * print "[]"
+  131 print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
+  132 format PCT_LOW
+  133 format PCT_HIGH
   134 label *label48
   135 print .ACTIVE_TEXT
   136 set :n .START
 
   143 op add :n :n 1
   144 jump *label53 lessThan :n @links
   145 label *label51
-    * print "[]"
-    * print "\n"
-    * print "# of cycles: "
-    * print .CYCLES
+  146 print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
+  147 format .CYCLES
   148 op sub *tmp54 @time :start
   149 op floor *tmp55 *tmp54
-    * print "\n"
-    * print "[lightgray]Loop: "
-    * print *tmp55
-    * print " "
-    * print "ms"
+  150 format *tmp55
   151 printflush .MESSAGE
   152 sensor *tmp23 .SWITCH @enabled
   153 jump *label54 equal *tmp23 0

Final code before resolving virtual instructions:

label __start__
set PCT_LOW 60
set PCT_HIGH 80
set .CONTAINER null
set .SORTER null
set .SWITCH null
set .STATE null
set .START null
set .SENSOR null
set .ON null
set .MESSAGE null
set .MAXIMUM null
set .ACTIVE_TEXT null
set .CYCLES 0
label *label0
print "Configuring regulator...\n"
set :n @links
jump *label5 lessThanEq :n 0
label *label52
op sub :n :n 1
getlink :block :n
print "Found: {0}\n"
format :block
sensor *tmp5 :block @type
sensor *tmp56 *tmp5 @id
jump *label55 greaterThanEq *tmp56 147
multijump *tmp56 0 0
multilabel *label63
set .MESSAGE :block
jump *label6 always
multilabel *label64
set .SWITCH :block
jump *label6 always
multilabel *label58
set .SORTER :block
jump *label6 always
multilabel *label62
set .CONTAINER :block
set .SENSOR @totalItems
set .MAXIMUM @itemCapacity
op add .START :n 1
jump *label6 always
multilabel *label59
set .CONTAINER :block
set .SENSOR @totalLiquids
set .MAXIMUM @liquidCapacity
op add .START :n 1
jump *label6 always
multilabel *label61
set .CONTAINER :block
set .SENSOR @totalPower
set .MAXIMUM @powerCapacity
op add .START :n 1
jump *label6 always
multilabel *label60
set .CONTAINER :block
set .SENSOR @powerNetStored
set .MAXIMUM @powerNetCapacity
op add .START :n 1
multilabel *label57
label *label55
label *label6
jump *label52 greaterThan :n 0
label *label5
print "Message: {0}\nSwitch: {0}\nSorter: {0}\nContainer: {0}\n"
format .MESSAGE
format .SWITCH
format .SORTER
format .CONTAINER
jump *label21 notEqual .CONTAINER null
print "No container.\n"
label *label21
printflush .MESSAGE
jump *label0 equal .CONTAINER null
sensor *tmp14 .SORTER @type
op strictEqual .INVERTED *tmp14 @inverted-sorter
set .STATE true
set .CYCLES 1
op xor .ON .INVERTED true
select *tmp20 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
set .ACTIVE_TEXT *tmp20
control enabled .SWITCH 0
sensor *tmp23 .SWITCH @enabled
jump __start__ notEqual *tmp23 0
label *label54
set :start @time
sensor :item .SORTER @config
op equal *tmp27 :item null
op notEqual *tmp28 .SENSOR @totalItems
op or *tmp29 *tmp27 *tmp28
jump *label31 equal *tmp29 false
set :item .SENSOR
print "Measuring [gold]total[] in "
print .CONTAINER
jump *label32 always
label *label31
print "Measuring [gold]{0}[] in "
format :item
print .CONTAINER
label *label32
sensor :max .CONTAINER .MAXIMUM
sensor :amount .CONTAINER :item
op mul *tmp33 100 :amount
op idiv :pct *tmp33 :max
jump *label33 greaterThan :pct PCT_LOW
jump *label34 equal .STATE true
set .STATE true
op add .CYCLES .CYCLES 1
op xor .ON .INVERTED true
select *tmp41 notEqual .ON false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
set .ACTIVE_TEXT *tmp41
jump *label34 always
label *label33
jump *label40 lessThan :pct PCT_HIGH
jump *label43 equal .STATE false
set .STATE false
op add .CYCLES .CYCLES 1
set .ON .INVERTED
select *tmp48 notEqual .INVERTED false "\nCurrently active:[green]" "\nCurrently inactive:[salmon]"
set .ACTIVE_TEXT *tmp48
label *label43
label *label40
label *label34
print "\nLevel: [gold]{0}%[]"
format :pct
jump *label47 equal .INVERTED false
print "\nActivate above [green]{0}%[]\nDeactivate below [salmon]{0}%[]"
format PCT_HIGH
format PCT_LOW
jump *label48 always
label *label47
print "\nActivate below [green]{0}%[]\nDeactivate above [salmon]{0}%[]"
format PCT_LOW
format PCT_HIGH
label *label48
print .ACTIVE_TEXT
set :n .START
jump *label51 greaterThanEq .START @links
label *label53
getlink :block :n
control enabled :block .ON
print "\n    "
print :block
op add :n :n 1
jump *label53 lessThan :n @links
label *label51
print "[]\n# of cycles: {0}\n[lightgray]Loop: {0} ms"
format .CYCLES
op sub *tmp54 @time :start
op floor *tmp55 *tmp54
format *tmp55
printflush .MESSAGE
sensor *tmp23 .SWITCH @enabled
jump *label54 equal *tmp23 0
