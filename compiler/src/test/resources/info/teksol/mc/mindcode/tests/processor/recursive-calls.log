   146 instructions before optimizations.
     6 instructions eliminated by Temp Variables Elimination (5 iterations).
    15 instructions eliminated by Dead Code Elimination (6 iterations).
     3 instructions eliminated by Jump Optimization (4 iterations).
     3 instructions eliminated by Single Step Elimination (5 iterations).
     7 instructions eliminated by Data Flow Optimization (4 iterations).
     3 instructions eliminated by Unreachable Code Elimination (2 iterations).
    12 instructions eliminated by Stack Optimization.
    97 instructions after optimizations.

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-9 instructions):
 
     4 set :foo:b 0
     5 callrec bank1 *label0 *label3 :foo*retval
     6 label *label3
-    * set *tmp0 :foo*retval
     7 assertprints "0001111223221211" "foo"
     8 assertflush
     9 set :bar:n 3
 
    11 set :bar:b 0
    12 callrec bank1 *label1 *label4 :bar*retval
    13 label *label4
-    * set *tmp1 :bar*retval
    14 assertprints "0001111223333444" "bar"
    15 assertflush
    16 set :baz:n 3
 
    18 set :baz:b 0
    19 callrec bank1 *label2 *label5 :baz*retval
    20 label *label5
-    * set *tmp2 :baz*retval
    21 assertprints "0001111223221211" "baz"
    22 stop
    23 end
 
    43 pop bank1 :foo:a
    44 pop bank1 :foo:n
    45 set *tmp9 :foo*retval
-    * set *tmp5 *tmp9
    46 jump *label8 always
    47 label *label7
-    * set *tmp5 null
    48 label *label8
    49 op add *tmp10 :foo:b 1
    50 set :foo:b *tmp10
 
    76 set :bar:a *tmp18
    77 pop bank1 :bar:n
    78 set *tmp19 :bar*retval
-    * set *tmp13 *tmp19
    79 jump *label12 always
    80 label *label11
-    * set *tmp13 null
    81 label *label12
    82 op add *tmp20 :bar:b 1
    83 set :bar:b *tmp20
 
   109 pop bank1 :baz:b
   110 pop bank1 :baz:n
   111 set *tmp27 :baz*retval
-    * set *tmp23 *tmp27
   112 jump *label16 always
   113 label *label15
-    * set *tmp23 null
   114 label *label16
   115 op add *tmp28 :baz:b 1
   116 set :baz:b *tmp28

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-3 instructions):
 
    42 pop bank1 :foo:b
    43 pop bank1 :foo:a
    44 pop bank1 :foo:n
-    * set *tmp9 :foo*retval
    45 jump *label8 always
    46 label *label7
    47 label *label8
 
    74 set :bar:b *tmp17
    75 set :bar:a *tmp18
    76 pop bank1 :bar:n
-    * set *tmp19 :bar*retval
    77 jump *label12 always
    78 label *label11
    79 label *label12
 
   106 pop bank1 :baz:a
   107 pop bank1 :baz:b
   108 pop bank1 :baz:n
-    * set *tmp27 :baz*retval
   109 jump *label16 always
   110 label *label15
   111 label *label16

Modifications by Initial phase, Dead Code Elimination, iteration 3 (-3 instructions):
 
    49 set :foo:b *tmp10
    50 print :foo:a
    51 print :foo:b
-    * set :foo*retval :foo:b
    52 label *label6
    53 returnrec bank1
    54 end
 
    80 set :bar:b *tmp20
    81 print :bar:a
    82 print :bar:b
-    * set :bar*retval :bar:b
    83 label *label10
    84 returnrec bank1
    85 end
 
   111 set :baz:b *tmp28
   112 print :baz:a
   113 print :baz:b
-    * set :baz*retval :baz:b
   114 label *label14
   115 returnrec bank1
   116 end

Modifications by Initial phase, Temp Variables Elimination, iteration 1 (-6 instructions):
 
    24 label *label0
    25 print :foo:a
    26 print :foo:b
-    * op add *tmp3 :foo:a 1
-    * set :foo:a *tmp3
+   27 op add :foo:a :foo:a 1
    28 op greaterThan *tmp4 :foo:n 0
    29 jump *label7 equal *tmp4 false
    30 op sub *tmp6 :foo:n 1
 
    44 jump *label8 always
    45 label *label7
    46 label *label8
-    * op add *tmp10 :foo:b 1
-    * set :foo:b *tmp10
+   47 op add :foo:b :foo:b 1
    48 print :foo:a
    49 print :foo:b
    50 label *label6
 
    53 label *label1
    54 print :bar:a
    55 print :bar:b
-    * op add *tmp11 :bar:a 1
-    * set :bar:a *tmp11
+   56 op add :bar:a :bar:a 1
    57 op greaterThan *tmp12 :bar:n 0
    58 jump *label11 equal *tmp12 false
    59 op sub *tmp14 :bar:n 1
 
    73 jump *label12 always
    74 label *label11
    75 label *label12
-    * op add *tmp20 :bar:b 1
-    * set :bar:b *tmp20
+   76 op add :bar:b :bar:b 1
    77 print :bar:a
    78 print :bar:b
    79 label *label10
 
    82 label *label2
    83 print :baz:a
    84 print :baz:b
-    * op add *tmp21 :baz:a 1
-    * set :baz:a *tmp21
+   85 op add :baz:a :baz:a 1
    86 op greaterThan *tmp22 :baz:n 0
    87 jump *label15 equal *tmp22 false
    88 op sub *tmp24 :baz:n 1
 
   102 jump *label16 always
   103 label *label15
   104 label *label16
-    * op add *tmp28 :baz:b 1
-    * set :baz:b *tmp28
+  105 op add :baz:b :baz:b 1
   106 print :baz:a
   107 print :baz:b
   108 label *label14

Modifications by Iterated phase, Jump Optimization, pass 1, iteration 1 (-3 instructions):
 
    25 print :foo:a
    26 print :foo:b
    27 op add :foo:a :foo:a 1
-    * op greaterThan *tmp4 :foo:n 0
-    * jump *label7 equal *tmp4 false
+   28 jump *label7 lessThanEq :foo:n 0
    29 op sub *tmp6 :foo:n 1
    30 push bank1 :foo:n
    31 push bank1 :foo:a
 
    53 print :bar:a
    54 print :bar:b
    55 op add :bar:a :bar:a 1
-    * op greaterThan *tmp12 :bar:n 0
-    * jump *label11 equal *tmp12 false
+   56 jump *label11 lessThanEq :bar:n 0
    57 op sub *tmp14 :bar:n 1
    58 push bank1 :bar:n
    59 set *tmp15 :bar:b
 
    81 print :baz:a
    82 print :baz:b
    83 op add :baz:a :baz:a 1
-    * op greaterThan *tmp22 :baz:n 0
-    * jump *label15 equal *tmp22 false
+   84 jump *label15 lessThanEq :baz:n 0
    85 op sub *tmp24 :baz:n 1
    86 push bank1 :baz:n
    87 push bank1 :baz:b

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-3 instructions):
 
    40 pop bank1 :foo:b
    41 pop bank1 :foo:a
    42 pop bank1 :foo:n
-    * jump *label8 always
    43 label *label7
    44 label *label8
    45 op add :foo:b :foo:b 1
 
    67 set :bar:b *tmp17
    68 set :bar:a *tmp18
    69 pop bank1 :bar:n
-    * jump *label12 always
    70 label *label11
    71 label *label12
    72 op add :bar:b :bar:b 1
 
    94 pop bank1 :baz:a
    95 pop bank1 :baz:b
    96 pop bank1 :baz:n
-    * jump *label16 always
    97 label *label15
    98 label *label16
    99 op add :baz:b :baz:b 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    32 push bank1 :foo:b
    33 set *tmp7 :foo:b
    34 set *tmp8 :foo:a
-    * set :foo:n *tmp6
-    * set :foo:a *tmp7
+   35 op sub :foo:n :foo:n 1
+   36 set :foo:a :foo:b
    37 set :foo:b *tmp8
    38 callrec bank1 *label0 *label9 :foo*retval
    39 label *label9
 
    57 push bank1 :bar:n
    58 set *tmp15 :bar:b
    59 set *tmp16 :bar:a
-    * set :bar:n *tmp14
-    * set :bar:a *tmp15
+   60 op sub :bar:n :bar:n 1
+   61 set :bar:a :bar:b
    62 set :bar:b *tmp16
    63 callrec bank1 *label1 *label13 :bar*retval
    64 label *label13
    65 set *tmp17 :bar:a
    66 set *tmp18 :bar:b
-    * set :bar:b *tmp17
+   67 set :bar:b :bar:a
    68 set :bar:a *tmp18
    69 pop bank1 :bar:n
    70 label *label11
 
    86 push bank1 :baz:a
    87 set *tmp25 :baz:b
    88 set *tmp26 :baz:a
-    * set :baz:n *tmp24
-    * set :baz:a *tmp25
+   89 op sub :baz:n :baz:n 1
+   90 set :baz:a :baz:b
    91 set :baz:b *tmp26
    92 callrec bank1 *label2 *label17 :baz*retval
    93 label *label17

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-7 instructions):
 
    26 print :foo:b
    27 op add :foo:a :foo:a 1
    28 jump *label7 lessThanEq :foo:n 0
-    * op sub *tmp6 :foo:n 1
    29 push bank1 :foo:n
    30 push bank1 :foo:a
    31 push bank1 :foo:b
-    * set *tmp7 :foo:b
    32 set *tmp8 :foo:a
    33 op sub :foo:n :foo:n 1
    34 set :foo:a :foo:b
 
    51 print :bar:b
    52 op add :bar:a :bar:a 1
    53 jump *label11 lessThanEq :bar:n 0
-    * op sub *tmp14 :bar:n 1
    54 push bank1 :bar:n
-    * set *tmp15 :bar:b
    55 set *tmp16 :bar:a
    56 op sub :bar:n :bar:n 1
    57 set :bar:a :bar:b
    58 set :bar:b *tmp16
    59 callrec bank1 *label1 *label13 :bar*retval
    60 label *label13
-    * set *tmp17 :bar:a
    61 set *tmp18 :bar:b
    62 set :bar:b :bar:a
    63 set :bar:a *tmp18
 
    75 print :baz:b
    76 op add :baz:a :baz:a 1
    77 jump *label15 lessThanEq :baz:n 0
-    * op sub *tmp24 :baz:n 1
    78 push bank1 :baz:n
    79 push bank1 :baz:b
    80 push bank1 :baz:a
-    * set *tmp25 :baz:b
    81 set *tmp26 :baz:a
    82 op sub :baz:n :baz:n 1
    83 set :baz:a :baz:b

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
    39 pop bank1 :foo:a
    40 pop bank1 :foo:n
    41 label *label7
-    * label *label8
    42 op add :foo:b :foo:b 1
    43 print :foo:a
    44 print :foo:b
-    * label *label6
    45 returnrec bank1
    46 end
    47 label *label1
 
    61 set :bar:a *tmp18
    62 pop bank1 :bar:n
    63 label *label11
-    * label *label12
    64 op add :bar:b :bar:b 1
    65 print :bar:a
    66 print :bar:b
-    * label *label10
    67 returnrec bank1
    68 end
    69 label *label2
 
    84 pop bank1 :baz:b
    85 pop bank1 :baz:n
    86 label *label15
-    * label *label16
    87 op add :baz:b :baz:b 1
    88 print :baz:a
    89 print :baz:b
-    * label *label14
    90 returnrec bank1
    91 end

Modifications by Jumps phase, Unreachable Code Elimination, pass 3, iteration 1 (-3 instructions):
 
    43 print :foo:a
    44 print :foo:b
    45 returnrec bank1
-    * end
    46 label *label1
    47 print :bar:a
    48 print :bar:b
 
    64 print :bar:a
    65 print :bar:b
    66 returnrec bank1
-    * end
    67 label *label2
    68 print :baz:a
    69 print :baz:b
 
    86 print :baz:a
    87 print :baz:b
    88 returnrec bank1
-    * end

Modifications by Final phase, Stack Optimization, iteration 1 (-12 instructions):
 
    26 print :foo:b
    27 op add :foo:a :foo:a 1
    28 jump *label7 lessThanEq :foo:n 0
-    * push bank1 :foo:n
    29 push bank1 :foo:a
    30 push bank1 :foo:b
    31 set *tmp8 :foo:a
 
    36 label *label9
    37 pop bank1 :foo:b
    38 pop bank1 :foo:a
-    * pop bank1 :foo:n
    39 label *label7
    40 op add :foo:b :foo:b 1
    41 print :foo:a
 
    46 print :bar:b
    47 op add :bar:a :bar:a 1
    48 jump *label11 lessThanEq :bar:n 0
-    * push bank1 :bar:n
    49 set *tmp16 :bar:a
    50 op sub :bar:n :bar:n 1
    51 set :bar:a :bar:b
 
    55 set *tmp18 :bar:b
    56 set :bar:b :bar:a
    57 set :bar:a *tmp18
-    * pop bank1 :bar:n
    58 label *label11
    59 op add :bar:b :bar:b 1
    60 print :bar:a
 
    65 print :baz:b
    66 op add :baz:a :baz:a 1
    67 jump *label15 lessThanEq :baz:n 0
-    * push bank1 :baz:n
    68 push bank1 :baz:b
    69 push bank1 :baz:a
    70 set *tmp26 :baz:a
 
    75 label *label17
    76 pop bank1 :baz:a
    77 pop bank1 :baz:b
-    * pop bank1 :baz:n
    78 label *label15
    79 op add :baz:b :baz:b 1
    80 print :baz:a

Final code before resolving virtual instructions:

set *sp 0
assertflush
set :foo:n 3
set :foo:a 0
set :foo:b 0
callrec bank1 *label0 *label3 :foo*retval
label *label3
assertprints "0001111223221211" "foo"
assertflush
set :bar:n 3
set :bar:a 0
set :bar:b 0
callrec bank1 *label1 *label4 :bar*retval
label *label4
assertprints "0001111223333444" "bar"
assertflush
set :baz:n 3
set :baz:a 0
set :baz:b 0
callrec bank1 *label2 *label5 :baz*retval
label *label5
assertprints "0001111223221211" "baz"
stop
end
label *label0
print :foo:a
print :foo:b
op add :foo:a :foo:a 1
jump *label7 lessThanEq :foo:n 0
push bank1 :foo:a
push bank1 :foo:b
set *tmp8 :foo:a
op sub :foo:n :foo:n 1
set :foo:a :foo:b
set :foo:b *tmp8
callrec bank1 *label0 *label9 :foo*retval
label *label9
pop bank1 :foo:b
pop bank1 :foo:a
label *label7
op add :foo:b :foo:b 1
print :foo:a
print :foo:b
returnrec bank1
label *label1
print :bar:a
print :bar:b
op add :bar:a :bar:a 1
jump *label11 lessThanEq :bar:n 0
set *tmp16 :bar:a
op sub :bar:n :bar:n 1
set :bar:a :bar:b
set :bar:b *tmp16
callrec bank1 *label1 *label13 :bar*retval
label *label13
set *tmp18 :bar:b
set :bar:b :bar:a
set :bar:a *tmp18
label *label11
op add :bar:b :bar:b 1
print :bar:a
print :bar:b
returnrec bank1
label *label2
print :baz:a
print :baz:b
op add :baz:a :baz:a 1
jump *label15 lessThanEq :baz:n 0
push bank1 :baz:b
push bank1 :baz:a
set *tmp26 :baz:a
op sub :baz:n :baz:n 1
set :baz:a :baz:b
set :baz:b *tmp26
callrec bank1 *label2 *label17 :baz*retval
label *label17
pop bank1 :baz:a
pop bank1 :baz:b
label *label15
op add :baz:b :baz:b 1
print :baz:a
print :baz:b
returnrec bank1
