    87 instructions before optimizations.
     1 instructions eliminated by Case Expression Optimization.
    13 instructions eliminated by Dead Code Elimination (5 iterations).
     1 instructions eliminated by Condition Optimization (4 iterations).
     2 instructions eliminated by Single Step Elimination (2 passes, 6 iterations).
     1 instructions eliminated by Data Flow Optimization (2 passes, 8 iterations).
     1 instructions eliminated by Loop Optimization (2 iterations).
     2 loops improved by Loop Optimization.
     2 instructions added by Case Switching (3 iterations).
     1 case expressions converted to switched jumps by Case Switching.
    10 instructions eliminated by Jump Straightening (4 iterations).
    60 instructions after optimizations.

Pass 1: speed optimization selection (cost limit 941):
  * Convert case at line 27:5 (segments: 10)                     size    +2, benefit     1125.0, efficiency    562.500 (+2 instructions)

Modifications by Initial phase, Case Expression Optimization, iteration 1 (-1 instructions):
 
    18 op mod *tmp2 :processNumber:n 10
    19 # "Function: def processDigit(in n)"
    20 set :processDigit:n *tmp2
-    * set *tmp5 :processDigit:n
-    * jump *label10 equal *tmp5 0
+   21 jump *label10 equal :processDigit:n 0
    22 jump *label9 always
    23 label *label10
    24 op add .S0 .S0 1
    25 set *tmp4 .S0
    26 jump *label8 always
    27 label *label9
-    * jump *label12 equal *tmp5 1
+   28 jump *label12 equal :processDigit:n 1
    29 jump *label11 always
    30 label *label12
    31 op add .S1 .S1 1
    32 set *tmp4 .S1
    33 jump *label8 always
    34 label *label11
-    * jump *label14 equal *tmp5 2
+   35 jump *label14 equal :processDigit:n 2
    36 jump *label13 always
    37 label *label14
    38 op add .S2 .S2 1
    39 set *tmp4 .S2
    40 jump *label8 always
    41 label *label13
-    * jump *label16 equal *tmp5 3
+   42 jump *label16 equal :processDigit:n 3
    43 jump *label15 always
    44 label *label16
    45 op add .S3 .S3 1
    46 set *tmp4 .S3
    47 jump *label8 always
    48 label *label15
-    * jump *label18 equal *tmp5 4
+   49 jump *label18 equal :processDigit:n 4
    50 jump *label17 always
    51 label *label18
    52 op add .S4 .S4 1
    53 set *tmp4 .S4
    54 jump *label8 always
    55 label *label17
-    * jump *label20 equal *tmp5 5
+   56 jump *label20 equal :processDigit:n 5
    57 jump *label19 always
    58 label *label20
    59 op add .S5 .S5 1
    60 set *tmp4 .S5
    61 jump *label8 always
    62 label *label19
-    * jump *label22 equal *tmp5 6
+   63 jump *label22 equal :processDigit:n 6
    64 jump *label21 always
    65 label *label22
    66 op add .S6 .S6 1
    67 set *tmp4 .S6
    68 jump *label8 always
    69 label *label21
-    * jump *label24 equal *tmp5 7
+   70 jump *label24 equal :processDigit:n 7
    71 jump *label23 always
    72 label *label24
    73 op add .S7 .S7 1
    74 set *tmp4 .S7
    75 jump *label8 always
    76 label *label23
-    * jump *label26 equal *tmp5 8
+   77 jump *label26 equal :processDigit:n 8
    78 jump *label25 always
    79 label *label26
    80 op add .S8 .S8 1
    81 set *tmp4 .S8
    82 jump *label8 always
    83 label *label25
-    * jump *label28 equal *tmp5 9
+   84 jump *label28 equal :processDigit:n 9
    85 jump *label27 always
    86 label *label28
    87 op add .S9 .S9 1

Modifications by Initial phase, Dead Code Elimination, iteration 1 (-2 instructions):
 
    90 label *label27
    91 set *tmp4 null
    92 label *label8
-    * set *tmp3 *tmp4
    93 label *label7
    94 op idiv :processNumber:n :processNumber:n 10
    95 label *label5
    96 jump *label4 always
    97 label *label6
-    * set *tmp0 null
    98 label *label3
    99 label *label1
   100 op add :i :i 1

Modifications by Initial phase, Dead Code Elimination, iteration 2 (-11 instructions):
 
    22 jump *label9 always
    23 label *label10
    24 op add .S0 .S0 1
-    * set *tmp4 .S0
    25 jump *label8 always
    26 label *label9
    27 jump *label12 equal :processDigit:n 1
    28 jump *label11 always
    29 label *label12
    30 op add .S1 .S1 1
-    * set *tmp4 .S1
    31 jump *label8 always
    32 label *label11
    33 jump *label14 equal :processDigit:n 2
    34 jump *label13 always
    35 label *label14
    36 op add .S2 .S2 1
-    * set *tmp4 .S2
    37 jump *label8 always
    38 label *label13
    39 jump *label16 equal :processDigit:n 3
    40 jump *label15 always
    41 label *label16
    42 op add .S3 .S3 1
-    * set *tmp4 .S3
    43 jump *label8 always
    44 label *label15
    45 jump *label18 equal :processDigit:n 4
    46 jump *label17 always
    47 label *label18
    48 op add .S4 .S4 1
-    * set *tmp4 .S4
    49 jump *label8 always
    50 label *label17
    51 jump *label20 equal :processDigit:n 5
    52 jump *label19 always
    53 label *label20
    54 op add .S5 .S5 1
-    * set *tmp4 .S5
    55 jump *label8 always
    56 label *label19
    57 jump *label22 equal :processDigit:n 6
    58 jump *label21 always
    59 label *label22
    60 op add .S6 .S6 1
-    * set *tmp4 .S6
    61 jump *label8 always
    62 label *label21
    63 jump *label24 equal :processDigit:n 7
    64 jump *label23 always
    65 label *label24
    66 op add .S7 .S7 1
-    * set *tmp4 .S7
    67 jump *label8 always
    68 label *label23
    69 jump *label26 equal :processDigit:n 8
    70 jump *label25 always
    71 label *label26
    72 op add .S8 .S8 1
-    * set *tmp4 .S8
    73 jump *label8 always
    74 label *label25
    75 jump *label28 equal :processDigit:n 9
    76 jump *label27 always
    77 label *label28
    78 op add .S9 .S9 1
-    * set *tmp4 .S9
    79 jump *label8 always
    80 label *label27
-    * set *tmp4 null
    81 label *label8
    82 label *label7
    83 op idiv :processNumber:n :processNumber:n 10

Modifications by Iterated phase, Jump Straightening, pass 1, iteration 1 (-10 instructions):
 
    18 op mod *tmp2 :processNumber:n 10
    19 # "Function: def processDigit(in n)"
    20 set :processDigit:n *tmp2
-    * jump *label10 equal :processDigit:n 0
-    * jump *label9 always
+   21 jump *label9 notEqual :processDigit:n 0
    22 label *label10
    23 op add .S0 .S0 1
    24 jump *label8 always
    25 label *label9
-    * jump *label12 equal :processDigit:n 1
-    * jump *label11 always
+   26 jump *label11 notEqual :processDigit:n 1
    27 label *label12
    28 op add .S1 .S1 1
    29 jump *label8 always
    30 label *label11
-    * jump *label14 equal :processDigit:n 2
-    * jump *label13 always
+   31 jump *label13 notEqual :processDigit:n 2
    32 label *label14
    33 op add .S2 .S2 1
    34 jump *label8 always
    35 label *label13
-    * jump *label16 equal :processDigit:n 3
-    * jump *label15 always
+   36 jump *label15 notEqual :processDigit:n 3
    37 label *label16
    38 op add .S3 .S3 1
    39 jump *label8 always
    40 label *label15
-    * jump *label18 equal :processDigit:n 4
-    * jump *label17 always
+   41 jump *label17 notEqual :processDigit:n 4
    42 label *label18
    43 op add .S4 .S4 1
    44 jump *label8 always
    45 label *label17
-    * jump *label20 equal :processDigit:n 5
-    * jump *label19 always
+   46 jump *label19 notEqual :processDigit:n 5
    47 label *label20
    48 op add .S5 .S5 1
    49 jump *label8 always
    50 label *label19
-    * jump *label22 equal :processDigit:n 6
-    * jump *label21 always
+   51 jump *label21 notEqual :processDigit:n 6
    52 label *label22
    53 op add .S6 .S6 1
    54 jump *label8 always
    55 label *label21
-    * jump *label24 equal :processDigit:n 7
-    * jump *label23 always
+   56 jump *label23 notEqual :processDigit:n 7
    57 label *label24
    58 op add .S7 .S7 1
    59 jump *label8 always
    60 label *label23
-    * jump *label26 equal :processDigit:n 8
-    * jump *label25 always
+   61 jump *label25 notEqual :processDigit:n 8
    62 label *label26
    63 op add .S8 .S8 1
    64 jump *label8 always
    65 label *label25
-    * jump *label28 equal :processDigit:n 9
-    * jump *label27 always
+   66 jump *label27 notEqual :processDigit:n 9
    67 label *label28
    68 op add .S9 .S9 1
    69 jump *label8 always

Modifications by Iterated phase, Condition Optimization, pass 1, iteration 1 (-1 instructions):
 
    13 # "Function: def processNumber(in n)"
    14 set :processNumber:n :i
    15 label *label4
-    * op greaterThan *tmp1 :processNumber:n 0
-    * jump *label6 equal *tmp1 false
+   16 jump *label6 lessThanEq :processNumber:n 0
    17 op mod *tmp2 :processNumber:n 10
    18 # "Function: def processDigit(in n)"
    19 set :processDigit:n *tmp2

Modifications by Iterated phase, Single Step Elimination, pass 1, iteration 1 (-1 instructions):
 
    65 jump *label27 notEqual :processDigit:n 9
    66 label *label28
    67 op add .S9 .S9 1
-    * jump *label8 always
    68 label *label27
    69 label *label8
    70 label *label7

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
     0 set .S9 0
-    * set .S8 .S9
-    * set .S7 .S8
-    * set .S6 .S7
-    * set .S5 .S6
-    * set .S4 .S5
-    * set .S3 .S4
-    * set .S2 .S3
-    * set .S1 .S2
-    * set .S0 .S1
+    1 set .S8 0
+    2 set .S7 .S9
+    3 set .S6 .S8
+    4 set .S5 .S7
+    5 set .S4 .S6
+    6 set .S3 .S5
+    7 set .S2 .S4
+    8 set .S1 .S3
+    9 set .S0 .S2
    10 set :i 1
    11 label *label0
    12 jump *label2 greaterThan :i 100
 
    17 op mod *tmp2 :processNumber:n 10
    18 # "Function: def processDigit(in n)"
    19 set :processDigit:n *tmp2
-    * jump *label9 notEqual :processDigit:n 0
+   20 jump *label9 notEqual *tmp2 0
    21 label *label10
    22 op add .S0 .S0 1
    23 jump *label8 always
    24 label *label9
-    * jump *label11 notEqual :processDigit:n 1
+   25 jump *label11 notEqual *tmp2 1
    26 label *label12
    27 op add .S1 .S1 1
    28 jump *label8 always
    29 label *label11
-    * jump *label13 notEqual :processDigit:n 2
+   30 jump *label13 notEqual *tmp2 2
    31 label *label14
    32 op add .S2 .S2 1
    33 jump *label8 always
    34 label *label13
-    * jump *label15 notEqual :processDigit:n 3
+   35 jump *label15 notEqual *tmp2 3
    36 label *label16
    37 op add .S3 .S3 1
    38 jump *label8 always
    39 label *label15
-    * jump *label17 notEqual :processDigit:n 4
+   40 jump *label17 notEqual *tmp2 4
    41 label *label18
    42 op add .S4 .S4 1
    43 jump *label8 always
    44 label *label17
-    * jump *label19 notEqual :processDigit:n 5
+   45 jump *label19 notEqual *tmp2 5
    46 label *label20
    47 op add .S5 .S5 1
    48 jump *label8 always
    49 label *label19
-    * jump *label21 notEqual :processDigit:n 6
+   50 jump *label21 notEqual *tmp2 6
    51 label *label22
    52 op add .S6 .S6 1
    53 jump *label8 always
    54 label *label21
-    * jump *label23 notEqual :processDigit:n 7
+   55 jump *label23 notEqual *tmp2 7
    56 label *label24
    57 op add .S7 .S7 1
    58 jump *label8 always
    59 label *label23
-    * jump *label25 notEqual :processDigit:n 8
+   60 jump *label25 notEqual *tmp2 8
    61 label *label26
    62 op add .S8 .S8 1
    63 jump *label8 always
    64 label *label25
-    * jump *label27 notEqual :processDigit:n 9
+   65 jump *label27 notEqual *tmp2 9
    66 label *label28
    67 op add .S9 .S9 1
    68 label *label27

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 2 (-1 instructions):
     0 set .S9 0
     1 set .S8 0
-    * set .S7 .S9
-    * set .S6 .S8
-    * set .S5 .S7
-    * set .S4 .S6
-    * set .S3 .S5
-    * set .S2 .S4
-    * set .S1 .S3
-    * set .S0 .S2
+    2 set .S7 0
+    3 set .S6 0
+    4 set .S5 .S9
+    5 set .S4 .S8
+    6 set .S3 .S7
+    7 set .S2 .S6
+    8 set .S1 .S5
+    9 set .S0 .S4
    10 set :i 1
    11 label *label0
    12 jump *label2 greaterThan :i 100
 
    16 jump *label6 lessThanEq :processNumber:n 0
    17 op mod *tmp2 :processNumber:n 10
    18 # "Function: def processDigit(in n)"
-    * set :processDigit:n *tmp2
    19 jump *label9 notEqual *tmp2 0
    20 label *label10
    21 op add .S0 .S0 1

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 3:
 
     1 set .S8 0
     2 set .S7 0
     3 set .S6 0
-    * set .S5 .S9
-    * set .S4 .S8
-    * set .S3 .S7
-    * set .S2 .S6
-    * set .S1 .S5
-    * set .S0 .S4
+    4 set .S5 0
+    5 set .S4 0
+    6 set .S3 0
+    7 set .S2 0
+    8 set .S1 .S9
+    9 set .S0 .S8
    10 set :i 1
    11 label *label0
    12 jump *label2 greaterThan :i 100

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 4:
 
     5 set .S4 0
     6 set .S3 0
     7 set .S2 0
-    * set .S1 .S9
-    * set .S0 .S8
+    8 set .S1 0
+    9 set .S0 0
    10 set :i 1
    11 label *label0
    12 jump *label2 greaterThan :i 100

Modifications by Iterated phase, Loop Optimization, pass 1, iteration 1 (-1 instructions):
 
     9 set .S0 0
    10 set :i 1
    11 label *label0
-    * jump *label2 greaterThan :i 100
+   12 label *label29
    13 # "Function: def processNumber(in n)"
    14 set :processNumber:n :i
    15 label *label4
    16 jump *label6 lessThanEq :processNumber:n 0
+   17 label *label30
    18 op mod *tmp2 :processNumber:n 10
    19 # "Function: def processDigit(in n)"
    20 jump *label9 notEqual *tmp2 0
 
    70 label *label7
    71 op idiv :processNumber:n :processNumber:n 10
    72 label *label5
-    * jump *label4 always
+   73 jump *label30 greaterThan :processNumber:n 0
    74 label *label6
    75 label *label3
    76 label *label1
    77 op add :i :i 1
-    * jump *label0 always
+   78 jump *label29 lessThanEq :i 100
    79 label *label2
    80 assertequals 11 .S0 "Unexpected value of S0"
    81 assertequals 21 .S1 "Unexpected value of S1"

Modifications by Convert case at line 27:5 (segments: 10) (+2 instructions):
 
    17 label *label30
    18 op mod *tmp2 :processNumber:n 10
    19 # "Function: def processDigit(in n)"
-    * jump *label9 notEqual *tmp2 0
+   20 jump *label32 greaterThanEq *tmp2 5
+   21 jump *label33 greaterThanEq *tmp2 2
+   22 jump *label31 lessThan *tmp2 0
+   23 jump *label12 greaterThanEq *tmp2 1
    24 label *label10
-    * op add .S0 .S0 1
-    * jump *label8 always
+   25 op add .S0 .S0 1
+   26 jump *label8 always
+   27 label *label33
+   28 jump *label14 lessThan *tmp2 3
+   29 jump *label18 greaterThanEq *tmp2 4
+   30 label *label16
+   31 op add .S3 .S3 1
+   32 jump *label8 always
+   33 label *label32
+   34 jump *label34 greaterThanEq *tmp2 8
+   35 jump *label20 lessThan *tmp2 6
+   36 jump *label24 greaterThanEq *tmp2 7
+   37 label *label22
+   38 op add .S6 .S6 1
+   39 jump *label8 always
+   40 label *label34
+   41 jump *label26 lessThan *tmp2 9
+   42 jump *label28 lessThan *tmp2 10
+   43 jump *label31 always
    44 label *label9
-    * jump *label11 notEqual *tmp2 1
    45 label *label12
    46 op add .S1 .S1 1
    47 jump *label8 always
    48 label *label11
-    * jump *label13 notEqual *tmp2 2
    49 label *label14
    50 op add .S2 .S2 1
    51 jump *label8 always
    52 label *label13
-    * jump *label15 notEqual *tmp2 3
-    * label *label16
-    * op add .S3 .S3 1
-    * jump *label8 always
    53 label *label15
-    * jump *label17 notEqual *tmp2 4
    54 label *label18
    55 op add .S4 .S4 1
    56 jump *label8 always
    57 label *label17
-    * jump *label19 notEqual *tmp2 5
    58 label *label20
    59 op add .S5 .S5 1
    60 jump *label8 always
    61 label *label19
-    * jump *label21 notEqual *tmp2 6
-    * label *label22
-    * op add .S6 .S6 1
-    * jump *label8 always
    62 label *label21
-    * jump *label23 notEqual *tmp2 7
    63 label *label24
    64 op add .S7 .S7 1
    65 jump *label8 always
    66 label *label23
-    * jump *label25 notEqual *tmp2 8
    67 label *label26
    68 op add .S8 .S8 1
    69 jump *label8 always
    70 label *label25
-    * jump *label27 notEqual *tmp2 9
    71 label *label28
    72 op add .S9 .S9 1
    73 label *label27
+   74 label *label31
    75 label *label8
    76 label *label7
    77 op idiv :processNumber:n :processNumber:n 10

Modifications by Iterated phase, Data Flow Optimization, pass 1, iteration 1:
 
    13 # "Function: def processNumber(in n)"
    14 set :processNumber:n :i
    15 label *label4
-    * jump *label6 lessThanEq :processNumber:n 0
+   16 jump *label6 lessThanEq :i 0
    17 label *label30
    18 op mod *tmp2 :processNumber:n 10
    19 # "Function: def processDigit(in n)"

Modifications by Jumps phase, Jump Normalization, pass 3, iteration 1:
 
     8 set .S1 0
     9 set .S0 0
    10 set :i 1
-    * label *label0
    11 label *label29
    12 # "Function: def processNumber(in n)"
    13 set :processNumber:n :i
-    * label *label4
    14 jump *label6 lessThanEq :i 0
    15 label *label30
    16 op mod *tmp2 :processNumber:n 10
 
    19 jump *label33 greaterThanEq *tmp2 2
    20 jump *label31 lessThan *tmp2 0
    21 jump *label12 greaterThanEq *tmp2 1
-    * label *label10
    22 op add .S0 .S0 1
    23 jump *label8 always
    24 label *label33
    25 jump *label14 lessThan *tmp2 3
    26 jump *label18 greaterThanEq *tmp2 4
-    * label *label16
    27 op add .S3 .S3 1
    28 jump *label8 always
    29 label *label32
    30 jump *label34 greaterThanEq *tmp2 8
    31 jump *label20 lessThan *tmp2 6
    32 jump *label24 greaterThanEq *tmp2 7
-    * label *label22
    33 op add .S6 .S6 1
    34 jump *label8 always
    35 label *label34
    36 jump *label26 lessThan *tmp2 9
    37 jump *label28 lessThan *tmp2 10
    38 jump *label31 always
-    * label *label9
    39 label *label12
    40 op add .S1 .S1 1
    41 jump *label8 always
-    * label *label11
    42 label *label14
    43 op add .S2 .S2 1
    44 jump *label8 always
-    * label *label13
-    * label *label15
    45 label *label18
    46 op add .S4 .S4 1
    47 jump *label8 always
-    * label *label17
    48 label *label20
    49 op add .S5 .S5 1
    50 jump *label8 always
-    * label *label19
-    * label *label21
    51 label *label24
    52 op add .S7 .S7 1
    53 jump *label8 always
-    * label *label23
    54 label *label26
    55 op add .S8 .S8 1
    56 jump *label8 always
-    * label *label25
    57 label *label28
    58 op add .S9 .S9 1
-    * label *label27
    59 label *label31
    60 label *label8
-    * label *label7
    61 op idiv :processNumber:n :processNumber:n 10
-    * label *label5
    62 jump *label30 greaterThan :processNumber:n 0
    63 label *label6
-    * label *label3
-    * label *label1
    64 op add :i :i 1
    65 jump *label29 lessThanEq :i 100
-    * label *label2
    66 assertequals 11 .S0 "Unexpected value of S0"
    67 assertequals 21 .S1 "Unexpected value of S1"
    68 assertequals 20 .S2 "Unexpected value of S2"

Modifications by Jumps phase, Single Step Elimination, pass 3, iteration 1 (-1 instructions):
 
    74 assertequals 20 .S8 "Unexpected value of S8"
    75 assertequals 20 .S9 "Unexpected value of S9"
    76 stop
-    * end

Final code before resolving virtual instructions:

set .S9 0
set .S8 0
set .S7 0
set .S6 0
set .S5 0
set .S4 0
set .S3 0
set .S2 0
set .S1 0
set .S0 0
set :i 1
label *label29
# "Function: def processNumber(in n)"
set :processNumber:n :i
jump *label6 lessThanEq :i 0
label *label30
op mod *tmp2 :processNumber:n 10
# "Function: def processDigit(in n)"
jump *label32 greaterThanEq *tmp2 5
jump *label33 greaterThanEq *tmp2 2
jump *label31 lessThan *tmp2 0
jump *label12 greaterThanEq *tmp2 1
op add .S0 .S0 1
jump *label8 always
label *label33
jump *label14 lessThan *tmp2 3
jump *label18 greaterThanEq *tmp2 4
op add .S3 .S3 1
jump *label8 always
label *label32
jump *label34 greaterThanEq *tmp2 8
jump *label20 lessThan *tmp2 6
jump *label24 greaterThanEq *tmp2 7
op add .S6 .S6 1
jump *label8 always
label *label34
jump *label26 lessThan *tmp2 9
jump *label28 lessThan *tmp2 10
jump *label31 always
label *label12
op add .S1 .S1 1
jump *label8 always
label *label14
op add .S2 .S2 1
jump *label8 always
label *label18
op add .S4 .S4 1
jump *label8 always
label *label20
op add .S5 .S5 1
jump *label8 always
label *label24
op add .S7 .S7 1
jump *label8 always
label *label26
op add .S8 .S8 1
jump *label8 always
label *label28
op add .S9 .S9 1
label *label31
label *label8
op idiv :processNumber:n :processNumber:n 10
jump *label30 greaterThan :processNumber:n 0
label *label6
op add :i :i 1
jump *label29 lessThanEq :i 100
assertequals 11 .S0 "Unexpected value of S0"
assertequals 21 .S1 "Unexpected value of S1"
assertequals 20 .S2 "Unexpected value of S2"
assertequals 20 .S3 "Unexpected value of S3"
assertequals 20 .S4 "Unexpected value of S4"
assertequals 20 .S5 "Unexpected value of S5"
assertequals 20 .S6 "Unexpected value of S6"
assertequals 20 .S7 "Unexpected value of S7"
assertequals 20 .S8 "Unexpected value of S8"
assertequals 20 .S9 "Unexpected value of S9"
stop
