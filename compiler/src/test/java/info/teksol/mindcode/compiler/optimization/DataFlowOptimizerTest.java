package info.teksol.mindcode.compiler.optimization;

import info.teksol.mindcode.MindcodeMessage;
import info.teksol.mindcode.compiler.CompilerProfile;
import info.teksol.mindcode.compiler.ExpectedMessages;
import info.teksol.mindcode.compiler.GenerationGoal;
import info.teksol.mindcode.logic.ProcessorVersion;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;

import java.util.List;

import static info.teksol.mindcode.logic.Opcode.*;
import static org.junit.jupiter.api.Assertions.assertEquals;

@Order(99)
class DataFlowOptimizerTest extends AbstractOptimizerTest<DataFlowOptimizer> {

    @Override
    protected Class<DataFlowOptimizer> getTestedClass() {
        return DataFlowOptimizer.class;
    }

    @Override
    protected List<Optimization> getAllOptimizations() {
        // Need to test interactions with all optimizers except function inlining
        return Optimization.LIST.stream().filter(o -> o != Optimization.FUNCTION_INLINING).toList();
    }

    @Override
    protected CompilerProfile createCompilerProfile() {
        return super.createCompilerProfile().setGoal(GenerationGoal.SPEED);
    }

    //<editor-fold desc="Warnings">
    @Test
    void generatesUninitializedWarning() {
        assertGeneratesMessages(
                ExpectedMessages.create().add("List of uninitialized variables: i."),
                """
                        j = i;
                        i = 10;      // Avoid the warning generated by dead code eliminator
                        print(i, j);
                        """
        );
    }

    @Test
    void recognizesIfStatementInitialization() {
        assertGeneratesMessages(
                ExpectedMessages.none(),
                """
                        if switch1.enabled then
                            a = rand(10);
                            b = rand(10);
                        else
                            a = -rand(10);
                            b = -rand(10);
                        end;
                        print(a, b);
                        """
        );
    }

    @Test
    void recognizesPartialIfStatementInitialization() {
        assertGeneratesMessages(
                ExpectedMessages.create().add("List of uninitialized variables: b."),
                """
                        if switch1.enabled then
                            a = 1;
                            b = a;
                        else
                            a = 2;
                            print(a);
                        end;
                        print(b);
                        """
        );
    }

    @Test
    void generatesWarningsAboutLocalVariables() {
        assertGeneratesMessages(
                ExpectedMessages.create().add("List of uninitialized variables: foo.n."),
                """
                         def foo()
                             print(n);
                         end;
                         foo();
                         foo();
                        """
        );
    }

    @Test
    void generatesNoWarningsAboutFunctionParameters() {
        assertGeneratesMessages(
                ExpectedMessages.none(),
                """
                         def foo(n)
                             print(n);
                         end;
                         foo(0);
                         foo(1);
                        """
        );
    }

    @Test
    void producesNoWarningsOnBasicLevel() {
        assertGeneratesMessages(createTestCompiler(CompilerProfile.standardOptimizations(false)),
                ExpectedMessages.none(),
                """
                        for n in 0 ... 1000 do
                            j = switch1.enabled;
                            print(j);
                        end;
                        """
        );
    }

    @Test
    void producesNoWarningsOnBasicLoop() {
        assertGeneratesMessages(createTestCompiler(CompilerProfile.standardOptimizations(false)),
                ExpectedMessages.none(),
                """
                        while true do
                            i = switch1.enabled;
                        end;
                        print(i);
                        """
        );
    }

    @Test
    void producesNoWarningsOnBasicLoop2() {
        assertGeneratesMessages(createTestCompiler(CompilerProfile.standardOptimizations(false)),
                ExpectedMessages.none(),
                """
                        x = 159;
                        while x > 10 do
                            x1 = x - 5;
                            x = x1;
                        end;
                        """
        );
    }
    //</editor-fold>

    //<editor-fold desc="Global variables/parameters/blocks">
    @Test
    void leavesGlobalParameters() {
        assertCompilesTo("""
                        param a = 1;
                        b = 2;
                        print(a * b);
                        """,
                createInstruction(SET, "a", "1"),
                createInstruction(OP, "mul", var(0), "a", "2"),
                createInstruction(PRINT, var(0))
        );
    }

    @Test
    void correctlyProcessesFunctions() {
        assertGeneratesMessages(
                ExpectedMessages.none(),
                """
                        #set optimization = experimental;
                        A = 10;
                        for i = 0; i < A; i += 1 do
                            foo(2);
                        end;
                        
                        noinline def foo(n)
                            println(n);
                            bar(n);
                        end;
                        
                        noinline def bar(x)
                            A = x;
                        end;
                        """
        );
    }

    //</editor-fold>


    //<editor-fold desc="Volatile variables">
    // TODO Activate after adding support for volatile declaration for blocks
    /*
    @Test
    void recognizesNonvolatileSensorWithBlocks() {
        assertCompilesTo(createTestCompiler(createCompilerProfile().setMemoryModel(MemoryModel.ALIASED)),
                        """
                        a = message1.type;
                        b = message1.type;
                        print(a, b);
                        """,
                createInstruction(SENSOR, "a", "message1", "@type"),
                createInstruction(PRINT, "a"),
                createInstruction(PRINT, "a")
        );
    }

    @Test
    void recognizesNonvolatileSensorWithVariables() {
        assertCompilesTo(createTestCompiler(createCompilerProfile().setMemoryModel(MemoryModel.ALIASED)),
                        """
                        block = getlink(0);
                        a = block.type;
                        b = block.type;
                        print(a, b);
                        """,
                createInstruction(GETLINK, "block", "0"),
                createInstruction(SENSOR, "a", "block", "@type"),
                createInstruction(PRINT, "a"),
                createInstruction(PRINT, "a")
        );
    }
    */

    @Test
    void respectsVolatileVariables() {
        assertCompilesTo(
                ExpectedMessages.create()
                        .add("Variable 'A' is used as argument in the 'sync()' function, will be considered volatile."),
                """
                        sync(A);
                        before = A;
                        wait(1000);
                        after = A;
                        print(after - before);
                        """,
                createInstruction(SYNC, "A"),
                createInstruction(SET, "before", "A"),
                createInstruction(WAIT, "1000"),
                createInstruction(SET, "after", "A"),
                createInstruction(OP, "sub", var(2), "after", "before"),
                createInstruction(PRINT, var(2))
        );
    }
    //</editor-fold>


    //<editor-fold desc="Main variables">
    @Test
    void removesUnneededVariables() {
        assertCompilesTo("""
                        i = 5;
                        j = 10;
                        j = 15;
                        i = j + 2;
                        print(i, j);
                        """,
                createInstruction(PRINT, q("1715"))
        );
    }


    @Test
    void leavesUninitializedVariables() {
        assertCompilesTo(
                ExpectedMessages.create().add("List of uninitialized variables: flag."),
                """
                        print(flag);
                        flag = 1;
                        """,
                createInstruction(PRINT, "flag"),
                createInstruction(SET, "flag", "1")        // This instruction is kept
        );
    }

    @Test
    void keepsLatestAssignment() {
        assertCompilesTo("""
                        index = 0;
                        b = rand(10);
                        index = 0;
                        while index < 1000 do
                            print(b);
                            index = index + 1;
                        end;
                        """,
                createInstruction(OP, "rand", "b", "10"),
                createInstruction(SET, "index", "0"),
                createInstruction(LABEL, var(1003)),
                createInstruction(PRINT, "b"),
                createInstruction(OP, "add", "index", "index", "1"),
                createInstruction(JUMP, var(1003), "lessThan", "index", "1000")
        );
    }
    //</editor-fold>

    //<editor-fold desc="If statements">
    @Test
    void processesIfStatements() {
        assertCompilesTo("""
                        a = 0;
                        b = 0;
                        if switch1.enabled then
                            a = 1;
                            b = 2;
                        else
                            a = 2;
                            b = 3;
                            print(a);
                        end;
                        print(b);
                        """,
                createInstruction(SENSOR, var(0), "switch1", "@enabled"),
                createInstruction(JUMP, var(1000), "equal", var(0), "false"),
                createInstruction(SET, "b", "2"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "b", "3"),
                createInstruction(PRINT, "2"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "b")
        );
    }

    @Test
    void evaluatesConstantIfsFully() {
        assertCompilesTo("""
                        i = 1;
                        print(i % 2 == 0 ? 1 : 2);
                        """,
                createInstruction(PRINT, var(2))
        );
    }

    @Test
    void evaluatesConstantIfsInLoopFully() {
        assertCompilesTo("""
                        def getBit(bitIndex)
                            bitIndex % 2;
                        end;
                        
                        for i in 1 ... 2 do
                            print(getBit(i) ? 1 : 0);
                        end;
                        """,
                createInstruction(PRINT, "1")
        );
    }

    @Test
    void removesUnneededAssignmentsInConditions() {
        assertCompilesTo("""
                        a = 0;
                        if switch1.enabled then
                            a = 1;
                            b = a;
                        else
                            a = 2;
                            b = 1;
                        end;
                        print(a, b);
                        """,
                createInstruction(SET, "a", "2"),
                createInstruction(SENSOR, var(0), "switch1", "@enabled"),
                createInstruction(JUMP, var(1001), "equal", var(0), "false"),
                createInstruction(SET, "a", "1"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "a"),
                createInstruction(PRINT, "1")
        );
    }

    @Test
    void IdentifiesUninitializedVariables() {
        assertCompilesTo(ExpectedMessages.create().add("List of uninitialized variables: a, b."),
                """
                        if switch1.enabled then
                            a = 1;
                        else
                            b = 1;
                        end;
                        print(a, b);
                        """,
                createInstruction(SENSOR, var(0), "switch1", "@enabled"),
                createInstruction(JUMP, var(1000), "equal", var(0), "false"),
                createInstruction(SET, "a", "1"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "b", "1"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "a"),
                createInstruction(PRINT, "b")
        );
    }

    @Test
    void handlesSingleBranchIfStatements() {
        assertCompilesTo("""
                        a = 1;
                        if switch1.enabled then
                            a = 2;
                        end;
                        print(a);
                        """,
                createInstruction(SET, "a", "1"),
                createInstruction(SENSOR, var(0), "switch1", "@enabled"),
                createInstruction(JUMP, var(1000), "equal", var(0), "false"),
                createInstruction(SET, "a", "2"),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "a")
        );
    }

    @Test
    void handlesOptimizedIfStatements() {
        assertCompilesTo("""
                        a = 10;
                        print(a > 5 ? "High" : "Low");
                        """,
                createInstruction(PRINT, q("High"))
        );
    }

    @Test
    void optimizesBranchedExpressions() {
        assertCompilesTo("""
                        a = rand(10);
                        b = a + 1;
                        if switch1.enabled then
                            c = 2 * (a + 1);
                            print(c);
                        else
                            c = 10;
                            print(c);
                        end;
                        print(b, c);
                        """,
                createInstruction(OP, "rand", "a", "10"),
                createInstruction(OP, "add", "b", "a", "1"),
                createInstruction(SENSOR, var(2), "switch1", "@enabled"),
                createInstruction(JUMP, var(1000), "equal", var(2), "false"),
                createInstruction(OP, "mul", "c", "2", "b"),
                createInstruction(PRINT, "c"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "c", "10"),
                createInstruction(PRINT, "10"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "b"),
                createInstruction(PRINT, "c")
        );
    }

    @Test
    void optimizesAssignmentsInConditions() {
        assertCompilesTo("""
                        if result = !rand(10) then
                            print("A");
                        end;
                        print(result);
                        """,
                createInstruction(OP, "rand", var(0), "10"),
                createInstruction(OP, "equal", "result", var(0), "false"),
                createInstruction(JUMP, var(1000), "equal", "result", "false"),
                createInstruction(PRINT, q("A")),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "result")
        );
    }
    //</editor-fold>

    //<editor-fold desc="Case statements">
    @Test
    void handlesCaseExpressions() {
        assertCompilesTo("""
                        a = case cell1[0]
                            when 0, 1, 2 then 10;
                            when 10 .. 20 then 20;
                            else 30;
                        end;
                        print(a);
                        """,
                createInstruction(READ, var(0), "cell1", "0"),
                createInstruction(JUMP, var(1002), "equal", var(0), "0"),
                createInstruction(JUMP, var(1002), "equal", var(0), "1"),
                createInstruction(JUMP, var(1001), "notEqual", var(0), "2"),
                createInstruction(LABEL, var(1002)),
                createInstruction(SET, var(1), "10"),
                createInstruction(JUMP, var(1000), "always"),
                createInstruction(LABEL, var(1001)),
                createInstruction(JUMP, var(1003), "lessThan", var(0), "10"),
                createInstruction(JUMP, var(1004), "lessThanEq", var(0), "20"),
                createInstruction(JUMP, var(1003), "always"),
                createInstruction(LABEL, var(1004)),
                createInstruction(SET, var(1), "20"),
                createInstruction(JUMP, var(1000), "always"),
                createInstruction(LABEL, var(1003)),
                createInstruction(SET, var(1), "30"),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, var(1))
        );
    }

    @Test
    void handlesCaseExpressionsWithWhenSideEffects() {
        assertCompilesTo(ExpectedMessages.create().add("List of uninitialized variables: x."),
                """
                        case switch1.enabled
                            when 1, x = 2 then print(x);
                        end;
                        """,
                createInstruction(LABEL, "__start__"),
                createInstruction(SENSOR, var(0), "switch1", "@enabled"),
                createInstruction(JUMP, var(1002), "equal", var(0), "1"),
                createInstruction(SET, "x", "2"),
                createInstruction(JUMP, "__start__", "notEqual", var(0), "2"),
                createInstruction(LABEL, var(1002)),
                createInstruction(PRINT, "x")
        );
    }

    @Test
    void handlesConstantCaseExpressions() {
        assertCompilesTo("""
                        n = 1;
                        sort = case n when 1 then sorter1; end;
                        print(sort);
                        """,
                createInstruction(SET, var(0), "sorter1"),
                createInstruction(PRINT, var(0))
        );
    }
    //</editor-fold>

    //<editor-fold desc="Loops">
    @Test
    void handlesWhileLoops() {
        assertCompilesTo("""
                        i = 0;
                        while i < 10000 do
                            i = i + 1;
                        end;
                        print(i);
                        """,
                createInstruction(SET, "i", "0"),
                createInstruction(LABEL, var(1003)),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1003), "lessThan", "i", "10000"),
                createInstruction(PRINT, "i")
        );
    }

    @Test
    void handlesForEachLoops() {
        assertCompilesTo(createTestCompiler(
                        createCompilerProfile().setOptimizationLevel(Optimization.LOOP_UNROLLING, OptimizationLevel.NONE)),
                """
                        for i in 1, 2, 3 do
                            print(i);
                        end;
                        """,
                createInstruction(SETADDR, var(0), var(1003)),
                createInstruction(SET, "i", "1"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(GOTOLABEL, var(1003), "marker0"),
                createInstruction(SETADDR, var(0), var(1004)),
                createInstruction(SET, "i", "2"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(GOTOLABEL, var(1004), "marker0"),
                createInstruction(SETADDR, var(0), var(1005)),
                createInstruction(SET, "i", "3"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "i"),
                createInstruction(GOTO, var(0), "marker0"),
                createInstruction(GOTOLABEL, var(1005), "marker0")
        );
    }

    @Test
    void handlesForEachLoopsWithModifications() {
        assertCompilesTo(createTestCompiler(
                        createCompilerProfile().setOptimizationLevel(Optimization.LOOP_UNROLLING, OptimizationLevel.NONE)),
                """
                        for out i, out j in a, b, c, d do
                            i = rand(10);
                            j = 2 * i;
                        end;
                        
                        print(a, b, c, d);
                        """,
                createInstruction(SETADDR, var(0), var(1003)),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(GOTOLABEL, var(1003), "marker0"),
                createInstruction(SET, "a", "i"),
                createInstruction(SET, "b", "j"),
                createInstruction(SETADDR, var(0), var(1004)),
                createInstruction(LABEL, var(1001)),
                createInstruction(OP, "rand", "i", "10"),
                createInstruction(OP, "mul", "j", "2", "i"),
                createInstruction(GOTO, var(0), "marker0"),
                createInstruction(GOTOLABEL, var(1004), "marker0"),
                createInstruction(SET, "c", "i"),
                createInstruction(SET, "d", "j"),
                createInstruction(PRINT, "a"),
                createInstruction(PRINT, "b"),
                createInstruction(PRINT, "c"),
                createInstruction(PRINT, "d")
        );
    }

    @Test
    void handlesDoWhileLoops() {
        assertCompilesTo("""
                        i = 0;
                        do
                            min = cell1[i];
                            i += 1;
                        loop while i < 1000;
                        print(min);
                        """,
                createInstruction(SET, "i", "0"),
                createInstruction(LABEL, var(1000)),
                createInstruction(READ, "min", "cell1", "i"),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1000), "lessThan", "i", "1000"),
                createInstruction(PRINT, "min")
        );
    }

    @Test
    void handlesRangedForLoops() {
        // min is uninitialized because we do not know the loop body will execute
        assertCompilesTo(
                ExpectedMessages.create()
                        .add("List of uninitialized variables: SIZE, min.")
                        .add("List of uninitialized variables: SIZE."),
                """
                        for i in 0 ... SIZE - 1 do
                            min = cell1[i];
                        end;
                        print(min);
                        """,
                createInstruction(OP, "sub", var(1), "SIZE", "1"),
                createInstruction(SET, "i", "0"),
                createInstruction(JUMP, var(1002), "greaterThanEq", "0", var(1)),
                createInstruction(LABEL, var(1003)),
                createInstruction(READ, "min", "cell1", "i"),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1003), "lessThan", "i", var(1)),
                createInstruction(LABEL, var(1002)),
                createInstruction(PRINT, "min")
        );
    }

    @Test
    void handlesNestedLoops() {
        assertCompilesTo("""
                        for i = 0; i < 1000; i += 1 do
                            for j = 0; j < 1000; j += 1 do
                                print(i, j);
                            end;
                        end;
                        """,
                createInstruction(SET, "i", "0"),
                createInstruction(LABEL, var(1006)),
                createInstruction(SET, "j", "0"),
                createInstruction(LABEL, var(1007)),
                createInstruction(PRINT, "i"),
                createInstruction(PRINT, "j"),
                createInstruction(OP, "add", "j", "j", "1"),
                createInstruction(JUMP, var(1007), "lessThan", "j", "1000"),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1006), "lessThan", "i", "1000")
        );
    }

    @Test
    void handlesDescendingLoops() {
        assertCompilesTo("""
                        const LENGTH = 1500;
                        for row = LENGTH - 2; row >= 0; row -= 1 do
                            for col = row + 1; col >= 0; col -= 1 do
                                print(col);
                            end;
                        end;
                        """,
                createInstruction(SET, "row", "1498"),
                createInstruction(LABEL, var(1006)),
                createInstruction(OP, "add", "col", "row", "1"),
                createInstruction(JUMP, var(1005), "lessThan", "col", "0"),
                createInstruction(LABEL, var(1007)),
                createInstruction(PRINT, "col"),
                createInstruction(OP, "sub", "col", "col", "1"),
                createInstruction(JUMP, var(1007), "greaterThanEq", "col", "0"),
                createInstruction(LABEL, var(1005)),
                createInstruction(OP, "sub", "row", "row", "1"),
                createInstruction(JUMP, var(1006), "greaterThanEq", "row", "0")
        );
    }

    @Test
    void handlesContinueInLoops() {
        assertCompilesTo("""
                        for i in 1 ... 1000 do
                            if i == 5 then
                                continue;
                            else
                                str = i;
                            end;
                            print(str);
                        end;
                        """,
                createInstruction(SET, "i", "1"),
                createInstruction(LABEL, var(1005)),
                createInstruction(JUMP, var(1001), "equal", "i", "5"),
                createInstruction(PRINT, "i"),
                createInstruction(LABEL, var(1001)),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1005), "lessThan", "i", "1000")
        );
    }

    @Test
    void handlesDeadEnds() {
        assertCompilesTo("""
                        for i in 1 ... 1000 do
                            print(i);
                            if i == 5 then
                                continue;
                            else
                                break;
                            end;
                            print(i + 1);
                        end;
                        """,
                createInstruction(LABEL, "__start__"),
                createInstruction(SET, "i", "1"),
                createInstruction(LABEL, var(1005)),
                createInstruction(PRINT, "i"),
                createInstruction(JUMP, "__start__", "notEqual", "i", "5"),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1005), "lessThan", "i", "1000")
        );
    }

    @Test
    void optimizesDataFlowAfterLoopOptimization() {
        assertCompilesTo("""
                        index = rand(10);
                        parent = 0;
                        while (child = parent * 2 + 1) <= index do
                            parent = child;
                        end;
                        print(parent);
                        """,
                createInstruction(OP, "rand", "index", "10"),
                createInstruction(SET, "parent", "0"),
                createInstruction(SET, "child", "1"),
                createInstruction(JUMP, var(1002), "greaterThan", "1", "index"),
                createInstruction(LABEL, var(1003)),
                createInstruction(SET, "parent", "child"),
                createInstruction(OP, "mul", var(1), "child", "2"),
                createInstruction(OP, "add", "child", var(1), "1"),
                createInstruction(JUMP, var(1003), "lessThanEq", "child", "index"),
                createInstruction(LABEL, var(1002)),
                createInstruction(PRINT, "parent")
        );
    }

    @Test
    void handlesNonConstantExpressions() {
        assertCompilesTo("""
                        x = 0;
                        while true do
                            print(x + 1);
                            x = rand(10);
                            print(x + 1);
                        end;
                        """,
                createInstruction(SET, "x", "0"),
                createInstruction(LABEL, var(1000)),
                createInstruction(OP, "add", var(0), "x", "1"),
                createInstruction(PRINT, var(0)),
                createInstruction(OP, "rand", "x", "10"),
                createInstruction(OP, "add", var(2), "x", "1"),
                createInstruction(PRINT, var(2)),
                createInstruction(JUMP, var(1000), "always")
        );
    }

    @Test
    void properlyInvalidatesExpressions() {
        assertCompilesTo("""
                        a = rand(10) > 5;
                        b = a > 5;
                        c = b or a < 5;
                        d = a;
                        
                        while true do
                            if c then
                                d += 1;
                                c = b or d < 5;
                            end;
                        end;
                        """,
                createInstruction(OP, "rand", var(0), "10"),
                createInstruction(OP, "greaterThan", "a", var(0), "5"),
                createInstruction(OP, "greaterThan", "b", "a", "5"),
                createInstruction(OP, "lessThan", var(3), "a", "5"),
                createInstruction(OP, "or", "c", "b", var(3)),
                createInstruction(SET, "d", "a"),
                createInstruction(LABEL, var(1000)),
                createInstruction(JUMP, var(1000), "equal", "c", "false"),
                createInstruction(OP, "add", "d", "d", "1"),
                createInstruction(OP, "lessThan", var(4), "d", "5"),
                createInstruction(OP, "or", "c", "b", var(4)),
                createInstruction(JUMP, var(1000), "always")


        );
    }
    //</editor-fold>

    //<editor-fold desc="Exit points">
    @Test
    void handlesReturnStatements() {
        assertCompilesTo("""
                        inline def foo(n)
                          return n;
                        end;
                        
                        print(foo(4));
                        """,
                createInstruction(PRINT, "4")
        );
    }

    @Test
    void handlesConditionalReturnStatements() {
        assertCompilesTo("""
                        #set optimization = advanced;
                        
                        print(foo(rand(10)));
                        def foo(d)
                            if d % 2 == 0 then
                                return 1;
                            end;
                        end;
                        """,
                createInstruction(OP, "rand", var(0), "10"),
                createInstruction(OP, "mod", var(2), var(0), "2"),
                createInstruction(JUMP, var(1002), "notEqual", var(2), "0"),
                createInstruction(SET, var(1), "1"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(LABEL, var(1002)),
                createInstruction(SET, var(1), "null"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, var(1))
        );
    }

    @Test
    void handlesEndInFunction() {
        assertCompilesTo("""
                        def foo(n)
                            if n > 0 then
                                return n;
                            end;
                            end();
                        end;
                        print(foo(rand(10)));
                        """,
                createInstruction(OP, "rand", var(0), "10"),
                createInstruction(JUMP, var(1001), "greaterThan", var(0), "0"),
                createInstruction(END),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, var(0))
        );
    }

    @Test
    void handlesReturnInLoop() {
        assertCompilesTo(new TestCompiler(CompilerProfile.fullOptimizations(false)),
                """
                        if UNIT_S1 == null then UNIT_S1 = findUnit(); end;
                        inline def findUnit()
                            while true do
                                return @unit;
                            end;
                        end;
                        """,
                createInstruction(LABEL, "__start__"),
                createInstruction(JUMP, "__start__", "notEqual", "UNIT_S1", "null"),
                createInstruction(SET, var(2), "@unit"),
                createInstruction(SET, "UNIT_S1", var(2))
        );
    }
    //</editor-fold>

    //<editor-fold desc="Inline functions">
    @Test
    public void handlesSimpleParameters() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n);
                        end;
                        bar(5);
                        """,
                createInstruction(PRINT, "5")
        );
    }

    @Test
    public void handlesInlineFunctionsGlobalVariables() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n);
                        end;
                        X = rand(1000);
                        bar(X);
                        """,
                createInstruction(OP, "rand", "X", "1000"),
                createInstruction(PRINT, "X")
        );
    }

    @Test
    public void handlesBlockNames() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n);
                        end;
                        bar(switch1);
                        """,
                createInstruction(PRINT, "switch1")
        );
    }

    @Test
    public void handlesChainedVariables() {
        assertCompilesTo("""
                        inline def bar(n)
                            a = n;
                            print(a);
                        end;
                        bar(5);
                        """,
                createInstruction(PRINT, "5")
        );
    }

    @Test
    public void handlesArgumentsInExpressions() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n + 1);
                        end;
                        bar(5);
                        """,
                createInstruction(PRINT, "6")
        );
    }

    @Test
    public void preservesVolatileVariables() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n);
                        end;
                        bar(@time);
                        """,
                createInstruction(SET, "__fn0_n", "@time"),
                createInstruction(PRINT, "__fn0_n")
        );
    }

    @Test
    public void preservesModifiedVariables() {
        assertCompilesTo("""
                        inline def bar(n)
                            while n < 1000 do
                                n += 1;
                                print(n);
                            end;
                        end;
                        bar(0);
                        """,
                createInstruction(SET, "__fn0_n", "0"),
                createInstruction(LABEL, var(1005)),
                createInstruction(OP, "add", "__fn0_n", "__fn0_n", "1"),
                createInstruction(PRINT, "__fn0_n"),
                createInstruction(JUMP, var(1005), "lessThan", "__fn0_n", "1000")
        );
    }

    @Test
    void passesParameterToFunctionRegressionTest() {
        assertCompilesTo(createTestCompiler(createCompilerProfile().setAllOptimizationLevels(OptimizationLevel.ADVANCED)),
                """
                        inline def d(n)
                            n;
                        end;
                        print(1 < d(2));
                        printflush(message1);
                        """,
                createInstruction(PRINT, "true"),
                createInstruction(PRINTFLUSH, "message1")
        );
    }

    @Test
    public void handlesNestedParameters() {
        assertCompilesTo("""
                        inline def foo(n)
                            print(n);
                        end;
                        inline def bar(n)
                            foo(n);
                        end;
                        bar(5);
                        """,
                createInstruction(PRINT, "5")
        );
    }

    @Test
    void handlesComplexInlineFunctionArgumentSetup() {
        assertCompilesTo("""
                        printDomeStatus(@silicon, "\\n[green]Silicon[] status:\\n");
                        inline def printDomeStatus(item, text)
                            print(text);
                            level = dome1.sensor(item);
                            print($"  dome:  [green]$[]\\n", level);
                        end;
                        """,
                createInstruction(PRINT, q("\n[green]Silicon[] status:\n  dome:  [green]{0}[]\n")),
                createInstruction(SENSOR, "__fn0_level", "dome1", "@silicon"),
                createInstruction(FORMAT, "__fn0_level")
        );
    }
    //</editor-fold>

    //<editor-fold desc="Function arguments/calls">
    @Test
    void handlesFunctionArgumentSetup() {
        assertCompilesTo("""
                        def getBit(bitIndex)
                          bitIndex * 2;
                        end;
                        
                        for n in 1 .. 1000 do
                            print(getBit(n \\ 2));
                        end;
                        getBit(0);
                        """,
                createInstruction(SET, "n", "1"),
                createInstruction(LABEL, var(1007)),
                createInstruction(OP, "idiv", "__fn0_bitIndex", "n", "2"),
                createInstruction(SETADDR, "__fn0retaddr", var(1004)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1004), "__fn0"),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(OP, "add", "n", "n", "1"),
                createInstruction(JUMP, var(1007), "lessThanEq", "n", "1000"),
                createInstruction(SET, "__fn0_bitIndex", "0"),
                createInstruction(SETADDR, "__fn0retaddr", var(1005)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1005), "__fn0"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(OP, "mul", "__fn0retval", "__fn0_bitIndex", "2"),
                createInstruction(GOTO, "__fn0retaddr", "__fn0")
        );
    }

    @Test
    void optimizesFunctionArguments() {
        assertCompilesTo("""
                        def foo(n)
                            print(n * 2);
                        end;
                        foo(2);
                        foo(2);
                        """,
                createInstruction(SET, "__fn0_n", "2"),
                createInstruction(SETADDR, "__fn0retaddr", var(1001)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1001), "__fn0"),
                createInstruction(SETADDR, "__fn0retaddr", var(1002)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1002), "__fn0"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(OP, "mul", var(2), "__fn0_n", "2"),
                createInstruction(PRINT, var(2)),
                createInstruction(GOTO, "__fn0retaddr", "__fn0")
        );
    }

    @Test
    void compilesRecursiveFibonacci() {
        assertCompilesTo("""
                        allocate stack in bank1[0...512];
                        def fib(n)
                            n < 2 ? n : fib(n - 1) + fib(n - 2);
                        end;
                        print(fib(10));
                        """,
                createInstruction(SET, "__sp", "0"),
                createInstruction(SET, "__fn0_n", "10"),
                createInstruction(CALLREC, "bank1", var(1000), var(1001), "__fn0retval"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "__fn0retval", "__fn0_n"),
                createInstruction(JUMP, var(1004), "lessThan", "__fn0_n", "2"),
                createInstruction(PUSH, "bank1", "__fn0_n"),
                createInstruction(OP, "sub", "__fn0_n", "__fn0_n", "1"),
                createInstruction(CALLREC, "bank1", var(1000), var(1005), "__fn0retval"),
                createInstruction(LABEL, var(1005)),
                createInstruction(POP, "bank1", "__fn0_n"),
                createInstruction(SET, var(4), "__fn0retval"),
                createInstruction(PUSH, "bank1", var(4)),
                createInstruction(OP, "sub", "__fn0_n", "__fn0_n", "2"),
                createInstruction(CALLREC, "bank1", var(1000), var(1006), "__fn0retval"),
                createInstruction(LABEL, var(1006)),
                createInstruction(POP, "bank1", var(4)),
                createInstruction(OP, "add", "__fn0retval", var(4), "__fn0retval"),
                createInstruction(LABEL, var(1004)),
                createInstruction(RETURN, "bank1")
        );
    }

    @Test
    public void preservesGlobalVariablesWithFunctionCalls() {
        assertCompilesTo("""
                        inline def bar(n)
                            foo(n);
                            print(n);
                        end;
                        def foo(n)
                            print(n);
                        end;
                        X = rand(1000);
                        Y = rand(1000);
                        foo(X);
                        bar(Y);
                        """,
                createInstruction(OP, "rand", "X", "1000"),
                createInstruction(OP, "rand", "Y", "1000"),
                createInstruction(SET, "__fn0_n", "X"),
                createInstruction(SETADDR, "__fn0retaddr", var(1001)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1001), "__fn0"),
                createInstruction(SET, "__fn0_n", "Y"),
                createInstruction(SETADDR, "__fn0retaddr", var(1004)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1004), "__fn0"),
                createInstruction(PRINT, "Y"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "__fn0_n"),
                createInstruction(GOTO, "__fn0retaddr", "__fn0")
        );
    }

    @Test
    public void handlesConstantFunctionReturn() {
        assertCompilesTo("""
                        def foo(n)
                            print(n);
                            5;
                        end;
                        print(foo(2));
                        print(foo(3));
                        """,
                createInstruction(SET, "__fn0_n", "2"),
                createInstruction(SETADDR, "__fn0retaddr", var(1001)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1001), "__fn0"),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(SET, "__fn0_n", "3"),
                createInstruction(SETADDR, "__fn0retaddr", var(1002)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1002), "__fn0"),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "__fn0_n"),
                createInstruction(SET, "__fn0retval", "5"),
                createInstruction(GOTO, "__fn0retaddr", "__fn0")
        );
    }

    @Test
    public void preservesVariableStateAcrossPushAndPop() {
        // Explanation of the test:
        // The recursive call foo(m, n - 1) modifies __fn0_n (it is set to n - 1 when passing new value to the recursive call)
        // Data Flow analysis of push/pop should determine the value of n remains unchanged after the call
        // Because of this, it subsequently determines the __tmp1 variable in loop condition can be replaced by __fn0_n
        assertCompilesTo("""
                        allocate stack in bank1[0...512];
                        def foo(n)
                            if n > 0 then
                                foo(n - 1);
                            end;
                        end;
                        print(foo(10));
                        """,
                createInstruction(SET, "__sp", "0"),
                createInstruction(SET, "__fn0_n", "10"),
                createInstruction(CALLREC, "bank1", var(1000), var(1001), "__fn0retval"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "__fn0retval", "null"),
                createInstruction(JUMP, var(1004), "lessThanEq", "__fn0_n", "0"),
                createInstruction(OP, "sub", "__fn0_n", "__fn0_n", "1"),
                createInstruction(CALLREC, "bank1", var(1000), var(1005), "__fn0retval"),
                createInstruction(LABEL, var(1005)),
                createInstruction(LABEL, var(1004)),
                createInstruction(RETURN, "bank1")
        );
    }

    @Test
    public void preservesVariableStateAcrossPushAndPopInLoop() {
        // Explanation of the test:
        // The recursive call foo(m, n - 1) modifies __fn0_n (it is set to n - 1 when passing new value to the recursive call)
        // Data Flow analysis of push/pop should determine the value of n remains unchanged after the call
        // Because of this, it subsequently determines the __tmp1 variable in loop condition can be replaced by __fn0_n
        assertCompilesTo("""
                        allocate stack in bank1[0...512];
                        def foo(n)
                            for i in 1 .. n do
                                print(n);
                                foo(n - 1);
                            end;
                        end;
                        foo(10);
                        """,
                createInstruction(SET, "__sp", "0"),
                createInstruction(SET, "__fn0_n", "10"),
                createInstruction(CALLREC, "bank1", var(1000), var(1001), "__fn0retval"),
                createInstruction(LABEL, var(1001)),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "__fn0_i", "1"),
                createInstruction(JUMP, var(1005), "greaterThan", "1", "__fn0_n"),
                createInstruction(LABEL, var(1007)),
                createInstruction(PRINT, "__fn0_n"),
                createInstruction(PUSH, "bank1", "__fn0_n"),
                createInstruction(PUSH, "bank1", "__fn0_i"),
                createInstruction(OP, "sub", "__fn0_n", "__fn0_n", "1"),
                createInstruction(CALLREC, "bank1", var(1000), var(1006), "__fn0retval"),
                createInstruction(LABEL, var(1006)),
                createInstruction(POP, "bank1", "__fn0_i"),
                createInstruction(POP, "bank1", "__fn0_n"),
                createInstruction(OP, "add", "__fn0_i", "__fn0_i", "1"),
                createInstruction(JUMP, var(1007), "lessThanEq", "__fn0_i", "__fn0_n"),
                createInstruction(LABEL, var(1005)),
                createInstruction(RETURN, "bank1")
        );
    }
    //</editor-fold>

    //<editor-fold desc="Subexpressions">
    @Test
    void optimizesSubexpressions() {
        assertCompilesTo("""
                        a = rand(10);
                        b = a + 1;
                        c = 1 + (a + 1);
                        d = 2 + (1 + a);
                        print(a, b, c, d);
                        """,
                createInstruction(OP, "rand", "a", "10"),
                createInstruction(OP, "add", "b", "a", "1"),
                createInstruction(OP, "add", "c", "a", "2"),
                createInstruction(OP, "add", "d", "a", "3"),
                createInstruction(PRINT, "a"),
                createInstruction(PRINT, "b"),
                createInstruction(PRINT, "c"),
                createInstruction(PRINT, "d")
        );
    }

    @Test
    void optimizesExtendedSubexpressions() {
        assertCompilesTo("""
                        a = 1;
                        b = rand(10);
                        c = 2;
                        d = a + b + c;
                        print(d);
                        """,
                createInstruction(OP, "rand", "b", "10"),
                createInstruction(OP, "add", "d", "b", "3"),
                createInstruction(PRINT, "d")
        );
    }

    @Test
    void avoidsIncompatibleLiterals() {
        assertCompilesTo(createTestCompiler(createCompilerProfile().setProcessorVersion(ProcessorVersion.V7A)),
                """
                        base = 2;
                        a = base ** 8;
                        b = base ** a;
                        print(a, b);
                        """,
                createInstruction(OP, "pow", "b", "2", "256"),
                createInstruction(PRINT, "256"),
                createInstruction(PRINT, "b")
        );
    }

    @Test
    void optimizesComplexExpressions() {
        assertCompilesTo("""
                        a = rand(10);
                        b = rand(10);
                        print(1 + sqrt(a * a + b * b));
                        print(2 + sqrt(a * a + b * b));
                        print(1 + sqrt(a * a + b * b));
                        """,
                createInstruction(OP, "rand", "a", "10"),
                createInstruction(OP, "rand", "b", "10"),
                createInstruction(OP, "mul", var(2), "a", "a"),
                createInstruction(OP, "mul", var(3), "b", "b"),
                createInstruction(OP, "add", var(4), var(2), var(3)),
                createInstruction(OP, "sqrt", var(5), var(4)),
                createInstruction(OP, "add", var(6), "1", var(5)),
                createInstruction(PRINT, var(6)),
                createInstruction(OP, "add", var(11), "2", var(5)),
                createInstruction(PRINT, var(11)),
                createInstruction(PRINT, var(6))
        );
    }

    @Test
    void optimizesAddAfterSub() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp0, a, P1),
                        createInstruction(OP, add, tmp1, tmp0, P10),    // (a - 1) + 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, P1, a),
                        createInstruction(OP, add, tmp1, tmp0, P10),    // (1 - a) + 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, a, P1),
                        createInstruction(OP, add, tmp1, P10, tmp0),    // 10 + (a - 1)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, P1, a),
                        createInstruction(OP, add, tmp1, P10, tmp0),    // 10 + (1 - a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, add, tmp1, a, P9),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P11, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp1, a, P9),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P11, a),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesSubAfterAdd() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, add, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (a + 1) - 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp0, P1, a),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (1 + a) - 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, P10, tmp0),    // 10 - (a + 1)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp0, P1, a),
                        createInstruction(OP, sub, tmp1, P10, tmp0),    // 10 - (1 + a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp1, a, P9),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, a, P9),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P9, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P9, a),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesSubAfterAdd0() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, add, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (a + 1) - 10
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp1, a, P9),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesSubAfterSub() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (a - 1) - 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, P1, a),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (1 - a) - 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, P10, tmp0),    // 10 - (a - 1)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, P1, a),
                        createInstruction(OP, sub, tmp1, P10, tmp0),    // 10 - (1 - a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp1, a, P11),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, N9, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P11, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp1, a, P9),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesMulAfterDiv() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, div, tmp0, a, P2),
                        createInstruction(OP, mul, tmp1, tmp0, P4),    // (a / 2) * 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, P2, a),
                        createInstruction(OP, mul, tmp1, tmp0, P4),    // (2 / a) * 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, a, P2),
                        createInstruction(OP, mul, tmp1, P4, tmp0),    // 4 * (a / 2)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, P2, a),
                        createInstruction(OP, mul, tmp1, P4, tmp0),    // 4 * (2 / a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, mul, tmp1, a, P2),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P8, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp1, a, P2),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P8, a),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesDivAfterMul() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, mul, tmp0, a, P2),
                        createInstruction(OP, div, tmp1, tmp0, P4),    // (a * 2) / 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp0, P2, a),
                        createInstruction(OP, div, tmp1, tmp0, P4),    // (2 * a) / 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp0, a, P2),
                        createInstruction(OP, div, tmp1, P4, tmp0),    // 4 / (a * 2)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp0, P2, a),
                        createInstruction(OP, div, tmp1, P4, tmp0),    // 4 / (2 * a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, div, tmp1, a, P2),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, a, P2),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P2, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P2, a),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesDivAfterDiv() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, div, tmp0, a, P2),
                        createInstruction(OP, div, tmp1, tmp0, P4),    // (a / 2) / 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, P2, a),
                        createInstruction(OP, div, tmp1, tmp0, P4),    // (2 / a) / 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, a, P2),
                        createInstruction(OP, div, tmp1, P4, tmp0),    // 4 / (a / 2)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, P2, a),
                        createInstruction(OP, div, tmp1, P4, tmp0),    // 4 / (2 / a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, div, tmp1, a, P8),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P0_5, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P8, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp1, a, P2),
                        createInstruction(PRINT, tmp1)
                )
        );
    }
    //</editor-fold>

    //<editor-fold desc="Assignments">
    @Test
    void handlesSelfReference() {
        assertCompilesTo("""
                        param TICKS = 100;
                        nextTick = @tick;
                        prevTick = @tick;
                        currTick = @tick;
                        
                        nextTick = nextTick + TICKS;
                        if @tick > nextTick + TICKS then
                            prevTick = @tick;
                            nextTick = prevTick + TICKS;
                            currTick = prevTick;
                        end;
                        print(nextTick, prevTick, currTick);
                        """,
                createInstruction(SET, "TICKS", "100"),
                createInstruction(SET, "nextTick", "@tick"),
                createInstruction(SET, "prevTick", "@tick"),
                createInstruction(SET, "currTick", "@tick"),
                createInstruction(OP, "add", "nextTick", "nextTick", "TICKS"),
                createInstruction(OP, "add", var(1), "nextTick", "TICKS"),
                createInstruction(JUMP, var(1000), "lessThanEq", "@tick", var(1)),
                createInstruction(SET, "prevTick", "@tick"),
                createInstruction(OP, "add", "nextTick", "prevTick", "TICKS"),
                createInstruction(SET, "currTick", "prevTick"),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "nextTick"),
                createInstruction(PRINT, "prevTick"),
                createInstruction(PRINT, "currTick")
        );
    }

    @Test
    void handlesChainAssignment() {
        assertCompilesTo("""
                        param FROM_INDEX = 0;
                        param OFFSET_Y = 2;
                        cry = cly = FROM_INDEX == 0 ? 0 : OFFSET_Y;
                        print(cry, cly);
                        """,
                createInstruction(SET, "FROM_INDEX", "0"),
                createInstruction(SET, "OFFSET_Y", "2"),
                createInstruction(SET, var(1), "OFFSET_Y"),
                createInstruction(JUMP, var(1001), "notEqual", "FROM_INDEX", "0"),
                createInstruction(SET, var(1), "0"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, var(1)),
                createInstruction(PRINT, var(1))
        );
    }

    // This test makes sure the assignments were all fully evaluated in one iteration.
    @Test
    void handlesAssignmentSequences() {
        TestCompiler compiler = createTestCompiler();
        assertCompilesTo(compiler,
                """
                        i = 0;
                        print(i);
                        i += 1;
                        print(i);
                        i += 1;
                        print(i);
                        """,
                createInstruction(PRINT, q("012"))
        );

        String message = compiler.getMessages().stream()
                .map(MindcodeMessage::message)
                .filter(m -> m.contains("instructions eliminated by Data Flow Optimization"))
                .findFirst().orElse("No Data Flow Optimization message found.");

        assertEquals("3 instructions eliminated by Data Flow Optimization (4 iterations).", message.trim());
    }
    //</editor-fold>

    //<editor-fold desc="External memory">
    @Test
    void optimizesMemoryAccess() {
        assertCompilesTo(ExpectedMessages.create().add("List of uninitialized variables: i."),
                """
                        if cell1[i] > cell1[i + 1] then
                            a = cell1[i];
                            cell1[i] = cell1[i + 1];
                            cell1[i + 1] = a;
                        end;
                        """,
                createInstruction(LABEL, "__start__"),
                createInstruction(READ, var(0), "cell1", "i"),
                createInstruction(OP, "add", var(2), "i", "1"),
                createInstruction(READ, var(1), "cell1", var(2)),
                createInstruction(JUMP, "__start__", "lessThanEq", var(0), var(1)),
                createInstruction(READ, "a", "cell1", "i"),
                createInstruction(READ, var(6), "cell1", var(2)),
                createInstruction(WRITE, var(6), "cell1", "i"),
                createInstruction(WRITE, "a", "cell1", var(2))
        );
    }

    @Test
    void optimizesMemoryWriteAccess() {
        assertCompilesTo("""
                        allocate heap in cell1;
                        $A = rand(10);
                        print($A);
                        """,
                createInstruction(OP, "rand", var(0), "10"),
                createInstruction(WRITE, var(0), "cell1", "0"),
                createInstruction(READ, var(1), "cell1", "0"),
                createInstruction(PRINT, var(1))
        );
    }
    //</editor-fold>
}