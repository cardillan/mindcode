// Instant Overdrive Dome
// Unit transport of silicon or phase fabric to overdrive dome using two units

// Linked structures
// dome1: the dome to supply
// message1: status

#set target = ML7A      // Using revised syntax for ulocate

UNIT                    = @flare        // Which unit to use

// BASIC INITIALIZATION
/////////////////////////////////////////////////////////
const RADIUS_WITHIN     = 8
const RADIUS_APPROACH   = 6

const S_UNUSED          = 0             // Unit is not used.
const S_INIT            = 1             // Unloading wrong items held by unit/initializing unit
const S_APPROACH_SRC    = 2             // Approaching source block
const S_APPROACH_DST    = 3             // Approaching destination block

const SUPPLY_INTERVAL   = 50 - 3        // How long it takes for Overdrive Dome to use up all supplies (sec)
                                        // Subtract three for safety

// FIND DOME
// Now this is funny: the processor might get built way
// earlier than the dome and miss it in initialization
/////////////////////////////////////////////////////////
DOME = dome1
while DOME == null
    print("[gold]Waiting for an overdrive dome to be connected...")
    printflush(message1)
    DOME = dome1
end

// ACTIVATION SWITCH
/////////////////////////////////////////////////////////
while not switch1.enabled
    println("[coral]Activate switch to begin supplying overdrive dome...")
    printflush(message1)
end

// BASIC INITIALIZATION - REBINDING UNIT
/////////////////////////////////////////////////////////
printf("[gold]Binding units...")
printflush(message1)
rebindUnits()

// First set of units is always needed
if UNIT_S1 == null UNIT_S1 = findUnit() end
if UNIT_P1 == null UNIT_P1 = findUnit() end

if UNIT_S1.firstItem == @phase-fabric or UNIT_P1.firstItem == @silicon
    // At least one of our units holds wrong item. Swapping them fixes at least one
    u = UNIT_S1
    UNIT_S1 = UNIT_P1
    UNIT_P1 = u
end

// GATHERING STATISTICS
/////////////////////////////////////////////////////////
UNIT_CAPACITY = UNIT_S1.itemCapacity
SPEED = UNIT_S1.speed
SPEED_TENTHS = SPEED / 10

print("[gold]Locating core...")
printflush(message1)
do
    CORE = ulocate(building, core, false)
loop while CORE == null

CORE_X = CORE.x
CORE_Y = CORE.y
DOME_X = DOME.x
DOME_Y = DOME.y

// Compute the travel period
travel_time = 2 * len(DOME_X - CORE_X, DOME_Y - CORE_Y) / SPEED

// Do we need a backup set of units? 
FOUR_UNITS = travel_time >= SUPPLY_INTERVAL

if FOUR_UNITS
    if UNIT_S2 == null UNIT_S2 = findUnit() end
    if UNIT_P2 == null UNIT_P2 = findUnit() end

    if UNIT_S1.firstItem == @phase-fabric and UNIT_P2.firstItem != @phase-fabric
        // Swapping this way cannot hurt
        u = UNIT_S1
        UNIT_S1 = UNIT_P2
        UNIT_P2 = u
    end
    
    // Swap them?
    if UNIT_S2.firstItem == @phase-fabric or UNIT_P2.firstItem == @silicon
        // At least one of our units holds wrong item. Swapping them fixes at least one
        u = UNIT_S2
        UNIT_S2 = UNIT_P2
        UNIT_P2 = u
    end

    GROUP1 = "probe  1"
    GROUP2 = "probe 2"
else
    ubind(UNIT_S2); unbind(); UNIT_S2 = null
    ubind(UNIT_P2); unbind(); UNIT_P2 = null
    GROUP1 = "probe"
end

SUPPLY_S_FIRST = not FOUR_UNITS or UNIT_S1.totalItems < UNIT_S2.totalItems
SUPPLY_P_FIRST = not FOUR_UNITS or UNIT_P1.totalItems < UNIT_P2.totalItems

// MAIN LOOP
/////////////////////////////////////////////////////////
while switch1.enabled
    start = @time
    println(" === [gold]Supplying Overdrive Dome[] === ")

    // Note: processUnit rebinds a unit if it is lost. Store it back
    printDomeStatus(@silicon, "\n[green]Silicon[] status:\n")
    UNIT_S1 = processUnit(UNIT_S1, @silicon, GROUP1, SUPPLY_S_FIRST)
    if FOUR_UNITS
        UNIT_S2 = processUnit(UNIT_S2, @silicon, GROUP2, not SUPPLY_S_FIRST)
        SUPPLY_S_FIRST = SUPPLY_S_FIRST ? UNIT_S1.totalItems > 0 : UNIT_S2.totalItems == 0
    end

    printDomeStatus(@phase-fabric, "\n[green]Phase fabric[] status:\n")
    UNIT_P1 = processUnit(UNIT_P1, @phase-fabric, GROUP1, SUPPLY_P_FIRST)
    if FOUR_UNITS
        UNIT_P2 = processUnit(UNIT_P2, @phase-fabric, GROUP2, not SUPPLY_P_FIRST)
        SUPPLY_P_FIRST = SUPPLY_P_FIRST ? UNIT_P1.totalItems > 0 : UNIT_P2.totalItems == 0
    end

    printf("\n[lightgray]Loop time: $ ms", floor(@time - start))
    printflush(message1)
end

inline def rebindUnits()
    UNIT_S1 = UNIT_P1 = UNIT_S2 = UNIT_P2 = null
    count = 0

    while true
        ubind(UNIT)
        if @unit != null
            first_unit = @unit
            break
        end
        printf("[salmon]No unit of type $UNIT found. 1")
        printflush(message1)
    end

    // We have some unit. Try to find unit owned by us
    first_unit = @unit
    do
        if @unit.controller == @this
            count += 1
            flag(S_INIT)
            UNIT_S2 = UNIT_P2
            UNIT_P2 = UNIT_S1
            UNIT_S1 = UNIT_P1
            UNIT_P1 = @unit
            if UNIT_S2 != null
                break
            end
        end
        ubind(UNIT)
    loop while @unit != first_unit and first_unit.dead === 0
    return count
end

inline def findUnit()
    while true
        ubind(UNIT)
        if @unit == null
            printf("[salmon]No unit of type $UNIT found...")
        elsif @unit.controlled != 0
            printf("[salmon]Looking for a free $UNIT...")
        else
            flag(S_INIT)
            return @unit
        end
        printflush(message1)
    end
end

inline def processUnit(unit, item, group, supply)
    ubind(unit)

    // Unit lost. Rebind it
    if (@unit.dead === 0) <= (@unit.controller != @this)
        findUnit()
    end

    // We have a bound, functioning unit
    state = @unit.flag
    distance = -1
    color = "gold"

    // Initializes the unit. Used as starting state, to make sure
    // the unit is free to accept whatever it has to transport
    if state == S_INIT
        if @unit.firstItem == item
            // We've got what we need, bring the supplies in!
            // Jump threading optimization here...
            state = S_APPROACH_DST
        elsif @unit.totalItems == 0
            // We're empty, resupply
            // Jump threading optimization here...
            state = S_APPROACH_SRC
        else
            // Get rid of whatever we might be carrying right now
            MSG = ", initializing\n"
            approach(CORE_X, CORE_Y, RADIUS_APPROACH)
            if within(CORE_X, CORE_Y, RADIUS_WITHIN)
                itemDrop(CORE, UNIT_CAPACITY)
            end
        end
    end

    if state == S_APPROACH_SRC
        if within(CORE_X, CORE_Y, RADIUS_WITHIN)
            itemTake(CORE, item, UNIT_CAPACITY)
            if @unit.totalItems >= UNIT_CAPACITY
                approach(DOME_X, DOME_Y, RADIUS_APPROACH)
                // Jump threading optimization here...
                state = S_APPROACH_DST
            else
                MSG = ", loading\n"
            end
        else
            approach(CORE_X, CORE_Y, RADIUS_APPROACH)
            MSG = ", fetching in [gold]"
            distance = len(CORE_X - @unit.x, CORE_Y - @unit.y) \ SPEED_TENTHS / 10
        end
    end

    if state == S_APPROACH_DST
        if within(DOME_X, DOME_Y, RADIUS_WITHIN)
            if supply
                itemDrop(DOME, UNIT_CAPACITY)
                MSG = ", supplying\n"
                color = "green"
            else
                approach(DOME_X, DOME_Y, RADIUS_APPROACH)   // Keep the unit active
                MSG = ", waiting\n"
            end
            if @unit.totalItems <= 0
                approach(CORE_X, CORE_Y, RADIUS_APPROACH)
                state = S_APPROACH_SRC
            else
            end
        else
            approach(DOME_X, DOME_Y, RADIUS_APPROACH)
            MSG = ", returning in [gold]"
            distance = len(DOME_X - @unit.x, DOME_Y - @unit.y) \ SPEED_TENTHS / 10
        end
    end

    flag(state)

    printf("  $group: [$color]$[]", @unit.totalItems)
    if distance >= 0
        // TODO: invert-branches optimization for non-invertible conditions
        printf("$MSG$distance[] sec\n")
    else
        print(MSG)
    end

    return @unit
end

inline def printDomeStatus(item, text)
    print(text)
    level = DOME.sensor(item)
    if level > 3
        printf("  dome:  [green]$[]\n", level)
    else
        printf("  dome:  [coral]$[]\n", level)
    end
end
