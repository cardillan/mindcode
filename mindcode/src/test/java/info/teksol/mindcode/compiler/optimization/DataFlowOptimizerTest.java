package info.teksol.mindcode.compiler.optimization;

import info.teksol.mindcode.compiler.CompilerMessage;
import info.teksol.mindcode.compiler.CompilerProfile;
import info.teksol.mindcode.compiler.GenerationGoal;
import org.junit.jupiter.api.Test;

import java.util.List;

import static info.teksol.mindcode.logic.Opcode.*;
import static org.junit.jupiter.api.Assertions.assertEquals;

class DataFlowOptimizerTest extends AbstractOptimizerTest<DataFlowOptimizer> {

    @Override
    protected Class<DataFlowOptimizer> getTestedClass() {
        return DataFlowOptimizer.class;
    }

    @Override
    protected List<Optimization> getAllOptimizations() {
        // Need to test interactions with all optimizers except function inlining
        return Optimization.LIST.stream().filter(o -> o != Optimization.FUNCTION_INLINING).toList();
    }

    @Override
    protected CompilerProfile createCompilerProfile() {
        return super.createCompilerProfile().setGoal(GenerationGoal.SPEED);
    }

    //<editor-fold desc="Warnings">
    @Test
    void generatesUninitializedWarning() {
        assertGeneratesWarnings(
                """
                        j = i
                        i = 10      // Avoid the warning generated by dead code eliminator
                        print(i, j)
                        """,
                "List of uninitialized variables: i."
        );
    }

    @Test
    void recognizesIfStatementInitialization() {
        assertGeneratesWarnings(
                """
                        if switch1.enabled
                            a = rand(10)
                            b = rand(10)
                        else
                            a = -rand(10)
                            b = -rand(10)
                        end
                        print(a, b)
                        """,
                ""
        );
    }

    @Test
    void recognizesPartialIfStatementInitialization() {
        assertGeneratesWarnings(
                """
                        if switch1.enabled
                            a = 1
                            b = a
                        else
                            a = 2
                            print(a)
                        end
                        print(b)
                        """,
                "List of uninitialized variables: b."
        );
    }

    @Test
    void generatesWarningsAboutLocalVariables() {
        assertGeneratesWarnings(
                """
                         def foo()
                             print(n)
                         end
                         foo()
                         foo()
                        """,
                "List of uninitialized variables: foo.n."
        );
    }

    @Test
    void generatesNoWarningsAboutFunctionParameters() {
        assertGeneratesWarnings(
                """
                         def foo(n)
                             print(n)
                         end
                         foo(0)
                         foo(1)
                        """,
                ""
        );
    }

    @Test
    void producesNoWarningsOnBasicLevel() {
        assertGeneratesWarnings(createTestCompiler(CompilerProfile.standardOptimizations(false)),
                """
                        for n in 0 ... 1000
                            j = switch1.enabled
                            print(j)
                        end
                        """,
                ""
        );
    }

    @Test
    void producesNoWarningsOnBasicLoop() {
        assertGeneratesWarnings(createTestCompiler(CompilerProfile.standardOptimizations(false)),
                """
                        while true
                            i = switch1.enabled
                        end
                        print(i)
                        """,
                ""
        );
    }

    @Test
    void producesNoWarningsOnBasicLoop2() {
        assertGeneratesWarnings(createTestCompiler(CompilerProfile.standardOptimizations(false)),
                """
                        x = 159
                        while x > 10
                            x1 = x - 5
                            x = x1
                        end
                        """,
                ""
        );
    }
    //</editor-fold>

    //<editor-fold desc="Main variables">
    @Test
    void removesUnneededVariables() {
        assertCompilesTo("""
                        i = 5
                        j = 10
                        j = 15
                        i = j + 2
                        print(i, j)
                        """,
                createInstruction(PRINT, q("1715")),
                createInstruction(END)
        );
    }


    @Test
    void leavesUninitializedVariables() {
        assertCompilesToWithMessages(ignore("List of uninitialized variables: flag."),
                """
                        print(flag)
                        flag = 1
                        """,
                createInstruction(PRINT, "flag"),
                createInstruction(SET, "flag", "1"),        // This instruction is kept
                createInstruction(END)
        );
    }

    @Test
    void keepsLatestAssignment() {
        assertCompilesTo("""
                        index = 0
                        b = rand(10)
                        index = 0
                        while index < 1000
                            print(b)
                            index = index + 1
                        end
                        """,
                createInstruction(OP, "rand", "b", "10"),
                createInstruction(SET, "index", "0"),
                createInstruction(LABEL, var(1003)),
                createInstruction(PRINT, "b"),
                createInstruction(OP, "add", "index", "index", "1"),
                createInstruction(JUMP, var(1003), "lessThan", "index", "1000"),
                createInstruction(END)
        );
    }
    //</editor-fold>

    //<editor-fold desc="If statements">
    @Test
    void processesIfStatements() {
        assertCompilesTo("""
                        a = 0
                        b = 0
                        if switch1.enabled
                            a = 1
                            b = 2
                        else
                            a = 2
                            b = 3
                            print(a)
                        end
                        print(b)
                        """,
                createInstruction(SENSOR, var(0), "switch1", "@enabled"),
                createInstruction(JUMP, var(1000), "equal", var(0), "false"),
                createInstruction(SET, "b", "2"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "b", "3"),
                createInstruction(PRINT, "2"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "b"),
                createInstruction(END)
        );
    }

    @Test
    void evaluatesConstantIfsFully() {
        assertCompilesTo("""
                        i = 1
                        print(i % 2 == 0 ? 1 : 2)
                        """,
                createInstruction(PRINT, var(2)),
                createInstruction(END)
        );
    }

    @Test
    void evaluatesConstantIfsInLoopFully() {
        assertCompilesTo("""
                        def getBit(bitIndex)
                          bitIndex % 2
                        end
                                                
                        for i in 1 ... 2
                            print(getBit(i) ? 1 : 0)
                        end
                        """,
                createInstruction(PRINT, "1"),
                createInstruction(END)
        );
    }

    @Test
    void removesUnneededAssignmentsInConditions() {
        assertCompilesTo("""
                        a = 0
                        if switch1.enabled
                            a = 1
                            b = a
                        else
                            a = 2
                            b = 1
                        end
                        print(a, b)
                        """,
                createInstruction(SET, "a", "2"),
                createInstruction(SENSOR, var(0), "switch1", "@enabled"),
                createInstruction(JUMP, var(1001), "equal", var(0), "false"),
                createInstruction(SET, "a", "1"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "a"),
                createInstruction(PRINT, "1"),
                createInstruction(END)
        );
    }

    @Test
    void IdentifiesUninitializedVariables() {
        assertCompilesToWithMessages(ignore("List of uninitialized variables: a, b."),
                        """
                        if switch1.enabled
                            a = 1
                        else
                            b = 1
                        end
                        print(a, b)
                        """,
                createInstruction(SENSOR, var(0), "switch1", "@enabled"),
                createInstruction(JUMP, var(1000), "equal", var(0), "false"),
                createInstruction(SET, "a", "1"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "b", "1"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "a"),
                createInstruction(PRINT, "b"),
                createInstruction(END)
        );
    }

    @Test
    void handlesSingleBranchIfStatements() {
        assertCompilesTo("""
                        a = 1
                        if switch1.enabled
                            a = 2
                        end
                        print(a)
                        """,
                createInstruction(SET, "a", "1"),
                createInstruction(SENSOR, var(0), "switch1", "@enabled"),
                createInstruction(JUMP, var(1000), "equal", var(0), "false"),
                createInstruction(SET, "a", "2"),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "a"),
                createInstruction(END)
        );
    }

    @Test
    void handlesOptimizedIfStatements() {
        assertCompilesTo("""
                        a = 10
                        print(a > 5 ? "High" : "Low")
                        """,
                createInstruction(PRINT, q("High")),
                createInstruction(END)
        );
    }

    @Test
    void optimizesBranchedExpressions() {
        assertCompilesTo("""
                        a = rand(10)
                        b = a + 1
                        if switch1.enabled
                            c = 2 * (a + 1)
                            print(c)
                        else
                            c = 10
                            print(c)
                        end
                        print(b, c)
                        """,
                createInstruction(OP, "rand", "a", "10"),
                createInstruction(OP, "add", "b", "a", "1"),
                createInstruction(SENSOR, var(2), "switch1", "@enabled"),
                createInstruction(JUMP, var(1000), "equal", var(2), "false"),
                createInstruction(OP, "mul", "c", "2", "b"),
                createInstruction(PRINT, "c"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "c", "10"),
                createInstruction(PRINT, "10"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "b"),
                createInstruction(PRINT, "c"),
                createInstruction(END)
        );
    }

    @Test
    void optimizesAssignmentsInConditions() {
        assertCompilesTo("""
                        if result = !rand(10)
                            print("A")
                        end
                        print(result)
                        """,
                createInstruction(OP, "rand", var(0), "10"),
                createInstruction(OP, "equal", "result", var(0), "false"),
                createInstruction(JUMP, var(1000), "equal", "result", "false"),
                createInstruction(PRINT, q("A")),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "result"),
                createInstruction(END)
        );
    }
    //</editor-fold>

    //<editor-fold desc="Case statements">
    @Test
    void handlesCaseExpressions() {
        assertCompilesTo("""
                        a = case cell1[0]
                            when 0, 1, 2 then 10
                            when 10 .. 20 then 20
                            else 30
                        end
                        print(a)
                        """,
                createInstruction(READ, "__ast0", "cell1", "0"),
                createInstruction(JUMP, var(1002), "equal", "__ast0", "0"),
                createInstruction(JUMP, var(1002), "equal", "__ast0", "1"),
                createInstruction(JUMP, var(1001), "notEqual", "__ast0", "2"),
                createInstruction(LABEL, var(1002)),
                createInstruction(SET, var(1), "10"),
                createInstruction(JUMP, var(1000), "always"),
                createInstruction(LABEL, var(1001)),
                createInstruction(JUMP, var(1003), "lessThan", "__ast0", "10"),
                createInstruction(JUMP, var(1004), "lessThanEq", "__ast0", "20"),
                createInstruction(JUMP, var(1003), "always"),
                createInstruction(LABEL, var(1004)),
                createInstruction(SET, var(1), "20"),
                createInstruction(JUMP, var(1000), "always"),
                createInstruction(LABEL, var(1003)),
                createInstruction(SET, var(1), "30"),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, var(1)),
                createInstruction(END)
        );
    }

    @Test
    void handlesCaseExpressionsWithWhenSideEffects() {
        assertCompilesToWithMessages(ignore("List of uninitialized variables: x."),
                        """
                        case switch1.enabled
                            when 1, x = 2 then print(x)
                        end
                        """,
                createInstruction(LABEL, "__start__"),
                createInstruction(SENSOR, "__ast0", "switch1", "@enabled"),
                createInstruction(JUMP, var(1002), "equal", "__ast0", "1"),
                createInstruction(SET, "x", "2"),
                createInstruction(JUMP, "__start__", "notEqual", "__ast0", "2"),
                createInstruction(LABEL, var(1002)),
                createInstruction(PRINT, "x"),
                createInstruction(END)
        );
    }
    //</editor-fold>

    //<editor-fold desc="Loops">
    @Test
    void handlesWhileLoops() {
        assertCompilesTo("""
                        i = 0
                        while i < 10000
                            i = i + 1
                        end
                        print(i)
                        """,
                createInstruction(SET, "i", "0"),
                createInstruction(LABEL, var(1003)),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1003), "lessThan", "i", "10000"),
                createInstruction(PRINT, "i"),
                createInstruction(END)
        );
    }

    @Test
    void handlesForEachLoops() {
        assertCompilesTo(createTestCompiler(
                createCompilerProfile().setOptimizationLevel(Optimization.LOOP_UNROLLING, OptimizationLevel.OFF)),
                        """
                        for i in (1, 2, 3)
                            print(i)
                        end
                        """,
                createInstruction(SETADDR, var(0), var(1003)),
                createInstruction(SET, "i", "1"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(GOTOLABEL, var(1003), "marker0"),
                createInstruction(SETADDR, var(0), var(1004)),
                createInstruction(SET, "i", "2"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(GOTOLABEL, var(1004), "marker0"),
                createInstruction(SETADDR, var(0), var(1005)),
                createInstruction(SET, "i", "3"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "i"),
                createInstruction(GOTO, var(0), "marker0"),
                createInstruction(GOTOLABEL, var(1005), "marker0"),
                createInstruction(END)
        );
    }

    @Test
    void handlesDoWhileLoops() {
        assertCompilesTo("""
                        i = 0
                        do
                            min = cell1[i]
                            i += 1
                        loop while i < 1000
                        print(min)
                        """,
                createInstruction(SET, "i", "0"),
                createInstruction(LABEL, var(1000)),
                createInstruction(READ, "min", "cell1", "i"),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1000), "lessThan", "i", "1000"),
                createInstruction(PRINT, "min"),
                createInstruction(END)
        );
    }

    @Test
    void handlesRangedForLoops() {
        // min is uninitialized because we do not know the loop body will execute
        assertCompilesToWithMessages(
                ignore(
                        "List of uninitialized variables: SIZE.",
                        "List of uninitialized variables: min."
                ),
                """
                        for i in 0 ... SIZE - 1
                            min = cell1[i]
                        end
                        print(min)
                        """,
                createInstruction(OP, "sub", var(1), "SIZE", "1"),
                createInstruction(SET, "i", "0"),
                createInstruction(JUMP, var(1002), "greaterThanEq", "0", var(1)),
                createInstruction(LABEL, var(1003)),
                createInstruction(READ, "min", "cell1", "i"),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1003), "lessThan", "i", var(1)),
                createInstruction(LABEL, var(1002)),
                createInstruction(PRINT, "min"),
                createInstruction(END)
        );
    }

    @Test
    void handlesNestedLoops() {
        assertCompilesTo("""
                        for i = 0; i < 1000; i += 1
                            for j = 0; j < 1000; j += 1
                                print(i, j)
                            end
                        end
                        """,
                createInstruction(SET, "i", "0"),
                createInstruction(LABEL, var(1006)),
                createInstruction(SET, "j", "0"),
                createInstruction(LABEL, var(1007)),
                createInstruction(PRINT, "i"),
                createInstruction(PRINT, "j"),
                createInstruction(OP, "add", "j", "j", "1"),
                createInstruction(JUMP, var(1007), "lessThan", "j", "1000"),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1006), "lessThan", "i", "1000"),
                createInstruction(END)
        );
    }

    @Test
    void handlesDescendingLoops() {
        assertCompilesTo("""
                        const LENGTH = 1500
                        for row = LENGTH - 2; row >= 0; row -= 1
                            for col = row + 1; col >= 0; col -= 1
                                print(col)
                            end
                        end
                        """,
                createInstruction(SET, "row", "1498"),
                createInstruction(LABEL, var(1006)),
                createInstruction(OP, "add", "col", "row", "1"),
                createInstruction(JUMP, var(1005), "lessThan", "col", "0"),
                createInstruction(LABEL, var(1007)),
                createInstruction(PRINT, "col"),
                createInstruction(OP, "sub", "col", "col", "1"),
                createInstruction(JUMP, var(1007), "greaterThanEq", "col", "0"),
                createInstruction(LABEL, var(1005)),
                createInstruction(OP, "sub", "row", "row", "1"),
                createInstruction(JUMP, var(1006), "greaterThanEq", "row", "0"),
                createInstruction(END)
        );
    }

    @Test
    void handlesContinueInLoops() {
        assertCompilesTo("""
                        for i in 1 ... 1000
                            if i == 5
                                continue
                            else
                                str = i
                            end
                            print(str)
                        end
                        """,
                createInstruction(SET, "i", "1"),
                createInstruction(LABEL, var(1005)),
                createInstruction(JUMP, var(1001), "equal", "i", "5"),
                createInstruction(PRINT, "i"),
                createInstruction(LABEL, var(1001)),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1005), "lessThan", "i", "1000"),
                createInstruction(END)
        );
    }

    @Test
    void handlesDeadEnds() {
        assertCompilesTo("""
                        for i in 1 ... 1000
                            print(i)
                            if i == 5
                                continue
                            else
                                break
                            end
                            print(i + 1)
                        end
                        """,
                createInstruction(LABEL, "__start__"),
                createInstruction(SET, "i", "1"),
                createInstruction(LABEL, var(1005)),
                createInstruction(PRINT, "i"),
                createInstruction(JUMP, "__start__", "notEqual", "i", "5"),
                createInstruction(OP, "add", "i", "i", "1"),
                createInstruction(JUMP, var(1005), "lessThan", "i", "1000"),
                createInstruction(END)
        );
    }

    @Test
    void optimizesDataFlowAfterLoopOptimization() {
        assertCompilesTo("""
                        index = rand(10)
                        parent = 0
                        while (child = parent * 2 + 1) <= index
                            parent = child
                        end
                        print(parent)
                        """,
                createInstruction(OP, "rand", "index", "10"),
                createInstruction(SET, "parent", "0"),
                createInstruction(SET, "child", "1"),
                createInstruction(JUMP, var(1002), "greaterThan", "1", "index"),
                createInstruction(LABEL, var(1003)),
                createInstruction(SET, "parent", "child"),
                createInstruction(OP, "mul", var(1), "child", "2"),
                createInstruction(OP, "add", "child", var(1), "1"),
                createInstruction(JUMP, var(1003), "lessThanEq", "child", "index"),
                createInstruction(LABEL, var(1002)),
                createInstruction(PRINT, "parent"),
                createInstruction(END)
        );
    }
    //</editor-fold>

    //<editor-fold desc="Exit points">
    @Test
    void handlesReturnStatements() {
        assertCompilesTo("""
                        inline def foo(n)
                          return n
                        end
                                        
                        print(foo(4))
                        """,
                createInstruction(PRINT, "4"),
                createInstruction(END)
        );
    }

    @Test
    void handlesConditionalReturnStatements() {
        assertCompilesTo("""
                        #set optimization = aggressive

                        print(foo(rand(10)))
                        def foo(d)
                            if d % 2 == 0
                                return 1
                            end
                        end
                        """,
                createInstruction(OP, "rand", var(0), "10"),
                createInstruction(OP, "mod", var(2), var(0), "2"),
                createInstruction(JUMP, var(1002), "notEqual", var(2), "0"),
                createInstruction(SET, var(1), "1"),
                createInstruction(JUMP, var(1001), "always"),
                createInstruction(LABEL, var(1002)),
                createInstruction(SET, var(1), "null"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, var(1)),
                createInstruction(END)
        );
    }

    @Test
    void handlesEndInFunction() {
        assertCompilesTo("""
                        def foo(n)
                            if n > 0
                                return n
                            end
                            end()
                        end
                        print(foo(rand(10)))
                        """,
                createInstruction(OP, "rand", var(0), "10"),
                createInstruction(JUMP, var(1001), "greaterThan", var(0), "0"),
                createInstruction(END),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, var(0)),
                createInstruction(END)

        );
    }

    @Test
    void handlesReturnInLoop() {
        assertCompilesTo(new TestCompiler(CompilerProfile.fullOptimizations(false)),
                """
                        if UNIT_S1 == null UNIT_S1 = findUnit() end
                        inline def findUnit()
                            while true
                                return @unit
                            end
                        end
                        """,
                createInstruction(LABEL, "__start__"),
                createInstruction(JUMP, "__start__", "notEqual", "UNIT_S1", "null"),
                createInstruction(SET, var(2), "@unit"),
                createInstruction(SET, "UNIT_S1", var(2)),
                createInstruction(END)
        );
    }
    //</editor-fold>

    //<editor-fold desc="Inline functions">
    @Test
    public void handlesSimpleParameters() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n)
                        end
                        bar(5)
                        """,
                createInstruction(PRINT, "5"),
                createInstruction(END)
        );
    }

    @Test
    public void handlesInlineFunctionsGlobalVariables() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n)
                        end
                        X = 5
                        bar(X)
                        """,
                createInstruction(SET, "X", "5"),
                createInstruction(PRINT, "X"),
                createInstruction(END)
        );
    }

    @Test
    public void handlesBlockNames() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n)
                        end
                        bar(switch1)
                        """,
                createInstruction(PRINT, "switch1"),
                createInstruction(END)
        );
    }

    @Test
    public void handlesChainedVariables() {
        assertCompilesTo("""
                        inline def bar(n)
                            a = n
                            print(a)
                        end
                        bar(5)
                        """,
                createInstruction(PRINT, "5"),
                createInstruction(END)
        );
    }

    @Test
    public void handlesArgumentsInExpressions() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n + 1)
                        end
                        bar(5)
                        """,
                createInstruction(PRINT, "6"),
                createInstruction(END)
        );
    }

    @Test
    public void preservesVolatileVariables() {
        assertCompilesTo("""
                        inline def bar(n)
                            print(n)
                        end
                        bar(@time)
                        """,
                createInstruction(SET, "__fn0_n", "@time"),
                createInstruction(PRINT, "__fn0_n"),
                createInstruction(END)
        );
    }

    @Test
    public void preservesModifiedVariables() {
        assertCompilesTo("""
                        inline def bar(n)
                            while n < 1000
                                n += 1
                                print(n)
                            end
                        end
                        bar(0)
                        """,
                createInstruction(SET, "__fn0_n", "0"),
                createInstruction(LABEL, var(1005)),
                createInstruction(OP, "add", "__fn0_n", "__fn0_n", "1"),
                createInstruction(PRINT, "__fn0_n"),
                createInstruction(JUMP, var(1005), "lessThan", "__fn0_n", "1000"),
                createInstruction(END)
        );
    }

    @Test
    void passesParameterToFunctionRegressionTest() {
        assertCompilesTo(createTestCompiler(createCompilerProfile().setAllOptimizationLevels(OptimizationLevel.AGGRESSIVE)),
                """
                        inline def d(n)
                            n
                        end
                        print(1 < d(2))
                        printflush(message1)
                        """,
                createInstruction(PRINT, "true"),
                createInstruction(PRINTFLUSH, "message1"),
                createInstruction(END)
        );
    }

    @Test
    public void handlesNestedParameters() {
        assertCompilesTo("""
                        inline def foo(n)
                            print(n)
                        end
                        inline def bar(n)
                            foo(n)
                        end
                        bar(5)
                        """,
                createInstruction(PRINT, "5"),
                createInstruction(END)
        );
    }

    @Test
    void handlesComplexInlineFunctionArgumentSetup() {
        assertCompilesTo("""
                        printDomeStatus(@silicon, "\\n[green]Silicon[] status:\\n")
                        inline def printDomeStatus(item, text)
                            print(text)
                            level = dome1.sensor(item)
                            printf("  dome:  [green]$[]\\n", level)
                        end
                        """,
                createInstruction(SENSOR, "__fn0_level", "dome1", "@silicon"),
                createInstruction(PRINT, q("\n[green]Silicon[] status:\n  dome:  [green]")),
                createInstruction(PRINT, "__fn0_level"),
                createInstruction(PRINT, q("[]\n")),
                createInstruction(END)
        );
    }
    //</editor-fold>

    //<editor-fold desc="Function arguments/calls">
    @Test
    void handlesFunctionArgumentSetup() {
        assertCompilesTo("""
                        def getBit(bitIndex)
                          bitIndex * 2
                        end
                                                
                        for n in 1 .. 1000
                            print(getBit(n \\ 2))
                        end
                        getBit(0)
                        """,
                createInstruction(SET, "n", "1"),
                createInstruction(LABEL, var(1007)),
                createInstruction(OP, "idiv", "__fn0_bitIndex", "n", "2"),
                createInstruction(SETADDR, "__fn0retaddr", var(1004)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1004), "__fn0"),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(OP, "add", "n", "n", "1"),
                createInstruction(JUMP, var(1007), "lessThanEq", "n", "1000"),
                createInstruction(SET, "__fn0_bitIndex", "0"),
                createInstruction(SETADDR, "__fn0retaddr", var(1005)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1005), "__fn0"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(OP, "mul", "__fn0retval", "__fn0_bitIndex", "2"),
                createInstruction(GOTO, "__fn0retaddr", "__fn0")
        );
    }

    @Test
    void optimizesFunctionArguments() {
        assertCompilesTo("""
                        def foo(n)
                            print(n * 2)
                        end
                        foo(2)
                        foo(2)
                        """,
                createInstruction(SET, "__fn0_n", "2"),
                createInstruction(SETADDR, "__fn0retaddr", var(1001)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1001), "__fn0"),
                createInstruction(SETADDR, "__fn0retaddr", var(1002)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1002), "__fn0"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(OP, "mul", var(2), "__fn0_n", "2"),
                createInstruction(PRINT, var(2)),
                createInstruction(GOTO, "__fn0retaddr", "__fn0")
        );
    }

    @Test
    void compilesRecursiveFibonacci() {
        assertCompilesTo("""
                        allocate stack in bank1[0...512]
                        def fib(n)
                            n < 2 ? n : fib(n - 1) + fib(n - 2)
                        end
                        print(fib(10))
                        """,
                createInstruction(SET, "__sp", "0"),
                createInstruction(SET, "__fn0_n", "10"),
                createInstruction(CALLREC, "bank1", var(1000), var(1001), "__fn0retval"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "__fn0retval", "__fn0_n"),
                createInstruction(JUMP, var(1004), "lessThan", "__fn0_n", "2"),
                createInstruction(PUSH, "bank1", "__fn0_n"),
                createInstruction(OP, "sub", "__fn0_n", "__fn0_n", "1"),
                createInstruction(CALLREC, "bank1", var(1000), var(1005), "__fn0retval"),
                createInstruction(LABEL, var(1005)),
                createInstruction(POP, "bank1", "__fn0_n"),
                createInstruction(SET, var(4), "__fn0retval"),
                createInstruction(PUSH, "bank1", var(4)),
                createInstruction(OP, "sub", "__fn0_n", "__fn0_n", "2"),
                createInstruction(CALLREC, "bank1", var(1000), var(1006), "__fn0retval"),
                createInstruction(LABEL, var(1006)),
                createInstruction(POP, "bank1", var(4)),
                createInstruction(OP, "add", "__fn0retval", var(4), "__fn0retval"),
                createInstruction(LABEL, var(1004)),
                createInstruction(RETURN, "bank1")
        );
    }

    @Test
    public void preservesGlobalVariablesWithFunctionCalls() {
        assertCompilesTo("""
                        inline def bar(n)
                            foo(n)
                            print(n)
                        end
                        def foo(n)
                            print(n)
                        end
                        X = 5
                        Y = 6
                        foo(X)
                        bar(Y)
                        """,
                createInstruction(SET, "X", "5"),
                createInstruction(SET, "Y", "6"),
                createInstruction(SET, "__fn0_n", "X"),
                createInstruction(SETADDR, "__fn0retaddr", var(1001)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1001), "__fn0"),
                createInstruction(SET, "__fn0_n", "Y"),
                createInstruction(SETADDR, "__fn0retaddr", var(1004)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1004), "__fn0"),
                createInstruction(PRINT, "Y"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "__fn0_n"),
                createInstruction(GOTO, "__fn0retaddr", "__fn0")
        );
    }

    @Test
    public void handlesConstantFunctionReturn() {
        assertCompilesTo("""
                        def foo(n)
                            print(n)
                            5
                        end
                        print(foo(2))
                        print(foo(3))
                        """,
                createInstruction(SET, "__fn0_n", "2"),
                createInstruction(SETADDR, "__fn0retaddr", var(1001)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1001), "__fn0"),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(SET, "__fn0_n", "3"),
                createInstruction(SETADDR, "__fn0retaddr", var(1002)),
                createInstruction(CALL, var(1000), "__fn0retval"),
                createInstruction(GOTOLABEL, var(1002), "__fn0"),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "__fn0_n"),
                createInstruction(SET, "__fn0retval", "5"),
                createInstruction(GOTO, "__fn0retaddr", "__fn0")
        );
    }

    @Test
    public void preservesVariableStateAcrossPushAndPop() {
        // Explanation of the test:
        // The recursive call foo(m, n - 1) modifies __fn0_n (it is set to n - 1 when passing new value to the recursive call)
        // Data Flow analysis of push/pop should determine the value of n remains unchanged after the call
        // Because of this, it subsequently determines the __tmp1 variable in loop condition can be replaced by __fn0_n
        assertCompilesTo("""
                        allocate stack in bank1[0...512]
                        def foo(n)
                            if n > 0
                                foo(n - 1)
                            end
                        end
                        print(foo(10))
                        """,
                createInstruction(SET, "__sp", "0"),
                createInstruction(SET, "__fn0_n", "10"),
                createInstruction(CALLREC, "bank1", var(1000), var(1001), "__fn0retval"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, "__fn0retval"),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "__fn0retval", "null"),
                createInstruction(JUMP, var(1004), "lessThanEq", "__fn0_n", "0"),
                createInstruction(OP, "sub", "__fn0_n", "__fn0_n", "1"),
                createInstruction(CALLREC, "bank1", var(1000), var(1005), "__fn0retval"),
                createInstruction(LABEL, var(1005)),
                createInstruction(LABEL, var(1004)),
                createInstruction(RETURN, "bank1")
        );
    }

    @Test
    public void preservesVariableStateAcrossPushAndPopInLoop() {
        // Explanation of the test:
        // The recursive call foo(m, n - 1) modifies __fn0_n (it is set to n - 1 when passing new value to the recursive call)
        // Data Flow analysis of push/pop should determine the value of n remains unchanged after the call
        // Because of this, it subsequently determines the __tmp1 variable in loop condition can be replaced by __fn0_n
        assertCompilesTo("""
                        allocate stack in bank1[0...512]
                        def foo(n)
                            for i in 1 .. n
                                print(n)
                                foo(n - 1)
                            end
                        end
                        foo(10)
                        """,
                createInstruction(SET, "__sp", "0"),
                createInstruction(SET, "__fn0_n", "10"),
                createInstruction(CALLREC, "bank1", var(1000), var(1001), "__fn0retval"),
                createInstruction(LABEL, var(1001)),
                createInstruction(END),
                createInstruction(LABEL, var(1000)),
                createInstruction(SET, "__fn0_i", "1"),
                createInstruction(JUMP, var(1005), "greaterThan", "1", "__fn0_n"),
                createInstruction(LABEL, var(1007)),
                createInstruction(PRINT, "__fn0_n"),
                createInstruction(PUSH, "bank1", "__fn0_n"),
                createInstruction(PUSH, "bank1", "__fn0_i"),
                createInstruction(OP, "sub", "__fn0_n", "__fn0_n", "1"),
                createInstruction(CALLREC, "bank1", var(1000), var(1006), "__fn0retval"),
                createInstruction(LABEL, var(1006)),
                createInstruction(POP, "bank1", "__fn0_i"),
                createInstruction(POP, "bank1", "__fn0_n"),
                createInstruction(OP, "add", "__fn0_i", "__fn0_i", "1"),
                createInstruction(JUMP, var(1007), "lessThanEq", "__fn0_i", "__fn0_n"),
                createInstruction(LABEL, var(1005)),
                createInstruction(RETURN, "bank1")
        );
    }
    //</editor-fold>

    //<editor-fold desc="Subexpressions">
    @Test
    void optimizesSubexpressions() {
        assertCompilesTo("""
                        a = rand(10)
                        b = a + 1
                        c = 1 + (a + 1)
                        d = 2 + (1 + a)
                        print(a, b, c, d)
                        """,
                createInstruction(OP, "rand", "a", "10"),
                createInstruction(OP, "add", "b", "a", "1"),
                createInstruction(OP, "add", "c", "a", "2"),
                createInstruction(OP, "add", "d", "a", "3"),
                createInstruction(PRINT, "a"),
                createInstruction(PRINT, "b"),
                createInstruction(PRINT, "c"),
                createInstruction(PRINT, "d"),
                createInstruction(END)
        );
    }

    @Test
    void optimizesExtendedSubexpressions() {
        assertCompilesTo("""
                        a = 1
                        b = rand(10)
                        c = 2
                        d = a + b + c
                        print(d)
                        """,
                createInstruction(OP, "rand", "b", "10"),
                createInstruction(OP, "add", "d", "b", "3"),
                createInstruction(PRINT, "d"),
                createInstruction(END)
        );
    }

    @Test
    void avoidsIncompatibleLiterals() {
        assertCompilesTo("""
                        base = 2
                        a = base ** 8
                        b = base ** a
                        print(a, b)
                        """,
                createInstruction(OP, "pow", "b", "2", "256"),
                createInstruction(PRINT, "256"),
                createInstruction(PRINT, "b"),
                createInstruction(END)
        );
    }

    @Test
    void optimizesComplexExpressions() {
        assertCompilesTo("""
                        a = rand(10)
                        b = rand(10)
                        print(1 + sqrt(a * a + b * b))
                        print(2 + sqrt(a * a + b * b))
                        print(1 + sqrt(a * a + b * b))
                        """,
                createInstruction(OP, "rand", "a", "10"),
                createInstruction(OP, "rand", "b", "10"),
                createInstruction(OP, "mul", var(2), "a", "a"),
                createInstruction(OP, "mul", var(3), "b", "b"),
                createInstruction(OP, "add", var(4), var(2), var(3)),
                createInstruction(OP, "sqrt", var(5), var(4)),
                createInstruction(OP, "add", var(6), "1", var(5)),
                createInstruction(PRINT, var(6)),
                createInstruction(OP, "add", var(11), "2", var(5)),
                createInstruction(PRINT, var(11)),
                createInstruction(PRINT, var(6)),
                createInstruction(END)
        );
    }

    @Test
    void optimizesAddAfterSub() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp0, a, P1),
                        createInstruction(OP, add, tmp1, tmp0, P10),    // (a - 1) + 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, P1, a),
                        createInstruction(OP, add, tmp1, tmp0, P10),    // (1 - a) + 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, a, P1),
                        createInstruction(OP, add, tmp1, P10, tmp0),    // 10 + (a - 1)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, P1, a),
                        createInstruction(OP, add, tmp1, P10, tmp0),    // 10 + (1 - a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, add, tmp1, a, P9),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P11, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp1, a, P9),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P11, a),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesSubAfterAdd() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, add, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (a + 1) - 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp0, P1, a),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (1 + a) - 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, P10, tmp0),    // 10 - (a + 1)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp0, P1, a),
                        createInstruction(OP, sub, tmp1, P10, tmp0),    // 10 - (1 + a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp1, a, P9),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, a, P9),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P9, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P9, a),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesSubAfterAdd0() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, add, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (a + 1) - 10
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp1, a, P9),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesSubAfterSub() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (a - 1) - 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, P1, a),
                        createInstruction(OP, sub, tmp1, tmp0, P10),    // (1 - a) - 10
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, a, P1),
                        createInstruction(OP, sub, tmp1, P10, tmp0),    // 10 - (a - 1)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp0, P1, a),
                        createInstruction(OP, sub, tmp1, P10, tmp0),    // 10 - (1 - a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, sub, tmp1, a, P11),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, N9, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, sub, tmp1, P11, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, add, tmp1, a, P9),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesMulAfterDiv() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, div, tmp0, a, P2),
                        createInstruction(OP, mul, tmp1, tmp0, P4),    // (a / 2) * 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, P2, a),
                        createInstruction(OP, mul, tmp1, tmp0, P4),    // (2 / a) * 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, a, P2),
                        createInstruction(OP, mul, tmp1, P4, tmp0),    // 4 * (a / 2)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, P2, a),
                        createInstruction(OP, mul, tmp1, P4, tmp0),    // 4 * (2 / a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, mul, tmp1, a, P2),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P8, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp1, a, P2),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P8, a),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesDivAfterMul() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, mul, tmp0, a, P2),
                        createInstruction(OP, div, tmp1, tmp0, P4),    // (a * 2) / 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp0, P2, a),
                        createInstruction(OP, div, tmp1, tmp0, P4),    // (2 * a) / 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp0, a, P2),
                        createInstruction(OP, div, tmp1, P4, tmp0),    // 4 / (a * 2)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp0, P2, a),
                        createInstruction(OP, div, tmp1, P4, tmp0),    // 4 / (2 * a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, div, tmp1, a, P2),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, a, P2),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P2, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P2, a),
                        createInstruction(PRINT, tmp1)
                )
        );
    }

    @Test
    void optimizesDivAfterDiv() {
        assertOptimizesTo(
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, div, tmp0, a, P2),
                        createInstruction(OP, div, tmp1, tmp0, P4),    // (a / 2) / 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, P2, a),
                        createInstruction(OP, div, tmp1, tmp0, P4),    // (2 / a) / 4
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, a, P2),
                        createInstruction(OP, div, tmp1, P4, tmp0),    // 4 / (a / 2)
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp0, P2, a),
                        createInstruction(OP, div, tmp1, P4, tmp0),    // 4 / (2 / a)
                        createInstruction(PRINT, tmp1)
                ),
                List.of(
                        createInstruction(OP, rand, a, P10),
                        createInstruction(OP, div, tmp1, a, P8),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P0_5, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, div, tmp1, P8, a),
                        createInstruction(PRINT, tmp1),
                        createInstruction(OP, mul, tmp1, a, P2),
                        createInstruction(PRINT, tmp1)
                )
        );
    }
    //</editor-fold>

    //<editor-fold desc="Assignments">
    @Test
    void handlesSelfReference() {
        assertCompilesTo("""
                        TICKS = 100
                        nextTick = @tick
                        prevTick = @tick
                        currTick = @tick

                        nextTick = nextTick + TICKS
                        if @tick > nextTick + TICKS
                            prevTick = @tick
                            nextTick = prevTick + TICKS
                            currTick = prevTick
                        end
                        print(nextTick, prevTick, currTick)
                        """,
                createInstruction(SET, "TICKS", "100"),
                createInstruction(SET, "nextTick", "@tick"),
                createInstruction(SET, "prevTick", "@tick"),
                createInstruction(SET, "currTick", "@tick"),
                createInstruction(OP, "add", "nextTick", "nextTick", "TICKS"),
                createInstruction(OP, "add", var(1), "nextTick", "TICKS"),
                createInstruction(JUMP, var(1000), "lessThanEq", "@tick", var(1)),
                createInstruction(SET, "prevTick", "@tick"),
                createInstruction(OP, "add", "nextTick", "prevTick", "TICKS"),
                createInstruction(SET, "currTick", "prevTick"),
                createInstruction(LABEL, var(1000)),
                createInstruction(PRINT, "nextTick"),
                createInstruction(PRINT, "prevTick"),
                createInstruction(PRINT, "currTick"),
                createInstruction(END)
        );
    }

    @Test
    void handlesChainAssignment() {
        assertCompilesTo("""
                        FROM_INDEX = 0
                        OFFSET_Y = 2
                        cry = cly = FROM_INDEX == 0 ? 0 : OFFSET_Y
                        print(cry, cly)
                        """,
                createInstruction(SET, "FROM_INDEX", "0"),
                createInstruction(SET, "OFFSET_Y", "2"),
                createInstruction(SET, var(1), "OFFSET_Y"),
                createInstruction(JUMP, var(1001), "notEqual", "FROM_INDEX", "0"),
                createInstruction(SET, var(1), "0"),
                createInstruction(LABEL, var(1001)),
                createInstruction(PRINT, var(1)),
                createInstruction(PRINT, var(1)),
                createInstruction(END)
        );
    }

    // This test makes sure the assignments were all fully evaluated in one iteration.
    @Test
    void handlesAssignmentSequences() {
        TestCompiler compiler = createTestCompiler();
        assertCompilesTo(compiler,
                """
                        i = 0
                        print(i)
                        i += 1
                        print(i)
                        i += 1
                        print(i)
                        """,
                createInstruction(PRINT, q("012")),
                createInstruction(END)
        );

        String message = compiler.getMessages().stream()
                .map(CompilerMessage::message)
                .filter(m -> m.contains("instructions eliminated by Data Flow Optimization"))
                .findFirst().orElse("No Data Flow Optimization message found.");

        assertEquals("3 instructions eliminated by Data Flow Optimization (4 iterations).", message.trim());
    }
    //</editor-fold>

    //<editor-fold desc="External memory">
    @Test
    void optimizesMemoryAccess() {
        assertCompilesToWithMessages(ignore("List of uninitialized variables: i."),
                """
                        if cell1[i] > cell1[i + 1]
                            a = cell1[i]
                            cell1[i] = cell1[i + 1]
                            cell1[i + 1] = a
                        end
                        """,
                createInstruction(LABEL, "__start__"),
                createInstruction(READ, var(0), "cell1", "i"),
                createInstruction(OP, "add", var(2), "i", "1"),
                createInstruction(READ, var(1), "cell1", var(2)),
                createInstruction(JUMP, "__start__", "lessThanEq", var(0), var(1)),
                createInstruction(READ, "a", "cell1", "i"),
                createInstruction(READ, var(6), "cell1", var(2)),
                createInstruction(WRITE, var(6), "cell1", "i"),
                createInstruction(WRITE, "a", "cell1", var(2)),
                createInstruction(END)
        );
    }

    @Test
    void optimizesMemoryWriteAccess() {
        assertCompilesTo("""
                        allocate heap in cell1
                        $A = rand(10)
                        print($A)
                        """,
                createInstruction(OP, "rand", var(0), "10"),
                createInstruction(WRITE, var(0), "cell1", "0"),
                createInstruction(READ, var(1), "cell1", "0"),
                createInstruction(PRINT, var(1)),
                createInstruction(END)
        );
    }
    //</editor-fold>
}